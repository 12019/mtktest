/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * mph_cs_msg.h
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *   This file contains L1A message struct prototypes exported by L1A
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef _MPH_CS_MSG_H
#define _MPH_CS_MSG_H

#ifndef _MPH_CS_DEF_H
#error "mph_cs_def.h should be included before mph_cs_msg.h"
#endif

#if 0 /* TODO_HB: */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_power_scan_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to request power
*     scan on the supported band or according to the stored list if the
*     BA list is indicated as true. For power scan on the stored list,
*     L1A does not check if all carriers indicated on the BA list are
*     in the supported bands. In other words, the upper layer shall check
*     it to avoid power scan failure.
*
***************************************************************************/
typedef struct
{
   kal_uint8               ref_count;
   kal_uint16              msg_len;
   kal_uint8               scan_id;
   kal_uint8               bands_scan; /* The bands to be scanned */
   kal_bool                bcch_list_valid;  /* It indicates if the
                                                bcch_list is valid */
   mph_stored_bcch_list_struct    bcch_list;  /* The list of bcch carriers
                                          to be scanned */
} mphc_power_scan_req_struct;

/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_manusel_pwrscan_req_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer for confirming the
*     power scan request. It contains the power measurements sorted in unit
*     of 1/4dbm for power scan.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_uint8   bands_scan; /* The bands to be scanned */
   kal_uint8   scan_id;
   kal_bool                         bcch_list_valid;  /* It indicates if the bcch_list is valid */
   mph_stored_bcch_list_struct      bcch_list;  /* The list of bcch carriers to be scanned */
} mphc_manusel_pwrscan_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_power_scan_cnf_struct
*
*  DESCRIPTION
*     mphc_power_scan_cnf_struct
*     This message is sent from L1A to the upper layer as confirmation
*     of the MPHC_POWER_SCAN_REQ. It contains the power measurements
*     sorted in unit of 1/4dbm for power scan.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_uint8   scan_id;
   kal_uint16  arfcn_scanned_list_len; /*length of  scanned list */
   /* the set of the reported arfcn */
   ARFCN       arfcn[MPH_MAX_POWER_SCAN_RESULTS_LEN];
   /* measured power sum in 1/4 dBm */
   PowerSum    power_sum_in_quarter_dbm[MPH_MAX_POWER_SCAN_RESULTS_LEN];
} mphc_power_scan_cnf_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_manusel_pwrscan_cnf_struct
*
*  DESCRIPTION
*     mphc_power_scan_cnf_struct
*     This message is sent from L1A to the upper layer as confirmation
*     of the MPHC_POWER_SCAN_REQ. It contains the power measurements
*     sorted in unit of 1/4dbm for power scan.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_uint16  arfcn_scanned_list_len; /*length of  scanned list */
   kal_uint8   scan_id;
   /* the set of the reported arfcn */
   ARFCN       arfcn[MPH_MAX_POWER_SCAN_RESULTS_LEN];
   /* measured power sum in 1/4 dBm */
   PowerSum    power_sum_in_quarter_dbm[MPH_MAX_POWER_SCAN_RESULTS_LEN];
} mphc_manusel_pwrscan_cnf_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_bsic_sync_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to
*     request BSIC of a specified carrier.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   ARFCN       arfcn;   /* The carrier to do synchronization and bsic
                           acquisition */
   kal_bool    is_need_freq_correction;
} mphc_bsic_sync_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_bsic_sync_cnf_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for the result of BSIC
*     decoding on the specific channel. It is the confirmation for
*     MPHC_BSIC_SYNC_REQ. The decoded BSIC is also included.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   ARFCN       arfcn;   /* The carrier to do synchronization and bsic
                           acquisition */
   kal_bool    result;  /* The result of BSIC acquisition */
   BSIC        bsic;
   FrameNumber frame_offset;  /* Frame offset of timing information of
                                 this arfcn for L1 use */
   kal_int32   ebit_offset;   /* Ebit offset of timing information of
                                 this arfcn for L1 use */
} mphc_bsic_sync_cnf_struct;

/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_deactivate_cnf_struct
*
*  DESCRIPTION
*     This message is sent from L1A to upper layer for deactivate result
*
***************************************************************************/
typedef struct
{
   kal_uint8            ref_count;
   kal_uint16           msg_len;
   kal_bool             is_successful;
} mphc_deactivate_cnf_struct;

/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_specific_sync_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to override L1
*     internal synchronization, frame offset and ebit offset, setting.
*     In other words, it specifies L1 current timing information to
*     synchronize with a target arfcn.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   ARFCN       arfcn_sync; /* The specific arfcn to be synchronized */
   BSIC        bsic; /* The BSIC of the specific arfcn */
   FrameNumber frame_offset;  /* Frame offset of timing information of
                                 this arfcn for L1 use */
   kal_int32   ebit_offset;   /* Ebit offset of timing information of
                                 this arfcn for L1 use */
} mphc_specific_sync_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_serv_bcch_monitor_req_struct
*
*  DESCRIPTION
*     This message is sent from THE UPPER LAYER to L1A for requesting L1
*     to begin monitoring BCCh carrier of the arfcn with which L1 has
*     already synchronied. L1 will begin BCCh reading according to the
*     mask included in this message. The parameter, mask, is a 32-bit integer
*     but only the 16LSBs of it take effective on indicating on which TC the
*     BCCh block shall be received. The 8 MSBs of the effective 16-bit
*     of the mask are for BCCh Ext reading and the 8 LSBs of the effective
*     16-bit indicate the TCs of BCCh Norm on which system information shall
*     be acquired. For example, if the mask equals 1111000000000000, the BCCh
*     blocks on BCCh Ext shall be readed as TC=4,5,6,7. If L1 receives mask
*     configuration at paging reorganization phase, the mask will be saved
*     but shall not be applied on current BCCh reading. As transition from
*     paging reorganization to normal paging or extended paging, the latest
*     mask shall be applied. L1 shall continue the system information
*     reading according to the mask until it is changed.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_int32   mask;    /* The bit mask to indicate on which TC the BCCh
                        shall be read */
} mphc_serv_bcch_monitor_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_idle_ccch_start_req_struct
*     mphc_ccch_update_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for request to monitor
*     the CCCH with which L1 has alreay decoded its BSIC. RR shall expect
*     to start paging reorganization after sending this message
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_bool    imsi_valid; /* It indicates if imsi_mod_1000 is valid  */
   kal_int32   imsi_mod_1000; /* IMSI mod 1000 */
   kal_int32   bs_pa_mfrms;   /* The number of 51-multiframes between
                                 transmission of paging messages to
                                 mobiles of the same paging group, 2~9 */
   kal_int32   bs_ag_blks_res;   /* The number of blocks on each common
                                    control channel reserved for access
                                    grant messages, 0~7 */
   kal_int32   bs_cc_chans; /* The number of common control channel, 1~4 */
   kal_bool    bs_ccch_sdcch_comb;  /* It indicates if CCCh and SDCCh are
                                       combined into one channel */
} mphc_idle_ccch_start_req_struct,
  mphc_ccch_update_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_unitdata_ind_struct
*
*  DESCRIPTION
*  This message is sent from L1A to the upper layer when a radio block with
*  good quality has been received in idle mode. The channel type of the
*  received radio block is indicated in this message. Beware that the
*  variable,"channel_type", is dependent on L1 internal design and is just
*  for reference.
*
***************************************************************************/
typedef struct
{
   kal_uint8                  ref_count;
   kal_uint16                 msg_len;
   /* The arfcn on which this radio block is received */
   ARFCN                      arfcn;
   /* The first frame number on which this radio block is received */
   FrameNumber                frame_number;

#ifdef __PS_SERVICE__
   /* C-value calculated by L1 for GPRS case */
   kal_int16                  c_value;
#endif

   /* The channel type of this radio block */
   mph_channel_type_enum      channel_type;
   /* It indicates if it is received on extended channel */
   kal_bool                   is_extended;
   /* It indicates the TC value as channel_type=BCCh */
   kal_int8                   tc;
   /* The body of layer2 frame, N201_MAX=23 */
   BlockData                  layer2_frame[MPH_N201_MAX];
} mphc_unitdata_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_page_mode_change_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for request to change
*     the page mode. As transition from paging reorganization to normal
*     paging or extended paging, it shall also recover BCCh reading by
*     the mask configured in paging reorganization phase besides paging
*     reception cahnged.
*
***************************************************************************/
typedef struct
{
   kal_uint8              ref_count;
   kal_uint16             msg_len;
   mph_paging_mode_enum   paging_mode; /* The indication of paging mode,
                                           MPH_NORMAL_PAGING,
                                           MPH_EXTENDED_PAGING,
                                           MPH_PAGING_REORGANIZATION,
                                           MPH_SAME_AS_BEFORE */
} mphc_page_mode_change_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_random_access_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to request the random
*     access burst transmission.
*
***************************************************************************/
typedef struct
{
   kal_uint8       ref_count;
   kal_uint16      msg_len;
   kal_uint8       req_id;  /*sequence number for RR to know the ._cnf received is old or new*/
   RAChData          rach_data;  /* The data to be filled in the random
                                    access burst */
   FrameNumber       rand; /* The random value from which the RACH slot
                              on which the random access burst is to be sent*/
   PowerControlLevel    power_ctrl_level;  /* Transmission power, 0~31db */
#ifdef __EGPRS_MODE__
   mph_ats_type_enum  ats_type; 
#endif
} mphc_random_access_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_random_access_cnf_struct
*
*  DESCRIPTION
*     This message is sent from L1A to RR as the confirmation for
*     MPH_RANDOM_ACCESS_REQ. The frameNumber in this message indicates
*     the actual frame number the random access burst is sent.
*
***************************************************************************/
typedef struct
{
   kal_uint8      ref_count;
   kal_uint16     msg_len;
   kal_uint8      req_id;  /*sequence number for RR to know the ._cnf received is old or new*/
   RAChData       rach_data;  /* The data was sent */
   FrameNumber    tx_frame_number;  /* Frame number on which the
                                        message was sent */
} mphc_random_access_cnf_struct;
#ifdef __AMR_SUPPORT__
/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_amr_req_struct
*
*  DESCRIPTION
*     This struct is sent from RR to L1A with mphc_immed_assign_req_struct
*
***************************************************************************/
typedef struct
{
   kal_bool amr_valid;        /* the AMR's parameter exist(TRUE) or not(FALSE) */
   FrameNumber frame_number;  /* the frame number to get RATSCCH messages */
   kal_uint8 cmip;            /* CMI phase */
   kal_uint8 mr_ver;          /* MultiRate speech VERsion : 001-amr verion 1*/
   kal_bool nscb;             /* Noise Supression Control Bit : 0-noise supression is used */
   kal_bool icmi;             /* Initial Codec Mode Indicator : 0-is defined by the implicit rule, 1-initial Codec Mode is start_codec_mode */
   kal_uint8 start_codec_mode;/* Start Codec Mode:00-codec_mode1,01-codec_mode2,02-codec_mode3,03-codec_mode4 */
   kal_uint8 acs;             /* AMR Codec Activate Set */
   kal_uint8 threshold[3];    /* Threshold1/Threshold2/Threshold3 */
   kal_uint8 hysteresis[3];   /* Hysteresis1/Hysteresis2/Hysteresis3 */
} mphc_amr_req_struct;
#endif /* __AMR_SUPPORT__ */
/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_immed_assign_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for tuning to the
*     assigned channel and entering the dedicated mode. It includes the
*     channel information before and after the starting time. As the upper
*     layer receives IMMEDIATE ASSIGNMENT or IMMEDIATE ASSIGNMENT EXTENDED
*     message indicating the MS to be from the network. On receiving this
*     message, L1 will cancel any random access bursts which may be queued,
*     stop BCCh/CCCh/CBCh, switch to the assigned channel according to the
*     indicated starting time,and enter dedicated mode. "dtx_allowed" is the
*     latest DTX mode received from network on BCCH.
*
***************************************************************************/
typedef struct
{
   kal_uint8                        ref_count;
   kal_uint16                       msg_len;
   /* Indication of DTX support */
   kal_bool                         dtx_allowed;
   /* Power control indicator, It indicates if measurements on the bursts
      on the BCCH frequency shall not be used in the RXLEV averaging process.*/
   kal_bool                         pwrc;
   /* Timing Advance parameter to be used on the channel coded as in GSM
      04.18 */
   TimingAdvance                    timing_advance;
   /* Whether the starting_time is valid */
   kal_bool                         starting_time_valid;
   FrameNumber                      starting_time;

   /* KAL_TRUE - before time channel is valid
      KAL_FALSE - befor time channel is not valid */
   kal_bool                         before_time_channel_valid;
   /* used when starting time is not reached for the dedicated channel */
   mph_channel_description_struct   before_time_channel;
   /* used when starting time is reached for the dedicated channel */
   mph_channel_description_struct   after_time_channel;
} mphc_immed_assign_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_channel_assign_req_struct
*
*  DESCRIPTION
*  This message is sent from the upper layer to L1A to tune to a specified
*  assigned channel. It includes the channel information before and after
*  the starting time. After receiving ASSIGNMENT COMMAND message from the
*  network, the upper layer shall suspend the L2. "dtx_allowed" is the
*  latest DTX mode received from network on SACCH in dedicated mode, or on
*  BCCH if the MS hasn't received the information in idle mode. If the
*  indicated starting time is expired, L1 shall switch to the assigned
*  channel immediately. Otherwise, L1 shall stay in the old channel and
*  continue all activities until the starting time exipred. After switching
*  to the new channel, L1 will send a confirmation to notify the upper layer.
*  After receiving this confirmation, the upper layer shall be able to
*  continue its activity on the new channel.
*
***************************************************************************/
typedef struct
{
   kal_uint8                        ref_count;
   kal_uint16                       msg_len;
   /* Indication of DTX support */
   kal_bool                         dtx_allowed;
   /* Power control indicator, It indicates if measurements on the bursts on the
      BCCH frequency shall not be used in the RXLEV averaging process.*/
   kal_bool                         pwrc;
   PowerControlLevel                power_ctrl_level; /* Power control level
                                                         used by L1 */
   /* Whether the starting_time is valid */
   kal_bool                         starting_time_valid;
   FrameNumber                      starting_time;

   /* Whether ciphering related parameters are valid. If invalid no ciphering
      shall be done by L1 */
   kal_uint8                        cipher_flag;
   /* ciphering algorithm shall be applied */
   kal_int8                         ciphering_algorithm;
   kal_uint8                        cipher_key[MPH_CIPHER_KEY_LENGTH];

   /* KAL_TRUE - before time channel is valid
      KAL_FALSE - befor time channel is not valid */
   kal_bool                         before_time_channel_valid;

   /* used when starting time is not reached for the dedicated channel */
   mph_channel_description_struct   before_time_channel;
   /* used when starting time is reached for the dedicated channel */
   mph_channel_description_struct   after_time_channel;
#ifdef __AMR_SUPPORT__
   mphc_amr_req_struct              mphc_amr_para;
#endif /* __AMR_SUPPORT__ */
} mphc_channel_assign_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_channel_release_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to release the main
*     dedicated channels.
*
***************************************************************************/
typedef struct
{
   kal_uint8      ref_count;
   kal_uint16     msg_len;
   kal_uint8      cause;  /* The release cause */
} mphc_channel_release_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_handover_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to initiate the
*     handover procedure. It is used when RR has received an HANDOVER COMMAND
*     from the network, and has got the confirmation for suspending L2
*     multiframe operations. All four kinds of handover types are supported
*     by L1. "handover_ref" of 0 means no handover access burst must be sent
*     by L1. Otherwise, L1A will trigger the transmission of the random
*     access bursts to complete the handover procedure.
*
***************************************************************************/
typedef struct
{
   kal_uint8                        ref_count;
   kal_uint16                       msg_len;
   /* pre-synch, finely pre-synch, non-synch, pseudo synch */
   kal_uint8                        handover_type;
   /* Indication to send handover access */
   mph_handover_atc_enum            atc;
   /* Indication of DTX support */
   kal_bool                         dtx_allowed;
   /* Whether the starting_time is valid */
   kal_bool                         starting_time_valid;
   FrameNumber                      starting_time;

   kal_bool                         timing_advance_valid;
   /* Timing Advance parameter to be used on the channel coded as in
      GSM 04.18 */
   TimingAdvance                    timing_advance;

   PowerControlLevel                power_ctrl_level; /* Power control level
                                                         used by L1 */

   kal_uint8                        cipher_flag; /* Whether ciphering
                                                    related parameters
                                                    are valid. If
                                                    invalid no ciphering
                                                    shall be done by L1 */
   /* ciphering algorithm shall be applied */
   kal_int8                         ciphering_algorithm;
   kal_uint8                        cipher_key[MPH_CIPHER_KEY_LENGTH];

   /* KAL_TRUE - before time channel is valid
      KAL_FALSE - befor time channel is not valid */
   kal_bool                         before_time_channel_valid;

   /* used when starting time is not reached for the dedicated channel */
   mph_channel_description_struct   before_time_channel;

   /* used when starting time is reached for the dedicated channel */
   mph_channel_description_struct   after_time_channel;

   /* Value of 0 means no handover access burst must be sent by MPAL/L1 */
   RAChData                         handover_ref;

   kal_bool                         rtd_valid;
   kal_uint8                        rtd;  /* real time difference */
   kal_bool                         nci;
   BSIC                             bsic;
   FrameNumber                      frame_offset;  /* Frame offset of timing information of
                                                      this arfcn for L1 use */
   kal_int32                        ebit_offset;   /* Ebit offset of timing information of
                                                      this arfcn for L1 use */
   /* arfcn of target cell, 0-1023 */
   ARFCN                            target_bcch_arfcn;
#ifdef __AMR_SUPPORT__
   mphc_amr_req_struct              mphc_amr_para;
#endif /* __AMR_SUPPORT__ */                                       
} mphc_handover_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_handover_cnf_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer as the confirmation
*     for MPHC_HANDOVER_CNF. It indicates the results about the acquisition
*     of necessary information for handover and setup of the new channel
*     and the reason if it fails.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_uint8   error_cause;  /* The error cause */
} mphc_handover_cnf_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_handover_access_start_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer as the indication for
*     handover access burst transmission. L1 will send this message to the
*     upper layer after starting the first handover access burst transmission.
*     In other words, after the upper layer receive this message, it shall
*     assume L1 has already switched to the new channel and started random
*     access burst transmission. The frame number in this message indicates
*     the actual frame number on which the first access burst is sent.
*
***************************************************************************/
typedef struct
{
   kal_uint8         ref_count;
   kal_uint16        msg_len;
   FrameNumber       frame_number; /* The frame number on which the first
                                      random access burst is actually sent */
   RAChData          handover_ref; /* The data to be filled in handover access
                                      burst  */
} mphc_handover_access_start_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_handover_connected_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer as the indication of
*     L1 link establishment.
*
***************************************************************************/
typedef struct
{
   kal_uint8         ref_count;
   kal_uint16        msg_len;
   kal_uint32        otd; /* observed time difference */
   TimingAdvance     timing_advance; /* Timing advance for old cell */
} mphc_handover_connected_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_handover_access_stop_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to stop sending
*     the handover access message after the upper layer receives the
*     timing advance information in the asynchronous handover case.
*
***************************************************************************/
typedef struct
{
   kal_uint8         ref_count;
   kal_uint16        msg_len;
   TimingAdvance     timing_advance; /* timing advance for the new cell */
} mphc_handover_access_stop_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_handover_access_stop_cnf_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer as the confirmation
*     for MPHC_HANDOVER_ACCESS_STOP_REQ in the asynchronous handover case.
*     This message will contain the related timing information for the old
*     cell obtained from L1.
*
***************************************************************************/
typedef struct
{
   kal_uint8         ref_count;
   kal_uint16        msg_len;
   kal_uint32        otd; /* observed time difference */
   TimingAdvance     timing_advance; /* timing advance for the new cell */
} mphc_handover_access_stop_cnf_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_frequency_redefinition_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to update the
*     frequency definition for hopping sequence. If the frequency set
*     for this command are not in one band, L1 shall return the confirmation
*     immediately with the information about the starting time expiry.
*     Otherwise, if the mobile station receives a FREQUENCY REDEFENITION
*     message on a channel for which it has a pending redefinition, the
*     frequencies, hopping and starting time parameters defined by the
*     new frequency redefinition procedure supersedes those of the
*     pending one. After the starting time expiry, L1 will send the
*     confirmation to the upper layer immediately.
*
***************************************************************************/
typedef struct
{
   kal_uint8                  ref_count;
   kal_uint16                 msg_len;
   /* It indicates if the frequency set in this command are all in one band */
   kal_bool                   is_freq_in_one_band;
   /* The starting time for frequency redefinition */
   FrameNumber                starting_time;
   /* frequency definition to be applied */
   mph_freq_params_struct     freq_def;
} mphc_frequency_redefinition_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_frequency_redefinition_cnf_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer as the confirmation
*     for RR_MPAL_FREQ_REDEF_REQ. If the frequency set for this command are
*     not in one band, L1 shall return the confirmation immediately with
*     the information about the starting time expiry.Otherwise, after
*     the upper layer receives this message, it shall assume the
*     frequency redefinition has been applied. The parameter,
*     "currentDcch", in this message indicates if the frequency
*     redefinition is applied on the current DCCh.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_bool    current_dch;  /* If this frequency definition is applied
                                 on the current channel*/
   kal_bool    is_freq_in_one_band; /* It indicates if the frequency set
                                    of this command are all in one band */
   /* Indication of starting time expiry */
   kal_bool    starting_time_expired;
} mphc_frequency_redefinition_cnf_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_channel_mode_modify_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to change the
*     channel mode for the specified channel. As channel mode is changed from
*     signalling only mode to traffic mode or between different traffic
*     mode, the dtx mode may be changed. The changed dtx mode shall be
*     included in this message to inform L1
*
***************************************************************************/
typedef struct
{
   kal_uint8                  ref_count;
   kal_uint16                 msg_len;
   mph_channel_mode_enum      ch_mode; /* The modified chanel mode */
   /* It indicates if the network support dtx mode in the new channel mode */
   kal_bool                   dtx_allowed;
#ifdef __AMR_SUPPORT__
   mphc_amr_req_struct        mphc_amr_para;
#endif /* __AMR_SUPPORT__ */
} mphc_channel_mode_modify_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_ciphering_mode_command_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to setup the
*     ciphering mode.
*     A valid CIPHERING MODE COMMAND message is defined to be one of the
*     following:
*     one that indicates "start ciphering" and is received by the mobile
*     station in the "not ciphered" mode
*     one that indicates "no ciphering" and is received by the MS in the
*     "not ciphered" mode
*     one that indicates "no ciphering" and is received by the mobile
*     station in the "ciphered" mode.
*     The upper layer shall take care of the above restriction for
*     ciphering mode command to avoid invalid configuration.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_uint8   cipher_flag; /* Whether ciphering
                               related parameters
                               are valid. If
                               invalid no ciphering
                               shall be done by L1 */
   /* ciphering algorithm shall be applied */
   kal_int8    ciphering_algorithm;
   kal_uint8   cipher_key[MPH_CIPHER_KEY_LENGTH];
} mphc_ciphering_mode_command_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_close_tch_loop_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for closing
*     specified type TCH loop for loop back test.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   LoopMode    loopback_type; /* 0: MPH_TCH_LOOP_A
                                 1: MPH_TCH_LOOP_B
                                 2: MPH_TCH_LOOP_C
                                 3: MPH_TCH_LOOP_D
                                 4: MPH_TCH_LOOP_E
                                 5: MPH_TCH_LOOP_F */
} mphc_close_tch_loop_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_dai_test_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to request DAI
*     interface setup for DAI test.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_uint8   device;  /* 0:normal operation
                           1:test of speech decoder/DTX functions(downlink)
                           2:test of speech encoder/DTX functions(uplink)
                           4:test of acoustic devices and A/D & D/A */
} mphc_dai_test_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_power_class_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to configure
*     the powerclass.
*
***************************************************************************/
typedef struct
{
   kal_uint8                    ref_count;
   kal_uint16                   msg_len;
   kal_int8                     gsm450_power_class;
   kal_int8                     gsm480_power_class;
   kal_int8                     gsm850_power_class;
   kal_int8                     gsm900_power_class;  /* MPH_POWER_CLASS_1 = 0,
                                                     MPH_POWER_CLASS_2 = 1,
                                                     MPH_POWER_CLASS_3 = 2,
                                                     MPH_POWER_CLASS_4 = 3,
                                                     MPH_POWER_CLASS_5 = 4,
                                                     MPH_POWER_CLASS_INVALID = -1 */
   kal_int8                     dcs_power_class;
   kal_int8                     pcs_power_class;

#ifdef __PS_SERVICE__
   PowerControlLevel            ms_txpwr_max_cch_for_gprs;
   mph_txpwr_change_cause_enum  change_cause;
#endif
} mphc_power_class_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cell_option_update_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to configure the
*     DTX mode and PWRC.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_bool    dtx_allowed;   /* Indication of DTX support in netwrok */
   kal_bool    pwrc; /* Indication of PWRC setting */
} mphc_cell_option_update_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_extended_meas_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for extended
*     measurements. L1 will start the extended measurement in the
*     next reporting period.
*     NOTE: only the first 21 entries in the frequencyList are used.
*
***************************************************************************/
typedef struct
{
   kal_uint8            ref_count;
   kal_uint16           msg_len;
   /* Extended measurement frequency list */
   mph_bcch_list_struct     ext_meas_freq_list;
} mphc_extended_meas_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_extended_meas_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer for extended
*     measurements results.It contains individual sample for each carrier
*     indicated in MPHC_EXTENDED_MEAS_REQ.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_uint8   ext_meas_freq_list_len; /* The number of valid elements
                                          in measurement results */
   kal_bool    dtx_used;   /* Indication of DTX used in MS */
   kal_uint8   list_ref;   /* list reference number for differentiating
                              the results for different request*/
   /* The pointer to the set of arfcns for extended measurement*/
   kal_uint16  arfcn[MPH_MAX_EXT_MEAS_FREQ_LIST_LEN];
   /* The pointer to the results of extended measurement in unit of 1/4dbm */
   kal_int16   rlac_in_quarter_dbm[MPH_MAX_EXT_MEAS_FREQ_LIST_LEN];
} mphc_extended_meas_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_block_quality_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer for decoding fail of
*     the PCH/BCCH/NBCCH/CBCH block in idle mode. The type of the bad block
*     will be indicated in this message.
*
***************************************************************************/
typedef struct
{
   kal_uint8                  ref_count;
   kal_uint16                 msg_len;
   /* BCCH channel number(C0) of the cell on which the block was received */
   ARFCN                      arfcn;
   /* frame number of the first frame of the received block */
   FrameNumber                frame_number;
   /* refer to mph_channel_type_enum */
   mph_channel_type_enum      channel_type;
   /* It indicates if it is received on extended channel */
   kal_bool                   is_extended;
   mph_block_mointor_enum     rx_block_status;
   kal_int8                   tc;
#ifdef __PS_SERVICE__
   /* C-value calculated by L1 for GPRS case */
   kal_int16                  c_value;
#endif
} mphc_block_quality_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_serv_idle_meas_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer for the results
*     of measurement on the serving cell in idle mode. The running average of
*     measurement results will be sent in every 5 secs. The power
*     measurement for serving cell in idle mode will be started
*     automatically as entering idle mode.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   Power       rlac_in_quarter_dbm; /* The power measurement results in
                                   uint of 1/4dbm */
} mphc_serv_idle_meas_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_serv_dedi_meas_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer for the results
*     of measurement on the serving cell. The running average of measurements
*     will be sent in every reporting period (104 TDMA frames). The power
*     measurement for serving cell in idle mode will be started
*     automatically as entering dedicated mode.
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   /* The full power measurement results in uint of 1/4dbm */
   kal_int16   rlac_full_in_quarter_dbm;
   /* The sub power measurement results in uint of 1/4dbm */
   kal_int16   rlac_sub_in_quarter_dbm;
   kal_uint8   rxqual_level_full;  /* The quality level of full rxqual */
   kal_uint8   rxqual_level_sub;   /* The quality level of full rxqual */
   /* The indication of dtx in this reporting period */
   kal_bool    dtx_used;
#ifdef __R99__
   kal_int8   mean_bep;
   kal_int8   cv_bep;
   kal_int32  rxlev_val;
   kal_int8   nbr_rcdv_blocks;
#endif /*__R99__*/
#ifdef __AMR_SUPPORT__
   kal_bool amr_info_valid;
   kal_uint8 cmr_cmc_cmiu_cmid;
   kal_uint8 c_i;
   kal_uint16 icm;
   kal_uint16 acs;
#endif /* __AMR_SUPPORT__ */
} mphc_serv_dedi_meas_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_neighbor_meas_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for requesting L1
*     to start the measurements on the neighbor cell. This message contains
*     the related configuration. L1 will start the measurement reporting
*     for every round measurement of the carriers indicated in this
*     message after receiving this message. The measurements will be
*     continued until L1 receives a empty BA list. In idle mode, the
*     running average of the measurement results will be sent in every
*     5 secs. In dedicated mode, the running average of the measurement
*     results will be sent every reporting period(104 TDMA frames).
*
***************************************************************************/
typedef struct
{
   kal_uint8            ref_count;
   kal_uint16           msg_len;
   mph_bcch_list_struct ba_list; /* BA list for neighbor cell measurement */

#ifdef  __PS_SERVICE__
   kal_bool             gprs_meas_mode;  /* indicate gsm or gprs average
                                            period should be used        */
#endif
} mphc_neighbor_meas_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_neighbor_meas_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer for the results of
*     measurement on the neighbor cell after L1 receives
*     MPHC_NEIGHBOR_MEAS_REQ. It contains individual single sample for each
*     carrier indicated in MPHC_NEIGHBOR_MEAS_REQ. In idle mode, the running
*     average of the measurement results will be sent every 5 secs.
*     In dedicated mode, the running average of the measurement results will
*     be sent in every reporting period(104 TDMA frames). If there
*     is no enough samples collected as L1 shall send this indication to
*     the upper layer, the rlac_in_quarter_dbm shall be set to "1".
*
***************************************************************************/
typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  msg_len;
   kal_uint8   list_ref;   /* BA list reference */
   kal_uint8   list_len;   /* The number of valid elements of
                              rlac_in_quarter_dbm */
   ARFCN       arfcn_list[MPH_MAX_BA_LIST_LEN+1]; /* The list arfcn on which
                                                the measurements are taken */
   Power       rlac_in_quarter_dbm[MPH_MAX_BA_LIST_LEN+1]; /* The measurement
                                                            average for each
                                                            carrier in unit
                                                            of 1/4dbm */
} mphc_neighbor_meas_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_neighbor_bsic_start_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for requesting L1
*     to decode BSIC on the specified carriers. L1 will report any BSIC
*     immediately after decoding it.
*     This procedure is single-shot. In other words, the request for one
*     specific carrier runs out after the BSIC is decoded or all the
*     retries are failed. If the upper layer want to take BSIC
*     confirmation on the same arfcn, it shall re-initiate the request
*     for this.
*     The upper layer shall request it again if want to re-confirm the
*     same BSIC. This process will be stopped if L1 receive
*     MPHC_NEIGHBOR_BSIC_STOP_REQ for all pending candidates.
*     If the upper layer just wants to update some carriers among the
*     pending candidates for BSIC acquisition, it shall stop some old
*     pending candidates with MPHC_NEIGHBOR_BSIC_STOP_REQ and add some
*     new candidates by this message. L1 will append the BSIC
*     acquisitions for these candidates to the serving drain.
*
***************************************************************************/
typedef struct
{
   kal_uint8                              ref_count;
   kal_uint16                             msg_len;

#ifdef __PS_SERVICE__
   /* Indication of BSIC acquisition for the extended measurement in GPRS */
   kal_bool                               is_for_extended_meas;
#endif

   /* The number of valid element in bsic_acquisition_list */
   kal_uint8                              list_len;
   /* The database for BSIC acquisition */
   mph_neighbor_bsic_acquisition_struct   neighbor_bsic_acquisition_list
                                        [MPH_MAX_NEIGHBOR_BSIC_NUM+1];
} mphc_neighbor_bsic_start_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_neighbor_bsic_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer for the results
*     of BSIC decoding. The timing information, frame offset and ebit offset,
*     for L1 internal use are also included.
*
***************************************************************************/
typedef struct
{
   kal_uint8      ref_count;
   kal_uint16     msg_len;

#ifdef __PS_SERVICE__
   /* Indication of BSIC acquisition for the extended measurement in GPRS */
   kal_bool       is_for_extended_meas;
#endif

   kal_bool       is_for_manual_list;   /* True for manual list construction */
   ARFCN          arfcn;   /* The arfcn corresponding to the acquired bsic */
   /* It indicates if the bsic is acquired correctly */
   kal_bool       bsic_valid;
   BSIC           bsic; /* The acquired bsic */
   FrameNumber    frame_offset;  /* The acquired frame offset for L1 use */
   kal_int32      ebit_offset;   /* The acquired ebit offset for L1 use */
} mphc_neighbor_bsic_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_neighbor_bsic_stop_req_struct
*
*  DESCRIPTION
*     This message is sent from RR to MPAL to stop the BSIC decoding on
*     some specific carriers. If the parameter, "list_len", equals to 0,
*     L1 will consider it as stopping all pending BSIC acquisitions.
*
***************************************************************************/
typedef struct
{
   kal_uint8      ref_count;
   kal_uint16     msg_len;
   /* Indication to stop BSIC acquisition for the extended measurement in GPRS */

#ifdef  __PS_SERVICE__
   /* When is_for_extended_meas is KAL_TRUE, it means stop all bsic request
      for packet extended measurement. In this case, list_len and
      neighbor_bsic_acquisition_stop_list will be ignored */
   kal_bool       is_for_extended_meas;
#endif

   kal_uint8      list_len;   /* The number of valid element in
                                 bsic_acquisition_stop_list */
   /* The arfcn to stop bsic acquisition */
   ARFCN          neighbor_bsic_acquisition_stop_list
                  [MPH_MAX_NEIGHBOR_BSIC_NUM+1];
} mphc_neighbor_bsic_stop_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_neighbor_sys_info_read_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for requesting L1
*     to request the system information acquisition on neighbor cell.
*     The BCCh acqusition will be continued with the mask until the
*     upper layer stops it or set the mask to 0. This process will be
*     stopped if RR_MPAL_NEIGHBOR_SYS_INFO_STOP_REQ for all pending
*     candidates is received.
*     If the upper layer just wants to update some carriers among the
*     pending candidates for BCCH acquisition, it shall stop some old
*     pending candidates with RR_MPAL_NEIGHBOR_BCCH_STOP_REQ and add
*     some new candidates by this message. It will append the BCCH
*     acquisitions for these candidates to the serving drain.
*     The upper layer can request prioritize surrounding cell system
*     information reading than serving cell PCh reception by set the
*     priority to true.
*     In neighbor_bcch_acquisition_struct structure, it also provides a
*     mechanism to prioritize a SI reception on specific carrier. It is
*     to prevent this acquisition from delay duing to the collision with
*     BCCh acquisition on another carrier and guarantee the on-time
*     requirement requested by the upper layer.
*
***************************************************************************/
typedef struct
{
   kal_uint8                              ref_count;
   kal_uint16                             msg_len;
   /* The database for neighbor cell BCCh acquisition */
   mph_neighbor_bcch_acquisition_struct   nbcch_acquisition;
   /* It indicates if it is prior to PDTCh reception */
   kal_bool                                is_prior_to_pdtch_rx;
} mphc_neighbor_sys_info_read_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_neighbor_sys_info_stop_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to stop the
*     neighbor cell BCCH acquisition. If the parameter, "list_len",
*     equals to 0, L1 will consider it as stopping all pending BCCH
*     acquisitions and removing all from the serving drain.
*
***************************************************************************/
typedef struct
{
   kal_uint8      ref_count;
   kal_uint16     msg_len;
   kal_uint8      list_len;   /* The number of valid element in
                                 nbcch_acquisition_stop_list */
   /* The arfcn for to stop neighbor cell BCCh acquisition */
   kal_uint16     nbcch_acquisition_stop_list
                  [MPH_MAX_NEIGHBOR_BCCH_NUM];
#if 1 //__NORMAL_NW_SEARCH__
   kal_uint8      manual_list;  /* 1 stop the manual list, 0 stop the neighbor list */
#endif
} mphc_neighbor_sys_info_stop_req_struct;
#if 1 //__NORMAL_NW_SEARCH__
/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cell_bsic_start_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for requesting L1
*     to decode BSIC on the specified carriers. It works in scan mode. In order to 
*     read some cell PLMN, and these cells will be the candidation for camp on in 
*     the future.
*
***************************************************************************/
typedef struct
{
   kal_uint8                              ref_count;
   kal_uint16                             msg_len;
   /* The number of valid element in bsic_acquisition_list */
   kal_uint8                              list_len;
   /* The database for BSIC acquisition */
   mph_cell_bsic_acquisition_struct   cell_bsic_acquisition_list
                                        [MPH_MAX_NEIGHBOR_BSIC_NUM];
} mphc_cell_bsic_start_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cell_bsic_ind_struct
*
*  DESCRIPTION
*     This message is sent from L1A to the upper layer for the results
*     of BSIC decoding. The timing information, frame offset and ebit offset,
*     for L1 internal use are also included.
*
***************************************************************************/
typedef struct
{
   kal_uint8      ref_count;
   kal_uint16     msg_len;

   ARFCN          arfcn;   /* The arfcn corresponding to the acquired bsic */
   /* It indicates if the bsic is acquired correctly */
   kal_bool       bsic_valid;
   BSIC           bsic; /* The acquired bsic */
   FrameNumber    frame_offset;  /* The acquired frame offset for L1 use */
   kal_int32      ebit_offset;   /* The acquired ebit offset for L1 use */
} mphc_cell_bsic_ind_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cell_bsic_stop_req_struct
*
*  DESCRIPTION
*     This message is sent from RR to MPAL to stop the BSIC decoding on
*     some specific carriers. If the parameter, "list_len", equals to 0,
*     L1 will consider it as stopping all pending BSIC acquisitions.
*
***************************************************************************/
typedef struct
{
   kal_uint8      ref_count;
   kal_uint16     msg_len;

} mphc_cell_bsic_stop_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cell_sys_info_read_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A for requesting L1
*     to request the system information acquisition on assigned cell.
*     
***************************************************************************/
typedef struct
{
   kal_uint8                              ref_count;
   kal_uint16                             msg_len;
   /* The database for cell BCCh acquisition */
   mph_cell_bcch_acquisition_struct   cell_bcch_acquisition;
} mphc_cell_sys_info_read_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cell_sys_info_stop_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to stop some
*     cell BCCH acquisition. If the parameter, "list_len",
*     equals to 0, L1 will consider it as stopping all pending BCCH
*     acquisitions.
*
***************************************************************************/
typedef struct
{
   kal_uint8      ref_count;
   kal_uint16     msg_len;
   kal_uint8      list_len;   /* The number of valid element in
                                 cell_bcch_acquisition_stop_list */
   /* The arfcn for to stop neighbor cell BCCh acquisition */
   kal_uint16     cell_bcch_acquisition_stop_list
                  [MPH_MAX_NEIGHBOR_BCCH_NUM];
} mphc_cell_sys_info_stop_req_struct;
#endif

/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_rach_abort_req_struct
*     mphc_immed_assign_cnf_struct
*     mphc_channel_assign_cnf_struct
*     mphc_channel_release_cnf_struct
*     mphc_channel_reconnect_req_struct
*     mphc_channel_reconnect_cnf_struct
*     mphc_channel_mode_modify_cnf_struct
*     mphc_ciphering_mode_command_cnf_struct
*     mphc_close_tch_loop_cnf_struct
*     mphc_open_tch_loop_req_struct
*     mphc_open_tch_loop_cnf_struct
*     mphc_deactivate_req_struct
*
*  DESCRIPTION
*     mphc_rach_abort_struct:
*     This message is sent from the upper layer to L1A to stop the sending
*     access burst.
*
*     mphc_immed_assign_cnf_struct:
*     This message is sent from L1A to the upper layer as the confirmation for
*     MPHC_IMMED_ASSIGNED_REQ. After the upper layer receives this message,
*     it shall assume L1 has switched to the immediate assigned channel and
*     starts the dedicated mode operation.
*
*     mphc_channel_assign_cnf_struct:
*     This message is sent from L1A to the upper layer as the confirmation for
*     MPHC_CHANNEL_ASSIGN_REQ. After the upper layer receives this message,
*     it shall assume L1 has switched to the assigned channel. After switching
*     to the new channel, L1 will send this message to notify the upper layer.
*     If the starting time is valid and has not expired, L1 will suspend all
*     activities, and then switch to the new channel at starting time.
*
*     mphc_channel_release_cnf_struct:
*     This message is sent from L1A to the upper layer as the confirmation
*     for MPHC_CHANNEL_RELEASE_REQ. After the upper receives this message and
*     the result is ok, it shall assume the physical link of the dedicated
*     channel has already been disconnected.
*
*     mphc_channel_reconnect_req_struct:
*     This message is sent from the upper layer to L1A to request to go
*     back to the old channel as channel assignment failure or handover
*     failure occurs.
*
*     mphc_channel_reconnect_cnf_struct:
*     This message is sent from L1A to the upper layer as the confirmation for
*     MPHC_CHANNEL_RECONNECT_REQ. After the upper layer receives
*     this message, it shall assume the physical link of the old channel
*     has been established
*
*     mphc_channel_mode_modify_cnf_struct:
*     This message is sent from L1A to the upper layer as the confirmation for
*     MPHC_CHANNEL_MODE_MODIFY_REQ. After the upper layer receives
*     this message, it shall assume the channel mode has been applied.
*
*     mphc_ciphering_mode_command_cnf_struct:
*     This message is sent from L1A to the upper layer as the confirmation for
*     MPHC_CIPHERING_MODE_COMMAND_REQ. After the upper layer receives
*     this message, it shall assume the ciphering mode command has been
*     applied.
*
*     mphc_close_tch_loop_cnf_struct:
*     This message is sent from the upper layer to RR as the conformation of
*     MPHC_CLOSE_TCH_LOOP_REQ. After receiving it, the upper layer
*     shall expect it has been ready for close tch loop ack transmission.
*
*     mphc_open_tch_loop_req_struct:
*     This message is sent from the upper layer to L1A for opening
*     specified type TCH loop for loop back test.
*
*     mphc_open_tch_loop_cnf_struct:
*     This message is sent from L1A to the upper layer as the conformation of
*     MPHC_OPEN_TCH_LOOP_REQ. After receiving it, the upper layer
*     shall expect it has been ready for open tch loop ack transmission.
*
*     mphc_deactivate_req_struct:
*     This message is sent from the upper layer to L1A for requesting power
*     scan on the supported band to contruct the list for manual selection.
*
***************************************************************************/
typedef struct
{
   kal_uint8  ref_count;
   kal_uint16 msg_len;
} mphc_rach_abort_req_struct,
  mphc_immed_assign_cnf_struct,
  mphc_channel_assign_cnf_struct,
  mphc_channel_release_cnf_struct,
  mphc_channel_reconnect_req_struct,
  mphc_channel_reconnect_cnf_struct,
  mphc_channel_mode_modify_cnf_struct,
  mphc_ciphering_mode_command_cnf_struct,
  mphc_close_tch_loop_cnf_struct,
  mphc_open_tch_loop_req_struct,
  mphc_open_tch_loop_cnf_struct,
  mphc_manusel_pwrscan_stop_req_struct,
#ifdef __GEMINI__
  mphc_suspend_alt_l1_req_struct,
  mphc_resume_req_struct,
#endif /* end of __GEMINI__ */
  mphc_deactivate_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cbch_config_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to configurs CBCh
*     service
*
*
***************************************************************************/
typedef struct
{
   kal_uint8                      ref_count;
   kal_uint16                     msg_len;
   mph_channel_description_struct ch_desc;
} mphc_cbch_config_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cbch_start_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to start CBCh
*     service
*
*
***************************************************************************/
typedef struct
{
   kal_uint8                      ref_count;
   kal_uint16                     msg_len;
   kal_uint8                      cbch_mode;
} mphc_cbch_start_req_struct;

/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cbch_stop_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to stop CBCh
*     service
*
*
***************************************************************************/
typedef struct
{
   kal_uint8                      ref_count;
   kal_uint16                     msg_len;
   kal_uint8                      cbch_mode;
} mphc_cbch_stop_req_struct;


/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_cbch_skip_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to skip the specified
*     number of CBCh block to be received according to the CBCh scheduling
*
*
***************************************************************************/
typedef struct
{
   kal_uint8                      ref_count;
   kal_uint16                     msg_len;
   kal_int32                      num_skip;
   kal_uint8                      cbch_mode;
} mphc_cbch_skip_req_struct;

/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_sim_ready_notify_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to notify
*     L1 the sim card status
*
*
***************************************************************************/
typedef struct
{
   kal_uint8                      ref_count;
   kal_uint16                     msg_len;
   kal_uint8                      status;
} mphc_sim_ready_notify_req_struct;

/***************************************************************************
*  PRIMITIVE STRUCTURE
*     mphc_sim_status_update_req_struct
*
*  DESCRIPTION
*     This message is sent from the upper layer to L1A to notify
*     SIM setting/insertion for GEMINI
*
*
***************************************************************************/
#ifdef __GEMINI__
typedef struct
{
   kal_uint8                      ref_count;
   kal_uint16                     msg_len;
   mph_sim_config_status_enum     sim_config_status;
   mph_sim_insert_status_enum     sim_insert_status;
} mphc_sim_status_update_req_struct;
#endif
/*****************************************************************************
* CALLBACK FUNCTION PROTOTYPE
*   mpal_facch_downlink
* DESCRIPTION
*   Function call to deliver the good downlink block to MPAL in dedicated
*   mode. This function is called by L1, and provided by MPAL.
*****************************************************************************/
extern void mpal_facch_downlink(kal_bool is_bad_frame, kal_uint8* downlink_data_ptr);

/*****************************************************************************
* CALLBACK FUNCTION PROTOTYPE
*   mpal_sdcch_downlink
* DESCRIPTION
*   Function call to deliver the good downlink block to MPAL in dedicated
*   mode. This function is called by L1, and provided by MPAL.
*****************************************************************************/
extern void mpal_sdcch_downlink(kal_bool is_bad_frame, kal_uint8* downlink_data_ptr);

/*****************************************************************************
* CALLBACK FUNCTION PROTOTYPE
*   mpal_sacch_downlink
* DESCRIPTION
*   Function call to deliver the good downlink block to MPAL in dedicated
*   mode. This function is called by L1, and provided by MPAL.
*****************************************************************************/
extern void mpal_sacch_downlink(kal_bool is_bad_frame, kal_uint8* downlink_data_ptr);

#endif /* end of _MPH_CS_MSG_H */

