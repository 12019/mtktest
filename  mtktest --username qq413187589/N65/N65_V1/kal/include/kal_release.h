/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   kal_release.h
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *   This file has to be included for accessing the target version
 *   functionalities of KAL.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/*********************************************************************
    (C) _____ (year of first publication) Sasken communication
    Technologies Limited, All rights reserved.
*   This file provides a template for .c files. This space
*   should be used to describe the file contents
*   Component-specific prefix : xxxx
*********************************************************************/

#ifndef _KAL_RELEASE_H
#define _KAL_RELEASE_H


/*************************************************************************
 * Include Statements
 *************************************************************************/

#if defined(KAL_ON_NUCLEUS)
#include "Nucleus.h"
#elif defined (KAL_ON_OSCAR)
#include "osc_release.h"
#elif defined(KAL_ON_THREADX)
#include "tx_api.h"
#endif

#include "stack_config.h"
#include "kal_non_specific_general_types.h"

#if defined(__MTK_TARGET__) || defined(KAL_ON_NUCLEUS) || defined (MTK_KAL_MNT) || defined(KAL_ON_OSCAR) || defined(KAL_ON_THREADX) || defined(L1_SIM)
#include "task_main_func.h"
#endif

#include "kal_common_defs.h"
#include "kal_internal_macros.h"

#ifndef GEN_FOR_PC
#include "string.h"
#endif


/*************************************************************************
 * Constant definition and check
 *************************************************************************/

#if defined(__MTK_TARGET__) || defined(KAL_ON_NUCLEUS) || defined (MTK_KAL_MNT) || defined(KAL_ON_OSCAR) || defined(KAL_ON_THREADX)

#if defined(DEBUG_KAL) && defined(RELEASE_KAL)
#error "Only one of DEBUG_KAL and RELEASE_KAL can be defined"
#endif

#if !defined(DEBUG_KAL) && !defined(RELEASE_KAL)
#error "At least one of DEBUG_KAL or RELEASE_KAL should be defined"
#endif

#endif  /* __MTK_TARGET__ || KAL_ON_NUCLEUS || MTK_KAL_MNT || KAL_ON_OSCAR || KAL_ON_THREADX */


/*************************************************************************
 * Special definition applied on MNT and OSCAR only
 *************************************************************************/

#if defined( MTK_KAL_MNT ) || defined(KAL_ON_OSCAR)
#ifdef __GNUC__
#ifndef __int64
#define __int64 long long
#endif /* __int64 */
#ifndef __inline
#define __inline static
#endif /* __inline */
#endif /* __GNUC__ */
#endif /* MTK_KAL_MNT || KAL_ON_OSCAR */


/*************************************************************************
 * Define data type and data structure
 *************************************************************************/

#if defined(KAL_ON_NUCLEUS) || defined (KAL_ON_OSCAR) || defined(KAL_ON_THREADX)
typedef enum
{
    KAL_PRIORITY_CLASS0        =     0,
    KAL_PRIORITY_CLASS1        =     10,
    KAL_PRIORITY_CLASS2        =     20,
    KAL_PRIORITY_CLASS3        =     30,
    KAL_PRIORITY_CLASS4        =     40,
    KAL_PRIORITY_CLASS5        =     50,
    KAL_PRIORITY_CLASS6        =     60,
    KAL_PRIORITY_CLASS7        =     70,
    KAL_PRIORITY_CLASS8        =     80,
    KAL_PRIORITY_CLASS9        =     90,
    KAL_PRIORITY_CLASS10       =     100,
    KAL_PRIORITY_CLASS11       =     110,
    KAL_PRIORITY_CLASS12       =     120,
    KAL_PRIORITY_CLASS13       =     130,
    KAL_PRIORITY_CLASS14       =     140,
    KAL_PRIORITY_CLASS15       =     150,
    KAL_PRIORITY_CLASS16       =     160,
    KAL_PRIORITY_CLASS17       =     170,
    KAL_PRIORITY_CLASS18       =     180,
    KAL_PRIORITY_CLASS19       =     190,
    KAL_PRIORITY_CLASS20       =     200,
    KAL_PRIORITY_CLASS21       =     210,
    KAL_PRIORITY_CLASS22       =     220,
    KAL_PRIORITY_CLASS23       =     230,
    KAL_PRIORITY_CLASS24       =     240,
    KAL_PRIORITY_CLASS25       =     250
} kal_priority_type;
#endif

typedef void *kal_taskid;

typedef void *kal_hisrid;

typedef struct
{
    kal_uint8 unused;
} *kal_semid;

typedef struct 
{
    kal_uint8 unused;
} *kal_msgqid;

typedef struct
{
    kal_uint32 pending_msgs;
    kal_uint32 max_msgs;
} kal_msgq_info;

typedef struct
{
    kal_uint8 unused;
} *kal_mutexid;

typedef struct 
{
    kal_uint8 unused;
} *kal_eventgrpid;

typedef struct
{
    kal_uint8 unused;
} *kal_poolid;

typedef struct
{
    kal_uint8 unused;
} *kal_timerid;

typedef void *KAL_ADM_ID;

typedef enum
{
    INVAID_EXCEPTION                =  0,
    UNDEF_EXCEPTION                 =  1,
    SWI_EXCEPTION                   =  2,
    PREFETCH_EXCEPTION              =  3,
    DATAABORT_EXCEPTION             =  4,
    ASSERT_FAIL_EXCEPTION           =  5,
    SYS_FATALERR_EXT_TASK_EXCEPTION =  6,
    SYS_FATALERR_EXT_BUF_EXCEPTION  =  7,
    SYS_LOCKUP                      =  8,
    ASSERT_DUMP_EXTENDED_RECORD     =  9,
    NUM_EXCEPTION
} exception_type;

enum { ASSERT_DUMP_PARAM_MAX = 10 };

typedef struct ASSERT_DUMP_PARAM
{
    kal_uint32 addr[ASSERT_DUMP_PARAM_MAX];
    kal_uint32 len[ASSERT_DUMP_PARAM_MAX];  /* in bytes */
} ASSERT_DUMP_PARAM_T;

typedef enum
{
    FACTORY_BOOT = 0,
    NORMAL_BOOT = 1,
    USBMS_BOOT =  2,
    NUM_OF_BOOT_MODE,
    UNKNOWN_BOOT_MODE = 0xff
} boot_mode_type;

typedef unsigned short WCHAR;


/*************************************************************************
 * Define constant
 *************************************************************************/

#define KAL_NILTASK_ID (kal_taskid)NULL
#define KAL_NILHISR_ID (kal_hisrid)NULL
#define KAL_NILTIMER_ID (kal_timerid)NULL
#define KAL_NILPOOL_ID (kal_poolid)NULL
#define KAL_NILMUTEX_ID (kal_mutexid)NULL
#define KAL_NILEVENTGRP_ID (kal_eventgrpid)NULL
#define KAL_NILSEM_ID (kal_semid)NULL
#define KAL_NILQ_ID (kal_msgqid)NULL
#define KAL_NILSEC (kal_uint32)0xffffffff
#define KAL_NILMSEC (kal_uint16)0xffff
#define KAL_NILTICK (kal_uint32)0xffffffff


/*************************************************************************
 * Define macro
 *************************************************************************/

__inline boot_mode_type stack_query_boot_mode(void)
{
	extern boot_mode_type system_boot_mode;
	return system_boot_mode;
} 

__inline void * kal_mem_cpy(void* dest, const void* src, kal_uint32 size)
{
    return memcpy ( dest, src, size );
}


__inline void * kal_mem_set(void* dest, kal_uint8 value, kal_uint32 size)
{
    return memset ( dest, value, size );
}

__inline kal_int32 kal_mem_cmp(const void* src1, const void* src2, kal_uint32 size)
{
    return memcmp ( src1, src2, size );
}


/*************************************************************************
 * Define export function prototype
 *************************************************************************/

/*
 * KAL initialize
 */

void kal_initialize(void);
void kal_initialize_mem(void);
kal_bool kal_query_systemInit(void);

/*
 * Task management
 */

kal_taskid kal_create_task(kal_char *task_name_ptr, kal_uint8 priority, kal_uint32 stack_size, \
                           kal_task_func_ptr entry_func_ptr, void *entry_param_ptr, kal_uint8 options);
void kal_delete_task(kal_taskid task_id);
void kal_sleep_task(kal_uint32 time_in_ticks);
kal_hisrid kal_create_hisr(kal_char* hisr_name, kal_uint8 priority, kal_uint32 stack_size, \
                           kal_hisr_func_ptr entry_func, kal_uint8 options);
void kal_activate_hisr(kal_hisrid ext_hisr_id);
kal_uint32 kal_change_priority(kal_taskid taskid, kal_uint32 new_priority);
kal_uint32 stack_change_priority_by_module_ID(module_type mod_ID, kal_uint32 new_priority);
kal_uint32 stack_change_default_priority_by_module_ID(module_type mod_ID, kal_uint32 new_priority);
void *kal_get_task_stack_ptr(kal_taskid taskid);
kal_uint32 kal_get_task_remain_stack_size(kal_taskid task);
kal_bool kal_if_hisr(void);
kal_taskid kal_get_task_self_id(void);
void kal_get_my_task_index(kal_uint32 *index);
kal_bool kal_if_lisr(void);


/*
 * Message queue
 */

kal_msgqid kal_create_msg_q(kal_char* queue_name_ptr, kal_uint16 msg_size, kal_uint16 max_msgs);
void kal_delete_msg_q(kal_msgqid queue_id);
kal_status kal_enque_msg(kal_msgqid ext_msg_q_id, void *buffer_ptr, kal_uint16 msg_size, 
                         kal_wait_mode wait_mode, kal_bool message_to_head);
kal_status kal_deque_msg(kal_msgqid ext_msg_q_id, void* buffer_ptr, kal_uint16 *msg_size,
                         kal_wait_mode wait_mode);
kal_bool kal_get_queue_info(kal_msgqid task_ext_qid, kal_msgq_info *msgq_info);

/*
 * MUTEX
 */

kal_mutexid kal_create_mutex(kal_char* mutex_name_ptr);
void kal_take_mutex(kal_mutexid mutex_id);
void kal_give_mutex(kal_mutexid mutex_id);

kal_mutexid kal_create_enh_mutex( kal_char* mutex_name_ptr);
void kal_take_enh_mutex( kal_mutexid    mutex_id );
void kal_give_enh_mutex( kal_mutexid    mutex_id );

/*
 * Semaphore
 */

kal_semid kal_create_sem(kal_char *sem_name_ptr, kal_uint32 initial_count);
kal_status kal_take_sem(kal_semid sem_id, kal_wait_mode wait_mode);
void kal_give_sem(kal_semid sem_id);
kal_uint32 kal_query_sem_value(kal_semid ext_sem_id_ptr);

/*
 * Event group
 */

kal_eventgrpid kal_create_event_group(kal_char *eventgrp_name);
void kal_delete_eventgrp(kal_eventgrpid eg_id);
kal_status kal_set_eg_events(kal_eventgrpid eg_id, kal_uint32 events, kal_uint8 operation);
kal_status kal_retrieve_eg_events(kal_eventgrpid eg_id, kal_uint32 requested_events, kal_uint8 operation, 
                                  kal_uint32 *retrieved_events, kal_uint32 suspend);

/*
 * Event pool
 */

void kal_evshed_create_pool(void);
void* kal_evshed_get_mem(kal_uint32 size);
void kal_evshed_free_mem(void* buff_ptr);

/*
 * Appliaction dynamic memory
 */

extern KAL_ADM_ID kal_adm_create(void *mem_addr, kal_uint32 size, kal_uint32 *subpool_size, kal_bool islogging);
extern void *kal_adm_internal_alloc(KAL_ADM_ID adm_id, kal_uint32 size, char *filename, kal_uint32 line);
#define kal_adm_alloc(adm_id, size) kal_adm_internal_alloc(adm_id, size, __FILE__, __LINE__)
extern void *kal_adm_internal_alloc_with_info(KAL_ADM_ID adm_id, kal_uint32 size, kal_uint32 *actual_size, char *filename, kal_uint32 line);
#define kal_adm_alloc_with_info(adm_id, size, actual_size) kal_adm_internal_alloc_with_info(adm_id, size, actual_size, __FILE__, __LINE__)
extern void kal_adm_free(KAL_ADM_ID adm_id, void *mem_addr);
extern kal_status kal_adm_delete(KAL_ADM_ID adm_id);
extern kal_uint32 kal_adm_get_max_alloc_size(KAL_ADM_ID adm_id);
extern kal_uint32 kal_adm_get_total_left_size(KAL_ADM_ID adm_id);
extern void kal_adm_print_log(KAL_ADM_ID adm_id);
extern void *kal_adm_check_integrity(KAL_ADM_ID adm_id);

/*
 * Memory management
 */

extern kal_uint32 kal_sys_mem_query_freesize(void);
extern kal_uint32 kal_debug_mem_query_freesize(void);


/*
 * Buffer Management
 */

kal_poolid kal_create_buff_pool(kal_uint32 buff_size, kal_uint16 num_buffs);
void kal_delete_buff_pool(kal_poolid pool_id);
void *kal_get_buffer(kal_poolid ext_pool_id, kal_uint32 alloc_id, kal_uint32 size,
                     kal_uint32 *num_free_buffs_p, kal_char *alloc_file, kal_uint32 alloc_line,
                     kal_bool alloc_check);
void kal_release_buffer(void *usr_buff, kal_uint32 dealloc_id, kal_char *dealloc_file, 
                        kal_uint32 dealloc_line);
kal_poolid kal_get_poolid_from_usr_buff(void* usr_buff_p);
kal_uint32 kal_get_num_free_buffs( kal_poolid pool_id );
kal_bool kal_query_ctrlbuf_max_consumption(kal_uint32 *ptr);


/*
 * Timer Management
 */

kal_timerid kal_create_timer(kal_char* timer_name_ptr);
void kal_set_timer(kal_timerid timer_id, kal_timer_func_ptr handler_func_ptr, void* handler_param_ptr, \
                   kal_uint32 delay, kal_uint32 reschedule_time);
void kal_cancel_timer(kal_timerid timer_id);
void kal_get_time(kal_uint32* ticks_ptr);
kal_uint32 kal_get_time_remaining(kal_timerid timer_id);
kal_uint32 kal_secs_to_ticks(kal_uint32 secs);
kal_uint32 kal_milli_secs_to_ticks(kal_uint32 milli_secs);
kal_uint32 kal_ticks_to_secs(kal_uint32 ticks);
kal_uint32 kal_ticks_to_milli_secs(kal_uint32 ticks);
kal_uint32 kal_check_allowed_sleep_clock(kal_uint32 period_ticks);
void kal_recover_clock(kal_uint32 delayed_ticks);
void kal_invoke_expired_events(kal_uint32 delayed_ticks);

#ifdef KAL_ON_OSCAR
/* this routine adjust simulated tick time in millisecond by user */
void kal_adjust_sim_tick(kal_uint32 new_msec);
#endif


/*
 * Error Handling and Debug Management
 */

void kal_fatal_error_handler(kal_char* error_message_ptr, kal_uint32 error_code, kal_uint32 os_error_code);
void kal_register_fatal_error_handler(kal_error_func_ptr fatal_handler_ptr);
void kal_exit(void);

#ifdef MTK_KAL_MNT

#define kal_print( string_to_be_printed ) NU_Printf( string_to_be_printed )
#define kal_printf( string_to_be_printed ) NU_Printf( string_to_be_printed )

#elif defined (KAL_ON_OSCAR)    /* MTK_KAL_MNT */

#define kal_print    OSC_Print_Msg
#define kal_printf   OSC_Print_Msg

#else   /* MTK_KAL_MNT */

#ifdef DEBUG_KAL

extern void kal_debug_print(kal_char* string_to_be_printed);
extern void dbg_print(char *fmt,...);

#define kal_print( string_to_be_printed ) kal_debug_print( string_to_be_printed )
#define kal_printf( string_to_be_printed ) dbg_print( string_to_be_printed )

#else   /* DEBUG_KAL */

#define kal_print( string_to_be_printed )
#define kal_printf( string_to_be_printed )

#endif   /* DEBUG_KAL */

#endif   /* MTK_KAL_MNT */

extern void stack_print(char* string);

#ifdef KAL_ON_OSCAR
#define system_print OSC_Print_Msg
#else
#define system_print(s) stack_print(s)
#endif


/*
 * Misc
 */

extern kal_char *kal_str_dup(kal_char *string);
extern kal_char *kal_strtok_r(kal_char *string, const kal_char *seperators, kal_char **ppLast);
#define kal_sprintf sprintf
extern char *basename(char *file);

#if defined(DEBUG_KAL)
extern void kal_assert_fail(char* expr, char* file, kal_uint32 line, kal_bool isext, kal_uint32 ex1, kal_uint32 ex2, kal_uint32 ex3, ASSERT_DUMP_PARAM_T *dump_param);
#else /* DEBUG_KAL */
extern void kal_assert_fail(void);
#endif /* DEBUG_KAL */

#if defined(NOKE_DEBUG)
extern void noke_dbg_printf( const char * format,  ... );
#endif
/*
 * Error Handling
 */
#ifdef __ROMSA_SUPPORT__

#if defined(DEBUG_KAL)

#define ROM_ASSERT(expr) {if(!(expr)) { ROMSA_FuncTable[ROMSA_PTR_kal_assert_fail]((void *)#expr, __FILE__, __LINE__, KAL_FALSE, 0, 0, 0); }else {}}
#define EXT_ROM_ASSERT(expr, e1, e2, e3) {if(!(expr)) { ROMSA_FuncTable[ROMSA_PTR_kal_assert_fail]((void *)#expr, __FILE__, __LINE__, KAL_TRUE, e1, e2, e3); }else {}};

#else   /* DEBUG_KAL */

#define ROM_ASSERT(expr) do { } while (0);
#define EXT_ROM_ASSERT(expr, e1, e2, e3) {if(!(expr)) { ROMSA_FuncTable[ROMSA_PTR_kal_assert_fail]((void *)NULL, NULL, 0, KAL_FALSE, 0, 0, 0); }else {}}

#endif  /* DEBUG_KAL */

#endif   /* __ROMSA_SUPPORT__ */

#if defined(__FUE__)

   #define ASSERT(expr) {if(!(expr)) {while(1);}else {}}
   #define EXT_ASSERT(expr, e1, e2, e3) {if(!(expr)) {while(1);}else {}}
   #define EXT_ASSERT_DUMP(expr, e1, e2, e3, param) {if(!(expr)) {while(1);}else {}}
#else
#if defined(DEBUG_KAL)

/* For target platform, layer1 simulation's ASSERT() defined in l1_tool.h */

#if defined(NOKE_DEBUG)
#define ASSERT(expr) {if(!(expr)){noke_dbg_printf("FILE: %s, LINE:%d\n",  __FILE__, __LINE__);kal_assert_fail(#expr, __FILE__, __LINE__, KAL_FALSE, 0, 0, 0, NULL);}else {}}
#else
#define ASSERT(expr) {if(!(expr)){kal_assert_fail(#expr, __FILE__, __LINE__, KAL_FALSE, 0, 0, 0, NULL);}else {}}
#endif
#define EXT_ASSERT(expr, e1, e2, e3) {if(!(expr)) { kal_assert_fail(#expr, __FILE__, __LINE__, KAL_TRUE, e1, e2, e3, NULL); }else {}}
#define EXT_ASSERT_DUMP(expr, e1, e2, e3, param) {if(!(expr)) { kal_assert_fail(#expr, __FILE__, __LINE__, KAL_TRUE, e1, e2, e3, (param)); }else {}}

#else   /* DEBUG_KAL */

#define ASSERT(expr) do { } while (0);
#define EXT_ASSERT(expr, e1, e2, e3) {if(!(expr)) { kal_assert_fail(); }else {}}
#define EXT_ASSERT_DUMP(expr, e1, e2, e3, param) {if(!(expr)) { kal_assert_fail(); }else {}}

#endif /* DEBUG_KAL */
#endif

/*
 * Wide character support
 */

/* 16bits string operations */
int kal_wstrlen(const WCHAR *wstr);
WCHAR *kal_wstrcpy(WCHAR *to, const WCHAR *from);
WCHAR *kal_wstrncpy(WCHAR *to, const WCHAR *from, int n);
int kal_wstrcmp(const WCHAR *s1, const WCHAR *s2);
int kal_wstrncmp(const WCHAR *s1, const WCHAR *s2, int n);
WCHAR *kal_wstrcat(WCHAR *s1, const WCHAR *s2);
WCHAR *kal_wstrncat(WCHAR *s1, const WCHAR *s2, int n);
WCHAR *kal_wstrchr(const WCHAR *s, int c);
WCHAR *kal_wstrrchr(const WCHAR *str, int ch);

/* dual 8bits string operations */
int kal_dchar_strlen(const char *wstr);
char *kal_dchar_strcpy(char *to, const char *from);
char *kal_dchar_strncpy(char *to, const char *from, int n);
int kal_dchar_strcmp(const char *s1, const char *s2);
int kal_dchar_strncmp(const char *s1, const char *s2, int n);
char *kal_dchar_strcat(char *s1, const char *s2);
char *kal_dchar_strncat(char *s1, const char *s2, int n);
char *kal_dchar_strchr(const char *s, int c);
char *kal_dchar_strrchr(const char *str, int ch);
void kal_dchar2char(WCHAR *outstr, char* tostr);

void kal_wsprintf(WCHAR *outstr, char *fmt,...);
#define kal_toWCHAR(asciiString) L##asciiString


/*************************************************************************
 * Include Statements (include at the end of file because of depnedency)
 *************************************************************************/

#if defined(KAL_ON_NUCLEUS)
#include "kal_nucleus_common_defs.h"
#include "kal_nucleus.h"
#elif defined(KAL_ON_OSCAR)
#include "kal_oscar_common_defs.h"
#include "kal_oscar.h"
#elif defined(KAL_ON_THREADX)
#include "kal_threadx.h"
#endif

#if defined(KAL_ON_NUCLEUS) || defined(MTK_KAL_MNT) || defined(KAL_ON_OSCAR) || defined(KAL_ON_THREADX)

#include "kal_internal.h"
#include "lcd_ip_cqueue.h"

#ifdef DEBUG_KAL
#include "kal_debug_common_defs.h"
#endif

#if defined(KAL_ON_NUCLEUS) || defined(MTK_KAL_MNT)
#include "kal_debug_nucleus.h"
#elif defined(KAL_ON_OSCAR)
#include "kal_debug_oscar.h"
#endif

#include "kal_debug.h"
#include "kal_trace.h"

#endif /* KAL_ON_NUCLEUS || MTK_KAL_MNT || KAL_ON_OSCAR || KAL_ON_THREADX */

#include "kal_active_module.h"


#endif /* _KAL_RELEASE_H */


