/*******************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*******************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *	isp_if.h
 *
 * Project:
 * --------
 *   MT6219,MT6226,MT6227,MT6228,MT6229,MT6230
 *
 * Description:
 * ------------
 *   This file is intends for ISP driver.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef _ISP_IF_H
#define _ISP_IF_H

#include "drv_features.h"
#include "reg_base.h"

#if (defined(DRV_ISP_6219_SERIES)||defined(DRV_ISP_6227_SERIES)||defined(DRV_ISP_6225_SERIES)||defined(DRV_ISP_6228_SERIES)||defined(DRV_ISP_6229_SERIES))
#include "isp_if_622x_series_hw.h"
#endif

#if (defined(DRV_ISP_6219_SERIES)||defined(DRV_ISP_6227_SERIES)||defined(DRV_ISP_6225_SERIES)||defined(DRV_ISP_6228_SERIES)||defined(DRV_ISP_6229_SERIES))

#define CAMERA_ISP_IDLE_EVENT			0x00000001
#define CAMERA_ISP_FRAME_READY_EVENT	0x00000002
#define CAMERA_JPEG_ENCODE_EVENT			0x00000004
#define CAMERA_ISP_VD_READY_EVENT		0x00000008

#define ISP_MAX_DIGITAL_ZOOM_FACTOR		80			/* 8X zoom */
#define ISP_MIN_DIGITAL_ZOOM_FACTOR		10			/* 1X zoom */
#define ISP_DIGITAL_ZOOM_INTERVAL		10

#define ISP_INC_DIGITAL_ZOOM		0
#define ISP_DEC_DIGITAL_ZOOM		1
#define ISP_INC_CONTRAST			0
#define ISP_DEC_CONTRAST			1
#define ISP_INC_BRIGHTNESS			0
#define ISP_DEC_BRIGHTNESS			1

#define LEAVE_INIT_ISP_IF							0x00000001
#define LEAVE_POWER_OFF_ISP						0x00000002
#define LEAVE_ISP_DIGITAL_ZOOM					0x00000004
#define LEAVE_ISP_FAST_ZOOM_SETTING				0x00000008
#define LEAVE_CAMERA_PREVIEW						0x00000010
#define LEAVE_EXIT_CAMERA_PREVIEW				0x00000020
#define LEAVE_CAMERA_CAPTURE_JPEG				0x00000040
#define LEAVE_STOP_CAMERA_CAPTURE				0x00000080
#define LEAVE_CAMERA_CAPTURE_BARCODE			0x00000100
#define LEAVE_STOP_CAMERA_CAPTURE_BARCODE		0x00000200
#define LEAVE_PAUSE_CAMERA_CAPTURE_BARCODE	0x00000400
#define LEAVE_RESUME_CAMERA_CAPTURE_BARCODE	0x00000800
#define LEAVE_CAMERA_CAPTURE_MEM					0x00001000
#define LEAVE_MPEG4_ENCODE							0x00002000
#define LEAVE_MPEG4_ENCODE_START					0x00004000
#define LEAVE_MPEG4_ENCODE_PAUSE					0x00008000
#define LEAVE_MPEG4_ENCODE_RESUME				0x00010000
#define LEAVE_EXIT_MPEG4_ENCODE					0x00020000
#define LEAVE_MJPEG_ENCODE							0x00040000
#define LEAVE_MJPEG_ENCODE_START					0x00080000
#define LEAVE_MJPEG_ENCODE_PAUSE					0x00100000
#define LEAVE_MJPEG_ENCODE_RESUME				0x00200000
#define LEAVE_EXIT_MJPEG_ENCODE					0x00400000

typedef enum
{
	CAMERA_SYSTEM_NORMAL_MODE=0,
	CAMERA_SYSTEM_META_MODE
} CAMERA_SYSTEM_ENUM;

typedef enum
{
	ISP_IDLE_STATE=0,
	ISP_STANDBY_STATE,
	ISP_PREVIEW_STATE,
	ISP_CAPTURE_JPEG_STATE,
	ISP_CAPTURE_MEM_STATE,
	ISP_MPEG4_ENCODE_STATE,
	ISP_CAPTURE_BARCODE_STATE,
	ISP_MJPEG_ENCODE_STATE,
	ISP_VIDEO_FULLDUPLEX_ENCODE_STATE
} ISP_OPERATION_STATE_ENUM;

typedef enum
{
	ISP_PREVIEW_MODE,
	ISP_MPEG4_PREVIEW_MODE,
	ISP_MPEG4_ENCODE_MODE,
	ISP_MJPEG_PREVIEW_MODE,
	ISP_MJPEG_ENCODE_MODE
} ISP_OPERATION_MODE_ENUM;

enum
{
	IMAGE_NORMAL=0,
	IMAGE_H_MIRROR,
	IMAGE_V_MIRROR,
	IMAGE_HV_MIRROR
};


#if (!defined(DRV_ISP_6219_SERIES))
typedef enum
{
	AF_ENABLE=0,
	AF_METERING,
	SHUTTER_PRIORITY,
	APERTURE_PRIORITY,
	SCENE_MODE
} LENS_OPERATION_ENUM;
#endif

#define CAMERA_IDLE_MODE		0
#define CAMERA_PREVIEW_MODE	1
#define CAMERA_CAPTURE_MODE	2

#define CAMERA_SUB_SAMPLE_1_1		0x0
#define CAMERA_SUB_SAMPLE_1_2		0x1
#define CAMERA_SUB_SAMPLE_1_4		0x2
#define CAMERA_SUB_SAMPLE_1_8		0x4

#define CAMERA_TEST_AE_COUNT				3
#define CAMERA_TEST_HISTOGRAM_COUNT		3
#define CAMERA_TEST_OPD_RESULT_COUNT	3

typedef struct
{
	kal_uint16 grab_start_x;				/* The first grabed column data of the image sensor in pixel clock count */
	kal_uint16 grab_start_y;				/* The first grabed row data of the image sensor in pixel clock count */
	kal_uint16 exposure_window_width;	/* Exposure window width of image sensor */
	kal_uint16 exposure_window_height;	/* Exposure window height of image sensor */
	kal_uint16 image_target_width;		/* image captured width */
	kal_uint16 image_target_height;		/* image captuerd height */
//	kal_uint16 isp_grab_width;				/* the image width that ISP would like to grab */
//	kal_uint16 isp_grab_height;			/* the image height that ISP would like to grab */
	kal_uint16 exposure_pixel;				/* exposure window width of image sensor + dummy pixel */
	kal_uint16 exposure_line;				/* exposure window width of image sensor + dummy line */
	kal_uint8  digital_zoom_factor;		/* digital zoom factor */
	kal_uint16 current_exposure_pixel;	/* exposure window width of image sensor + dummy pixel */
	kal_uint8  isp_hsub_factor;			/* isp horizontal sub-sample factor for special preview size of sensor, 1~255 */
	kal_uint8  isp_vsub_factor;			/* isp vertical sub-sample factor for special preview size of sensor,   1~255 */
#if (defined(YUV_SENSOR_SUPPORT))
	kal_bool		night_mode;					/* enable/disable camera night mode */
	kal_uint8 	exposure_value;			/* AE exposure target value */
	kal_uint8 	contrast_level;			/* ISP contrast gain level */
	kal_uint8 	brightness_level;			/* ISP brightness level */
	kal_uint8	saturation_value;			/* image processor saturation value */
	kal_uint8	wb_mode;						/* white balance mode */
	kal_uint8 	ev_value;					/* EV adjust value */
	kal_uint8 	banding_freq;				/* Banding frequency selection */
	kal_uint8 	image_effect;				/* image effect for preview */
	kal_uint16 	hue_value;					/* image processor hue value */
#endif
} image_sensor_exposure_window_struct;

typedef struct
{
	kal_bool		enable_shutter_tansfer;	/* capture only */
	kal_uint16	capture_shutter;			/* capture only */
	kal_uint8	image_mirror;
	kal_uint16 	frame_rate;
	kal_uint8 	meta_mode;					/* capture only, CAPTURE_MODE_ENUM */
	kal_bool		enable_flashlight_tansfer;	/* flash light capture only */	
	kal_uint16	flashlight_duty;				/* flash light capture only */	
	kal_uint16	flashlight_offset;			/* flash light capture only */		
	kal_uint16	flashlight_shut_factor;			/* flash light capture only */				
	kal_uint16  preview_width;
	kal_uint16  preview_height;
	kal_uint8	isp_op_mode;				/* isp operation mode */
	kal_uint16	sensor_frame_rate;		/* frame rate of sensor, 10 means 1fps */
} image_sensor_config_struct;

typedef struct
{
   kal_int8 (* sensor_init)(void);
   void (* get_sensor_id)(kal_uint8 *sensor_write_id, kal_uint8 *sensor_read_id);
   void (* get_sensor_size)(kal_uint16 *sensor_width, kal_uint16 *sensor_height);
   void (* get_sensor_period) (kal_uint16 *pixel_number, kal_uint16 *line_number);
   void (* sensor_preview_setting)(image_sensor_exposure_window_struct *image_window, image_sensor_config_struct *sensor_config_data);
   void (* sensor_capture_setting)(image_sensor_exposure_window_struct *image_window, image_sensor_config_struct *sensor_config_data);
   void (* write_sensor_reg)(kal_uint32 cmd, kal_uint32 para);
   kal_uint32 (* read_sensor_reg)(kal_uint32 cmd);
   void (* set_sensor_eshutter)(kal_uint16 eshutter);
   void (* set_camera_night_mode) (kal_bool enable);
   void (* sensor_power_off) (void);
   kal_uint16 (* set_sensor_gain) (kal_uint16 gain);
#if (!defined(DRV_ISP_6219_SERIES))
   void (* set_flashlight) (kal_bool enable);
#if (defined(YUV_SENSOR_SUPPORT))
   kal_uint32 (* yuv_sensor_setting)(kal_uint32 cmd, kal_uint32 para);
#endif
#endif
} image_sensor_func_struct;

/* lens interface */
typedef struct
{
	kal_int8 (* lens_init)(void);
	void (* lens_power_on)(void);
	void (* lens_power_off)(void);
	void (* lens_standby)(void);
	void (* get_lens_id)(kal_uint8 *id);
	kal_uint8 (*lens_af_home_check)(void);
	kal_uint32 (*get_lens_af_current_pos)( void );
	void (*lens_af_step_cw)( kal_uint32 num );
	void (*lens_af_step_ccw)( kal_uint32 num );
	void (*lens_af_move_to)( kal_int32 target_pos );
	kal_uint8 (*get_lens_af_status)( void );
	void (*lens_ms_open)(void);
	void (*lens_ms_close)(void);
	kal_uint8 (*get_lens_current_iris)(void);	
	void (*lens_set_iris)(kal_uint8 iris_sel);	
} lens_func_struct;

typedef struct
{
	kal_uint8 	lcd_id;
	kal_uint16 	lcm_start_x;				/* the start x axis of LCM to be updated*/
	kal_uint16 	lcm_start_y;				/* the start y axis of LCM to be updated*/
	kal_uint16 	lcm_end_x;					/* the end x axis of LCM to be updated*/
	kal_uint16 	lcm_end_y;					/* the end y axis of LCM to be updated*/
	kal_uint16 	roi_offset_x;				/* the ROI window offset x from main window */
	kal_uint16 	roi_offset_y;				/* the ROI window offset y from main window */
	kal_uint32 	update_layer;				/* the updated layer */
	kal_uint32 	hw_update_layer;			/* which layer will be applied by hw trigger or direct couple for MT6219 only */
	kal_uint8 	rotate_value;				/* rotate select for hardware update layer */
	kal_uint8	frame_rate;					/* camera or video frame rate, 0xFF for preview, 0x0F for 6219 video */
	kal_uint8	continue_capture;			

	kal_uint8 	contrast_level;			/* ISP contrast gain level */
	kal_uint8 	brightness_level;			/* ISP brightness level */
	kal_uint8	saturation_value;			/* image processor saturation value */
	kal_uint8	wb_mode;						/* white balance mode */
	kal_uint8 	ev_value;					/* EV adjust value */
	kal_uint8 	banding_freq;				/* Banding frequency selection */
	kal_uint8 	image_effect;				/* image effect for preview */
	kal_bool		night_mode;					/* enable/disable camera night mode */
	kal_uint16 	hue_value;					/* image processor hue value */
	kal_uint8 	exposure_value;			/* AE exposure target value */

	kal_uint32 	intmem_start_address;	/* internal memory start address for hardware engine buffer */
	kal_uint32 	intmem_size;				/* internal memory size for hardware engine buffer */
	kal_uint32 	extmem_start_address;	/* external memroy start address for hardware engine buffer */
	kal_uint32 	extmem_size;				/* external memory size for hardware engine buffer */

	kal_uint8	zoom_factor;				/* digital zoom factor from 10(1X) ~ 40 (4X) */
	kal_uint8   image_mirror;				/* horizonal/vertical mirror from image sensor */
	kal_uint16 	source_width;				/* the widht of source image into resizer */
	kal_uint16 	source_height;				/* the height of source image into resizer */
	kal_uint16 	target_width;				/* the width of target image */
	kal_uint16 	target_height;				/* the height of target image */
	kal_uint16  preview_offset_x;			/* the x offset from frame buffer */
	kal_uint16  preview_offset_y; 		/* the y offset from frame buffer */
	kal_uint32	frame_buffer_address;	/* the frame buffer start address of image DMA output for LCD fb update */
	kal_uint32 	frame_buffer_size;		/* the frame buffer size of image DMA output for LCD fb updaet */
	kal_uint32	frame_buffer_address1;	/* for LCD dual buffer update */
	kal_uint32 	frame_buffer_size1;		/* for LCD dual buffer update */
	kal_uint32	roi_background_color;			/* set the background color */
	kal_bool		lcd_update;					/* enable/disable LCD update */

	kal_uint16  	camera_offset_x;			/* the x offset from LCM for camera*/
	kal_uint16  	camera_offset_y; 			/* the y offset from LCM for camera*/
	kal_uint16	af_zone0_x;					/* AF Zone 0 X-coordinate, (0,0) means left-top corner */
	kal_uint16	af_zone0_y;					/* AF Zone 0 Y-coordinate */
	kal_uint16	af_zone1_x;					/* AF Zone 1 X-coordinate */
	kal_uint16	af_zone1_y;					/* AF Zone 1 Y-coordinate */
	kal_uint16	af_zone2_x;					/* AF Zone 2 X-coordinate */
	kal_uint16	af_zone2_y;					/* AF Zone 2 Y-coordinate */
	kal_uint16	af_zone3_x;					/* AF Zone 3 X-coordinate */
	kal_uint16	af_zone3_y;					/* AF Zone 3 Y-coordinate */
	kal_uint16	af_zone4_x;					/* AF Zone 4 X-coordinate */
	kal_uint16	af_zone4_y;					/* AF Zone 4 Y-coordinate */

#if (!defined(DRV_ISP_6219_SERIES))
	/* ISP Setting */
	kal_uint8	dsc_mode;							/* NORMALSCENE, PORTRAIT, LANDSCAPE, SPORT, FLOWER, NIGHTSCENE, TV, AV, ISO */
	kal_uint8	ae_metering_mode;					/* AUTO, SPOT, CENTRAL WEIGHT, AVERAGE */
	kal_uint8	af_mode;								/* AUTO, MACRO, INFINITE, MANUAL */
	kal_uint8	af_metering_mode;					/* SINGLE, MULTI3, MULTI5 */
	kal_uint16	tv_setting;							/* Shutter Priority Value Setting */
	kal_uint8	av_setting;							/* Aperture Priority Value Setting */
	kal_uint8	iso_setting;						/* AUTO, 100, 200, 400 */
	kal_uint8	flash_mode;							/* AUTO, ON, OFF, REDEYE */
#endif
#if (defined(DRV_ISP_6228_SERIES)||defined(DRV_ISP_6229_SERIES))
	/* IPP Setting */
	kal_bool		image_pitch_mode;					/* KAL_TRUE or KAL_FALSE for block mode of decoded image */
	kal_uint8	image_data_format;				/* IMGDMA_IBW_OUTPUT_RGB565 or IMGDMA_IBW_OUTPUT_RGB888 */
	kal_uint16	image_pitch_bytes;				/* pitch width */

	kal_bool		overlay_frame_mode;				/* KAL_TRUE or KAL_FALSE to enable or disable overlay function */
	kal_uint8	overlay_color_depth;				/* The color depth of overlay frame buffer */
	kal_uint8	overlay_frame_source_key;
	kal_uint16  overlay_frame_width;				/* Image width of overlay frame buffer */
	kal_uint16	overlay_frame_height;			/* Image height of overlay frame buffer */
	kal_uint32  overlay_frame_buffer_address;	/* The starting address of overlay frame buffer */
	/* TV Setting */
	kal_bool		tv_output;
	kal_uint16	tv_output_width;					/* image width for TV output */
	kal_uint16	tv_output_height;					/* image height for TV output */
	kal_uint16  tv_output_offset_x;				/* the offset X from TV output frame buffer to preview image */
	kal_uint16  tv_output_offset_y;				/* the offset Y from TV output frame buffer to preview image */
   kal_uint32 	tv_output_buffer1_address;		/* image buffer1 for TV source buffer */
   kal_uint32 	tv_output_buffer2_address;		/* image buffer2 for TV source buffer */
   kal_uint32  tv_rotate_buffer1_address;		/* image buffer1 for TV output rotate buffer */
   kal_uint32 	tv_rotate_buffer2_address;		/* image buffer2 for TV output rotate buffer */
   kal_uint32 	tv_output_buffer_size;			/* image buffer size for TV source buffer */
#endif

	void (*cam_preview_cb) (kal_uint8 return_code);	/* call back function for camera preview AE/AWB adjustment */
#if (!defined(DRV_ISP_6219_SERIES))
	void (*cam_focus_cb) (kal_uint8 return_code);	/* call back function for auto focus report */
#endif	
} camera_preview_process_struct;

typedef struct
{
	kal_uint32 	jpeg_file_size[20];
	kal_uint32 	jpeg_file_address[20];
} isp_burst_capture_info_struct;

typedef struct
{
	kal_uint32 	intmem_start_address;	/* internal memory start address for hardware engine buffer */
	kal_uint32 	intmem_size;				/* internal memory size for hardware engine buffer */
	kal_uint32 	extmem_start_address;	/* external memroy start address for hardware engine buffer */
	kal_uint32 	extmem_size;				/* external memory size for hardware engine buffer */
	
	kal_uint32  source_width;				/* the image width of resizer */
	kal_uint32	source_height;				/* the image height of resizer */
	kal_uint16 	target_width;				/* the width of target image */
	kal_uint16 	target_height;				/* the height of target image */

	kal_uint8  	image_quality;				/* the image quality after encoded */
	kal_uint8  	jpeg_gray_mode;			/* encode a file as gray mode or not */

   kal_uint32 	y_address;	            /* the source start address for SW JPEG encoder or LCD output */
	kal_uint32 	u_address;	            /* the source start address for SW JPEG encoder or LCD output */
   kal_uint32 	v_address;	            /* the source start address for SW JPEG encoder or LCD output */
   kal_uint32 	y_size;          			/* the size of y buffer for SW JPEG encoder or LCD output */
	kal_uint32 	u_size;          			/* the size of u buffer for SW JPEG encoder or LCD output */
   kal_uint32 	v_size;          			/* the size of v buffer for SW JPEG encoder or LCD output */

	kal_uint32 	target_buffer_start_address;	/* the start address for JPEG encoder or LCD output */
	kal_uint32 	target_buffer_size;				/* the maximum size of for JPEG encoder or LCD output */

    kal_bool memory_output; /* is direct couple to another buffer */
    kal_uint8 memory_output_type;
    kal_uint16 memory_output_width;
    kal_uint16 memory_output_height;
    kal_uint32 memory_output_buffer_address;
    kal_uint32 memory_output_buffer_size;

#if (!defined(DRV_ISP_6219_SERIES))
	kal_uint8	flash_mode;							/* AUTO, ON, OFF, RED-EYE */
#endif
#if (defined(DRV_ISP_6228_SERIES)||defined(DRV_ISP_6229_SERIES))
	/* ISP Setting */
	isp_burst_capture_info_struct 	*jpeg_file_info;
	kal_uint8 	snapshot_number;					/* total number of captured picture in on shot */

	/* JPEG Setting */
	kal_uint8	jpeg_yuv_mode;
	
	kal_bool		thumbnail_mode;					/* add thumbnail in JPEG file or not */
	kal_uint16	thumbnail_width;
	kal_uint16 	thumbnail_height;
	/* IPP Setting */
	kal_bool 	overlay_frame_mode;				/* KAL_TRUE or KAL_FALSE */
	kal_uint8	overlay_color_depth;				/* 1/2/4/8 bpp */
	kal_uint8	overlay_frame_source_key;		/* source key of the overlay frame buffer */
	kal_uint16  overlay_frame_width;				/* overlay frame width */
	kal_uint16	overlay_frame_height;			/* overlay frame height */
	kal_uint32  overlay_frame_buffer_address;	/* bsae address of the overlay frame buffer */

	kal_bool		image_pitch_mode;					/* KAL_TRUE or KAL_FALSE for block mode of decoded image */
	kal_uint8	image_data_format;				/* IMGDMA_IBW_OUTPUT_RGB565 or IMGDMA_IBW_OUTPUT_RGB888 */
	kal_uint16	image_pitch_bytes;				/* pitch width */

	/* Display Setting */
	kal_uint8 	lcd_id;
	kal_uint16 	lcm_start_x;				/* the start x axis of LCM to be updated*/
	kal_uint16 	lcm_start_y;				/* the start y axis of LCM to be updated*/
	kal_uint16 	lcm_end_x;					/* the end x axis of LCM to be updated*/
	kal_uint16 	lcm_end_y;					/* the end y axis of LCM to be updated*/
	kal_uint16 	roi_offset_x;				/* the ROI window offset x from main window */
	kal_uint16 	roi_offset_y;				/* the ROI window offset y from main window */
	kal_uint32 	update_layer;				/* the updated layer */
	kal_uint32 	hw_update_layer;			/* which layer will be applied by hw trigger or direct couple for MT6219 only */

	kal_bool		display;								/* output to LCM or TV */
	kal_uint32	frame_buffer_address;
	kal_uint32 	frame_buffer_size;

	kal_bool		tv_output;							/* works when display item is KAL_TRUE */
	kal_uint16	tv_output_width;					/* image width for TV output */
	kal_uint16	tv_output_height;					/* image height for TV output */
	kal_uint16  tv_output_offset_x;				/* the offset X from TV output frame buffer to preview image */
	kal_uint16  tv_output_offset_y;				/* the offset Y from TV output frame buffer to preview image */
   kal_uint32 	tv_output_buffer1_address;		/* image buffer1 for TV source buffer */
	kal_uint32 	tv_output_buffer2_address;		/* image buffer2 for TV source buffer, if snapshot_number==1, this buffer is not necessary */
   kal_uint32 	tv_output_buffer_size;			/* image buffer size for TV source buffer */
#endif

	void (*cam_capture_jpeg_cb) (kal_uint8 return_code);	/* call back function for camera capture */
} camera_capture_jpeg_struct;

typedef struct
{
	kal_uint8 	lcd_id;
	kal_uint16 	lcm_start_x;				/* the start x axis of LCM to be updated*/
	kal_uint16 	lcm_start_y;				/* the start y axis of LCM to be updated*/
	kal_uint16 	lcm_end_x;					/* the end x axis of LCM to be updated*/
	kal_uint16 	lcm_end_y;					/* the end y axis of LCM to be updated*/
	kal_uint16 	roi_offset_x;				/* the ROI window offset x from main window */
	kal_uint16 	roi_offset_y;				/* the ROI window offset y from main window */
	kal_uint32 	update_layer;				/* the updated layer */
	kal_uint32 	hw_update_layer;			/* which layer will be applied by hw trigger or direct couple for MT6219 only */

	kal_uint8 	banding_freq;				/* Banding frequency selection */
	kal_uint8   image_mirror;				/* horizonal/vertical mirror from image sensor */
	kal_uint8	frame_rate;					/* camera or video frame rate, 0xFF for preview, 0x0F for 6219 video */
	kal_uint8 	ev_value;					/* EV adjust value */
	
	kal_uint16  camera_offset_x;			/* the x offset from LCM for camera*/
	kal_uint16  camera_offset_y; 			/* the y offset from LCM for camera*/
	kal_uint16	af_zone0_x;					/* AF Zone 0 X-coordinate, (0,0) means left-top corner */
	kal_uint16	af_zone0_y;					/* AF Zone 0 Y-coordinate */
	kal_uint16	af_zone1_x;					/* AF Zone 1 X-coordinate */
	kal_uint16	af_zone1_y;					/* AF Zone 1 Y-coordinate */
	kal_uint16	af_zone2_x;					/* AF Zone 2 X-coordinate */
	kal_uint16	af_zone2_y;					/* AF Zone 2 Y-coordinate */
	kal_uint16	af_zone3_x;					/* AF Zone 3 X-coordinate */
	kal_uint16	af_zone3_y;					/* AF Zone 3 Y-coordinate */
	kal_uint16	af_zone4_x;					/* AF Zone 4 X-coordinate */
	kal_uint16	af_zone4_y;					/* AF Zone 4 Y-coordinate */

	kal_uint32 	intmem_start_address;	/* internal memory start address for hardware engine buffer */
	kal_uint32 	intmem_size;				/* internal memory size for hardware engine buffer */
	kal_uint32 	extmem_start_address;	/* external memroy start address for hardware engine buffer */
	kal_uint32 	extmem_size;				/* external memory size for hardware engine buffer */

	kal_uint32  source_width;				/* the image width of resizer */
	kal_uint32	source_height;				/* the image height of resizer */
	kal_uint16 	target_width;				/* the width of target barcode image */
	kal_uint16 	target_height;				/* the height of target barcode image */

	kal_uint32	frame_buffer_address;	/* the frame buffer start address of image DMA output for LCD fb update */
	kal_uint32 	frame_buffer_size;		/* the frame buffer size of image DMA output for LCD fb updaet */
	kal_uint32	frame_buffer_address1;	/* for LCD dual buffer update */
	kal_uint32 	frame_buffer_size1;		/* for LCD dual buffer update */

	kal_uint32 	barcode_buffer_address;	/* the start address for barcode image output */
	kal_uint32 	barcode_buffer_size;		/* the maximum buffer size for barcode image output */

#if (defined(DRV_ISP_6228_SERIES)||defined(DRV_ISP_6229_SERIES))
	kal_uint8   barcode_image_data_format;		/* IMGDMA_IBW_OUTPUT_RGB565 or IMGDMA_IBW_OUTPUT_RGB888 */

	kal_bool	image_pitch_mode;					/* KAL_TRUE or KAL_FALSE for block mode of decoded image */
	kal_uint8	image_data_format;				/* IMGDMA_IBW_OUTPUT_RGB565 or IMGDMA_IBW_OUTPUT_RGB888 */
	kal_uint16	image_pitch_bytes;				/* pitch width */

	kal_bool		tv_output;							/* works when display item is KAL_TRUE */
	kal_uint16	tv_output_width;					/* image width for TV output */
	kal_uint16	tv_output_height;					/* image height for TV output */
	kal_uint16  tv_output_offset_x;				/* the offset X from TV output frame buffer to preview image */
	kal_uint16  tv_output_offset_y;				/* the offset Y from TV output frame buffer to preview image */
   kal_uint32 	tv_output_buffer1_address;		/* image buffer1 for TV source buffer */
	kal_uint32 	tv_output_buffer2_address;		/* image buffer2 for TV source buffer, if snapshot_number==1, this buffer is not necessary */
   kal_uint32 	tv_output_buffer_size;			/* image buffer size for TV source buffer */
#endif

	void (*cam_preview_cb) (kal_uint8 return_code);	/* call back function for camera preview AE/AWB adjustment */
	void (*cam_capture_barcode_cb) (kal_uint8 return_code);	/* call back function for barcode capture */
	void (*cam_focus_cb) (kal_uint8 return_code);	/* call back function for auto focus report */
} camera_capture_barcode_struct;

typedef struct
{
	kal_uint32 	intmem_start_address;	/* internal memory start address for hardware engine buffer */
	kal_uint32 	intmem_size;				/* internal memory size for hardware engine buffer */
	kal_uint32 	extmem_start_address;	/* external memroy start address for hardware engine buffer */
	kal_uint32 	extmem_size;				/* external memory size for hardware engine buffer */
	kal_uint32  source_width;				/* the image width of resizer */
	kal_uint32	source_height;				/* the image height of resizer */
	kal_uint16 	target_width;				/* the width of target image */
	kal_uint16 	target_height;				/* the height of target image */
	kal_uint32 	imgdma_buffer_address;	/* the start address for image DMA output */
	kal_uint32 	imgdma_buffer_size;		/* the buffer size for image DMA output */

	kal_uint8 	block_mode;					/* block write out or not */
	kal_uint16 	dest_block_width;			/* x pitch of block write operation */
	kal_uint32 	dest_buffer_address;		/* the start address of desination buffer for LCD memory write out */
	kal_uint32 	dest_buffer_size;
	kal_uint16 	roi_offset_x;				/* x offset of interest area from dest buffer */
	kal_uint16	roi_offset_y;				/* y offset of interest area from dest buffer */
	kal_uint16	roi_width;					/* dest image width */
	kal_uint16	roi_height;					/* dest image height */
	kal_uint32 	update_layer;
	kal_uint32	hw_update_layer;
	kal_uint32	roi_background_color;	/* background color of memory otuput buffer */

#if (defined(DRV_ISP_6228_SERIES)||defined(DRV_ISP_6229_SERIES))
	/* ISP Setting */
	kal_bool		manual_wb;					/* KAL_TRUE or KAL_FALSE to enable or disable manual white balance */
	/* IPP Setting */
	kal_uint8 	overlay_frame_mode;
	kal_uint8 	overlay_color_depth;
	kal_uint8	overlay_frame_source_key;
	kal_uint16  overlay_frame_width;
	kal_uint16	overlay_frame_height;
	kal_uint32  overlay_frame_buffer_address;

	kal_bool		image_pitch_mode;			/* KAL_TRUE or KAL_FALSE for block mode of decoded image */
	kal_uint8	image_data_format;		/* IMGDMA_IBW_OUTPUT_RGB565 or IMGDMA_IBW_OUTPUT_RGB888 */
	kal_uint16	image_pitch_bytes;		/* pitch width */

	kal_bool		image_clip_mode;			/* KAL_TRUE or KAL_FALSE for clipping image */
	kal_uint16  image_clip_x1;				/* clip window start x for clipping captured image */
	kal_uint16  image_clip_x2;				/* clip window end x for clipping captured image */
	kal_uint16	image_clip_y1;				/* clip window start y for clipping captured image */
	kal_uint16	image_clip_y2;				/* clip window end y for clipping captured image */
	/* LCD Setting */
	kal_uint8 	memory_data_format;		/* output data format */
#endif

	void (*cam_capture_mem_cb) (kal_uint8 return_code);	/* call back function for camera capture */
}	camera_capture_mem_struct;

typedef struct
{
	kal_uint32 	intmem_start_address;	/* internal memory start address for hardware engine buffer */
	kal_uint32 	intmem_size;				/* internal memory size for hardware engine buffer */
	kal_uint32 	extmem_start_address;	/* external memroy start address for hardware engine buffer */
	kal_uint32 	extmem_size;				/* external memory size for hardware engine buffer */
	kal_uint32  video_buffer1_address;
	kal_uint32  video_buffer2_address;
	kal_bool		init_mem;					/* init intmem and extmem */
	
	kal_uint16  image_source_width;		/* the resizer input width of first run */
	kal_uint16 	image_source_height;		/* the resizer input height of first run */
	kal_uint16 	mpeg4_image_width;		/* the resier output width of first run for MPEG4 encoder */
	kal_uint16	mpeg4_image_height;		/* the resizer output height of first run for MPEG4 encoder */
	kal_uint16	image_target_width;		/* the resizer output width of second run for LCD display */
	kal_uint16 	image_target_height;		/* the resizer output height of second run for LCD display */

	kal_uint32 	encode_bit_rate;
	kal_uint8 	short_header_mode;
	kal_bool 	resume_enable;

	kal_uint8 	lcd_id;						/* MAIN_LCD or SUB_LCD */
	kal_uint16 	lcm_start_x;				/* the start x axis of LCM to be updated*/
	kal_uint16 	lcm_start_y;				/* the start y axis of LCM to be updated*/
	kal_uint16 	lcm_end_x;					/* the end x axis of LCM to be updated*/
	kal_uint16 	lcm_end_y;					/* the end y axis of LCM to be updated*/
	kal_uint16 	roi_offset_x;				/* the ROI window offset x from main window */
	kal_uint16 	roi_offset_y;				/* the ROI window offset y from main window */
	kal_uint32 	update_layer;				/* the updated layer */
	kal_uint32 	hw_update_layer;			/* which layer will be applied by hw trigger or direct couple for MT6219 only */
	kal_uint8 	rotate_value;				/* rotate select for hardware update layer */
	kal_uint8   image_mirror;				/* horizonal/vertical mirror from image sensor */
   kal_uint8   skip_frame_count;       /* skip frame count for video driver */
   kal_uint8	frame_rate;					/* video encoding frame rate , 0xFF for preview, 0x0F for 6219 video */
	kal_uint32	frame_buffer_address;	/* the frame buffer start address of image DMA output for LCD fb update */
	kal_uint32  frame_buffer_size;		/* the frame buffer size of image DMA output for LCD fb updaet */
	kal_uint16 	mpeg4_offset_x;
	kal_uint16	mpeg4_offset_y;
	kal_uint32	roi_background_color;	/* set the background color */
	kal_bool		lcd_update;					/* enable/disable LCD update */

	kal_uint8	zoom_factor;				/* digital zoom factor from 10(1X) ~ 40 (4X) */
	kal_uint8 	contrast_level;			/* ISP contrast gain level */
	kal_uint8 	brightness_level;			/* ISP brightness level */
	kal_uint8	saturation_value;			/* image processor saturation value */
	kal_uint8	wb_mode;						/* white balance mode */
	kal_uint8 	ev_value;					/* EV adjust value */
	kal_uint8 	banding_freq;				/* Banding frequency selection */
	kal_uint8 	image_effect;				/* image effect for preview */
	kal_bool		night_mode;					/* enable/disable camera night mode */

#if (defined(DRV_ISP_6228_SERIES)||defined(DRV_ISP_6229_SERIES))
	/* IPP Setting */
	kal_uint8 	overlay_frame_mode;
	kal_uint8 	overlay_color_depth;
	kal_uint8	overlay_frame_source_key;
	kal_uint16  overlay_frame_width;
	kal_uint16	overlay_frame_height;
	kal_uint32  overlay_frame_buffer_address;

	kal_bool		image_pitch_mode;							/* KAL_TRUE or KAL_FALSE for block mode of decoded image */
	kal_uint8	image_data_format;						/* IMGDMA_IBW_OUTPUT_RGB565 or IMGDMA_IBW_OUTPUT_RGB888 */
	kal_uint16	image_pitch_bytes;						/* pitch width */
	/* TV Setting */
	kal_bool		tv_output;
	kal_uint16	tv_output_width;
	kal_uint16 	tv_output_height;
	kal_uint16	tv_output_offset_x;
	kal_uint16	tv_output_offset_y;
   kal_uint32 	tv_output_buffer1_address;		/* image buffer1 for TV source buffer */
   kal_uint32 	tv_output_buffer2_address;		/* image buffer2 for TV source buffer */
   kal_uint32 	tv_output_buffer_size;			/* image buffer size for TV source buffer */
#endif

	void (*mpeg4_encode_cb) (kal_uint32 yuv_address);						/* call back function to start mpeg4 encoder */
	void (*encode_event_cb) (kal_uint8 event);  		/* call back function for event indication */
	void (*cam_encode_cb) (kal_uint8 return_code);	/* call back function for AE/AWB adjustment*/
}	mpeg4_encode_process_struct;

typedef struct
{
	kal_uint32 	intmem_start_address;	/* internal memory start address for hardware engine buffer */
	kal_uint32 	intmem_size;				/* internal memory size for hardware engine buffer */
	kal_uint32 	extmem_start_address;	/* external memroy start address for hardware engine buffer */
	kal_uint32 	extmem_size;				/* external memory size for hardware engine buffer */
	kal_uint32  video_buffer1_address;
	kal_uint32  video_buffer2_address;
	kal_bool		init_mem;					/* init intmem and extmem */
	
	kal_uint16  image_source_width;		/* the resizer input width of first run */
	kal_uint16 	image_source_height;		/* the resizer input height of first run */
	kal_uint16 	viedo_encode_image_width;		/* the resier output width of first run for video encoder */
	kal_uint16	viedo_encode_image_height;		/* the resizer output height of first run for video encoder */
	kal_uint16	image_target_width;		/* the resizer output width of second run for LCD display */
	kal_uint16 	image_target_height;		/* the resizer output height of second run for LCD display */

	kal_uint32 	encode_bit_rate;
	kal_uint8 	short_header_mode;
	kal_bool 	resume_enable;

	kal_uint8 	lcd_id;						/* MAIN_LCD or SUB_LCD */
	kal_uint16 	lcm_start_x;				/* the start x axis of LCM to be updated*/
	kal_uint16 	lcm_start_y;				/* the start y axis of LCM to be updated*/
	kal_uint16 	lcm_end_x;					/* the end x axis of LCM to be updated*/
	kal_uint16 	lcm_end_y;					/* the end y axis of LCM to be updated*/
	kal_uint16 	roi_offset_x;				/* the ROI window offset x from main window */
	kal_uint16 	roi_offset_y;				/* the ROI window offset y from main window */
	kal_uint32 	update_layer;				/* the updated layer */
	kal_uint32 	hw_update_layer;			/* which layer will be applied by hw trigger or direct couple for MT6219 only */
	kal_uint8 	rotate_value;				/* rotate select for hardware update layer */
	kal_uint8   image_mirror;				/* horizonal/vertical mirror from image sensor */
   kal_uint8   skip_frame_count;       /* skip frame count for video driver */
   kal_uint8	frame_rate;					/* video encoding frame rate , 0xFF for preview, 0x0F for 6219 video */
	kal_uint32	frame_buffer_address;	/* the frame buffer start address of image DMA output for LCD fb update */
	kal_uint32  frame_buffer_size;		/* the frame buffer size of image DMA output for LCD fb updaet */
	kal_uint16 	viedo_encode_offset_x;  /* TODO: Typo */
	kal_uint16	viedo_encode_offset_y;  /* TODO: Typo */
	kal_uint32	roi_background_color;	/* set the background color */
	kal_bool		lcd_update;					/* enable/disable LCD update */

	kal_uint8	zoom_factor;				/* digital zoom factor from 10(1X) ~ 40 (4X) */
	kal_uint8 	contrast_level;			/* ISP contrast gain level */
	kal_uint8 	brightness_level;			/* ISP brightness level */
	kal_uint8	saturation_value;			/* image processor saturation value */
	kal_uint8	wb_mode;						/* white balance mode */
	kal_uint8 	ev_value;					/* EV adjust value */
	kal_uint8 	banding_freq;				/* Banding frequency selection */
	kal_uint8 	image_effect;				/* image effect for preview */
	kal_bool		night_mode;					/* enable/disable camera night mode */

	/* IPP Setting */
	kal_uint8 	overlay_frame_mode;
	kal_uint8 	overlay_color_depth;
	kal_uint8	overlay_frame_source_key;
	kal_uint16  overlay_frame_width;
	kal_uint16	overlay_frame_height;
	kal_uint32  overlay_frame_buffer_address;

	kal_bool		image_pitch_mode;							/* KAL_TRUE or KAL_FALSE for block mode of decoded image */
	kal_uint8	image_data_format;						/* IMGDMA_IBW_OUTPUT_RGB565 or IMGDMA_IBW_OUTPUT_RGB888 */
	kal_uint16	image_pitch_bytes;						/* pitch width */
	
	/* TV Setting */
	kal_bool		tv_output;
	kal_uint16	tv_output_width;
	kal_uint16 	tv_output_height;
	kal_uint16	tv_output_offset_x;
	kal_uint16	tv_output_offset_y;
   kal_uint32 	tv_output_buffer1_address;		/* image buffer1 for TV source buffer */
   kal_uint32 	tv_output_buffer2_address;		/* image buffer2 for TV source buffer */
   kal_uint32 	tv_output_buffer_size;			/* image buffer size for TV source buffer */

	void (*video_encode_cb) (kal_uint32 yuv_address);	/* call back function to start video_encode encoder */
	void (*encode_event_cb) (kal_uint8 event);  		/* call back function for event indication */
	void (*cam_encode_cb) (kal_uint8 return_code);	/* call back function for AE/AWB adjustment*/
}	fullvideo_encode_process_struct;

typedef struct
{
	kal_uint32 	intmem_start_address;	/* internal memory start address for hardware engine buffer */
	kal_uint32 	intmem_size;				/* internal memory size for hardware engine buffer */
	kal_uint32 	extmem_start_address;	/* external memroy start address for hardware engine buffer */
	kal_uint32 	extmem_size;				/* external memory size for hardware engine buffer */

	kal_uint16  source_width;				/* the resizer input width of first run */
	kal_uint16 	source_height;				/* the resizer input height of first run */
	kal_uint16	target_width;				/* the resizer output width of second run for LCD display */
	kal_uint16 	target_height;				/* the resizer output height of second run for LCD display */

	kal_uint8 	lcd_id;						/* MAIN_LCD or SUB_LCD */
	kal_uint16 	lcm_start_x;				/* the start x axis of LCM to be updated*/
	kal_uint16 	lcm_start_y;				/* the start y axis of LCM to be updated*/
	kal_uint16 	lcm_end_x;					/* the end x axis of LCM to be updated*/
	kal_uint16 	lcm_end_y;					/* the end y axis of LCM to be updated*/
	kal_uint16 	roi_offset_x;				/* the ROI window offset x from main window */
	kal_uint16 	roi_offset_y;				/* the ROI window offset y from main window */
	kal_uint32 	update_layer;				/* the updated layer */
	kal_uint32 	hw_update_layer;			/* which layer will be applied by hw trigger or direct couple for MT6219 only */
	kal_uint8 	rotate_value;				/* rotate select for hardware update layer */
	kal_bool		lcd_update;					/* enable/disable LCD update */

	kal_uint32	frame_buffer_address;	/* the frame buffer start address for LCD fb update */
	kal_uint32  frame_buffer_size;		/* the frame buffer size for LCD fb updaet */
	kal_uint32	frame_buffer_address1;	/* for LCD dual buffer update */
	kal_uint32 	frame_buffer_size1;		/* for LCD dual buffer update */

	kal_uint8   image_mirror;				/* horizonal/vertical mirror from image sensor */
	kal_uint8	zoom_factor;				/* digital zoom factor from 10(1X) ~ 40 (4X) */
	kal_uint8 	contrast_level;			/* ISP contrast gain level */
	kal_uint8 	brightness_level;			/* ISP brightness level */
	kal_uint8	saturation_value;			/* saturation value */
	kal_uint8	wb_mode;						/* white balance mode */
	kal_uint8 	ev_value;					/* EV adjust value */
	kal_uint8 	banding_freq;				/* Banding frequency selection */
	kal_uint8 	image_effect;				/* image effect for preview */
	kal_uint16 	hue_value;					/* image processor hue value */
	kal_bool		night_mode;					/* enable/disable camera night mode */
	
	void (*mjpeg_encode_cb) (kal_uint8 return_code);	/* call back function to start jpeg encoder */
}	mjpeg_encode_process_struct;

typedef enum
{
	CAPTURE_MODE_NORMAL = 0,
	CAPTURE_MODE_META,			/* meta mode capture, capture to internal mem */
	CAPTURE_MODE_META_EXT		/* meta mode capture, capture to external mem */
} SENSOR_CAPTURE_MODE_ENUM;

typedef enum
{
	OUTDOOR_WB = 0,
	COMPONENT_OFFSET,
	INTERPOLATION,
	AWB,
	COMPONENT_GAIN,
	MANUEL_WB_1,
	MANUEL_WB_2,
	MANUEL_WB_3,
	MANUEL_WB_4,
	MANUEL_WB_5,
	AE,
	COLOR_MATRIX,
	EDGE,
	COLOR_SUPPRESSION,
	GAMMA_SELECT,
	GAMMA_TUNING,
	GAMMA_PREDEFINE1,
	GAMMA_PREDEFINE2,
	GAMMA_PREDEFINE3,
	GAMMA_PREDEFINE4,
	GAMMA_PREDEFINE5,
	GAMMA_PREDEFINE6,
	GAMMA_PREDEFINE7,
	GAMMA_PREDEFINE8,
	GAMMA_PREDEFINE9,
	CONTRAST,
	BRIGHTNESS,
	SATURATION,
	TOTAL_GROUP_NUMBER
}ISP_ENGMODE_GROUP_ENUM;

typedef struct
{
	kal_uint8	item_name_ptr[50];
   kal_int32	item_value;
   kal_int32	min;			
   kal_int32	max;			
   kal_bool		is_read_only;
   kal_bool		is_need_restart;
   kal_bool		is_true_false;
}isp_engmode_item_info_struct;

typedef struct
{
	kal_bool		start;		//KAL_TRUE : START, KAL_FALSE : STOP
	kal_bool		zoom_in;		//KAL_TRUE : ZOOM IN , KAL_FALSE : ZOOM OUT
	kal_uint8	zoom_limit;	//Max Zoom Factor
	kal_uint8	zoom_step;	//Step of Zoom Factor for Zoom In or Zoom Out
	kal_uint8	zoom_speed;	//How many frames to Zoom one step, ex: 0: zoom one step per frame
}isp_fast_zoom_struct;

typedef struct{
 	kal_int8 c11;
 	kal_int8 c12;
 	kal_int8 c21;
 	kal_int8 c22;
}ISP_HUE_STURCT;

typedef struct
{
  kal_uint32	mtk_para[300];
} exif_MTK_camera_para_struct;

extern kal_uint32 camera_process_stage;
extern kal_uint32 isp_frame_count;
extern camera_preview_process_struct isp_preview_config_data;
extern camera_capture_jpeg_struct isp_capture_jpeg_data;
extern ISP_OPERATION_STATE_ENUM isp_operation_state;
extern volatile kal_uint8 isp_digital_zoom_factor;
extern volatile kal_uint8 isp_contrast_gain;
extern volatile kal_uint8 isp_brightness_level;
extern kal_uint8 preview_hue_level,preview_saturation_level;
extern camera_capture_mem_struct isp_capture_mem_data;
extern mpeg4_encode_process_struct mpeg4_encode_data;
extern mjpeg_encode_process_struct mjpeg_encode_data;
extern kal_bool mjpeg_encode_enable;
extern image_sensor_func_struct *image_sensor_func;
extern image_sensor_exposure_window_struct exposure_window;
extern image_sensor_config_struct sensor_config_data;
extern kal_bool MPEG4_RECODE_START;
extern kal_uint8 hist_idx;
extern kal_uint16 isp_grab_width,isp_grab_height,isp_grab_start_x,isp_grab_start_y;
extern kal_uint8 isp_sub_sample_mode,isp_horizontal_subsample,isp_vertical_subsample;
extern kal_int8 sensor_err_check;
extern kal_bool isp_enter_exit_process_flag;
extern volatile kal_bool isp_idle_done_flag;
extern kal_uint16 image_setting_index;
extern kal_bool isp_digital_zoom_flag;
extern kal_uint8 ae_count;
extern kal_uint8 hist_idx;
extern kal_uint32	vd_blanking_lines;
extern kal_uint8 ae_hw_frame_count_backup[2];
extern kal_uint16 exif_isp_target_width, exif_isp_target_height;

extern isp_fast_zoom_struct isp_fast_zoom_data;
extern kal_bool wait_first_frame_flag;
extern kal_bool isp_first_preview_frame;
extern volatile kal_uint8 isp_preview_2a_enable;
extern kal_uint8 isp_preview_frame;
extern kal_uint8	camera_system_operation_mode;
extern kal_uint8 fast_zoom_count;
extern kal_uint32 time_tick_buff[10];
extern kal_uint32 time_tick;
#if (!defined(DRV_ISP_6219_SERIES))
extern void (*cam_preview_cb) (kal_uint8 return_code);
extern void (*cam_focus_cb) (kal_uint8 return_code);
extern lens_func_struct *lens_func;
#endif

void init_isp_if(void);
void set_isp_interrupt_trigger_delay_lines(kal_uint16 lines);
void power_off_isp(void);
kal_uint16 get_camera_frame_period(void);
void set_vd_blanking_lines(kal_uint32 lines);
kal_uint32 get_vd_blanking_lines(void);
void get_image_sensor_exposure_window(kal_uint16 *exposure_pixel, kal_uint16 *exposure_line);
void isp_contrast_setting(kal_uint8 contrast_level);
void isp_bright_setting(kal_uint8 bright_level);
kal_uint8 get_max_digital_zoom_factor(kal_uint16 target_width, kal_uint16 target_height);
void isp_digital_zoom(kal_uint8 zoom_factor);
kal_uint8 isp_led_setting(kal_bool light);
kal_uint8 camera_preview_process(camera_preview_process_struct *isp_data);
kal_uint8 exit_camera_preview_process(void);
kal_uint32 camera_capture_jpeg_process(camera_capture_jpeg_struct *isp_data);
kal_uint32 camera_capture_barcode_process(camera_capture_barcode_struct *isp_data);
kal_uint8 stop_camera_capture_barcode_process(void);
void pause_camera_capture_barcode_process(void);
void resume_camera_capture_barcode_process(void);
kal_uint8 camera_capture_mem_process(camera_capture_mem_struct *isp_data);
kal_uint8 mpeg4_encode_process(mpeg4_encode_process_struct *mpeg4_data);
kal_uint8 mpeg4_encode_start(void);
kal_uint8 mpeg4_encode_pause(void);
kal_uint8 mpeg4_encode_resume(void);
kal_uint8 exit_mpeg4_encode_process(void);
kal_uint8 camera_image_setting(kal_uint8 type_sel, kal_uint16 para);
void background_image_setting(void);
void get_isp_engmode_group_count(kal_int32* group_count_ptr);
void get_isp_engmode_group_info(kal_uint16 group_idx, kal_uint8* group_name_ptr, kal_int32* item_count_ptr);
void get_isp_engmode_item_info(kal_uint16 group_idx, kal_uint16 item_idx, isp_engmode_item_info_struct* info_ptr);
kal_bool set_isp_engmode_item_info(kal_uint16 group_idx, kal_uint16 item_idx, kal_int32 item_value);
void set_isp_driving_current(kal_uint8 current);
kal_uint8 stop_camera_capture_process(void);
void isp_fast_zoom_setting(isp_fast_zoom_struct zoom_data);
kal_uint8 get_isp_digital_zoom_factor(void);
void camera_operation_setting(kal_uint8 func_sel, kal_uint16 para);
#if (defined(DRV_ISP_6228_SERIES)||defined(DRV_ISP_6229_SERIES))
void adjustment_isp_hue_para(kal_uint16 degree);
void disable_adjustment_isp_hue_para(void);
#endif

/* EXIF Support */
void exif_update_MTK_para_struct_AEAWB(exif_MTK_camera_para_struct* para);
#if (defined(AF_SUPPORT)&&(!defined(DRV_ISP_6219_SERIES)))
void exif_update_MTK_para_struct_AF(exif_MTK_camera_para_struct* para);
#endif

kal_uint8 mjpeg_encode_process(mjpeg_encode_process_struct *mjpeg_data);
kal_uint8 mjpeg_encode_start(void);
kal_uint8 mjpeg_encode_pause(void);
kal_uint8 mjpeg_encode_resume(void);
kal_uint8 exit_mjpeg_encode_process(void);
kal_uint8 get_mjpeg_frame_rate(void);

#endif /* MT6219||MT6228||MT6226||MT6227||MT6229 */
#endif /* _ISP_IF_H */
