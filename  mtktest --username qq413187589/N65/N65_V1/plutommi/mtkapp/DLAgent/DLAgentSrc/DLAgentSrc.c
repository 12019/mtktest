/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/
 
#include "MMI_include.h"

#if !defined (__MMI_DOWNLOAD_AGENT__)


void mmi_da_init_app(void)                  {}
void mmi_da_enter_idle_screen_notify(void)  {}
U8 mmi_da_launch_ring_buffer_check(void)    { return MMI_FALSE; }
void mmi_da_entry_new_push_ind(void)        {}

#else

#include "CommonScreens.h"
#include "ProtocolEvents.h"
#include "app_mine.h"
#include "FileMgr.h"

#include "drm_def.h"                    /* DRM_PROC_RESULT_OK */
#include "drm_gprot.h"
#include "RightsMgrGProt.h"

#include "DLAgentDef.h"
#include "DLAgentGprot.h"
#include "DLAgentprot.h"
#include "DLAgentResDef.h"
#include "DLAgentWPS.h"

#include "SimDetectionDef.h"            /* SCR_SIM_INSERTION and SCR_SIM_BLOCK */
#include "IdleAppDef.h"                 /* IDLE_SCREEN_ID */
#include "MessagesResourceData.h"       /* IMG_NEW_MESSAGE_NOTIFICATION_MSG */
#include "FileManagerGProt.h"           /* GetFileSystemErrorString */
#include "settingProfile.h"
#include "FileManagerDef.h"
#include "imageViewerResDef.h"
#include "SettingDefs.h"
#include "CallManagementGprot.h"
#include "IdleAppProt.h"                /* mmi_idle_is_on_idle_screen */

#include "wap_ps_struct.h"
#include "wapadp.h"
#include "Conversions.h"

#include "UnicodeStrgprot.h"
#include "ProfileGprots.h"              /* stopRequestedTone*/
#ifdef __USB_IN_NORMAL_MODE__
#include "ExtDeviceDefs.h"
#endif 
#include "USBDeviceGprot.h"             /* mmi_usb_is_in_mass_storage_mode */
#include "gpioInc.h"                    /* TurnOnBacklight */
#include "inet_msg_api.h"               /*inet_msg_get_header_field */

extern S32 mmi_fmgr_get_da_file_option(S8* filepath);

#if 0 //defined(WIN32)
/* under construction !*/
#endif

/****************************************************************************
* Define
*****************************************************************************/

typedef enum {
    MMI_DA_FILESTAMP_CHECK_OK,
    MMI_DA_FILESTAMP_CHECK_FAIL,
    MMI_DA_FILESTAMP_CHECK_FAIL_TEMP,

    MMI_DA_FILESTAMP_CHECK_MAX
} mmi_da_job_filestamp_enum;

/****************************************************************************
* Define - Macro
*****************************************************************************/

#define DA_JOB_GET_FILEPATH(job, strbuff, length) \
    da_module_table[job->type]->get_filepath(job, strbuff, length)

#define DA_JOB_GET_PROGRESS(job, info) \
    da_module_table[job->type]->get_progress(job, &info)

#define DA_JOB_GET_ID(job) da_module_table[job->type]->get_id(job)

#define DA_JOB_UNIQUE_ID(job) DA_MAKE_UNIQUE_ID(job, DA_JOB_GET_ID(job))

#define DA_PUSH_ID DA_MAKE_UNIQUE_ID_EX(MMI_DA_JOB_TYPE_PUSH, 0)

/****************************************************************************
* Typedef - Struct
*****************************************************************************/

typedef struct _mmi_da_push_item_struct
{
    mmi_da_job_struct   job;            // must be first variable!
    
    U16                 *filepath;
    U16                 *filename;
    S8                  *url;
    S8                  *mime_type_string;
    U32                 file_length;
    U32                 header_len;
    S8                  *header;
    mmi_da_action_enum  action;

    struct _mmi_da_push_item_struct* next_item;

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    mmi_da_job_struct*  exist_job;
#endif
    BOOL                is_normal_save;    
} mmi_da_push_item_struct;

typedef struct
{
    /* Data */
    mmi_da_job_struct   *setuping_job; /* job is not start yet, only 1 job at a time */
    
    mmi_da_job_struct   *curr_job;
    mmi_da_job_struct   *list_job;
    S32                 list_job_num;

    U32                 last_error;

    mmi_da_job_struct   *curr_op_job;   /* current operationing job */

    /* UI usage */
    S32                 job_list_highlight_index;
    S32                 job_list_option_highlight_index;
    BOOL                job_list_dirty_flag;
    BOOL                job_list_timer_enable_flag;
    U16                 job_list_current_option_menu_id;

    mmi_da_setting_struct setting;  /* the one and ONLY one setting body */

    /* push objects */
    mmi_da_push_item_struct *push_item_curr;
    mmi_da_push_item_struct *push_item_list;
    S32                     push_item_num;

    /* in foreground state */
    BOOL                    in_foreground;

} mmi_da_context_struct;

/****************************************************************************
* Global Variable
*****************************************************************************/

extern const mmi_da_module_funcptr_table mm_da_http_module;
#ifdef __MMI_OMA_DD_DOWNLOAD__
extern const mmi_da_module_funcptr_table mm_da_oma_module;
#ifdef __MMI_OMA_DD2_DOWNLOAD__
extern const mmi_da_module_funcptr_table mm_da_oma2_module;
#endif    
#endif    

/****************************************************************************
* Static Variable
*****************************************************************************/

static mmi_da_context_struct da_context;

const static mmi_da_module_funcptr_table* da_module_table[MMI_DA_JOB_TYPE_TOTAL]=
{
    &mm_da_http_module
#ifdef __MMI_OMA_DD_DOWNLOAD__
    ,&mm_da_oma_module
#ifdef __MMI_OMA_DD2_DOWNLOAD__
    ,&mm_da_oma2_module
#endif    
#endif    
};

/****************************************************************************
* Function Forward Declaration
*****************************************************************************/
/* Tool Function */
static mmi_da_job_struct* _mmi_da_get_nth_job(S32 index);
static S32 _mmi_da_get_job_index(const mmi_da_job_struct* job);
static BOOL _mmi_da_free_job(mmi_da_job_struct *job);
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void _mmi_da_send_download_info_ind(void);
static BOOL _mmi_da_job_match_need_complete_notify_func(const mmi_da_job_struct* job, U32 criteria);
#endif
static void _mmi_da_update_timer_handler(void* param);
static U32 _mmi_da_format_job_detail(const mmi_da_job_struct *job, U16* strBuffer, U32 buffer_len, U32 count);

static void mmi_da_job_make_filestamp(mmi_da_job_struct* job);
static mmi_da_job_filestamp_enum mmi_da_job_check_filestamp(mmi_da_job_struct* job, U16* error_reason_id);
static BOOL _mmi_da_job_match_state_func(const mmi_da_job_struct* job, U32 criteria);

/* UI Flow function */
static S32 _mmi_da_job_get_item(S32 start_index, gui_iconlist_menu_item *menu_data, S32 data_size);
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void mmi_da_entry_job_list(void);
static void mmi_da_entry_job_list_option(void);
#endif
static void mmi_da_entry_job_detail(void);
static void mmi_da_entry_dispatch_confirm(void);
    
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void _mmi_da_job_list_option_hdlr(void);
static void mmi_da_job_list_option_lsk_hdlr(void);
static void mmi_da_curr_job_suspend_hdlr(void);
#endif
static void mmi_da_curr_job_abort_hdlr(void);
static void mmi_da_job_complete(const mmi_da_job_struct* job);

/* Push object support */
static void mmi_da_recv_dispatch_file_req(void *MsgStruct, int mod_src, void *ilm_p);
static BOOL mmi_da_push_filename_done(U32 criteria, U16* filepath, BOOL canback, BOOL canpopup);
static void mmi_da_push_dispatch(mmi_da_push_item_struct *item);
static void mmi_da_push_free_item(mmi_da_push_item_struct *item);
static void _mmi_da_push_dispatch_to_app(void);
static void _mmi_da_push_cancel_dispatch(void);
static void mmi_da_push_select_storage(mmi_da_push_item_struct *item, mmi_da_setting_struct *setting);
static void mmi_da_push_entry_dispatch_confirm(void);

/* Browser Entry point. */
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void mmi_da_recv_wap_notify_ind(void *MsgStruct, int mod_src, void *ilm_p);
#endif
static void mmi_da_suspended_in_background_callback(mmi_da_job_struct* job, U16 string_id);

#define END_OF_FUNCTION_DECLARATION
/****************************************************************************
* Function 
*****************************************************************************/

/*****************************************************************************
* FUNCTION
*   mmi_da_init_app
* DESCRIPTION
*   initial download agent, set handler and state and initial table
* PARAMETERS
*   void
* RETURNS
*   void
*****************************************************************************/
void mmi_da_init_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 buf_createpath[128];
    int i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Check */
    ASSERT(MMI_DA_ACT_INTERNAL_BASE >= MMI_DA_ACT_TOTAL);

    /* init */
    mmi_da_scr_init();
    mmi_da_wps_init();

    /* make sure there is download folder */
    kal_wsprintf((unsigned short*)buf_createpath, "%c:\\%w",MMI_PUBLIC_DRV, FMGR_DEFAULT_FOLDER_TEMP);
    FS_XDelete((unsigned short*)buf_createpath,
       FS_FILE_TYPE | FS_DIR_TYPE | FS_RECURSIVE_TYPE,
       NULL,
       0);
    mmi_da_util_create_file_dir((U16*)buf_createpath, FALSE);

    /* init context */
    memset(&da_context, 0, sizeof(da_context));
    da_context.list_job_num = -1;   /* -1 means not initialized */

    /* init each module */
    for(i=0;i<MMI_DA_JOB_TYPE_TOTAL;i++)
    {
		if(da_module_table[i])
	        da_module_table[i]->init();
    }

    SetProtocolEventHandler((PsFuncPtr) mmi_da_recv_dispatch_file_req, MSG_ID_MMI_DA_DISPATCH_FILE_REQ);

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    SetProtocolEventHandler((PsFuncPtr) mmi_da_recv_wap_notify_ind, MSG_ID_MMI_DA_WAP_NOTIFY_IND);
#endif

    /* hide menu item for future usage */
    mmi_frm_hide_menu_item(MENU_ID_DA_JOB_OPTION_OMA_UPDATE);

//    SetHiliteHandler(MENU_ID_BRW_REN_PAGE_DLAGENT, _mmi_da_highlight_download_list);
}

#define DA_API

void mmi_da_init_job_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* lazy init job list */
    if(da_context.list_job_num == -1)
    {
        /* read job list from NVRAM */

        da_context.list_job_num = 0;
    }
}

mmi_da_job_struct* mmi_da_job_create(mmi_da_job_type_enum type, void *obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct *job = NULL;
    U32 job_count;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_da_init_job_list();

    if(da_context.setuping_job || da_context.push_item_curr)
    {
        da_context.last_error = MMI_DA_IERROR_ANOTHER_JOB;
        goto end_create;
    }

    if(da_context.list_job_num >= MMI_DA_MAX_JOB)
    {
        da_context.last_error = MMI_DA_IERROR_EXCEED_MAX_JOB;
        goto end_create;
    }

    job_count = mmi_da_count_job(_mmi_da_job_match_state_func, MMI_DA_JOB_STATE_DOWNLOADING) +
                mmi_da_count_job(_mmi_da_job_match_state_func, MMI_DA_JOB_STATE_PROCESSING);
    if(job_count >= MMI_DA_MAX_DL)
    {
        da_context.last_error = MMI_DA_IERROR_EXCEED_MAX_DL;
        goto end_create;
    }

    return mmi_da_job_create_ex(type, obj);

end_create:
    DA_TRACE_FUNC3(mmi_da_job_create, type, (U32)job, da_context.last_error);
    return job;
}

mmi_da_job_struct* mmi_da_job_create_ex(mmi_da_job_type_enum type, void *obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct *job = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_da_init_job_list();
    
    if(da_context.setuping_job || da_context.push_item_curr)
    {
        da_context.last_error = MMI_DA_IERROR_ANOTHER_JOB;
        goto end_create;
    }
    
    job = (mmi_da_job_struct*)OslMalloc(sizeof(mmi_da_job_struct));
    if(!job)
    {
        da_context.last_error = MMI_DA_IERROR_NO_MEMORY;
        goto end_create;
    }
    
    memset(job, 0, sizeof(mmi_da_job_struct));
    job->data_ptr = obj;
    job->type = type;
    job->state = MMI_DA_JOB_STATE_INIT;

#ifdef __DRM_SUPPORT__
    job->drm.drm_serial = 0xFF;
#endif

    da_context.setuping_job = job;

end_create:
    DA_TRACE_FUNC3(mmi_da_job_create, type, (U32)job, da_context.last_error);
    return job;
}

BOOL mmi_da_job_cancel(mmi_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL                ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_job_cancel);

    /* this func is only to cancel current setuping job */

    if(!da_context.setuping_job)
        return FALSE;
    if(job != da_context.setuping_job)
    {
        ASSERT(0);
        return FALSE;
    }

    ASSERT(job->state == MMI_DA_JOB_STATE_INIT || job->state == MMI_DA_JOB_STATE_ABORTED);
    ret = _mmi_da_free_job(job);
    da_context.setuping_job = NULL;
    return ret;
    
}

BOOL mmi_da_job_start(mmi_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *i_job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_job_start);

    /* Put current setupping job into Job List */
    
    if(!da_context.setuping_job)
        return FALSE;
    if(job != da_context.setuping_job)
    {
        ASSERT(0);
        return FALSE;
    }

    ASSERT(job->state == MMI_DA_JOB_STATE_DOWNLOADING);

    if(!da_context.list_job)
    {
        ASSERT(da_context.list_job_num == 0);
        da_context.list_job = job;
        da_context.list_job_num++;
    }
    else
    {
        /* check if job exist, and find the tail */
        i_job = da_context.list_job;
        while(1)
        {
            if(i_job == job)
            {
                /* exist, leave */
                goto end;
            }
            if(!i_job->next_job)
                break;
            i_job = i_job->next_job;
        }

        /* not exist */
        ASSERT(!job->next_job);
        ASSERT(!job->prev_job);

        /* add to tail */
        job->prev_job = i_job;
        i_job->next_job = job;
        da_context.list_job_num++;
    }

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /* send download info indication */
    _mmi_da_send_download_info_ind();
#endif

end:
    da_context.setuping_job = NULL;
    return TRUE;
}

BOOL mmi_da_job_error_cleanup(mmi_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_job_error_cleanup);

    ASSERT(job->state == MMI_DA_JOB_STATE_ABORTED);
    return _mmi_da_free_job(job);
}

mmi_da_job_struct* mmi_da_find_job(mmi_da_job_match_funcptr_type func, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = da_context.list_job;
    while(job)
    {
        if(func(job, criteria))
            return job;

        job = job->next_job;
    }
    return NULL;
}

mmi_da_job_struct* mmi_da_find_job_by_filepath(U16* filepath, BOOL bpopup)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job;
    U16                 *job_filepath;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_filepath = (U16*)subMenuData;

    job = da_context.list_job;
    while(job)
    {
        DA_JOB_GET_FILEPATH(job, job_filepath, FMGR_MAX_PATH_LEN-1);
        if(0 == mmi_ucs2cmp((S8*)filepath, (S8*)job_filepath))
        {
            if(bpopup)
                DisplayPopup((U8*) GetString(STR_ID_DA_JOB_EXIST), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                             (U8) ERROR_TONE);
            return job;
        }

        job = job->next_job;
    }
    return NULL;
}

U32 mmi_da_count_job(mmi_da_job_match_funcptr_type func, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job;
    U32                 count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = da_context.list_job;
    while(job)
    {
        if(func(job, criteria))
            count++;

        job = job->next_job;
    }
    return count;
}

BOOL mmi_da_is_job_valid(const mmi_da_job_struct* comp_job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!comp_job)
        return FALSE;
    
    if(da_context.setuping_job == comp_job)
        return TRUE;
    
    job = da_context.list_job;
    while(job)
    {
        if(comp_job == job)
            return TRUE;

        job = job->next_job;
    }
    return FALSE;
}

mmi_da_setting_struct* mmi_da_get_setting_buffer(void)
{
    return &da_context.setting;
}

void mmi_da_copy_setting(mmi_da_job_struct* job, const mmi_da_setting_struct* setting_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job->setting_info.confirm_dispatch = setting_data->confirm_dispatch;
    job->setting_info.confirm_push = setting_data->confirm_push;
    job->setting_info.can_minimize = setting_data->can_minimize;
    job->setting_info.do_dispatch = setting_data->do_dispatch;
    job->setting_info.filepath_hdlr= setting_data->filepath_hdlr;
    job->setting_info.report_hdlr= setting_data->report_hdlr;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
BOOL mmi_da_is_in_foreground_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(mmi_da_is_in_voice_call())
        return FALSE;

    if(GetActiveScreenId() == SCR_ID_DA_JOB_LIST ||
        GetActiveScreenId() == SCR_ID_DA_JOB_OPTION ||
        GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL)
        return TRUE;

    // TODO: if in WAP browser, in_foregorund should be TRUE
    
    return da_context.in_foreground;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
U32 mmi_da_get_last_error(void)
{
    return da_context.last_error;
}

#define DA_API2

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void mmi_da_display_job_list(mmi_da_job_struct* job, BOOL check_complete)
{
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_display_job_list);
    
    ASSERT(!da_context.setuping_job);
    mmi_da_init_job_list();
    if(!da_context.list_job_num)
        return;
    
    da_context.job_list_highlight_index = job ? _mmi_da_get_job_index(job) : 0;
    mmi_da_entry_job_list();
    DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
    DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);
    DeleteScreenIfPresent(SCR_ID_DA_JOB_LIST);
#endif    
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void mmi_da_display_job_detail(mmi_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_display_job_detail);
    
    ASSERT(!da_context.setuping_job);
    mmi_da_init_job_list();

    if(MMI_DA_FILESTAMP_CHECK_OK == mmi_da_job_check_filestamp(job, NULL))
    {
        da_context.curr_job = job;
        mmi_da_entry_job_detail();
        DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
    }
    else
    {
        ASSERT(0); // TODO: not implemented
    }
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void mmi_da_update_job_status(const mmi_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_item_progress_struct info;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(job);
    DA_JOB_GET_PROGRESS(job, info);
    DA_TRACE_FUNC3(mmi_da_update_job_status, DA_JOB_UNIQUE_ID(job), job->state, info.currSize);

    /* report to app */
    if(job->setting_info.report_hdlr)
    {
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_REPORT_TO_APP, job->error_cause, 0, info.currSize);

        job->setting_info.report_hdlr(DA_JOB_UNIQUE_ID(job),
                                      mmi_da_util_state_transfer(job->state),
                                      job->error_cause,
                                      0, info.currSize);
    }

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    _mmi_da_send_download_info_ind();
#endif

    switch(job->state)
    {
#ifdef __DRM_SUPPORT__
    case MMI_DA_JOB_STATE_DRM_PROCESSING:   /* do nothing */
#endif
    case MMI_DA_JOB_STATE_PROCESSING:
        if(GetActiveScreenId() == SCR_ID_DA_JOB_OPTION &&
            _mmi_da_get_job_index(job) == da_context.job_list_highlight_index)
        {
            EntryNewScreen(SCR_ID_DA_JOB_OPTION, NULL, NULL, NULL);
            GoBackHistory();
        }
        /* Update now */
        if( GetActiveScreenId() == SCR_ID_DA_JOB_LIST ||
            (GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL && da_context.curr_job == job))
        {
            da_context.job_list_dirty_flag = TRUE;
            _mmi_da_update_timer_handler((void*)job);
        }
        break;
        
    case MMI_DA_JOB_STATE_DOWNLOADING:
        if( GetActiveScreenId() == SCR_ID_DA_JOB_LIST ||
            (GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL && da_context.curr_job == job))
        {
            // trigger a timer to refresh, 
            // use a dirty flag to mask sure only 1 timer is activated.
            if(!da_context.job_list_dirty_flag)
            {
                da_context.job_list_dirty_flag = TRUE;
                StartTimerEx(MMI_DA_TIMER_1, 500, _mmi_da_update_timer_handler, (void*)job);
            }
        }
        break;

    case MMI_DA_JOB_STATE_PAUSED:
#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        // Should not enter paused state
        ASSERT(0);
#endif

    case MMI_DA_JOB_STATE_COMPLETED:
        if(GetActiveScreenId() == SCR_ID_DA_JOB_OPTION &&
            _mmi_da_get_job_index(job) == da_context.job_list_highlight_index)
        {
            EntryNewScreen(SCR_ID_DA_JOB_OPTION, NULL, NULL, NULL);
            GoBackHistory();
        }
        
        mmi_da_job_make_filestamp((mmi_da_job_struct*)job);
        
        /* Force refresh */
        if(da_context.job_list_dirty_flag)
            StopTimer(MMI_DA_TIMER_1);
        da_context.job_list_dirty_flag = TRUE;
        _mmi_da_update_timer_handler((void*)job);

        /* complete popup */
        if(job->state == MMI_DA_JOB_STATE_COMPLETED)
        {
            /* check dispatch */
            if(job->type_handler == mmi_da_get_default_mime_type_handler())
            {
                U16 *filepath;
                filepath = (U16*)OslMalloc((FMGR_MAX_PATH_LEN + 1) * ENCODING_LENGTH);
                DA_JOB_GET_FILEPATH(job, filepath, FMGR_MAX_PATH_LEN);

                if(mmi_fmgr_get_da_file_option((S8*)filepath) <= 0)
                    ((mmi_da_job_struct*)job)->setting_info.do_dispatch = FALSE;
                
                OslMfree(filepath);
            }

            mmi_da_job_complete(job);
        }
        return;

    case MMI_DA_JOB_STATE_FAILED:
        if(GetActiveScreenId() == SCR_ID_DA_JOB_OPTION &&
            _mmi_da_get_job_index(job) == da_context.job_list_highlight_index)
        {
            EntryNewScreen(SCR_ID_DA_JOB_OPTION, NULL, NULL, NULL);
            GoBackHistory();
        }

#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        if(!IsScreenPresent(SCR_ID_DA_JOB_DETAIL))
        {
            _mmi_da_free_job((mmi_da_job_struct*)job);
        }
#endif                
        return;

    case MMI_DA_JOB_STATE_ABORTED:
        // clean up.
        _mmi_da_free_job((mmi_da_job_struct*)job);
        return;

    case MMI_DA_JOB_STATE_ABORTING:
        /* the only case will run into here is:
            1. the report handler aborted the job 
        */
        ASSERT(job->setting_info.report_hdlr);
        return;

    default:
        ASSERT(0); // not handled
        return;
    }
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void mmi_da_click_job(mmi_da_job_struct* job)
{
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(job);
    DA_TRACE_FUNC1(mmi_da_click_job, job->state);

    switch(job->state)
    {
        case MMI_DA_JOB_STATE_DOWNLOADING:
        case MMI_DA_JOB_STATE_ABORTING:
        case MMI_DA_JOB_STATE_PROCESSING:
#ifdef __DRM_SUPPORT__
        case MMI_DA_JOB_STATE_DRM_PROCESSING:
#endif
        case MMI_DA_JOB_STATE_COMPLETED:
        case MMI_DA_JOB_STATE_FAILED:
            mmi_da_display_job_list(job, FALSE);
            break;

        case MMI_DA_JOB_STATE_PAUSED:
            /* Resume then display */
            mmi_da_display_job_list(job, FALSE);

            if(mmi_da_count_job(_mmi_da_job_match_state_func, MMI_DA_JOB_STATE_DOWNLOADING) + 
                mmi_da_count_job(_mmi_da_job_match_state_func, MMI_DA_JOB_STATE_PROCESSING) >= MMI_DA_MAX_DL)
            {
                DisplayPopup((PU8) GetString(STR_ID_DA_PROMPT_EXCEED_MAX_DL), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                             (U8) ERROR_TONE);
                break;
            }
            
            /* job may be removed after display */
            if(mmi_da_is_job_valid(job) && da_module_table[job->type]->resume)
                da_module_table[job->type]->resume(job);
            break;

        default:
            ASSERT(0);
            break;
    }
#endif    
}

#define DA_API_LOCAL

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
/* Trigger by Timer */
static void _mmi_da_update_timer_handler(void* param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job;
    U32                 percentage;
    UI_string_type      display[3];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(!da_context.job_list_dirty_flag)
        return;
    
    da_context.job_list_dirty_flag = FALSE;
    job = (mmi_da_job_struct*)param;
   
    if( GetActiveScreenId() == SCR_ID_DA_JOB_LIST )
    {
        /* update screen */
        if(da_context.job_list_highlight_index < 0 || da_context.job_list_highlight_index >= da_context.list_job_num)
            da_context.job_list_highlight_index = 0;
        mmi_cat_refresh_asyncdynamic_list(da_context.list_job_num, 
            da_context.job_list_highlight_index, 
            _mmi_da_job_get_item, NULL);
    }
    else if(GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL && da_context.curr_job == job)
    {
        percentage = _mmi_da_format_job_detail(job, (U16*)subMenuData, MAX_SUB_MENU_SIZE, MAX_SUB_MENUS/2);
//        display[] = (UI_string_type)(subMenuData);
        display[0] = (UI_string_type)(subMenuData)+MAX_SUB_MENU_SIZE;
        display[1] = (UI_string_type)(subMenuData)+MAX_SUB_MENU_SIZE*2;
        display[2] = (UI_string_type)(subMenuData)+MAX_SUB_MENU_SIZE*3;
#if defined(__MMI_MAINLCD_128X128__)
        if(percentage == MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN)
            UpdateCategory402Value((U16)0, (U8*)display[0]);
        else
            UpdateCategory402Value((U16)percentage, NULL);
#else
        if(percentage == MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN)
            Cat412UpdateList((UI_string_type)mmi_da_util_get_filename((U16*)subMenuData), (U8)0, 1, display);
        else
            Cat412UpdateList((UI_string_type)mmi_da_util_get_filename((U16*)subMenuData), (U8)percentage, 3, display);
#endif
    }

}

static void _mmi_da_job_list_timer_handler(void* param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(!da_context.job_list_timer_enable_flag)
        return;

    da_context.job_list_timer_enable_flag = FALSE;
    
    job = (mmi_da_job_struct*)param;
    if(!mmi_da_is_job_valid(job))
        return;

    if( GetActiveScreenId() == SCR_ID_DA_JOB_LIST ||
        (GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL && da_context.curr_job == job) )
    {
        if(job->state == MMI_DA_JOB_STATE_COMPLETED)
        {
            mmi_da_job_complete(job);
            DeleteScreenIfPresent(SCR_ID_DA_JOB_CALLBACK_CONFIRM);
        }
        else if(job->state == MMI_DA_JOB_STATE_FAILED)
        {
            if(!job->popup_str_id)
                job->popup_str_id = STR_GLOBAL_ERROR;
                
            // TODO: display more info
            DisplayPopup((PU8) GetString((U16) job->popup_str_id), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) ERROR_TONE);
            job->popup_str_id = 0;
            job->state = MMI_DA_JOB_STATE_ABORTED;
            mmi_da_job_error_cleanup(job);
        }
        else if(job->popup_str_id)
        {
            DisplayPopup((PU8) GetString((U16) job->popup_str_id), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) ERROR_TONE);
            job->popup_str_id = 0;
        }
    }
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static mmi_da_job_struct* _mmi_da_get_nth_job(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct* job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(index >= da_context.list_job_num || index < 0)
        return NULL;
    
    job = da_context.list_job;
    while(index > 0 && job)
    {
        index --;
        job = job->next_job;
    }
    ASSERT(job);
    return job;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static S32 _mmi_da_get_job_index(const mmi_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = -1;
    mmi_da_job_struct* job_in;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job_in = da_context.list_job;
    while(job_in)
    {
        index ++;
        if(job_in == job)
            return index;
        job_in = job_in->next_job;
    }
    return -1;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static BOOL _mmi_da_free_job(mmi_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL                ret, in_detail;
    S32                 old_num, index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* abort first */
    ASSERT(job->state == MMI_DA_JOB_STATE_INIT ||
           job->state == MMI_DA_JOB_STATE_ABORTED ||
           job->state == MMI_DA_JOB_STATE_FAILED ||
           job->state == MMI_DA_JOB_STATE_COMPLETED);

    /* cache current job count */
    old_num = da_context.list_job_num;

    /* modified highlight index */
    index = _mmi_da_get_job_index(job);
    if(da_context.job_list_highlight_index == index)
    {
        da_context.job_list_highlight_index = -1;
    }
    else if(index != -1 && da_context.job_list_highlight_index > index)
    {
        da_context.job_list_highlight_index--;
    }
    
    in_detail = FALSE;
    if(da_context.curr_job == job)
    {
        da_context.curr_job = NULL;
        in_detail = TRUE;
    }
   
    /* check if job is in list, if yes, remove it first */
    if(job->prev_job || job->next_job || job == da_context.list_job)
        da_context.list_job_num--;
    if(job->prev_job)
        job->prev_job->next_job = job->next_job;
    if(job->next_job)
        job->next_job->prev_job = job->prev_job;
    if(job == da_context.list_job)
        da_context.list_job = job->next_job;

    /* call free func */
    ASSERT(job->type < MMI_DA_JOB_TYPE_TOTAL);
    ASSERT(da_module_table[job->type]->free);
    ret = da_module_table[job->type]->free(job);

#ifdef __DRM_SUPPORT__
    DA_FREE_BUFFER(job->drm.drm_info);
#endif
    OslMfree(job);

    // TODO: very ugly solution, try to find better way later

    if(!da_context.list_job_num)
    {
        if(GetActiveScreenId() == SCR_ID_DA_JOB_LIST)
            GoBackHistory();
        else
            DeleteScreenIfPresent(SCR_ID_DA_JOB_LIST);
    }
    if(da_context.job_list_highlight_index < 0)
    {
        if(GetActiveScreenId() == SCR_ID_DA_JOB_OPTION)
            GoBackHistory();
        else
            DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);
    }
    if(in_detail)
    {
        if(GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL)
            GoBackHistory();
        else
            DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
    }

    if(da_context.list_job_num && da_context.list_job_num != old_num && GetActiveScreenId() == SCR_ID_DA_JOB_LIST)
    {
        /* refresh */
        if(da_context.job_list_highlight_index < 0 || da_context.job_list_highlight_index >= da_context.list_job_num)
            da_context.job_list_highlight_index = 0;
        mmi_cat_refresh_asyncdynamic_list(da_context.list_job_num, 
            da_context.job_list_highlight_index, 
            _mmi_da_job_get_item, NULL);
    }

    DA_TRACE_ENDFUNC(_mmi_da_free_job);

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /* send download info indication when job count is updated */
    if(da_context.list_job_num != old_num)
    {
        _mmi_da_send_download_info_ind();
    }
#endif    
    return ret;
}

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void _mmi_da_send_download_info_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_download_info_ind_struct     *msg;
    mmi_da_job_struct                   *job;
    static S32                          job_count = 0;
    static S32                          active_job_count = 0;
    S32                                 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* calculate active job count */
    i = 0;
    job = da_context.list_job;
    while(job)
    {
        if(job->state == MMI_DA_JOB_STATE_DOWNLOADING)
            i++;
        job = job->next_job;
    }

    /* if either of them is changed */
    if(job_count != da_context.list_job_num || active_job_count != i)
    {
        job_count = da_context.list_job_num;
        active_job_count = i;

        msg = (mmi_da_download_info_ind_struct*) construct_local_para(sizeof(mmi_da_download_info_ind_struct), TD_CTRL);
        msg->job_count = job_count;
        msg->active_job_count = active_job_count;

#if defined(OBIGO_Q05A)
        mmi_da_send_ilm(msg, NULL, MSG_ID_MMI_DA_DOWNLOAD_INFO_IND, MOD_MMI);
#else
        mmi_da_send_ilm(msg, NULL, MSG_ID_MMI_DA_DOWNLOAD_INFO_IND, MOD_WAP);
#endif
    }
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static BOOL _mmi_da_job_match_need_complete_notify_func(const mmi_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (job->state == MMI_DA_JOB_STATE_COMPLETED && 
            job->notifyed_complete == FALSE && 
            job->setting_info.do_dispatch &&
            job->type_handler->dispatch_hdlr &&
            !job->setting_info.report_hdlr);
}
#endif

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static BOOL _mmi_da_job_match_state_func(const mmi_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (job->state == (mmi_da_job_state_enum)criteria);
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
BOOL mmi_da_job_match_id_func(const mmi_da_job_struct* job, U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(DA_JOB_UNIQUE_ID(job) == id)
        return TRUE;

    return FALSE;
}


#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static BOOL _mmi_da_job_has_popupinfo_func(const mmi_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (BOOL)job->popup_str_id;
}
#endif

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_suspend_all_job(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job, *next_job;
    S32                 prev_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    DA_TRACE_FUNC(mmi_da_suspend_all_job);
    
    next_job = da_context.list_job;
    while(next_job)
    {
        job = next_job;
        next_job = job->next_job;
        
        if(job->state == MMI_DA_JOB_STATE_DOWNLOADING)
        {
            prev_state = job->state;
            job->state = MMI_DA_JOB_STATE_ABORTING;

            da_module_table[job->type]->stop(job, 
                                             prev_state, TRUE,
                                             mmi_da_suspended_in_background_callback);
        }
#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        /* remove all job */
        else if(job->state == MMI_DA_JOB_STATE_COMPLETED)
        {
            _mmi_da_free_job(job);
        }
#ifdef __DRM_SUPPORT__
        else if(job->state == MMI_DA_JOB_STATE_DRM_PROCESSING)
        {
            job->state = MMI_DA_JOB_STATE_ABORTING;
            mmi_da_drm_process_file_abort(job);
        }
#endif     
        else if(job->state == MMI_DA_JOB_STATE_FAILED)
        {
            _mmi_da_free_job(job);
        }
#endif
    }
}

#define JOB_STAMP

static void mmi_da_job_make_filestamp(mmi_da_job_struct* job)
{
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16*        filepath;
    FS_HANDLE   filehandle;
    UINT        filesize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(job->state == MMI_DA_JOB_STATE_PAUSED ||
           job->state == MMI_DA_JOB_STATE_COMPLETED);
    
    filepath = (U16*)OslMalloc((FMGR_MAX_PATH_LEN + 1) * ENCODING_LENGTH);
    DA_JOB_GET_FILEPATH(job, filepath, FMGR_MAX_PATH_LEN);
    filehandle = FS_Open(filepath, FS_READ_ONLY);
    OslMfree(filepath);

    if(filehandle >= 0)
    {
        FS_GetFileSize(filehandle, &filesize);
        job->filestamp.curr_size = filesize;

        FS_Close(filehandle);
        DA_TRACE_FUNC1(mmi_da_job_make_filestamp, filesize);
    }
    else
    {
        job->filestamp.curr_size = 0xFFFFFFFF;
        DA_TRACE_FUNC1(mmi_da_job_make_filestamp, filehandle);
    }
#endif    
}

static mmi_da_job_filestamp_enum mmi_da_job_check_filestamp(mmi_da_job_struct* job, U16* error_reason_id)
{
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16*        filepath = NULL;
    FS_HANDLE   filehandle = 0;
    UINT        filesize;
    S32         ret;
    U16         error_id = STR_ID_DA_ERROR_TEMP_UNAVAILABLE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(job);
    ret = MMI_DA_FILESTAMP_CHECK_OK;
    
    if(job->state != MMI_DA_JOB_STATE_COMPLETED &&
        job->state != MMI_DA_JOB_STATE_PAUSED)
    {
        /* no need check */
        goto func_end;
    }

    
    // TODO: check for temporary or permant missing?

    filepath = (U16*)OslMalloc((FMGR_MAX_PATH_LEN + 1) * ENCODING_LENGTH);
    DA_JOB_GET_FILEPATH(job, filepath, FMGR_MAX_PATH_LEN);

#ifdef __USB_IN_NORMAL_MODE__
    if (mmi_usb_is_in_mass_storage_mode() &&
        mmi_usb_check_path_exported((PS8) filepath))
    {
        /* if path is exported , it is temporary */
        ret = MMI_DA_FILESTAMP_CHECK_FAIL_TEMP;
        error_id = STR_ID_USB_MODE_EXPORTED_WARNING;
        goto func_end;
    }
#endif

    /* try to open file */
    filehandle = FS_Open(filepath, FS_READ_ONLY);
    DA_FREE_BUFFER(filepath);

    if(filehandle >= FS_NO_ERROR)
    {
        /* we can provide more check here */
        if(job->filestamp.curr_size != 0xFFFFFFFF)
        {
            FS_GetFileSize(filehandle, &filesize);
            if(job->filestamp.curr_size != filesize)
            {
                ret = MMI_DA_FILESTAMP_CHECK_FAIL;
            }
        }
        FS_Close(filehandle);
    }
    else
    {
        error_id = GetFileSystemErrorString(filehandle);
        switch(filehandle)
        {
        case FS_DEVICE_BUSY:
            ret = MMI_DA_FILESTAMP_CHECK_FAIL_TEMP;
            break;

        default:
            ret = MMI_DA_FILESTAMP_CHECK_FAIL;
        }
    }

func_end:
    DA_TRACE_FUNC2(mmi_da_job_check_filestamp, ret, filehandle);
    DA_FREE_BUFFER(filepath);
    if(error_reason_id && error_id)
       *error_reason_id = error_id; 
    return ret;
#else
    return MMI_DA_FILESTAMP_CHECK_OK;
#endif    
}

#define JOB_LIST


static S32 _mmi_da_job_get_item(S32 start_index, gui_iconlist_menu_item *menu_data, S32 data_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct           *job;
    mmi_da_item_progress_struct info;
    U32                         percentage;
    S8                          *dl_str;
    S32                         i;
    U16                         icon_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for(i=0; i<data_size; i++)
    {
        job = _mmi_da_get_nth_job(i + start_index);
        ASSERT(job);

        DA_JOB_GET_FILEPATH(job, menu_data[i].item_list[0], MAX_ASYNCDYNAMIC_ITEM_TEXT_SIZE/ENCODING_LENGTH - 1);
        percentage = DA_JOB_GET_PROGRESS(job, info);
        dl_str = mmi_da_util_format_size_total(info.currSize, info.fileSize);

        mmi_asc_to_ucs2((S8*)menu_data[i].item_list[2], (S8*)dl_str);

        menu_data[i].item_list[1][0] = 0;
        if(percentage != MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN)
            kal_wsprintf(menu_data[i].item_list[1], "%d%c", percentage, '%');

        switch(job->state)
        {
        case MMI_DA_JOB_STATE_DOWNLOADING:
        case MMI_DA_JOB_STATE_ABORTING:
            icon_id = IMG_ID_DA_DOWNLOAD_STATE_LOADING;
            break;

        case MMI_DA_JOB_STATE_PROCESSING:
#ifdef __DRM_SUPPORT__
        case MMI_DA_JOB_STATE_DRM_PROCESSING:
#endif
            icon_id = IMG_ID_DA_DOWNLOAD_STATE_PROCESSING;
            break;

        case MMI_DA_JOB_STATE_COMPLETED:
            icon_id = IMG_ID_DA_DOWNLOAD_STATE_COMPLETE;
            break;

        case MMI_DA_JOB_STATE_PAUSED:
            icon_id = IMG_ID_DA_DOWNLOAD_STATE_PAUSE;
            break;
            
        case MMI_DA_JOB_STATE_FAILED:
            icon_id = IMG_GLOBAL_L1;
            break;
            
        default:
            icon_id = 0;
            break;
        }

        menu_data[i].image_list[0] = (PU8)GetImage((U16)icon_id);
    }
    return i;
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __DRM_SUPPORT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void _mmi_da_job_list_option_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = _mmi_da_get_nth_job(da_context.job_list_highlight_index);
    ASSERT(job);

    switch(mmi_da_job_check_filestamp(job, NULL))
    {
    case MMI_DA_FILESTAMP_CHECK_OK:
        mmi_da_entry_job_list_option();
        break;
        
    case MMI_DA_FILESTAMP_CHECK_FAIL_TEMP:
        mmi_da_entry_job_list_option();
        break;

    case MMI_DA_FILESTAMP_CHECK_FAIL:
        DisplayPopup((PU8) GetString(STR_ID_DA_ERROR_FILE_MISMATCH), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME, (U8) ERROR_TONE);
        job->state = MMI_DA_JOB_STATE_ABORTED;
        _mmi_da_free_job(job);
        break;

    default:
        ASSERT(0);
        break;
    }
}

static void _mmi_da_job_list_highlight_hdlr(S32 hiliteidx)
{
    da_context.job_list_highlight_index = hiliteidx;
}

static void _mmi_da_job_list_option_highlight_hdlr(S32 hiliteidx)
{
    da_context.job_list_option_highlight_index = hiliteidx;    
}

static void mmi_da_entry_job_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    mmi_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    da_context.in_foreground = TRUE;
    DA_TRACE_FUNC(mmi_da_entry_job_list);

    ASSERT(da_context.list_job_num > 0);
    
    EntryNewScreen(SCR_ID_DA_JOB_LIST, NULL, mmi_da_entry_job_list, NULL);

    guiBuffer = GetCurrGuiBuffer(SCR_ID_DA_JOB_LIST);

    RegisterHighlightHandler(_mmi_da_job_list_highlight_hdlr);

    if(da_context.job_list_highlight_index < 0 || da_context.job_list_highlight_index >= da_context.list_job_num)
        da_context.job_list_highlight_index = 0;
    
    ShowCategory427Screen(
        (UI_string_type)GetString(STR_GLOBAL_DOWNLOAD),
        (PU8)GetImage((U16)mmi_da_util_get_icon_from_appid(APP_WAP)),
        (UI_string_type)GetString(STR_GLOBAL_OPTIONS),
        (PU8)GetImage(IMG_GLOBAL_OPTIONS),
        (UI_string_type)GetString(STR_GLOBAL_BACK),
        (PU8)GetImage(IMG_GLOBAL_BACK),
        da_context.list_job_num,
        _mmi_da_job_get_item,
//        _mmi_da_job_get_hint,
        da_context.job_list_highlight_index,
        guiBuffer);

    if(!mmi_is_redrawing_bk_screens())
    {
        da_context.curr_job = NULL;
        
        if(!da_context.job_list_timer_enable_flag)
        {
            /* first check for highlight, then check all */
            job = _mmi_da_get_nth_job(da_context.job_list_highlight_index);

            /* check for 3 item:
                1: job with error
                2: job with popup info
                3: job is completed and not notify yet */
            if(!_mmi_da_job_match_state_func(job, MMI_DA_JOB_STATE_FAILED) &&
                !_mmi_da_job_match_need_complete_notify_func(job, 0) &&
                !_mmi_da_job_has_popupinfo_func(job, 0))
            {
                job = NULL;
            }

            if(!job)
                job = mmi_da_find_job(_mmi_da_job_match_state_func, MMI_DA_JOB_STATE_FAILED);
            if(!job)
                job = mmi_da_find_job(_mmi_da_job_match_need_complete_notify_func, 0);
            if(!job)
                job = mmi_da_find_job(_mmi_da_job_has_popupinfo_func, 0);

            if(job)        
            {
                /* complete job must be tested for filestamp */
                if(!_mmi_da_job_match_need_complete_notify_func(job, 0) ||
                    MMI_DA_FILESTAMP_CHECK_OK == mmi_da_job_check_filestamp(job, NULL))
                {
                    ClearInputEventHandler(MMI_DEVICE_ALL);
                    da_context.job_list_timer_enable_flag = TRUE;
                    StartTimerEx(MMI_DA_TIMER_2, 100, _mmi_da_job_list_timer_handler, (void*)job);
                    return;
                }
            }
        }
    }

    SetLeftSoftkeyFunction(_mmi_da_job_list_option_hdlr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

static void mmi_da_entry_job_list_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nStrItemList[10];   /* Stores the strings id of submenus returned */
    U16 nNumofItem;         /* Stores no of children in the submenu */
    U8 *guiBuffer;          /* Buffer holding history data */
    U16                 optionMenuId;
    mmi_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_entry_job_list_option);


    job = _mmi_da_get_nth_job(da_context.job_list_highlight_index);
    if(!job)
    {
        /* remove this screen */
        EntryNewScreen(SCR_ID_DA_JOB_OPTION, NULL, mmi_da_entry_job_list_option, NULL);
        guiBuffer = GetCurrGuiBuffer(SCR_ID_DA_JOB_OPTION);
        /* isBackHistory must be true */
        ASSERT(guiBuffer);
        DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);
        GoBackHistory();
        return;
    }

    mmi_frm_hide_menu_item(MENU_ID_DA_JOB_OPTION_RESUME);
    mmi_frm_hide_menu_item(MENU_ID_DA_JOB_OPTION_SUSPEND);

    switch(job->state)
    {
    case MMI_DA_JOB_STATE_COMPLETED:
        optionMenuId = MENU_ID_DA_JOB_OPTION2;

        if(!job->setting_info.do_dispatch || !job->type_handler->dispatch_hdlr)
            mmi_frm_hide_menu_item(MENU_ID_DA_JOB_OPTION_USE_NOW);
        else
            mmi_frm_unhide_menu_item(MENU_ID_DA_JOB_OPTION_USE_NOW);
        break;

    case MMI_DA_JOB_STATE_DOWNLOADING:
        optionMenuId = MENU_ID_DA_JOB_OPTION;
        if(da_module_table[job->type]->resume)
            mmi_frm_unhide_menu_item(MENU_ID_DA_JOB_OPTION_SUSPEND);
        break;
        
    case MMI_DA_JOB_STATE_PROCESSING:
#ifdef __DRM_SUPPORT__
    case MMI_DA_JOB_STATE_DRM_PROCESSING:
#endif
        optionMenuId = MENU_ID_DA_JOB_OPTION;
        break;

    case MMI_DA_JOB_STATE_PAUSED:
        optionMenuId = MENU_ID_DA_JOB_OPTION;
        if(da_module_table[job->type]->resume)
            mmi_frm_unhide_menu_item(MENU_ID_DA_JOB_OPTION_RESUME);
        break;

    default:
        return;
    }
    da_context.job_list_current_option_menu_id = optionMenuId;

    /* 1 Call Exit Handler */
    EntryNewScreen(SCR_ID_DA_JOB_OPTION, NULL, mmi_da_entry_job_list_option, NULL);

    /* 2 Get current screen to gui buffer  for history purposes */
    guiBuffer = GetCurrGuiBuffer(SCR_ID_DA_JOB_OPTION);

    /* 3. Retrieve no of child of menu item to be displayed */
    nNumofItem = GetNumOfChild_Ext(optionMenuId);

    ASSERT(nNumofItem <= 10);
    /* 4. Get attribute of menu to be displayed */

    /* 5. Retrieve string ids in sequence of given menu item to be displayed */
    GetSequenceStringIds_Ext(optionMenuId, nStrItemList);

    /* 6 Set current parent id */
    RegisterHighlightHandler(_mmi_da_job_list_option_highlight_hdlr);

    /* 8 Construct the Hints List - no need */

    ShowCategory52Screen(
        STR_GLOBAL_OPTIONS,
        mmi_da_util_get_icon_from_appid(APP_WAP),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        nNumofItem,
        nStrItemList,
        (PU16) gIndexIconsImageList,
        NULL,
        0, 0,
        guiBuffer);

    /* 9.Register function with right softkey */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);

    SetKeyHandler(mmi_da_job_list_option_lsk_hdlr, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetLeftSoftkeyFunction(mmi_da_job_list_option_lsk_hdlr, KEY_EVENT_UP);
}
#endif

static U32 _mmi_da_format_job_detail(const mmi_da_job_struct *job, U16* strBuffer, U32 buffer_len, U32 count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_item_progress_struct info;
    U32                         percentage;
    U16                         time_buffer[MMI_DA_UTIL_ESTIMATED_TIME_FORMAT_LEN]; /* xx min. xx sec. */
    S8                          *dl_str;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(count >= 3);
    
    percentage = DA_JOB_GET_PROGRESS(job, info);
    mmi_da_util_format_time(time_buffer, info.secs_remain);
    dl_str = mmi_da_util_format_size_total(info.currSize, info.fileSize);

    /* Filepath */
    DA_JOB_GET_FILEPATH(job, strBuffer, buffer_len-1);
    strBuffer[buffer_len-1] = 0;

    /* size information */
    mmi_asc_to_ucs2((S8*)(strBuffer + buffer_len), (S8*)dl_str);
    strBuffer[buffer_len*2-1] = 0;

    /* 2nd+3rd line */
    strBuffer[buffer_len*2] = 0;
    strBuffer[buffer_len*3] = 0;
    switch(job->state)
    {
    case MMI_DA_JOB_STATE_DOWNLOADING:
        /* display estimated time when downloading */
#if UI_DEVICE_WIDTH > UI_DEVICE_HEIGHT
        /* Landscape */
        kal_wsprintf((WCHAR*)(strBuffer + buffer_len*2), "%w:%w\n", GetString(STR_ID_DA_PROMPT_TIME_REMAIN), time_buffer);
        strBuffer[buffer_len*3-1] = 0;
#else
        kal_wsprintf((WCHAR*)(strBuffer + buffer_len*2), "%w:\n", GetString(STR_ID_DA_PROMPT_TIME_REMAIN));
        strBuffer[buffer_len*3-1] = 0;
        kal_wsprintf((WCHAR*)(strBuffer + buffer_len*3), "%w\n", time_buffer);
        strBuffer[buffer_len*4-1] = 0;
#endif        
        break;

#ifdef __DRM_SUPPORT__
    case MMI_DA_JOB_STATE_DRM_PROCESSING:
        mmi_ucs2ncpy((S8*)(strBuffer + buffer_len*2), (S8*)GetString(STR_GLOBAL_DRM_PROCESSING), buffer_len-1);
        strBuffer[buffer_len*3-1] = 0;
        break;
#endif

    case MMI_DA_JOB_STATE_PROCESSING:
        if(info.processing_string)
        {
            mmi_ucs2ncpy((S8*)(strBuffer + buffer_len*2), (S8*)info.processing_string, buffer_len-1);
            strBuffer[buffer_len*3-1] = 0;
        }
        break;
    }

    return percentage;
}

static void mmi_da_entry_job_detail(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct           *job;
    U32                         percentage;
    U16                         lskId, titleId;
    UI_string_type              display[3];
    BOOL                        can_minimize;
    U16                         bannerId;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_entry_job_detail);
    
    job = da_context.curr_job;
    if(!job)
    {
        ASSERT(0);
        return;
    }

    da_context.in_foreground = TRUE;
    
    percentage = _mmi_da_format_job_detail(job, (U16*)subMenuData, MAX_SUB_MENU_SIZE, MAX_SUB_MENUS/2);

    EntryNewScreen(SCR_ID_DA_JOB_DETAIL, NULL, mmi_da_entry_job_detail, NULL);

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    can_minimize = job->setting_info.can_minimize;
#else
    can_minimize = FALSE;
#endif

    lskId = can_minimize ? STR_GLOBAL_BACK : STR_GLOBAL_CANCEL;
    titleId = STR_GLOBAL_DOWNLOADING;
    if(job->notifyed_complete && job->state == MMI_DA_JOB_STATE_COMPLETED)
        titleId = STR_ID_DA_JOB_VIEW_DETAIL;

    if(job->state == MMI_DA_JOB_STATE_COMPLETED || job->state == MMI_DA_JOB_STATE_PAUSED)
        bannerId = 0;
    else
        bannerId = IMG_ID_DA_DOWNLOAD_PROGRESS_BANNER;

    display[0] = (UI_string_type)(subMenuData)+MAX_SUB_MENU_SIZE;
    display[1] = (UI_string_type)(subMenuData)+MAX_SUB_MENU_SIZE*2;
    
#if defined(__MMI_MAINLCD_128X128__)
    if(percentage == MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN)
    {
        ShowCategory402Screen(
            (U8*) GetString(STR_GLOBAL_DOWNLOADING),
            mmi_da_util_get_icon_from_appid(APP_WAP),
            0, 
            0, 
            lskId, 
            0,
            NULL, 0, (U8*)display[0]);
    }
    else
    {
        ShowCategory402Screen(
            (U8*) GetString(STR_GLOBAL_DOWNLOADING),
            mmi_da_util_get_icon_from_appid(APP_WAP),
            0, 
            0, 
            lskId, 
            0,
            NULL, (U16)percentage, (U8*)NULL);
    }
#else
    if(percentage == MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN)
    {
        ShowCategory412Screen(
            (UI_string_type)GetString(titleId),
            (PU8)GetImage(mmi_da_util_get_icon_from_appid(APP_WAP)),
            NULL,
            0,
            (UI_string_type)GetString(lskId),
            0,
            (PU8)GetImage(bannerId),
            (UI_string_type)mmi_da_util_get_filename((U16*)subMenuData),
            (U8)0,
            1,
            display,
            (U8*)subMenuData);
    }
    else
    {
        ShowCategory412Screen(
            (UI_string_type)GetString(titleId),
            (PU8)GetImage(mmi_da_util_get_icon_from_appid(APP_WAP)),
            NULL,
            0,
            (UI_string_type)GetString(lskId),
            0,
            (PU8)GetImage(bannerId),
            (UI_string_type)mmi_da_util_get_filename((U16*)subMenuData),
            (U8)percentage, 
            2,
            display,
            (U8*)subMenuData);
    }
#endif

    if(can_minimize)
        SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    else
        SetRightSoftkeyFunction(mmi_da_curr_job_abort_hdlr, KEY_EVENT_UP);

    /* Check fail job */
    if(!mmi_is_redrawing_bk_screens() && !can_minimize)
    {
        ASSERT(!da_context.job_list_timer_enable_flag);
        if(job->state == MMI_DA_JOB_STATE_FAILED ||
            job->state == MMI_DA_JOB_STATE_COMPLETED)
        {
            ClearInputEventHandler(MMI_DEVICE_ALL);
            da_context.curr_job = job;
            da_context.job_list_timer_enable_flag = TRUE;
            StartTimerEx(MMI_DA_TIMER_2, 100, _mmi_da_job_list_timer_handler, (void*)job);
        }
    }
}

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void mmi_da_job_list_option_lsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16                 menuID, error_id;
    mmi_da_job_struct   *job, *next_job;
    mmi_da_job_filestamp_enum check_result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC1(mmi_da_job_list_option_lsk_hdlr, da_context.job_list_current_option_menu_id);
    
    ASSERT(!da_context.curr_job);
    job = _mmi_da_get_nth_job(da_context.job_list_highlight_index);
    ASSERT(job);

    menuID = GetSeqItemId_Ext(da_context.job_list_current_option_menu_id, (U16) da_context.job_list_option_highlight_index);

    EntryNewScreen(SCR_ID_DA_JOB_OPTION, NULL, NULL, NULL);
    DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);

    switch(menuID)
    {
    case MENU_ID_DA_JOB_OPTION_USE_NOW:
    case MENU_ID_DA_JOB_OPTION_SAVE_AS:
    case MENU_ID_DA_JOB_OPTION_RESUME:
        check_result = mmi_da_job_check_filestamp(job, &error_id);
        if(check_result != MMI_DA_FILESTAMP_CHECK_OK)
        {
            DisplayPopup((PU8) GetString(error_id), IMG_GLOBAL_WARNING, 1, UI_POPUP_NOTIFYDURATION_TIME, (U8) WARNING_TONE);
            return;
        }
        break;
    }

    switch(menuID)
    {
    case MENU_ID_DA_JOB_OPTION_VIEW_DETAIL:
        da_context.curr_job = job;
        mmi_da_entry_job_detail();
        DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
        break;

    case MENU_ID_DA_JOB_OPTION_USE_NOW:
        ASSERT(job->state == MMI_DA_JOB_STATE_COMPLETED);

        if(!job->setting_info.do_dispatch || !job->type_handler->dispatch_hdlr)
        {
            DisplayPopup((PU8) GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME, (U8) ERROR_TONE);
        }
        else
        {
            da_module_table[job->type]->dispatch(job);
        }
        break;

    case MENU_ID_DA_JOB_OPTION_SAVE_AS:
        ASSERT(job->state == MMI_DA_JOB_STATE_COMPLETED);
        {
            /* emulate a SAVE AS push */
            mmi_da_dispatch_file_req_struct *p;

            p = (mmi_da_dispatch_file_req_struct*) construct_local_para(sizeof(mmi_da_dispatch_file_req_struct), TD_CTRL | TD_RESET);
            
            EntryNewScreen(SCR_ID_DA_DISPATCH_DUMMY, NULL, NULL, NULL);
            p->action = MMI_DA_ACT_INTERNAL_SAVE_AS | MMI_DA_ACT_INTERNAL_SAVE_AS_MOVE;
#ifdef __DRM_V02__
            if(job->drm.drm_method == DRM_METHOD_V2)
                p->action |= MMI_DA_ACT_INTERNAL_SAVE_AS_NORMAL;
#endif
            DA_JOB_GET_FILEPATH(job, p->filepath, FMGR_MAX_PATH_LEN);
            p->mime_type = job->mime_type ? job->mime_type->mime_type : MIME_TYPE_UNKNOWN;
            p->mime_subtype = job->mime_type ? job->mime_type->mime_subtype : MIME_SUBTYPE_UNRECOGNIZED;
            mmi_da_send_ilm(p, NULL, MSG_ID_MMI_DA_DISPATCH_FILE_REQ, MOD_MMI);
        }
        break;

    case MENU_ID_DA_JOB_OPTION_REMOVE:
        ASSERT(job->state == MMI_DA_JOB_STATE_COMPLETED);
        _mmi_da_free_job(job);
        DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, UI_POPUP_NOTIFYDURATION_TIME,
                     (U8) SUCCESS_TONE);
        break;

    case MENU_ID_DA_JOB_OPTION_REMOVE_ALL:
        /* remove all complete */
        menuID = 0;
        job = da_context.list_job;
        while(job)
        {
            next_job = job->next_job;
            if(job->state == MMI_DA_JOB_STATE_COMPLETED)
            {
                _mmi_da_free_job(job);
                menuID++;
            }
            job = next_job;
        }
        if(menuID)
        {
           DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) SUCCESS_TONE);
        }
        else
            GoBackHistory();
        break;

    case MENU_ID_DA_JOB_OPTION_CANCEL:
        da_context.curr_job = job;
        // TODO: what if abort take a while? should we add a "aborting" screen ?
        mmi_da_curr_job_abort_hdlr();
        break;
        
    case MENU_ID_DA_JOB_OPTION_SUSPEND:
        // TODO: what if suspend take a while? should we add a "suspending" screen ?
        da_context.curr_job = job;
        mmi_da_curr_job_suspend_hdlr();
        break;

    case MENU_ID_DA_JOB_OPTION_RESUME:
        ASSERT(job->state == MMI_DA_JOB_STATE_PAUSED);
        ASSERT(da_module_table[job->type]->resume);

        if(mmi_da_count_job(_mmi_da_job_match_state_func, MMI_DA_JOB_STATE_DOWNLOADING) +
            mmi_da_count_job(_mmi_da_job_match_state_func, MMI_DA_JOB_STATE_PROCESSING) >= MMI_DA_MAX_DL)
        {
            DisplayPopup((PU8) GetString(STR_ID_DA_PROMPT_EXCEED_MAX_DL), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) ERROR_TONE);
        }
        else
        {
            da_module_table[job->type]->resume(job);
        }
        break;

    default:
        GoBackHistory();
        break;
    }
}
#endif

static void mmi_da_curr_job_aborted_callback(mmi_da_job_struct* job, U16 string_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(job == da_context.curr_op_job);

    // TODO: report back to app if required.
    ASSERT(job->state == MMI_DA_JOB_STATE_ABORTED);

    da_context.curr_op_job = NULL;
    
    if(mmi_da_is_in_foreground_state() && !job->setting_info.report_hdlr)
    {
        if(!string_id)
            string_id = STR_ID_DA_OMA_USER_CANCELLED_MSG;
        DisplayPopup((PU8) GetString(string_id), IMG_GLOBAL_WARNING, 1, UI_POPUP_NOTIFYDURATION_TIME, (U8) WARNING_TONE);
    }
    
    _mmi_da_free_job(job);
    DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
    DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);
}

static void mmi_da_curr_job_abort_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 prev_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ASSERT(da_context.curr_job);
    
    DA_TRACE_FUNC1(mmi_da_curr_job_abort_hdlr, da_context.curr_job->state);
    
    da_context.curr_op_job = da_context.curr_job;
    
    prev_state = da_context.curr_job->state;
    da_context.curr_job->state = MMI_DA_JOB_STATE_ABORTING;
    ClearInputEventHandler(MMI_DEVICE_ALL);
        
    switch(prev_state)
    {
    case MMI_DA_JOB_STATE_DOWNLOADING:
    case MMI_DA_JOB_STATE_PROCESSING:
        da_module_table[da_context.curr_job->type]->stop(da_context.curr_job, 
                                                         prev_state, FALSE,
                                                         mmi_da_curr_job_aborted_callback);
        break;
        
#ifdef __DRM_SUPPORT__
    case MMI_DA_JOB_STATE_DRM_PROCESSING:
        mmi_da_drm_process_file_abort(da_context.curr_job);
        break;
#endif

    case MMI_DA_JOB_STATE_PAUSED:
        da_context.curr_job->state = MMI_DA_JOB_STATE_ABORTED;
        mmi_da_curr_job_aborted_callback(da_context.curr_job, 0);
        break;

    default:
        ASSERT(0);  // should not go here
    }
}

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void mmi_da_curr_job_suspended_callback(mmi_da_job_struct* job, U16 string_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(job == da_context.curr_job);

    ASSERT(job->state == MMI_DA_JOB_STATE_ABORTED);
    job->state = MMI_DA_JOB_STATE_PAUSED;

    ASSERT(!string_id);

    if(mmi_da_is_in_foreground_state())
    {
        DisplayPopup((PU8) GetString(STR_ID_DA_POPUP_SUSPENDED), IMG_GLOBAL_WARNING, 1, UI_POPUP_NOTIFYDURATION_TIME, (U8) WARNING_TONE);
    }
    DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
    DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);
    mmi_da_update_job_status(job);
}

static void mmi_da_curr_job_suspend_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 prev_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ASSERT(da_context.curr_job);
    
    prev_state = da_context.curr_job->state;
    da_context.curr_job->state = MMI_DA_JOB_STATE_ABORTING;
    ClearInputEventHandler(MMI_DEVICE_ALL);
    
    switch(prev_state)
    {
    case MMI_DA_JOB_STATE_DOWNLOADING:
        da_module_table[da_context.curr_job->type]->stop(da_context.curr_job, 
                                                         prev_state, TRUE,
                                                         mmi_da_curr_job_suspended_callback);
        break;
        
    default:
        GoBackHistory();
        break;
    }
}
#endif    

#define JOB_COMPLETE_DISPATCH

#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void mmi_da_job_entry_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(da_context.curr_job && da_context.curr_job->state == MMI_DA_JOB_STATE_COMPLETED);
    
    if(!da_context.curr_job->setting_info.do_dispatch || !da_context.curr_job->type_handler->dispatch_hdlr)
    {
        DisplayPopup((PU8) GetString(STR_ID_DA_PROMPT_DL_COMPLETE), IMG_GLOBAL_ACTIVATED, 1, UI_POPUP_NOTIFYDURATION_TIME,
                     SUCCESS_TONE);
        _mmi_da_free_job(da_context.curr_job);
    }
    else if(da_context.curr_job->setting_info.confirm_dispatch)
    {
        mmi_da_entry_dispatch_confirm();
    }
    else
    {
        da_module_table[da_context.curr_job->type]->dispatch(da_context.curr_job);
        _mmi_da_free_job(da_context.curr_job);
    }
}
#endif

static void mmi_da_job_complete(const mmi_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct           *thejob;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(job->state == MMI_DA_JOB_STATE_COMPLETED);
    
    thejob = (mmi_da_job_struct*)job;

#ifdef __DRM_V02__
    if(job->drm.drm_method != DRM_METHOD_NONE)
    {
        U16* filepath = (U16*)OslMalloc((FMGR_MAX_PATH_LEN + 1) * ENCODING_LENGTH);
        filepath[0] = 0;
        DA_JOB_GET_FILEPATH(job, filepath, FMGR_MAX_PATH_LEN);
        DRM_register_file((kal_wchar*)filepath);
        OslMfree(filepath);
    }
#endif

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(!mmi_da_is_in_foreground_state())
        return;
        
    if(!job->setting_info.do_dispatch || !job->type_handler->dispatch_hdlr)
    {
        // TODO: show job name, download complete
        DisplayPopup((PU8) GetString(STR_ID_DA_PROMPT_DL_COMPLETE), IMG_GLOBAL_ACTIVATED, 1, UI_POPUP_NOTIFYDURATION_TIME,
                     SUCCESS_TONE);

        thejob->notifyed_complete = TRUE;
        DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
        DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);
        return;
    }

    if(job->setting_info.report_hdlr)
    {
        // if alreayd reported, just clean up
        thejob->notifyed_complete = TRUE;
        return;
    }
    else if(job->setting_info.confirm_dispatch)
    {
        /* there are only 4 condition can display confirm */
        if( GetActiveScreenId() == SCR_ID_DA_JOB_LIST ||
            GetActiveScreenId() == SCR_ID_DA_JOB_OPTION ||
            (GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL && da_context.curr_job == job))
        {
            ASSERT(!da_context.push_item_curr);
            da_context.curr_job = thejob;
            mmi_da_entry_dispatch_confirm();
            DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
            DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);
        }
        return;
    }
    else if(!job->setting_info.can_minimize)
    {
        if( GetActiveScreenId() == SCR_ID_DA_JOB_LIST ||
            GetActiveScreenId() == SCR_ID_DA_JOB_OPTION ||
            (GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL && da_context.curr_job == job))
        {
            da_module_table[job->type]->dispatch(job);
        }
        else
        {
            return;
        }
    }
    else
    {
        /* no confirm, directly dispatch */
        da_module_table[job->type]->dispatch(job);
    }

    // remove job
    _mmi_da_free_job(thejob);

    // back to job list screen.
    if(GetActiveScreenId() == SCR_ID_DA_JOB_OPTION)
        GoBackHistory();
    else
        DeleteScreenIfPresent(SCR_ID_DA_JOB_OPTION);
    if(GetActiveScreenId() == SCR_ID_DA_JOB_DETAIL)
        GoBackHistory();
    else
        DeleteScreenIfPresent(SCR_ID_DA_JOB_DETAIL);
#else

    if(job->setting_info.report_hdlr)
    {
        _mmi_da_free_job(thejob);
        return;
    }
    
    da_context.curr_job = thejob;
    if(mmi_da_is_in_voice_call())
    {
        HistoryReplace(SCR_ID_DA_JOB_DETAIL , SCR_ID_DA_DUMMY, mmi_da_job_entry_complete);
        return;
    }

    mmi_da_job_entry_complete();
#endif
}

static void _mmi_da_job_cancel_dispatch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(da_context.curr_job);
    ASSERT(da_context.curr_job->state == MMI_DA_JOB_STATE_COMPLETED);

    ClearDelScrnIDCallbackHandler(SCR_ID_DA_JOB_CALLBACK_CONFIRM, NULL);
    
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(!da_context.curr_job->setting_info.can_minimize)
        _mmi_da_free_job(da_context.curr_job);
#else
    _mmi_da_free_job(da_context.curr_job);
#endif
    da_context.curr_job = NULL;
   
    if(GetActiveScreenId() == SCR_ID_DA_JOB_CALLBACK_CONFIRM)
        GoBackHistory();
    else
        DeleteScreenIfPresent(SCR_ID_DA_JOB_CALLBACK_CONFIRM);
}

static void _mmi_da_job_dispatch_to_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job;
    U16                 err_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(da_context.curr_job);
    job = da_context.curr_job;
    
    if(MMI_DA_FILESTAMP_CHECK_OK != mmi_da_job_check_filestamp(job, &err_id))
    {
        DisplayPopup((PU8) GetString((U16)err_id), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                     (U8) ERROR_TONE);
        _mmi_da_job_cancel_dispatch();
        return;
    }
    
    da_module_table[job->type]->dispatch(job);
    if(mmi_da_is_job_valid(job))
    {
        da_context.curr_job = job;
        _mmi_da_job_cancel_dispatch();
    }
}

static void mmi_da_dispatch_confirm_timer(void)
{
    if(GetActiveScreenId() == SCR_ID_DA_JOB_CALLBACK_CONFIRM)
        GoBackHistory();
}

static U8 _mmi_da_dispatch_confirm_delete_callback(void *in_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearDelScrnIDCallbackHandler(SCR_ID_DA_JOB_CALLBACK_CONFIRM, NULL);

    da_context.curr_job = NULL;

    return MMI_FALSE;
}

static void mmi_da_entry_dispatch_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_entry_dispatch_confirm);
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_DA_JOB_CALLBACK_CONFIRM);

    EntryNewScreen(SCR_ID_DA_JOB_CALLBACK_CONFIRM, NULL, mmi_da_entry_dispatch_confirm, NULL);

    SetDelScrnIDCallbackHandler(SCR_ID_DA_JOB_CALLBACK_CONFIRM, (HistoryDelCBPtr) _mmi_da_dispatch_confirm_delete_callback);

    if(!da_context.curr_job)
    {
        StartTimer(MMI_DA_TIMER_3, 1, mmi_da_dispatch_confirm_timer);
        return;
    }

    DA_JOB_GET_FILEPATH(da_context.curr_job, (U16*)subMenuData, FMGR_MAX_PATH_LEN);
    mmi_ucs2cat((S8*)subMenuData, (S8*)get_string(STR_ID_DA_PROMPT_DL_COMPLETE_ASK));
    da_context.curr_job->notifyed_complete = TRUE;

    ShowCategory74Screen(STR_ID_DA_JOB_USE,
                     mmi_da_util_get_icon_from_appid(APP_WAP),
                     STR_GLOBAL_YES, IMG_GLOBAL_YES,
                     STR_GLOBAL_NO, IMG_GLOBAL_NO,
                     (PU8) subMenuData,
                     mmi_ucs2strlen((PS8) subMenuData),
                     guiBuffer);

    SetLeftSoftkeyFunction(_mmi_da_job_dispatch_to_app, KEY_EVENT_UP);
    SetRightSoftkeyFunction(_mmi_da_job_cancel_dispatch, KEY_EVENT_UP);
}

#define PUSH_DISPATCH

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static mmi_da_push_item_struct* mmi_da_parse_dispatch_request(mmi_da_dispatch_file_req_struct* msg,
                                                              peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_push_item_struct *item;
    S8                      *mime_str;
    U16                     *ext;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    item = OslMalloc(sizeof(mmi_da_push_item_struct));
    memset(item, 0, sizeof(mmi_da_push_item_struct));
    
    ASSERT((U32)item == (U32)(&(item->job))); // make sure job is the first variable.

#ifdef __DRM_SUPPORT__
    item->job.drm.drm_serial = 0xFF;
#endif

    item->job.type = MMI_DA_JOB_TYPE_PUSH;
    item->job.state = MMI_DA_JOB_STATE_COMPLETED;

    mime_str = NULL;
    if(msg->mime_type_string[0])
        mime_str = msg->mime_type_string;

    ext = mmi_da_util_get_extension(msg->filename);
    if(!ext)
        ext = mmi_da_util_get_extension(msg->filepath);

    item->job.mime_type = mmi_da_util_lookup_mime_type((U8*)mime_str, ext, msg->mime_type, msg->mime_subtype);

    // special case
    if (msg->mime_type == MIME_TYPE_UNKNOWN &&
        msg->mime_subtype == MIME_SUBTYPE_UNRECOGNIZED)
        item->job.mime_type = NULL;

    item->job.type_handler = mmi_da_search_mime_type_handler(item->job.mime_type);

    UCS2_STR_MALLOC_COPY(item->filepath, msg->filepath);
    UCS2_STR_MALLOC_COPY(item->filename, msg->filename);
    
    ANSI_STR_MALLOC_COPY(item->mime_type_string, msg->mime_type_string);
    ANSI_STR_MALLOC_COPY(item->url, msg->url);

    item->file_length = mmi_da_util_get_file_size(item->filepath);

    item->action = msg->action;

    /* header */
    item->header_len = 0;
    item->header = NULL;

    if (peer_buff_ptr)
    {
        kal_uint16 len;
        mmi_da_dispatch_file_var_struct *buffer = (mmi_da_dispatch_file_var_struct *) get_pdu_ptr(peer_buff_ptr, &len);

        if( buffer->header_len > 0 )
        {
            item->header_len = buffer->header_len;
            item->header = (S8*)get_ctrl_buffer(buffer->header_len+1);
            memset(item->header, 0, buffer->header_len+1);
            memcpy(item->header, buffer->header, buffer->header_len);
        }

    }
    return item;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_recv_dispatch_file_req(void *MsgStruct, int mod_src, void *ilm_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_dispatch_file_req_struct *msg;
    ilm_struct                      *mmi_ilm_ptr = (ilm_struct*) ilm_p;
    MMI_BOOL                        can_popup, is_normal_save, is_move;
    mmi_da_push_item_struct         *item, *list;
    mmi_da_setting_struct           *setting;
#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    S8                              *cust_url = NULL;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_recv_dispatch_file_req);

    msg = (mmi_da_dispatch_file_req_struct*) MsgStruct;

    ASSERT(msg);
    ASSERT(msg->action == MMI_DA_PUSH || msg->action == MMI_DA_PUSH_SIM2 || msg->action == MMI_DA_SAVE_AS ||
           msg->action > MMI_DA_ACT_INTERNAL_BASE);

    is_normal_save = is_move = MMI_FALSE;
    can_popup = MMI_TRUE;

#ifdef __USB_IN_NORMAL_MODE__
    /* check is in mass storage mode */
    if(mmi_usb_is_in_mass_storage_mode())
    {
        /* phone drive is exported, cant use this app */
        mmi_usb_app_unavailable_popup(0);   /* pass 0 will show default string */
        can_popup = MMI_FALSE;
    }
#endif /* __USB_IN_NORMAL_MODE__ */

    if(isIncomingCall() || isOutgoingCall())
        can_popup = MMI_FALSE;

    if(da_context.setuping_job)
    {
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_DOWNLOAD_CONFIRM);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_END);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_FILENAME_OPTION);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_FILENAME);
        DeleteScreenIfPresent(SCR_FMGR_SEL_DRV);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_SEL_DRV);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_MARKER);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_BEGIN);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_AUTH);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_PLEASE_WAIT);
        DeleteScreenIfPresent(SCR_ID_DA_OMA_DOWNLOAD_OPTION);
        DeleteScreenIfPresent(SCR_ID_DA_OMA_DOWNLOAD_VIEW_DD);
        mmi_da_job_cancel(da_context.setuping_job);
    }


    if(msg->action & MMI_DA_ACT_INTERNAL_SAVE_AS)
    {
        if(msg->action & MMI_DA_ACT_INTERNAL_SAVE_AS_NORMAL)
            is_normal_save = MMI_TRUE;
        if(msg->action & MMI_DA_ACT_INTERNAL_SAVE_AS_MOVE)
            is_move = MMI_TRUE;
        
        if(GetActiveScreenId() != SCR_ID_DA_DISPATCH_DUMMY)
            can_popup = MMI_FALSE;
        msg->action = MMI_DA_SAVE_AS;
#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        if(!msg->mime_type_string[0] && msg->mime_type_string[1])
            cust_url = msg->mime_type_string+1;
#endif        
    }    
    
    if(msg->action == MMI_DA_SAVE_AS && !can_popup)
    {
        DA_TRACE_FUNC1(mmi_da_recv_dispatch_file_req, 0xFF);
        if(!is_move)
            FS_Delete(msg->filepath);
        return;
    }

    /* parse content */
    item = mmi_da_parse_dispatch_request(msg, mmi_ilm_ptr->peer_buff_ptr);
#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(cust_url)
        ANSI_STR_MALLOC_COPY(item->url, cust_url);
#endif

#ifdef __DRM_V02__    
    if(is_normal_save && DRM_is_archive(0, item->filepath))
    {
        item->job.type_handler = mmi_da_get_default_mime_type_handler();
    }
#endif    
    item->is_normal_save = is_normal_save;

    /* retrieve setting */
    setting = &da_context.setting;
    ASSERT(item->job.type_handler->setting_hdlr);
    item->job.type_handler->setting_hdlr(
            0,
            item->job.mime_type ? item->job.mime_type->mime_type: 0,
            item->job.mime_type ? item->job.mime_type->mime_subtype: 0,
            item->action,
            item->file_length,
            item->url,
            item->mime_type_string,
            0, NULL,
            setting);

    if((msg->action == MMI_DA_PUSH || msg->action == MMI_DA_PUSH_SIM2) && setting->confirm_push == TRUE)
    {
        /* if require confirm, alert user and push in queue */
        can_popup = MMI_FALSE;
        if(da_context.push_item_num < 8)
        {
            DisplayPopup((PU8) GetString(STR_ID_DA_NEW_PUSH), (U16) IMG_GLOBAL_WARNING, (U8) 1, (U32) UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) WARNING_TONE);
        }
    }
    
    /* cant popup, so store it for later use */
    if(!can_popup && setting->confirm_push == TRUE)
    {
        ASSERT(msg->action == MMI_DA_PUSH || msg->action == MMI_DA_PUSH_SIM2);

        if(da_context.push_item_num >= 8)
        {
            mmi_da_push_free_item(item);
            return;
        }
        else if(!da_context.push_item_num)
        {
            da_context.push_item_list = item;
        }
        else
        {
            list = da_context.push_item_list;
            while(list->next_item) list = list->next_item;
            list->next_item = item;
            item->next_item = NULL;
        }
        da_context.push_item_num++;
        return;
    }

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /* check if this dispatch is from job rename */
    if(is_move)
        item->exist_job = mmi_da_find_job_by_filepath(item->filepath, FALSE);
#endif

    /* in this case, it means, dispatch flow is re-entry, we should remove previous entry */
    if(da_context.push_item_curr)
    {
        DA_TRACE_FUNC1(mmi_da_recv_dispatch_file_req, 78);
        
        EntryNewScreen(SCR_ID_DA_DISPATCH_DUMMY, NULL, NULL, NULL);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_DOWNLOAD_CONFIRM);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_END);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_FILENAME_OPTION);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_FILENAME);
        DeleteScreenIfPresent(SCR_FMGR_SEL_DRV);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_SEL_DRV);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_MARKER);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_STORAGE_BEGIN);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_AUTH);
        DeleteScreenIfPresent(SCR_ID_DA_SCREEN_PLEASE_WAIT);
        ASSERT(!da_context.push_item_curr);
    }

    /* ok */
    da_context.push_item_curr = item;
    mmi_da_push_select_storage(item, setting);
    
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_push_select_storage(mmi_da_push_item_struct *item, mmi_da_setting_struct *setting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_scr_storage_parameter_struct para;
    U16                                 *filename;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ASSERT(item);
    if(!setting)
    {
        setting = &da_context.setting;
        ASSERT(item->job.type_handler->setting_hdlr);
        item->job.type_handler->setting_hdlr(
                0,
                item->job.mime_type ? item->job.mime_type->mime_type: 0,
                item->job.mime_type ? item->job.mime_type->mime_subtype: 0,
                item->action,
                item->file_length,
                item->url,
                item->mime_type_string,
                0, NULL,
                setting);
    }
    
    memset(&para, 0, sizeof(para));
    
    para.drv = setting->drv;
    para.storage = setting->storage;
    para.select_storage = (setting->storage == MMI_DA_STORAGE_NONE) ? TRUE : FALSE;

    para.folder = setting->folder;

    if(!setting->default_filename && setting->filename[0])  // Use setting given
        filename = setting->filename;
    else if(item->filename)                                 // Default
        filename = mmi_da_util_get_filename(item->filename);
    else if(item->filepath)
        filename = mmi_da_util_get_filename(item->filepath);
    else
    {
        ASSERT(0);
        return;
    }

    mmi_da_extract_filepath(filename, para.filename, para.fileext);
        
    para.select_filename = (!setting->default_filename && setting->filename[0] == 0) ? TRUE : FALSE;
    para.filesize = item->file_length;
    para.original_filepath = item->filepath;
    
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(item->exist_job)
        para.filecheck_func = (void*)mmi_da_find_job_by_filepath;
#endif

    if(item->job.mime_type && !item->is_normal_save)
        para.ext = (S8*)item->job.mime_type->file_ext;

    /* confirmed, select storage now. */
    if(item->url && strncmp(item->url, "mms", 3) == 0)
    {
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        ASSERT(!item->exist_job);
#endif
        mmi_da_scr_select_storage(mmi_da_push_filename_done, &para, (U32)item, APP_MESSAGES);
    }
    else
    {
        mmi_da_scr_select_storage(mmi_da_push_filename_done, &para, (U32)item, APP_WAP);
    }
}

#ifdef __DRM_SUPPORT__
/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_push_drm_process_callback(mmi_da_job_struct* job,
                                             U16 *new_filepath, U16 err_string_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_dispatch_file_req_struct *p;
    mmi_da_push_item_struct  *item;
    S32                      ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item = (mmi_da_push_item_struct*)job;

    if(!new_filepath)
    {
        if(err_string_id)
        {
            DisplayPopup((PU8) GetString((U16) err_string_id), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) ERROR_TONE);
        }
        /* failed, clear up */
        mmi_da_push_free_item(item);
        return;
    }

    /* delete old file */
    if(mmi_ucs2icmp((S8*)item->filepath, (S8*)new_filepath))
        ret = FS_Delete(item->filepath);

    /* here we can not use mmi_da_push_select_storage(), due to call stack too long and 
        mmi_da_push_select_storage() may be re-entryed */
    //mmi_da_push_select_storage(item, NULL);

    p = (mmi_da_dispatch_file_req_struct*) construct_local_para(sizeof(mmi_da_dispatch_file_req_struct), TD_CTRL | TD_RESET);
    mmi_ucs2ncpy((S8 *) p->filepath, (S8 *) new_filepath, 260);
    mmi_ucs2ncpy((S8 *) p->filename, (S8 *) mmi_da_util_get_filename(item->filepath), 255);
    p->mime_type = item->job.mime_type ? item->job.mime_type->mime_type: MIME_TYPE_UNKNOWN;
    p->mime_subtype = item->job.mime_type ? item->job.mime_type->mime_subtype: MIME_SUBTYPE_UNRECOGNIZED;
    if(item->url)
		strncpy(p->url, item->url, 31);
    
    EntryNewScreen(SCR_ID_DA_DISPATCH_DUMMY, NULL, NULL, NULL);
    p->action = MMI_DA_ACT_INTERNAL_SAVE_AS;
#ifdef __DRM_V02__
    if(item->job.drm.drm_method == DRM_METHOD_V2)
        p->action |= MMI_DA_ACT_INTERNAL_SAVE_AS_NORMAL;
#endif
    
    mmi_da_send_ilm(p, NULL, MSG_ID_MMI_DA_DISPATCH_FILE_REQ, MOD_MMI);

    DA_FREE_BUFFER(new_filepath);
    mmi_da_push_free_item(item);
}

#endif /* __DRM_SUPPORT__ */

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static BOOL mmi_da_push_filename_done(U32 criteria, U16* filepath, BOOL canback, BOOL canpopup)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_push_item_struct     *item;
	S32                         result;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_push_filename_done);

    item = (mmi_da_push_item_struct*)criteria;
    
    if(!filepath)
    {
        /* user cancel, free resource */
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        if(!item->exist_job)
            FS_Delete(item->filepath);
#else
        FS_Delete(item->filepath);
#endif
        mmi_da_push_free_item(item);
        return TRUE;
    }

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(item->exist_job)
    {
        /* it means this is a job rename */
        // TODO: add trace
        result = da_module_table[item->exist_job->type]->move(item->exist_job, filepath);
        if(result < 0)
        {
            DisplayPopup((PU8) GetString((U16) GetFileSystemErrorString(result)), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) ERROR_TONE);
            if(!canback)
                mmi_da_push_free_item(item);
            return FALSE;
        }

#ifdef __DRM_V02__
        if(DRM_is_drm_file(0, (kal_wchar*)filepath))
        {
            DRM_register_file((kal_wchar*)filepath);
        }
#endif

        DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, UI_POPUP_NOTIFYDURATION_TIME,
                     (U8) SUCCESS_TONE);

        mmi_da_push_free_item(item);
        return TRUE;
    }
#endif

    /* save it to new filepath*/
    if(mmi_ucs2icmp((S8*)filepath, (S8*)item->filepath) != 0)
    {
        /* Prevent Read Only */
        result = FS_Move(item->filepath, filepath,  FS_MOVE_KILL | FS_MOVE_OVERWRITE, NULL,NULL, 0);
        if (result < 0)
        {
            DisplayPopup((PU8) GetString((U16) GetFileSystemErrorString(result)), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) ERROR_TONE);
            if(!canback)
                mmi_da_push_free_item(item);
            return FALSE;
        }
        UCS2_STR_MALLOC_COPY(item->filepath, filepath);
        DA_FREE_BUFFER(item->filename);
    }

#ifdef __DRM_SUPPORT__
    /* parse DRM type first */
    if(!item->is_normal_save && mmi_da_is_drm_require_processing(item->job.mime_type))
    {
        mmi_da_drm_process_file((mmi_da_job_struct*)item, item->filepath, 
                                mmi_da_push_drm_process_callback);
        return TRUE;
    }
#endif

    /* dispatch it */
    mmi_da_push_dispatch(item);
    return TRUE;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_push_dispatch(mmi_da_push_item_struct *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_setting_struct           *setting;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    setting = &da_context.setting;
    ASSERT(item->job.type_handler->setting_hdlr);
    item->job.type_handler->setting_hdlr(
            0,
            item->job.mime_type ? item->job.mime_type->mime_type: 0,
            item->job.mime_type ? item->job.mime_type->mime_subtype: 0,
            item->action,
            item->file_length,
            item->url,
            item->mime_type_string,
            0, NULL,
            setting);

    if(item->job.type_handler == mmi_da_get_default_mime_type_handler() &&
        mmi_fmgr_get_da_file_option((S8*)item->filepath) <= 0)
    {
        setting->do_dispatch = FALSE;
    }

#ifdef __DRM_V02__
    if(DRM_is_drm_file(0, (kal_wchar*)item->filepath))
    {
        DRM_register_file((kal_wchar*)item->filepath);
    }
#endif

    if( !setting->do_dispatch || 
        !item->job.type_handler->dispatch_hdlr || 
        (setting->confirm_dispatch && mmi_da_is_in_voice_call())
      )
    {
        mmi_da_push_free_item(item);
        DisplayPopup((PU8) GetString(STR_GLOBAL_SAVED), IMG_GLOBAL_ACTIVATED, 1, UI_POPUP_NOTIFYDURATION_TIME,
                     SUCCESS_TONE);
        return;
    }

    if(setting->confirm_dispatch)
    {
        /* entry confirm screen */
        da_context.push_item_curr = item;
        mmi_da_push_entry_dispatch_confirm();
    }
    else if(item->job.type_handler->dispatch_hdlr)
    {
        S32 index;
        mmi_da_hook_dispatch_hdlr hook_hdlr;

        index = 0;
        while(1)
        {
            index = mmi_da_search_hook_handler(item->job.mime_type, index, &hook_hdlr);
            if(index == -1)
                break;
            
            DA_TRACE_FUNC1(mmi_da_call_hook_func_index, index);
            if(hook_hdlr && TRUE == hook_hdlr(DA_PUSH_ID,    // 0 == push's dispatch
                                          item->job.mime_type->mime_type,
                                          item->job.mime_type->mime_subtype,
                                          item->action,
                                          item->filepath,
                                          item->url,
                                          item->mime_type_string))
            {
                // someone return TRUE
                DA_TRACE_FUNC(mmi_da_func_is_hooked);
                return;
            }
        }
        
        /* no confirm, directly dispatch */
        item->job.type_handler->dispatch_hdlr(DA_PUSH_ID,    // 0 == push's dispatch
                                              item->job.mime_type->mime_type,
                                              item->job.mime_type->mime_subtype,
                                              item->action,
                                              item->filepath,
                                              item->url,
                                              item->mime_type_string);
        // remove job
        mmi_da_push_free_item(item);
    }
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_push_free_item(mmi_da_push_item_struct *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_push_item_struct     *prev_item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* remove from list if necessary */
    if(da_context.push_item_curr == item)
        da_context.push_item_curr = NULL;

    if(item == da_context.push_item_list)
    {
        da_context.push_item_list = item->next_item;
        da_context.push_item_num--;
    }
    else
    {
        prev_item = da_context.push_item_list;
        while(prev_item && prev_item->next_item != item)
            prev_item = prev_item->next_item;

        if(prev_item)
        {
            prev_item->next_item = item->next_item;
            da_context.push_item_num--;
        }
    }

    /* free it */
    DA_FREE_BUFFER(item->filepath);
    DA_FREE_BUFFER(item->filename);
    DA_FREE_BUFFER(item->url);
    DA_FREE_BUFFER(item->mime_type_string);
    DA_FREE_BUFFER(item->header);
    DA_FREE_BUFFER(item);

    DA_TRACE_ENDFUNC(mmi_da_push_free_item);
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void _mmi_da_push_cancel_dispatch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearDelScrnIDCallbackHandler(SCR_ID_DA_JOB_CALLBACK_CONFIRM, NULL);
    
    ASSERT(da_context.push_item_curr);
    mmi_da_push_free_item(da_context.push_item_curr);
    
    if(GetActiveScreenId() == SCR_ID_DA_JOB_CALLBACK_CONFIRM)
        GoBackHistory();
    else
        DeleteScreenIfPresent(SCR_ID_DA_JOB_CALLBACK_CONFIRM);
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void _mmi_da_push_dispatch_to_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_push_item_struct     *item;
    S32 index;
    mmi_da_hook_dispatch_hdlr hook_hdlr;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(da_context.push_item_curr);
    item = da_context.push_item_curr;

    if(!mmi_da_util_does_file_exist(item->filepath))
    {
        DisplayPopup((PU8) GetString((U16)FMGR_FS_FILE_NOT_FOUND_TEXT), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                     (U8) ERROR_TONE);
        _mmi_da_push_cancel_dispatch();
        return;
    }

    index = 0;
    while(1)
    {
        index = mmi_da_search_hook_handler(item->job.mime_type, index, &hook_hdlr);
        if(index == -1)
            break;
        
        DA_TRACE_FUNC1(mmi_da_call_hook_func_index, index);
        if(hook_hdlr && TRUE == hook_hdlr(DA_PUSH_ID,    // 0 == push's dispatch
                                      item->job.mime_type->mime_type,
                                      item->job.mime_type->mime_subtype,
                                      item->action,
                                      item->filepath,
                                      item->url,
                                      item->mime_type_string))
        {
            // someone return TRUE
            DA_TRACE_FUNC(mmi_da_func_is_hooked);
            return;
        }
    }
    
    item->job.type_handler->dispatch_hdlr(DA_PUSH_ID,    // 0 == push's dispatch
                                      item->job.mime_type->mime_type,
                                      item->job.mime_type->mime_subtype,
                                      item->action,
                                      item->filepath,
                                      item->url,
                                      item->mime_type_string);
    _mmi_da_push_cancel_dispatch();
}

static U8 _mmi_da_push_dispatch_confirm_delete_callback(void *in_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearDelScrnIDCallbackHandler(SCR_ID_DA_JOB_CALLBACK_CONFIRM, NULL);

    if(da_context.push_item_curr)
    {
        mmi_da_push_free_item(da_context.push_item_curr);    
    }

    return MMI_FALSE;
}

static void mmi_da_push_entry_dispatch_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 icon_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_entry_dispatch_confirm);
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_DA_JOB_CALLBACK_CONFIRM);

    EntryNewScreen(SCR_ID_DA_JOB_CALLBACK_CONFIRM, NULL, mmi_da_push_entry_dispatch_confirm, NULL);

    SetDelScrnIDCallbackHandler(SCR_ID_DA_JOB_CALLBACK_CONFIRM, (HistoryDelCBPtr) _mmi_da_push_dispatch_confirm_delete_callback);

    if(!da_context.push_item_curr)
    {
        StartTimer(MMI_DA_TIMER_3, 1, mmi_da_dispatch_confirm_timer);
        return;
    }

    mmi_ucs2cpy((S8*)subMenuData, (S8*)da_context.push_item_curr->filepath);
    mmi_ucs2cat((S8*)subMenuData, (S8*)get_string(STR_ID_DA_CALLBACK_NOW));

    icon_id = mmi_da_util_get_icon_from_appid(APP_WAP);
    if(da_context.push_item_curr->url && 
        strncmp(da_context.push_item_curr->url, "mms", 3) == 0)
    {
        icon_id = mmi_da_util_get_icon_from_appid(APP_MESSAGES);
    }
    ShowCategory74Screen(STR_ID_DA_JOB_USE,
                     icon_id,
                     STR_GLOBAL_YES, IMG_GLOBAL_YES,
                     STR_GLOBAL_NO, IMG_GLOBAL_NO,
                     (PU8) subMenuData,
                     mmi_ucs2strlen((PS8) subMenuData),
                     guiBuffer);

    SetLeftSoftkeyFunction(_mmi_da_push_dispatch_to_app, KEY_EVENT_UP);
    SetRightSoftkeyFunction(_mmi_da_push_cancel_dispatch, KEY_EVENT_UP);
}


/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_entry_new_push_no(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(da_context.push_item_curr);
    mmi_da_push_free_item(da_context.push_item_curr);
    if(GetActiveScreenId() == SCR_ID_DA_NEW_PUSH_IND)
        GoBackHistory();
    else
        DeleteScreenIfPresent(SCR_ID_DA_NEW_PUSH_IND);
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_entry_new_push_yes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(da_context.push_item_curr);
    mmi_da_push_select_storage(da_context.push_item_curr, NULL);
    if(GetActiveScreenId() == SCR_ID_DA_NEW_PUSH_IND)
        GoBackHistory();
    else
        DeleteScreenIfPresent(SCR_ID_DA_NEW_PUSH_IND);
}

/*****************************************************************************
* FUNCTION
*   mmi_da_entry_new_push_ind
* DESCRIPTION
*   Entry function: Enter the screen to indicate user there is a file need to process
* PARAMETERS
*   Void
* RETURNS
*   Void
*****************************************************************************/
static void mmi_da_entry_new_push(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_push_item_struct     *item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_entry_new_push);

    ASSERT(da_context.push_item_curr);
    item = da_context.push_item_curr;

    EntryNewScreen(SCR_ID_DA_NEW_PUSH_IND, NULL, NULL, NULL);

    if (g_keylock_context.gKeyPadLockFlag == 0)
    {
        ShowCategory154Screen(0, 0,
                              STR_GLOBAL_SAVE, MESSAGES_IMAGE_BASE,
                              STR_GLOBAL_CANCEL, MESSAGES_IMAGE_BASE,
                              (PU8) GetString(STR_ID_DA_NEW_PUSH),
                              (PU8) GetString(mmi_da_search_mime_type_string(item->job.mime_type)),
                              IMG_NEW_MESSAGE_NOTIFICATION_MSG, NULL);
        
        SetLeftSoftkeyFunction(mmi_da_entry_new_push_yes, KEY_EVENT_UP);
        SetRightSoftkeyFunction(mmi_da_entry_new_push_no, KEY_EVENT_UP);
    }
    else
    {
        ShowCategory154Screen(0, 0,
                              g_keylock_context.KeyLockLSKStringID,
                              g_keylock_context.KeyLockLSKIconID,
                              g_keylock_context.KeyLockRSKStringID,
                              g_keylock_context.KeyLockRSKIconID,
                              (PU8) GetString(STR_ID_DA_NEW_PUSH),
                              (PU8) GetString(mmi_da_search_mime_type_string(item->job.mime_type)),
                              IMG_NEW_MESSAGE_NOTIFICATION_MSG, NULL);
        da_context.push_item_curr = NULL;
    }
}


#define GENERAL

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
S32 mmi_da_stop_dl(S32 job_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = da_context.list_job;
    while(job)
    {
        if(DA_JOB_UNIQUE_ID(job) == job_id)
        {
            if(job->state == MMI_DA_JOB_STATE_DOWNLOADING)
            {
                DA_TRACE_FUNC2(mmi_da_stop_dl, job_id, 1);
                da_context.curr_job = job;
                mmi_da_curr_job_abort_hdlr();
                return MMI_DA_SUCCESS;
            }
            break;
        }
        job = job->next_job;
    }
    DA_TRACE_FUNC2(mmi_da_stop_dl, job_id, 0);
    return MMI_DA_ERROR_FAIL;    
}

/*****************************************************************************
* FUNCTION
*   mmi_da_get_header
* DESCRIPTION
*   Get Http header
* PARAMETERS
*   header_len  [OUT]   return the length of header
* RETURNS
*   return a header array to application. AP should invoke this api when their
*   dispatch function invoked. And AP should copy the header to another place,
*   because this array will be free after the callback function finished.
*****************************************************************************/
const S8* mmi_da_get_header(S32 session_id, U32* header_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(session_id == DA_PUSH_ID && da_context.push_item_curr)
    {
        if(header_len)
            *header_len = da_context.push_item_curr->header_len;
        return da_context.push_item_curr->header;
    }

    job = mmi_da_find_job(mmi_da_job_match_id_func, 
        DA_MAKE_UNIQUE_ID_EX(MMI_DA_JOB_TYPE_NORMAL, session_id));

    if(job)
    {
        return mmi_da_http_get_header(job, header_len);
    }
    if(header_len)
        *header_len = 0;
    return NULL;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void mmi_da_enter_idle_screen_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_enter_idle_screen_notify);

    ASSERT(!da_context.setuping_job);

    da_context.in_foreground = FALSE;
    mmi_da_suspend_all_job(); 

    if(da_context.push_item_curr && da_context.push_item_curr->action != MMI_DA_PUSH && da_context.push_item_curr->action != MMI_DA_PUSH_SIM2)
        mmi_da_push_free_item(da_context.push_item_curr);
    da_context.push_item_curr = NULL;
    
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
U8 mmi_da_launch_ring_buffer_check(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    if(da_context.push_item_num)
        return MMI_TRUE;
    
	return MMI_FALSE;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void mmi_da_entry_new_push_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_entry_new_push_ind);

#if 0 // No need to check complete in idle
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    if(da_context.push_item_num)
    {
        ASSERT(da_context.push_item_list);
        ASSERT(!da_context.push_item_curr);
        da_context.push_item_curr = da_context.push_item_list;
        mmi_da_entry_new_push();
    }
    
}

#ifdef __USB_IN_NORMAL_MODE__
/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
void mmi_da_usb_mode_on(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_usb_mode_on);

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(da_context.setuping_job)
    {
        // TODO: cancel it.
        //ASSERT(0);
    }
#endif

    mmi_da_suspend_all_job(); 
}
#endif

#define DRM_PROC

#ifdef __DRM_SUPPORT__

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_drm_process_file_finish(mmi_da_job_struct* job, S32 returnValue)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    mmi_da_setting_struct           *setting_data;
    const applib_mime_type_struct   *mime_type;
    U16                             *ori_filepath;
#endif    
    U8                              *content_type;
    S32                             handle;
    U16                             *new_filepath = NULL;
    BOOL                            is_archive = FALSE;
    U16                             err_string_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC1(mmi_da_drm_process_file_finish, returnValue);
 
    /* reset serial */
    if(job->drm.drm_serial != 0xFF)
    {
        job->drm.drm_serial = 0xFF;
    }
    new_filepath = NULL;

    if(job->state == MMI_DA_JOB_STATE_ABORTING)
    {
        err_string_id = STR_ID_DA_OMA_USER_CANCELLED_MSG;
        goto Finally;
    }

    if( returnValue != DRM_RESULT_OK )
    {
        mmi_drm_show_process_info(returnValue, (applib_mime_type_struct*)job->mime_type);
        goto Finally;
    }

    if( !mmi_da_is_drm_content(job->mime_type))
    {
        mmi_drm_show_process_info(returnValue, (applib_mime_type_struct*)job->mime_type);
        goto Finally;
    }

    /* get new file mime type information */
    handle = DRM_open_file(job->drm.drm_filepath, FS_READ_ONLY, DRM_PERMISSION_NONE);
    if (handle < FS_NO_ERROR)
    {
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_PROCESS_DRM_FILE, handle+10000);
        err_string_id = GetFileSystemErrorString(handle);
        goto Finally;
    }

    job->drm.drm_method = DRM_get_object_method(handle, NULL);
    content_type = (U8 *) DRM_get_content_type(handle, NULL);
#ifdef __DRM_V02__
    is_archive = DRM_is_archive(handle, NULL);
#endif
    DRM_close_file(handle);

    /* update mime_type & type_handler */
    if(is_archive)
    {
        job->type_handler = mmi_da_get_default_mime_type_handler();
    }
    else
    {
        DA_TRACE1(MMI_TRC_DA_MIMETYPE, content_type);
        /* new type */
        job->mime_type = mime_type_look_up((kal_char *) content_type, NULL, 0,0);;
        job->type_handler = mmi_da_search_mime_type_handler(job->mime_type);

        if (mmi_da_is_drm_file(job->mime_type))
        {
            /* we do not support drm + drm + drm ..... now */
            err_string_id = STR_GLOBAL_DRM_INVALID_FORMAT;
            goto Finally;
        }        
    }

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(job->type < MMI_DA_JOB_TYPE_TOTAL)
    {
        /* update setting */
        setting_data = mmi_da_get_setting_buffer();
        da_module_table[job->type]->get_setting(job, setting_data);
        mmi_da_copy_setting(job, setting_data);

        /* retrieve original filepath, and make a final filepath according to new setting */
        ori_filepath = (U16*)OslMalloc((FMGR_MAX_PATH_LEN + 1) * ENCODING_LENGTH);
        DA_JOB_GET_FILEPATH(job, ori_filepath, FMGR_MAX_PATH_LEN);

        mime_type = job->mime_type;
#ifdef __DRM_V02__
        if(job->drm.drm_method == DRM_METHOD_V2)    /* use .odf for drm 2.0 files */
            mime_type = mime_type_look_up( NULL, NULL, MIME_TYPE_APPLICATION, MIME_SUBTYPE_DRM_CONTENT_V2);
#endif    
        new_filepath = mmi_da_util_pathname_replace_ex(ori_filepath, setting_data->folder, NULL, mime_type);
        DA_FREE_BUFFER(ori_filepath);

        /* move drm processed file to new filepath */
        if(mmi_ucs2icmp((S8*)job->drm.drm_filepath, (S8*)new_filepath))
        {
            /* make sure folder exist */
            handle = mmi_da_util_create_file_dir(new_filepath, TRUE);
            if(handle >= 0)
            {
                /* Rename (same drv) */
                handle = FS_Rename(job->drm.drm_filepath, new_filepath);
                if(handle == FS_FILE_EXISTS)
                {
                    mmi_da_util_get_ok_filepath(NULL, &new_filepath);
                    handle = FS_Rename(job->drm.drm_filepath, new_filepath);
                }
            }
            
            if(handle < 0)
            {
                err_string_id = GetFileSystemErrorString(handle);
                goto Finally;
            }
        }

        DA_FREE_BUFFER(job->drm.drm_filepath);
    }
    else
#endif
    {
        /* Push */
        new_filepath = job->drm.drm_filepath;
        job->drm.drm_filepath = NULL;
    }
    
Finally:

    if( GetActiveScreenId() == SCR_ID_DA_DRM_PROCESSING )
    {
	    EntryNewScreen(SCR_ID_DA_DRM_PROCESSING, NULL, NULL, NULL);
    }
    DeleteScreenIfPresent(SCR_ID_DA_DRM_PROCESSING);
    
    /* there is error, remove the file */
    if(job->drm.drm_filepath)
    {
        FS_Delete(job->drm.drm_filepath);
        DA_FREE_BUFFER(job->drm.drm_filepath);
        DA_FREE_BUFFER(new_filepath);
    }

    // For auto-install DRM rights, remove the job whethere success or not.
    if( mmi_da_is_drm_right(job->mime_type) ||
        mmi_da_is_drm_roap(job->mime_type))
    {
        if(err_string_id)
        {
            DisplayPopup((PU8) GetString((U16) err_string_id), IMG_GLOBAL_ERROR, 1, UI_POPUP_NOTIFYDURATION_TIME,
                         (U8) ERROR_TONE);
        }

        job->state = MMI_DA_JOB_STATE_COMPLETED;
        if(job->type == MMI_DA_JOB_TYPE_PUSH)
            mmi_da_push_free_item((mmi_da_push_item_struct*)job);
        else
            _mmi_da_free_job(job);
        return;
    }

    /* call back */
    ASSERT(job->drm.callback);
    if(job->drm.callback)
    {
        /* its user's job to
            -> state = complete
            -> modified to new filepath, delete old file
            -> dispatch 
        */
        ((mmi_da_drm_process_callback_type)job->drm.callback)(job, new_filepath, err_string_id);
    }
    return;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static BOOL mmi_da_drm_match_serial_func(const mmi_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return job->drm.drm_serial == (U8)criteria;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_drm_process_callback(kal_uint8 serial, kal_int32 result,
                                        kal_uint32 offset, kal_uint32 len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC2(mmi_da_drm_process_callback, serial, result);

    /* push special handling */
    if(da_context.push_item_curr && da_context.push_item_curr->job.drm.drm_serial == serial)
    {
        mmi_da_drm_process_file_finish(&(da_context.push_item_curr->job), result);
        return;
    }

    /* find job according to serial */
    job = mmi_da_find_job(mmi_da_drm_match_serial_func, serial);
    if(!job)
        return;

    mmi_da_drm_process_file_finish(job, result);
}

/*****************************************************************************
* FUNCTION
*   mmi_da_entry_process_drm_file
* DESCRIPTION
* PARAMETERS
*   Void
* RETURNS
*   Void
*****************************************************************************/
static void mmi_da_entry_drm_processing(void)
{
    EntryNewScreen(SCR_ID_DA_DRM_PROCESSING, NULL, mmi_da_entry_drm_processing, NULL);
    ShowCategory66Screen(STR_GLOBAL_ACTIVATE, mmi_da_util_get_icon_from_appid(APP_MESSAGES),
                         0, 0, 0, 0, 
                         (U8 *) GetString(STR_GLOBAL_DRM_PROCESSING), 
                         IMG_GLOBAL_PROGRESS, NULL);
}

/*****************************************************************************
* FUNCTION
*   mmi_da_process_drm_file
* DESCRIPTION
*   Process the drm file. Replace correct MIME type in the message
*   Update the context if need.
* PARAMETERS
*   Void
* RETURNS
*   Void
*****************************************************************************/
void mmi_da_drm_process_file(mmi_da_job_struct* job, U16 *filepath,
                             mmi_da_drm_process_callback_type callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    drm_proc_enum   returnValue;
    U16             *path = NULL, *ptr;
    U32             len;
    BOOL            ret = TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_drm_process_file);
    
    /* prevent reentry */
    ASSERT(job->drm.drm_serial == 0xFF);
    ASSERT(job->state == MMI_DA_JOB_STATE_COMPLETED);
    
    ASSERT(callback);
    job->drm.callback = (void*)callback;

#ifdef __DRM_V01__
    if( job->mime_type->mime_subtype == MIME_SUBTYPE_DRM_CONTENT ||
        job->mime_type->mime_subtype == MIME_SUBTYPE_DRM_MESSAGE )
    {
        /* get a temp filename */
        UCS2_STR_MALLOC_COPY(path, filepath);
        ptr = mmi_da_util_get_filename(path);
        ASSERT(ptr != path);
        *ptr = 0;
        len = mmi_ucs2strlen((S8*)path)+FMGR_MAX_FILE_LEN+1;
        job->drm.drm_filepath = OslMalloc(len * ENCODING_LENGTH);

        len--;
        ret = mmi_da_util_get_temp_filename(path, job->drm.drm_filepath, len-1);

        DA_FREE_BUFFER(path);
    }
    else
#endif
    {
        /* no need to get temp filename, use same path */
        UCS2_STR_MALLOC_COPY(job->drm.drm_filepath, filepath);
        len = mmi_ucs2strlen((S8*)filepath);
    }

    if(!ret)
    {
        mmi_da_drm_process_file_finish(job, DRM_RESULT_INVALID);
        return;
    }

    if(job->type == MMI_DA_JOB_TYPE_PUSH && !mmi_da_is_drm_right(job->mime_type))
    {
        mmi_da_entry_drm_processing();
    }

	returnValue = DRM_async_process_file((kal_uint8 *) job->mime_type->mime_string,
                                         (kal_wchar *) filepath,
                                         (kal_wchar *) job->drm.drm_filepath,
                                         len * ENCODING_LENGTH,
                                         (kal_uint8 *) &job->drm.drm_serial,
                                         mmi_da_drm_process_callback);

    if (returnValue == DRM_PROC_ENCRYPT_BUSY || returnValue == DRM_PROC_ENCRYPT_OCCUPIED)
    {
        /* processing */
        job->state = MMI_DA_JOB_STATE_DRM_PROCESSING;

        if(job->type != MMI_DA_JOB_TYPE_PUSH)
            mmi_da_update_job_status(job);
        return;
    }

    /* done */
    mmi_da_drm_process_file_finish(job, returnValue);
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
BOOL mmi_da_drm_process_file_abort(mmi_da_job_struct* job)
{
    DA_TRACE_FUNC(mmi_da_drm_process_file_abort);
    
    ASSERT(job->drm.drm_serial != 0xFF);

    /* FALSE means stopped, TRUE means still canceling */
    if(!DRM_async_cancel_process(job->drm.drm_serial))
        return TRUE;

    /* return TRUE if stopped, FALSE if canceling */
    return FALSE;
}

#endif /* __DRM_SUPPORT */

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_suspended_in_background_callback(mmi_da_job_struct* job, U16 string_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(job->state == MMI_DA_JOB_STATE_ABORTED);

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(job->setting_info.can_minimize)
    {
        job->state = MMI_DA_JOB_STATE_PAUSED;
        mmi_da_update_job_status(job);
    }
    else
#endif        
    {
        _mmi_da_free_job(job);
    }
}

#define BROWSER_ENTRY

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void mmi_da_recv_wap_notify_ind(void *MsgStruct, int mod_src, void *ilm_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_da_wap_notify_ind_struct    *msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(mmi_da_recv_wap_notify_ind);

    msg = (mmi_da_wap_notify_ind_struct*) MsgStruct;

    ASSERT(msg);
    switch(msg->notify)
    {
    case MMI_DA_WAP_NOTIFY_DISPLAY_LIST:
        /* display list */
        mmi_da_display_job_list(NULL, TRUE);
        break;

    case MMI_DA_WAP_NOTIFY_BROWSER_CLOSED:
        /* suspend all job */
        da_context.in_foreground = FALSE;
        ASSERT(!da_context.setuping_job);
        mmi_da_suspend_all_job();
        break;

    default:
        break;
    }
}
#endif

#define DA_TRACE_HELPER

void mmi_da_trace_func(S32 func_enum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_TRC_DA_FUNC, func_enum, 
        da_context.list_job_num, da_context.push_item_num);

#if defined(DA_WIN32_TRACE)
    printf("--- [mmi_da] Func[0x%x], (J=%d,P=%d) ---\n", func_enum, 
        da_context.list_job_num, da_context.push_item_num);
#endif
}

void mmi_da_trace_func_ex(S32 func_enum, S32 p1, S32 p2, S32 p3)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_TRC_DA_FUNC_EX, func_enum, 
        da_context.list_job_num, da_context.push_item_num, p1, p2, p3);

#if defined(DA_WIN32_TRACE)
    printf("--- [mmi_da] Func[0x%x], (J=%d,P=%d), Para:%d,%d,%d ---\n", func_enum, 
        da_context.list_job_num, da_context.push_item_num, p1, p2, p3);
#endif
}

void mmi_da_trace_endfunc(S32 func_enum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_TRC_DA_END_FUNC, func_enum, 
        da_context.list_job_num, da_context.push_item_num);

#if defined(DA_WIN32_TRACE)
    printf("--- [mmi_da] End func[0x%x], (J=%d,P=%d) ---\n", func_enum, 
        da_context.list_job_num, da_context.push_item_num);
#endif
}


#endif /* __MMI_DOWNLOAD_AGENT__ */

