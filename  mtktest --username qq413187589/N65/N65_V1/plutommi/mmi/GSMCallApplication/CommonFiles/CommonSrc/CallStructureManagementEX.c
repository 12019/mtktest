/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*******************************************************************************
 *  Modification Notice:
 *  --------------------------
 *  This software is modified by MediaTek Inc. and the information contained
 *  herein is confidential. The software may not be copied and the information
 *  contained herein may not be used or disclosed except with the written
 *  permission of MediaTek Inc. (C) 2001
 *
 *******************************************************************************/

 /*******************************************************************************
 * Filename:
 * ---------
 *   CallStructureManagement.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *  .......
 *
 * Author:
 * -------
 * -------
 *
 *------------------------------------------------------------------------------
 * $Log$
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * created by clearfsimport
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * created by clearfsimport
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * fix group id problem
 *
 * removed!
 * removed!
 * wrong group id
 *
 * removed!
 * removed!
 * add to source control recursely
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * Don't resume audio when the incoming call is in black list.
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * hide *31#, #31# prefix string
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * check length instead of check first char, in order to handle unicode character which begins with zero.
 *
 * removed!
 * removed!
 * set CallEndedBeforeConnectflag true in call back to avoid asynchronize situation
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * Replace isIdleScreenReached by new API
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 *******************************************************************************/

/**
 * Copyright Notice
 * ?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */

/**************************************************************

   FILENAME : CallStructureManagement.c

   PURPOSE     : Call Structure Management API

   REMARKS     : nil

   AUTHOR      : Ashish

   DATE     : Nov 8,02

**************************************************************/
#include "MMI_include.h"

#ifdef __MMI_UCM__


#include "WrapperGprot.h"
#include "mdi_datatype.h"
#include "mdi_audio.h"
#include "DateTimeGProt.h"
#include "PhoneBookDef.h"
#include "PhoneBookTypes.h"
#include "PhoneBookGProt.h"
#include "IdleAppDef.h"
#include "SettingGprots.h"
#include "SATGProts.h"
#include "ManageCallMain.h"
#include "SimDetectionGProt.h"
#include "ProfileGprots.h"
#include "CSP.h"

#ifdef __CTM_SUPPORT__
#include "TextPhoneDef.h"
#include "TextPhoneProt.h"
#endif /* __CTM_SUPPORT__ */ 
#ifdef __MMI_VOIP__
#include "VoIPGProt.h"
#endif
#include "CallmanagementIdDefEX.h"
#include "CallManagementStructEX.h"
#include "CallStructureManagementProtEX.h"
#include "CallManagementGprotEX.h"
#include "CommonStubsProtEX.h"
#include "RedialHelperGProtEX.h"
#include "PsCallHelperDefEX.h"
#include "PsCallHelperGprotEX.h"
#include "IncomingCallManagementProtEX.h"
#include "OutgoingCallManagementProtEX.h"
#include "OutgoingCallHelperProtEX.h"
#include "CmErrorTypesEX.h"
#include "CmErrorHandlersProt.h"

#include "mmiapi_struct.h"
#include "CallsGProts.h"

#if defined(__MMI_BG_SOUND_EFFECT__)
#include "BGSoundGProt.h"
#endif
#ifdef __MMI_DUAL_SIM_MASTER__
#include "MTPNP_PFAL_CC.h"
#endif /* __MMI_DUAL_SIM_MASTER__ */

#include "UCMGProt.h"
#include "UCMCallProt.h"
#include "UCMResDef.h"

#ifdef __MMI_VIDEO_TELEPHONY__
#include "VTResDef.h"
#include "VTGProt.h"
#include "VTProt.h"
#endif /* __MMI_VIDEO_TELEPHONY__ */

#include "ProtocolEvents.h"


#include "GSM7BitDefaultAlphabet.h"

#include "l4c_common_enum.h" /*for UCM source ID*/

#include "PhoneBookTypes.h"

#include "SoundRecorderProt.h" /* for auto record */

#ifdef __WIFI_SUPPORT__
#include "wndrv_cnst.h"
#include "wndrv_supc_types.h"
#include "wndrv_api.h"
#include "supc_abm_msgs.h"
#endif /* __WIFI_SUPPORT__ */
#include "mmi2abm_struct.h"

#ifdef __MMI_DUAL_SIM_MASTER__
#include "MTPNP_AD_master_header.h"
#include "MTPNP_PFAL_CC_UCM.h"
#include "MTPNP_PFAL_CC.h"
extern mmi_gsm_ucm_act_opcode_enum MTPNP_PFAL_GetUCMOPCodeState(void);
#endif	/* __MMI_DUAL_SIM_MASTER__ */


static cm_context_struct g_CallManagement_cntxt;
cm_context_struct *cm_p = &g_CallManagement_cntxt;

//static CALL_STATE gCurrentState = CM_IDLE_STATE; //to manage the current state
//static CALL_STATE gPrevState = CM_IDLE_STATE; //to manage the previous state
//static CALL_INFO gAllCalls[MAX_CALLS];
//static CALL_INFO gCallStructureForCallLog;

static CM_CALL_HANDLE gCallHandleForStartTimeUpdate;
static MYTIME gTimeStructForEndedCallStartTime;
MYTIME gTimeStructForCallDuration;

static MMI_ANSWERING_MODE gCMAnsMode;
static PHB_CM_INTERFACE gPhoneNumberStruct;
static CHLD_REQ_ACTION gChldReqSent;

//static U16 gNumofActivecalls=0;               //to store the num of active calls.
//static U16 gNumOfHoldCalls=0;         //to store the num of hold calls.
//static U16 gTotalCallCount=0;         //to store the total calls.

static U16 gCallEndCause = 0;
static U32 gCtrTime;
U32 gSumACMValue = 0;

#ifdef __MMI_CM_BLACK_LIST__
static pBOOL gBlackIncomingFlag = FALSE; /* If the incoming call is in black list*/
#endif
static pBOOL gClearKeyFlag = TRUE;
static pBOOL gIsCCCall = TRUE;
static pBOOL gCallAbortRequested = FALSE;   /* To determine whether abort call has been called once */
static pBOOL gDropRequestFlag = FALSE;
static pBOOL gCallAbortReqSentFlag = FALSE;
static pBOOL gCallEndedBeforeConnFlag = FALSE;
static pBOOL gIncomingCallDroppedFlag = FALSE;
static pBOOL gMissedCallFlag = FALSE;
static pBOOL gCallWaitFlag = FALSE;
static pBOOL gCcbsFlag = FALSE;
static pBOOL gCcbsFlagActivated = FALSE;
static pBOOL gWait2RingCallFlag = FALSE;
static pBOOL gNoTwiceRingFlag = FALSE;
static U8 gErrorToneFlag = 0;
static pBOOL gAutoAnswerFlag = FALSE;

CM_CALL_HANDLE gCcbsHandle = -1;
static pBOOL gDropCCBSAnswerMTFlag = FALSE;
U8 gCcbsNumber[MAX_CM_NUMBER];

/* Start by Julia: Drop call refinement */
static pBOOL gAutoReleaseFlag = FALSE;

/* End by Julia */
static pBOOL gCallDeflectFlag = FALSE;
static pBOOL gShowAOC = FALSE;
static pBOOL gDTMFKeyUpFlag = TRUE;
static pBOOL gCMScrnFlag = TRUE;
static pBOOL gGetTimeBeforeActive = FALSE;

static pBOOL gWapCallPresent = FALSE;
static pBOOL gPreviousWapCall = FALSE;

static pBOOL gPriority = FALSE;
static pBOOL gDialedDigitCalledFlag = FALSE;
static pBOOL gSATScrnSavedFlag = FALSE;

static pBOOL gSyncFromAT = FALSE;

#ifdef __IP_NUMBER__
static U16 gTempUseIPNum = 0;
#endif 

extern U16 gtmpOutgoingIndex;
extern U8 isCSPPresent;

extern U8 gRedialMsgTemp;

/* extern U8 isIdleScreenReached; */


/*****************************************************************************
 * FUNCTION
 *  InitCallManagement
 * DESCRIPTION
 *  To Initialize the Call Management Application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitCallManagement(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    InitIncomingCall();
    InitOutGoingCall();
    memset (cm_p, 0, sizeof(cm_context_struct));
    ResetGlobalValues();

#ifdef __CTM_SUPPORT__
    mmi_init_ctm_call();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  ReinitalizeCallManagement
 * DESCRIPTION
 *  To Re-Initialize the Call Management Application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ReinitalizeCallManagement(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cm_p->alert_info.IsCTRStart == TRUE);
    StopTimer(CM_CTR_TIMER);

    ResetGlobalValues();
    ReinitalizeIncomingCall();
    ReinitializeOutgoingCall();
    SetCurrentState(CM_IDLE_STATE);
    SetPreviousState(CM_IDLE_STATE);
}


/*****************************************************************************
 * FUNCTION
 *  ResetGlobalValues
 * DESCRIPTION
 *  This function resets the state of all the internal
 *  call variables. This is to be called at time of exit
 *  from CM application
 * PARAMETERS
 *  void
 *  Index(?)        [OUT]       To the location where the call can be stored
 * RETURNS
 *  Index(?)
 *****************************************************************************/
void ResetGlobalValues(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CALL_INFO temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&cm_p->alert_info, 0, sizeof(cm_alert_struct));
    memset(&cm_p->redial_info, 0, sizeof(cm_redial_struct));

    /* do not reset history info, notify SS might not finish when get out of CM */

    /* keep call info for call log */
    memcpy(&temp, &cm_p->state_info.CallStructureForCallLog, sizeof(CALL_INFO));
    memset(&cm_p->state_info, 0, sizeof(cm_state_struct));
    memcpy(&cm_p->state_info.CallStructureForCallLog, &temp, sizeof(CALL_INFO));

    cm_p->alert_info.DTMF = TRUE;
    cm_p->history_info.IsSave = FALSE;
    //gNumofActivecalls=0;
    //gNumOfHoldCalls=0;
    //gTotalCallCount=0;
    //gCurrentState = CM_IDLE_STATE;
    //gPrevState = CM_IDLE_STATE;
    gSumACMValue = 0;
    InitCallInfo();
    SetShowAOC(FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  DeInitCM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DeInitCM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(mmi_ucm_app_total_call(MMI_UCM_SIM1_CALL_TYPE_ALL) > 0)
    {
        HangupAllCalls();
    }
}


/*****************************************************************************
 * FUNCTION
 *  InitCallInfo
 * DESCRIPTION
 *  Initializes the Call structres array
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitCallInfo(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (index = 0; index < MAX_CALLS; index++)
    {
        memset(&cm_p->state_info.AllCalls[index], 0, sizeof(CALL_INFO));
        cm_p->state_info.AllCalls[index].call_handle = -1;
    }

    cm_p->state_info.NumofActivecalls = 0;
    cm_p->state_info.NumofHeldcalls = 0;
    cm_p->state_info.TotalCallCount = 0;
    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);
}


/*****************************************************************************
 * FUNCTION
 *  ResetCallInfo
 * DESCRIPTION
 *  Helper function to reset a particular call structure
 * PARAMETERS
 *  nCallHandle     [IN]        // Handle for call structure to reset
 *  bIsHandle       [IN]        // If the n/w has supplied a handle
 * RETURNS
 *  void
 *****************************************************************************/
void ResetCallInfo(CM_CALL_HANDLE nCallHandle, pBOOL bIsHandle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bIsHandle)
    {
        index = GetMMIStructIndexof(nCallHandle);
    }
    else
    {
        index = nCallHandle;
    }

    memset(&cm_p->state_info.AllCalls[index], 0, sizeof(CALL_INFO));
    cm_p->state_info.AllCalls[index].call_handle = -1;
}


/*****************************************************************************
 * FUNCTION
 *  PurgeOutgoingCallsStructure
 * DESCRIPTION
 *  Wrapper to reinitialize all outgoing calls structure
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void PurgeOutgoingCallsStructure(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        /* Start by Julia: Drop call refinement - add CM_DISCONNECTING_STATE condition */
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE ||
            (cm_p->state_info.AllCalls[count].prev_state == CM_OUTGOING_STATE &&
             cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE))
            /* End by Julia */
        {
            SetCallState((CM_CALL_HANDLE) count, CM_IDLE_STATE, FALSE);
        }
    }
    /*mmi_gsm_sync_call_list_ind();*/
}


/*****************************************************************************
 * FUNCTION
 *  PurgeIncomingCallStructure
 * DESCRIPTION
 *  Wrapper to reinitialize incoming call structure
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void PurgeIncomingCallStructure(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        /* Start by Julia: Drop call refinement - add CM_DISCONNECTING_STATE condition */
        if (cm_p->state_info.AllCalls[count].curr_state == CM_INCOMING_STATE ||
            (cm_p->state_info.AllCalls[count].prev_state == CM_INCOMING_STATE &&
             cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE))
            /* End by Julia */
        {
            SetCallState((CM_CALL_HANDLE) count, CM_IDLE_STATE, FALSE);
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  PurgeAllCalls
 * DESCRIPTION
 *  Wrapper to reinitialize all non Idle calls structure
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void PurgeAllCalls(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* search all non-idle calls and reset them */
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state != CM_IDLE_STATE)
        {
            SetCallState((CM_CALL_HANDLE) count, CM_IDLE_STATE, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetIncomingCallStateActive
 * DESCRIPTION
 *  Function sets the state of incoming call to active
 * PARAMETERS
 *  void
 *  MYTIME(?)       [IN]        *time time strucutre to initialize
 * RETURNS
 *  void
 *****************************************************************************/
void SetIncomingCallStateActive(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        /* handle race condition:  
           when user answer incoming call and drop call very fast, it's possible that the answer 
           response comes later than the drop request and the call state will become 
           disconnecting, not incoming */
        if (cm_p->state_info.AllCalls[count].curr_state == CM_INCOMING_STATE ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE &&
             cm_p->state_info.AllCalls[count].prev_state == CM_INCOMING_STATE))
        {
            SetCallState((CM_CALL_HANDLE) cm_p->state_info.AllCalls[count].call_handle, CM_ACTIVE_STATE, TRUE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  AddNewCallInfo
 * DESCRIPTION
 *  Each New Incoming or outging call is stored
 *  In the calls array with this function
 * PARAMETERS
 *  Number                  [IN]        Of the call
 *  currentstate            [IN]        Current state of call wether incoming/outgoing
 *  prevstate               [IN]        Previous state of the call
 *  MOflag                  [IN]        Whether call is coming or outgoing
 *  currentCallHandle       [IN]        Call handle of the call
 *  callType                [IN]        
 *  pBname(?)               [IN]        Name of the caller
 * RETURNS
 *  void
 *****************************************************************************/
void AddNewCallInfo(
        PU8 Number,
        CALL_STATE currentstate,
        CALL_STATE prevstate,
        CALL_DIR MOflag,
        CM_CALL_HANDLE currentCallHandle,
        U8 callType)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;
    PHB_CM_INTERFACE phb_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = GetFirstFreeIndex();
    PRINT_INFORMATION("*** AddNewCallInfo index=%d\n", index);

    memset(&gPhoneNumberStruct, 0, sizeof(gPhoneNumberStruct));
    memset(&cm_p->state_info.AllCalls[index], 0, sizeof(CALL_INFO));
    gPhoneNumberStruct.pictureId = IMG_PHB_DEFAULT;

    SetPreviousCallWAP(FALSE);

    cm_p->state_info.AllCalls[index].call_handle = currentCallHandle;
 
    if(GetCurrentState() == CM_INCOMING_STATE)
    {
    cm_p->state_info.AllCalls[index].group_id = GetUnUsedGroupID(); 
    }
    else
    {
        /*outgoing call, before get DIAL_IND*/
        cm_p->state_info.AllCalls[index].group_id = MMI_UCM_INVALID_ID; 
    }
    
    cm_p->state_info.AllCalls[index].curr_state = currentstate;
    cm_p->state_info.AllCalls[index].prev_state = prevstate;
    cm_p->state_info.AllCalls[index].status_flag = 0;
    cm_p->state_info.AllCalls[index].orgination_flag = MOflag;
    cm_p->state_info.AllCalls[index].call_type = callType;

#ifdef __MMI_CH_QUICK_END__
    /* init quick end time */
    cm_p->alert_info.QuickEndTime = CHISTGetQuickEndTime();
#endif /* __MMI_CH_QUICK_END__ */ 

    if (Number[0] != '\0')
    {
        /* number existed, search phonebook if necessary */
        mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].number, (PS8) Number);
        mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].num, (PS8) Number);

        if (CM_CALL_MT == MOflag)
        {
            /* MO call needs to wait till dial_ind to search phonebook for name
               because number might be changed by SAT */
            PRINT_INFORMATION("GSM Call Application: AddNewCallInfo, MT call");
        #ifdef __MMI_DUAL_SIM_MASTER__
            phb_data = mmi_phb_call_get_data_for_call_mgnt(Number, FALSE, SIM1);
        #else /* __MMI_DUAL_SIM_MASTER__ */
            phb_data = mmi_phb_call_get_data_for_call_mgnt(Number, FALSE);
        #endif /* __MMI_DUAL_SIM_MASTER__ */
            mmi_ucs2cpy((PS8)phb_data.number, (PS8)Number);
            SetCMPhoneBookStruct(&phb_data);
            cm_p->state_info.AllCalls[index].name_dcs = gPhoneNumberStruct.name_dcs;
            mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].pBname, (PS8) gPhoneNumberStruct.name);
            if (!(gPhoneNumberStruct.number[0] == 0 && gPhoneNumberStruct.number[1] == 0))
            {
                mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].number, (PS8) gPhoneNumberStruct.number);
            }

            if (MOflag == CM_CALL_MT)
            {
                CMSetupAlertForMT();
            }
        #ifdef __MMI_INCOMING_CALL_VIDEO__
            /* waiting call and ccbs invoke can't use video for display, for UCM version, let UCM decide*/
            /*if (GetTotalCallCount() > 0 || GetCCBSFlag() == TRUE)
            {
                gPhoneNumberStruct.videoId = 0;
            }*/
        #endif /* __MMI_INCOMING_CALL_VIDEO__ */ 

        #ifdef __MMI_CM_BLACK_LIST__
            if (IsBlackListNum(Number) == TRUE)
            {
                cm_p->state_info.AllCalls[index].block_flag = TRUE;
            }
            else
            {
                cm_p->state_info.AllCalls[index].block_flag = FALSE;
            }
        #endif /* __MMI_CM_BLACK_LIST__ */ 
            /* memcpy((PS8)cm_p->state_info.AllCalls[index].pbNumber,(PS8)gPhoneNumberStruct.number,sizeof(cm_p->state_info.AllCalls[index].pbNumber)); */
        }
    #ifdef __SAT__
        else if (MOflag == CM_CALL_MO_STK)
        {
            PS8 tmpName;
            U8 dcs;

            PRINT_INFORMATION("GSM Call Application: AddNewCallInfo, MO STK call");

            tmpName = (PS8) SATGetCallDisplay(&dcs);
            if (tmpName != NULL)
            {
                cm_p->state_info.AllCalls[index].name_dcs = dcs;
                mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].pBname, tmpName);
            }
            else
            {
                /* if SAT didn't provide name, search phonebook name for SAT call */
            #ifdef __MMI_DUAL_SIM_MASTER__
                phb_data = mmi_phb_call_get_data_for_call_mgnt(Number, FALSE, SIM1);
            #else /* __MMI_DUAL_SIM_MASTER__ */
                phb_data = mmi_phb_call_get_data_for_call_mgnt(Number, FALSE);
            #endif /* __MMI_DUAL_SIM_MASTER__ */
                SetCMPhoneBookStruct(&phb_data);
                cm_p->state_info.AllCalls[index].name_dcs = gPhoneNumberStruct.name_dcs;
                mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].pBname, (PS8) gPhoneNumberStruct.name);
                if (!(gPhoneNumberStruct.number[0] == 0 && gPhoneNumberStruct.number[1] == 0))
                {
                    mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].number, (PS8) gPhoneNumberStruct.number);
                }
            }
        }
    #endif /* __SAT__ */
        else if (CHISTGetDialFromCallLogFlag() != 0)
        {
            LOG_CALL hilite_item;

            PRINT_INFORMATION("GSM Call Application: AddNewCallInfo, MO call from call log");

            /* dial from call log should directly use name in call log,
               no need to search phonebook */
            CHISTGetCallLogName(&hilite_item);
        #ifdef __MMI_DUAL_SIM_MASTER__
            cm_p->redial_info.DialFromCallLog = CHISTGetDialFromCallLogFlag(); /*auto redial from SIM1 or SIM2*/
            PRINT_INFORMATION("GSM Call Application: AddNewCallInfo, MO call from call log:%d",cm_p->redial_info.DialFromCallLog);
        #endif /* __MMI_DUAL_SIM_MASTER__*/
            cm_p->state_info.AllCalls[index].name_dcs = hilite_item.nameDCS;
            mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].pBname, (PS8) hilite_item.pbName);
            PRINT_INFORMATION("GSM Call Application: AddNewCallInfo, MO call from call log:%s",cm_p->state_info.AllCalls[index].pBname);
            /* memcpy((PS8)cm_p->state_info.AllCalls[index].pbNumber,(PS8)cm_p->state_info.AllCalls[index].number,sizeof(cm_p->state_info.AllCalls[index].pbNumber)); */
        }
    }
    else
    {
        mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].pBname, (PS8) GetString(STR_UNKNOWN_CALLER));
        cm_p->state_info.AllCalls[index].name_dcs = MMI_PHB_UCS2;
    }

    cm_p->state_info.TotalCallCount++;
    //mmi_frm_kbd_set_tone_state(MMI_KEY_VOL_TONE_DISABLED);

}


/*****************************************************************************
 * FUNCTION
 *  SetCallState
 * DESCRIPTION
 *  Sets the call state of a particular call
 *  
 *  This function updates all those variables which are
 *  required for managing the calls like number of hold calls
 *  number of active calls etc.
 * PARAMETERS
 *  nCallHandle     [IN]        // Handle for call structure for which flag is to be set
 *  state           [IN]        // State to set
 *  bIsHandle       [IN]        // If the n/w has supplied a handle
 * RETURNS
 *  void
 *****************************************************************************/
void SetCallState(CM_CALL_HANDLE nCallHandle, CALL_STATE state, pBOOL bIsHandle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bIsHandle)
    {
        index = GetMMIStructIndexof(nCallHandle);
    }
    else
    {
        index = nCallHandle;
    }
    /* Start by Julia: Drop call refinement */
    if (cm_p->state_info.AllCalls[index].curr_state != CM_DISCONNECTING_STATE)
        /* End by Julia */
    {
        cm_p->state_info.AllCalls[index].prev_state = cm_p->state_info.AllCalls[index].curr_state;
    }
    cm_p->state_info.AllCalls[index].curr_state = state;

    MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_SetCallState, state, cm_p->state_info.AllCalls[index].call_handle);

    if (cm_p->state_info.AllCalls[index].curr_state == CM_ACTIVE_STATE)
    {
        /* one call becomes active: incoming, outoing, hold -> active */
        cm_p->state_info.NumofActivecalls++;
        if (cm_p->state_info.AllCalls[index].prev_state == CM_HOLD_STATE)
        {
            cm_p->state_info.NumofHeldcalls--;
        }
    }

    if (cm_p->state_info.AllCalls[index].curr_state == CM_HOLD_STATE)
    {
        /* one call becomes hold: active -> hold */
        cm_p->state_info.NumofHeldcalls++;
        if (cm_p->state_info.AllCalls[index].prev_state == CM_ACTIVE_STATE)
        {
            cm_p->state_info.NumofActivecalls--;
        }
    }

    if (cm_p->state_info.AllCalls[index].curr_state == CM_IDLE_STATE)
    {
        if (cm_p->state_info.AllCalls[index].prev_state == CM_ACTIVE_STATE)
        {
            /* one active call ends */
            cm_p->state_info.NumofActivecalls--;
        }
        if (cm_p->state_info.AllCalls[index].prev_state == CM_HOLD_STATE)
        {
            /* one hold call ends */
            cm_p->state_info.NumofHeldcalls--;
        }

        if (cm_p->state_info.AllCalls[index].prev_state == CM_OUTGOING_STATE)
        {
            if (GetTotalCallCount() > 1)
            {
                SyncCallList();
            }
            SetSpeechFlag(FALSE);
            /* one outgoing call ends */
            SetCallEndedBeforeConnFlag(TRUE);
            /* where to log call? */
        }
        if (cm_p->state_info.AllCalls[index].prev_state == CM_INCOMING_STATE)
        {
            if (GetTotalCallCount() > 1)
            {
                SyncCallList();
            }
        }
        /* incoming call exist after call end => it was a waiting call */
        if (GetIncomingCallHandle() != -1 && 
        	cm_p->state_info.AllCalls[index].prev_state != CM_OUTGOING_STATE)
        {
            SetCallWaitFlag(TRUE);
        }

        ResetCallInfo(index, FALSE);
        cm_p->state_info.TotalCallCount--;
    }

}

/* Start by Julia: Drop call refinement */


/*****************************************************************************
 * FUNCTION
 *  SetAllCallState
 * DESCRIPTION
 *  Sets the call state of all calls
 *  
 *  It is for drop call refinement
 * PARAMETERS
 *  state       [IN]        // State to set
 * RETURNS
 *  void
 *****************************************************************************/
void SetAllCallState(CALL_STATE state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_INCOMING_STATE))
        {
            cm_p->state_info.AllCalls[count].prev_state = cm_p->state_info.AllCalls[count].curr_state;
            cm_p->state_info.AllCalls[count].curr_state = state;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetAllExceptWaitingCallState
 * DESCRIPTION
 *  Sets the call state of all calls
 *  
 *  It is for drop call refinement
 * PARAMETERS
 *  state       [IN]        // State to set
 * RETURNS
 *  void
 *****************************************************************************/
void SetAllExceptWaitingCallState(CALL_STATE state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE))
        {
            cm_p->state_info.AllCalls[count].prev_state = cm_p->state_info.AllCalls[count].curr_state;
            cm_p->state_info.AllCalls[count].curr_state = state;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetAllActiveCallState
 * DESCRIPTION
 *  Sets the call state of all active calls
 *  
 *  It is for drop call refinement
 * PARAMETERS
 *  state       [IN]        // State to set
 * RETURNS
 *  void
 *****************************************************************************/
void SetAllActiveCallState(CALL_STATE state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            cm_p->state_info.AllCalls[count].prev_state = CM_ACTIVE_STATE;
            cm_p->state_info.AllCalls[count].curr_state = state;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetAllHeldCallState
 * DESCRIPTION
 *  Sets the call state of all held calls
 *  
 *  It is for drop call refinement
 * PARAMETERS
 *  state       [IN]        // State to set
 * RETURNS
 *  void
 *****************************************************************************/
void SetAllHeldCallState(CALL_STATE state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE)
        {
            cm_p->state_info.AllCalls[count].prev_state = CM_HOLD_STATE;
            cm_p->state_info.AllCalls[count].curr_state = state;
        }
    }
}

/* End by Julia */


/*****************************************************************************
 * FUNCTION
 *  GetCallState
 * DESCRIPTION
 *  Gets state for a particular call handle
 * PARAMETERS
 *  handle          [IN]        
 *  state(?)        [OUT]       Of call
 * RETURNS
 *  CM_CALL_STATE
 *****************************************************************************/
CALL_STATE GetCallState(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].call_handle == handle)
        {
            return cm_p->state_info.AllCalls[count].curr_state;
        }
    }
    return CM_STATE_UNKNOWN;
}

/*****************************************************************************
 * FUNCTION
 *  RestoreCallState
 * DESCRIPTION
 *  Gets state for a particular call handle
 * PARAMETERS
 *  handle          [IN]        
 *  state(?)        [OUT]       Of call
 * RETURNS
 *  CM_CALL_STATE
 *****************************************************************************/
void RestoreCallState(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE)
        {
            cm_p->state_info.AllCalls[count].curr_state = cm_p->state_info.AllCalls[count].prev_state;
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  SyncCallList
 * DESCRIPTION
 *  Syncs Call List with L4
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SyncCallList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MakePsGetCallList((void*)PsCbackSyncCallList);
}


/*****************************************************************************
 * FUNCTION
 *  PsCbackSyncCallList
 * DESCRIPTION
 *  Call back Called after Call List synced
 * PARAMETERS
 *  MsgStruct       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void PsCbackSyncCallList(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_CALL_LIST_RSP *callRsp;
    MMI_CALL_LIST *callList;
    U8 count;
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    callRsp = (MMI_CALL_LIST_RSP*) MsgStruct;

    if (callRsp->result == KAL_TRUE)
    {
        callList = (MMI_CALL_LIST*) & callRsp->call_list;

        for (count = 0; (count < callList->length) && (callList->list[count].call_id != 0); count++)
        {
            index = GetMMIStructIndexof(callList->list[count].call_id);

            if (index != -1)
            {
                switch (callList->list[count].call_state)
                {
                    case CLCC_CALL_ACTIVE:
                    {
                        if (GetSyncCallFromATFlag() == TRUE &&
                            cm_p->state_info.AllCalls[index].curr_state == CM_INCOMING_STATE)
                        {
                            SetCallHandleForStartTimeUpdate(GetIncomingCallHandle());
                        }
                        cm_p->state_info.AllCalls[index].curr_state = CM_ACTIVE_STATE;
                        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_CallListActive);
                        break;
                    }
                    case CLCC_CALL_HELD:
                    {
                        cm_p->state_info.AllCalls[index].curr_state = CM_HOLD_STATE;
                        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_CallListHeld);
                        break;
                    }
                    case CLCC_CALL_DIALING:
                    {
                        cm_p->state_info.AllCalls[index].curr_state = CM_OUTGOING_STATE;
                        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_CallListOutgoing);
                        break;
                    }
                    case CLCC_CALL_ALERTING:
                    {
                        cm_p->state_info.AllCalls[index].curr_state = CM_OUTGOING_STATE;
                        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_CallListOutgoing);
                        break;
                    }
                    case CLCC_CALL_INCOMING:
                    {
                        cm_p->state_info.AllCalls[index].curr_state = CM_INCOMING_STATE;
                        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_CallListIncoming);
                        break;
                    }
                    case CLCC_CALL_WAITING:
                    {
                        cm_p->state_info.AllCalls[index].curr_state = CM_INCOMING_STATE;
                        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_CallListIncoming);
                        break;
                    }
                }   /* End of Switch */

            }   /* End of if */
            else
            {
                MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_ERROR_CallList);
                SetSyncCallFromATFlag(FALSE);
                return;
            }
        }   /* End of for */

        if ((0 == (callList->length))&&(GetCCBSFlag()==FALSE)) /*Mick: CCBS should remain there*/
        {
            PurgeAllCalls();
            MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_CallListEmpty);
        }
    }   /* End of if */
    else
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_ERROR_CallListFail);
        SetSyncCallFromATFlag(FALSE);
        return;
    }

    UpdateStateMachine();

    if(cm_p->ucm_operation == MMI_GSM_UCM_HOLD_AND_ACCEPT &&
        cm_p->ucm_action_type == MMI_GSM_UCM_NORMAL)
    {
        mmi_gsm_hold_and_accept_rsp(TRUE, NULL);
        return;
    }
    else if(cm_p->ucm_operation == MMI_GSM_UCM_HOLD &&
        cm_p->ucm_action_type == MMI_GSM_UCM_NORMAL)
    {
        mmi_gsm_hold_rsp(TRUE, NULL);
        return;
    }

    mmi_gsm_sync_call_list_ind();
}


/*****************************************************************************
 * FUNCTION
 *  UpdateStateMachine
 * DESCRIPTION
 *  Updates State Machine of CM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void UpdateStateMachine(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 NumofActivecalls = 0;
    U16 NumOfHoldCalls = 0;
    U16 TotalCallCount = 0;
    U16 count;
    U8 OutgoingFlag = 0;
    U8 IncomingFlag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_FUNC_UpdateStateMachine);

    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].call_handle == -1)
        {
            continue;
        }
        switch (cm_p->state_info.AllCalls[count].curr_state)
        {
            case CM_OUTGOING_STATE:
            {
                OutgoingFlag = 1;
                TotalCallCount++;
                break;
            }
            case CM_INCOMING_STATE:
            {
                IncomingFlag = 1;
                TotalCallCount++;
                break;
            }
            case CM_ACTIVE_STATE:
            {
                NumofActivecalls++;
                TotalCallCount++;
                break;
            }
            case CM_HOLD_STATE:
            {
                NumOfHoldCalls++;
                TotalCallCount++;
                break;
            }
        }

    }
    cm_p->state_info.NumofActivecalls = (U8) NumofActivecalls;
    cm_p->state_info.NumofHeldcalls = (U8) NumOfHoldCalls;
    cm_p->state_info.TotalCallCount = (U8) TotalCallCount;
    if (OutgoingFlag)
    {
        if (GetCurrentState() != CM_OUTGOING_STATE)
        {
            SetPreviousState(GetCurrentState());
            SetCurrentState(CM_OUTGOING_STATE);
        }
        return;
    }
    if (IncomingFlag)
    {
        if (GetCurrentState() != CM_INCOMING_STATE)
        {
            SetPreviousState(GetCurrentState());
            SetCurrentState(CM_INCOMING_STATE);
        }
        return;
    }
    if ((cm_p->state_info.NumofHeldcalls == cm_p->state_info.TotalCallCount) && (cm_p->state_info.TotalCallCount != 0))
    {
        if (GetCurrentState() != CM_HOLD_STATE)
        {
            SetPreviousState(GetCurrentState());
            SetCurrentState(CM_HOLD_STATE);
        }
        return;
    }
    if (cm_p->state_info.NumofActivecalls > 0)
    {
        if (GetCurrentState() != CM_ACTIVE_STATE)
        {
            SetPreviousState(GetCurrentState());
            SetCurrentState(CM_ACTIVE_STATE);
        }
        return;
    }
    if (TotalCallCount == 0)
    {
        SetPreviousState(GetCurrentState());
        SetCurrentState(CM_IDLE_STATE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetHoldFlag
 * DESCRIPTION
 *  This function is a wrapper to set state of the hold requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetHoldFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            SetCallflag(count, CM_HOLD_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  ResetHoldFlag
 * DESCRIPTION
 *  This function is a wrapper to set state of the hold requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ResetHoldFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            ResetCallflag(count, CM_HOLD_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetRetrieveFlag
 * DESCRIPTION
 *  This function is a wrapper to set retrieve requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetRetrieveFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE)
        {
            SetCallflag(count, CM_RETRIEVE_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  ResetRetrieveFlag
 * DESCRIPTION
 *  This function is a wrapper to set retrieve requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ResetRetrieveFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE)
        {
            ResetCallflag(count, CM_RETRIEVE_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetAllCallFlags
 * DESCRIPTION
 *  This function is a wrapper to set swap requested
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 GetAllCallFlags(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count, flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].call_handle != -1)
        {
            flag |= cm_p->state_info.AllCalls[count].status_flag;
        }
    }
    PRINT_INFORMATION("GetAllCallFlags: %d\n", flag);
    return flag;
}


/*****************************************************************************
 * FUNCTION
 *  SetSwapFlag
 * DESCRIPTION
 *  This function is a wrapper to set swap requested
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetSwapFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE))
        {
            SetCallflag(count, CM_SWAP_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  ResetSwapFlag
 * DESCRIPTION
 *  This function is a wrapper to set swap requested
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ResetSwapFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE))
        {
            ResetCallflag(count, CM_SWAP_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetConfFlag
 * DESCRIPTION
 *  This function is a wrapper to set conference requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetConfFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE))
        {
            SetCallflag(count, CM_CONF_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  ResetConfFlag
 * DESCRIPTION
 *  This function is a wrapper to set conference requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ResetConfFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE))
        {
            ResetCallflag(count, CM_CONF_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  ResetSplitFlag
 * DESCRIPTION
 *  This function is a wrapper to set split requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ResetSplitFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].status_flag & CM_SPLIT_REQUESTED) != 0)
        {
            ResetCallflag(count, CM_SPLIT_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  ResetEctFlag
 * DESCRIPTION
 *  This function is a wrapper to set split requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ResetEctFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].status_flag & CM_ECT_REQUESTED) != 0)
        {
            ResetCallflag(count, CM_ECT_REQUESTED, FALSE);
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  SetAllHangupFlag
 * DESCRIPTION
 *  This function is a wrapper to set hangup all requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetAllHangupFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* release all except waiting */
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE) ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE))
        {
            SetCallflag(count, CM_HANGUP_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetAllCallsHangupFlag
 * DESCRIPTION
 *  This function is a wrapper to set hangup all requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetAllCallsHangupFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* hang up all including waiting or incoming calls */
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state != CM_IDLE_STATE)
        {
            SetCallflag(count, CM_HANGUP_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetAllActHangupFlag
 * DESCRIPTION
 *  This function is a wrapper to set hangup request for all active call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetAllActHangupFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            SetCallflag(count, CM_HANGUP_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetAllHldHangupFlag
 * DESCRIPTION
 *  This function is a wrapper to set hangup request for all held calls
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetAllHldHangupFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE)
        {
            SetCallflag(count, CM_HANGUP_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  ResetAllHangupFlag
 * DESCRIPTION
 *  This function is a wrapper to set hangup all requested flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ResetAllHangupFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].status_flag & CM_HANGUP_REQUESTED) != 0)
        {
            ResetCallflag(count, CM_HANGUP_REQUESTED, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  CheckAllCallflag
 * DESCRIPTION
 *  This function is a wrapper to check all call flags
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL CheckAllCallflag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;
    U8 flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    flag = CM_HOLD_REQUESTED | CM_RETRIEVE_REQUESTED | CM_SPLIT_REQUESTED;

    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].status_flag & flag) != 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  GetChldReqSent
 * DESCRIPTION
 *  Helper function to get the
 *  action for which CHLD req was sent
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
CHLD_REQ_ACTION GetChldReqSent(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gChldReqSent;
}


/*****************************************************************************
 * FUNCTION
 *  SetChldReqSent
 * DESCRIPTION
 *  Helper function to set the action for which
 *  CHLD req has been sent
 * PARAMETERS
 *  action      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetChldReqSent(CHLD_REQ_ACTION action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("SetChldReqSent: %d\n", action);
    gChldReqSent = action;
}


/*****************************************************************************
 * FUNCTION
 *  MakeHold
 * DESCRIPTION
 *  This function is a wrapper to hold all active calls
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void MakeHold(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count, totalHeld = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_FUNC_MakeHold);
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            ResetCallflag(count, CM_HOLD_REQUESTED, FALSE);
            SetCallState(count, CM_HOLD_STATE, FALSE);
            totalHeld++;
        }
    }

    if (totalHeld > 0 && GetTotalCallCount() == totalHeld)
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_MakeHoldSet);
        SetPreviousState(GetCurrentState());
        SetCurrentState(CM_HOLD_STATE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  MakeRetrieve
 * DESCRIPTION
 *  This function is a wrapper to retrieve all held calls
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void MakeRetrieve(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count, totalActive = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_FUNC_MakeRetrieve);
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE)
        {
            ResetCallflag(count, CM_RETRIEVE_REQUESTED, FALSE);
            SetCallState(count, CM_ACTIVE_STATE, FALSE);
        }
    }

    if (totalActive > 0 && GetTotalCallCount() == totalActive)
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_MakeRetrieveSet);
        SetPreviousState(GetCurrentState());
        SetCurrentState(CM_ACTIVE_STATE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  MakeSwap
 * DESCRIPTION
 *  This function is a wrapper to swap  all held and active calls
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void MakeSwap(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count, totalHeld = 0, totalActive = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_FUNC_MakeSwap);
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].status_flag & CM_SWAP_REQUESTED)
        {
            if (cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE)
            {
                ResetCallflag(count, CM_SWAP_REQUESTED, FALSE);
                SetCallState(count, CM_ACTIVE_STATE, FALSE);
                totalActive++;
            }
            else if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
            {
                ResetCallflag(count, CM_SWAP_REQUESTED, FALSE);
                SetCallState(count, CM_HOLD_STATE, FALSE);
                totalHeld++;
            }
        }
    }
    if (totalHeld > 0 && GetTotalCallCount() == totalHeld)
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_MakeSwapSetHeld);
        SetPreviousState(GetCurrentState());
        SetCurrentState(CM_HOLD_STATE);
    }
    else if (totalActive > 0 && GetTotalCallCount() == totalActive)
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_MakeSwapSetActive);
        SetPreviousState(GetCurrentState());
        SetCurrentState(CM_ACTIVE_STATE);
    }
    else if (GetCurrentState() == CM_INCOMING_STATE)
    {
        if (totalActive == 0 && totalHeld > 0)
        {
            SetPreviousState(CM_HOLD_STATE);
        }
        else if (totalHeld == 0 && totalActive > 0)
        {
            SetPreviousState(CM_ACTIVE_STATE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  MakeConf
 * DESCRIPTION
 *  This function is a wrapper to conference all held and active calls
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void MakeConf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_FUNC_MakeConf);
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].status_flag & CM_CONF_REQUESTED)
        {
            ResetCallflag(count, CM_CONF_REQUESTED, FALSE);
            if (cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE)
            {
                /* conference makes held -> active, active remains active */
                SetCallState(count, CM_ACTIVE_STATE, FALSE);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  MakeAllActHangup
 * DESCRIPTION
 *  This function is a wrapper to hangup all active calls
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void MakeAllActHangup(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].status_flag & CM_HANGUP_REQUESTED)
        {
            ResetCallflag(count, CM_HANGUP_REQUESTED, FALSE);
            SetCallState(count, CM_IDLE_STATE, FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  MakeSplitSucess
 * DESCRIPTION
 *  This function is a wrapper to split conference call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void MakeSplitSucess(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* only active mpty can be split */
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            if (cm_p->state_info.AllCalls[count].status_flag & CM_SPLIT_REQUESTED)
            {
                ResetCallflag(count, CM_SPLIT_REQUESTED, FALSE);
            }
            else
            {
                SetCallState(count, CM_HOLD_STATE, FALSE);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  AllowMoreCalls
 * DESCRIPTION
 *  Function to decide if more incoming calls can be made
 * PARAMETERS
 *  void
 *  Call(?)     [OUT]       Handle
 *  U16(?)      [IN]        Idx index to the active call
 * RETURNS
 *  CM_CALL_HANDLE
 *****************************************************************************/
pBOOL AllowMoreCalls(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp = cm_p->state_info.TotalCallCount;
    if (GetCurrentState() == CM_INCOMING_STATE)
    {
        /* incoming call won't affect max call count */
        temp--;
    }
    if (temp >= MAX_CALLS - 1)
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_AllowMoreCalls1);
        return FALSE;
    }
    else if (EmergencyCallPresent())
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_AllowMoreCalls2);
        return FALSE;
    }
    else if (GetCallAbortReqSentFlag())
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_AllowMoreCalls3);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrentState
 * DESCRIPTION
 *  Helper function to get current state
 * PARAMETERS
 *  void
 *  current(?)      [OUT]       State
 * RETURNS
 *  CALL_STATE
 *****************************************************************************/
CALL_STATE GetCurrentState(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return cm_p->state_info.CurrentState;
}


/*****************************************************************************
 * FUNCTION
 *  GetPreviousState
 * DESCRIPTION
 *  Helper function to get previous state
 * PARAMETERS
 *  void
 *  current(?)      [OUT]       State
 * RETURNS
 *  CALL_STATE
 *****************************************************************************/
CALL_STATE GetPreviousState(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return cm_p->state_info.PrevState;
}


/*****************************************************************************
 * FUNCTION
 *  SetCurrentState
 * DESCRIPTION
 *  Helper function to set current state
 * PARAMETERS
 *  state       [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void SetCurrentState(CALL_STATE state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_SetCurrentState, state);
    cm_p->state_info.CurrentState = state;
}


/*****************************************************************************
 * FUNCTION
 *  SetPreviousState
 * DESCRIPTION
 *  Helper function to set previous state
 * PARAMETERS
 *  state       [IN]        // state to set as previous
 * RETURNS
 *  void
 *****************************************************************************/
void SetPreviousState(CALL_STATE state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_SetPreviousState, state);
    cm_p->state_info.PrevState = state;
}

/*****************************************************************************
 * FUNCTION
 *  GetTotalCallCount
 * DESCRIPTION
 *  Helper function to get total call count
 *  
 *  inclusive of incoming, outgoing, active and hold
 * PARAMETERS
 *  void
 *  total(?)        [OUT]       Call count
 * RETURNS
 *  U16
 *****************************************************************************/
U16 GetTotalCallCount(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return cm_p->state_info.TotalCallCount;
}

/*****************************************************************************
 * FUNCTION
 *  GetTotalActiveCallCount
 * DESCRIPTION
 *  Helper function to get total active call count
 * PARAMETERS
 *  void
 *  total(?)        [OUT]       Active call count
 * RETURNS
 *  U16
 *****************************************************************************/
S16 GetTotalActiveCallCount(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return cm_p->state_info.NumofActivecalls;
}


/*****************************************************************************
 * FUNCTION
 *  GetTotalHoldCallCount
 * DESCRIPTION
 *  Helper function to get total hold call count
 * PARAMETERS
 *  void
 *  total(?)        [OUT]       Hold call count
 * RETURNS
 *  U16
 *****************************************************************************/
U16 GetTotalHoldCallCount(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return cm_p->state_info.NumofHeldcalls;
}


/*****************************************************************************
 * FUNCTION
 *  SetCallflag
 * DESCRIPTION
 *  Sets a particular call flag
 * PARAMETERS
 *  nCallHandle     [IN]        // Handle for call structure for which flag is to be set
 *  flag            [IN]        // Flag to set
 *  bIsHandle       [IN]        // If the n/w has supplied a handle
 * RETURNS
 *  void
 *****************************************************************************/
void SetCallflag(CM_CALL_HANDLE nCallHandle, U8 flag, pBOOL bIsHandle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bIsHandle)
    {
        index = GetMMIStructIndexof(nCallHandle);
    }
    else
    {
        index = nCallHandle;
    }

    if (index >= 0)
    {
        cm_p->state_info.AllCalls[index].status_flag |= flag;
        PRINT_INFORMATION("SetCallflag: call index = %d, flag = %d\n", index, flag);
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCallflag
 * DESCRIPTION
 *  Gets call flag
 * PARAMETERS
 *  nCallHandle     [IN]        // Handle for call structure for which flag is to be set
 *  bIsHandle       [IN]        // If the n/w has supplied a handle
 * RETURNS
 *  void
 *****************************************************************************/
U8 GetCallflag(CM_CALL_HANDLE nCallHandle, pBOOL bIsHandle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bIsHandle)
    {
        index = GetMMIStructIndexof(nCallHandle);
    }
    else
    {
        index = nCallHandle;
    }

    if (index == -1)
    {
        PRINT_INFORMATION("Get Call Flag-- bad Index>>\n");
        return 0;
    }
    return cm_p->state_info.AllCalls[index].status_flag;
}


/*****************************************************************************
 * FUNCTION
 *  ResetCallflag
 * DESCRIPTION
 *  Sets a particular call flag
 * PARAMETERS
 *  nCallHandle     [IN]        // Handle for call structure for which flag is to be set
 *  flag            [IN]        // Flag to set
 *  bIsHandle       [IN]        // If the n/w has supplied a handle
 * RETURNS
 *  void
 *****************************************************************************/
void ResetCallflag(CM_CALL_HANDLE nCallHandle, U8 flag, pBOOL bIsHandle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bIsHandle)
    {
        index = GetMMIStructIndexof(nCallHandle);
    }
    else
    {
        index = nCallHandle;
    }

    if (index == -1)
    {
        PRINT_INFORMATION("Reset Call Flag-- bad Index>>\n");
        return;
    }
    cm_p->state_info.AllCalls[index].status_flag &= ~flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetCallDirFlag
 * DESCRIPTION
 *  Gets the call direction flag
 * PARAMETERS
 *  handle      [IN]        
 *  Call(?)     [OUT]       Direction
 * RETURNS
 *  U16
 *****************************************************************************/
U16 GetCallDirFlag(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = GetMMIStructIndexof(handle);
    return cm_p->state_info.AllCalls[index].orgination_flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetMMIStructIndexof
 * DESCRIPTION
 *  Gets the call index in the array for a specified index
 * PARAMETERS
 *  nCallIndex      [IN]        // Call handle
 *  Index(?)        [OUT]       
 * RETURNS
 *  U16
 *****************************************************************************/
S16 GetMMIStructIndexof(CM_CALL_HANDLE nCallIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (index = 0; index < MAX_CALLS; index++)
    {
        if (cm_p->state_info.AllCalls[index].call_handle == nCallIndex)
        {
            return index;
        }
    }
    PRINT_INFORMATION("\n Call Structure Corrupted @ GetMMIStructIndexof \n");
    return -1;
}


/*****************************************************************************
 * FUNCTION
 *  MapItemId2CallHandle
 * DESCRIPTION
 *  Function item Id to the call handle
 * PARAMETERS
 *  idx         [IN]        Index to the active call
 *  Call(?)     [OUT]       Handle
 * RETURNS
 *  CM_CALL_HANDLE
 *****************************************************************************/
CM_CALL_HANDLE MapItemId2CallHandle(U16 idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;
    U8 activeCalls = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            if (idx == activeCalls)
            {
                return cm_p->state_info.AllCalls[count].call_handle;
            }
            activeCalls++;
        }
    }
    return (CM_CALL_HANDLE) - 1;
}


/*****************************************************************************
 * FUNCTION
 *  GetFirstFreeIndex
 * DESCRIPTION
 *  This function iterates over the calls strcutre to locate
 *  an index to a location where call info can be stored
 * PARAMETERS
 *  void
 *  Index(?)        [OUT]       To the location where the call can be stored
 * RETURNS
 *  Index
 *****************************************************************************/
S16 GetFirstFreeIndex(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* must make change here to retrieve call index from PS */
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].call_handle == -1)
        {
            return count;
        }
    }
    return -1;
}

/* Start by Julia: Drop call refinement */


/*****************************************************************************
 * FUNCTION
 *  GetDisconnectingCallHandle
 * DESCRIPTION
 *  Helper function to check if there is any disconnecting call existed
 * PARAMETERS
 *  void
 * RETURNS
 *  CM_CALL_HANDLE
 *****************************************************************************/
CM_CALL_HANDLE GetDisconnectingCallHandle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (CM_DISCONNECTING_STATE == cm_p->state_info.AllCalls[count].curr_state)
        {
            return cm_p->state_info.AllCalls[count].call_handle;
        }
    }
    PRINT_INFORMATION("No Disconnecting Call ");
    return -1;
}

/* End by Julia */


/*****************************************************************************
 * FUNCTION
 *  GetIncomingCallHandle
 * DESCRIPTION
 *  Helper function to get handle of incoming calll
 * PARAMETERS
 *  void
 * RETURNS
 *  CM_CALL_HANDLE
 *****************************************************************************/
CM_CALL_HANDLE GetIncomingCallHandle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        /* Start by Julia: Drop call refinement - add CM_DISCONNECTING_STATE condition */
        if (cm_p->state_info.AllCalls[count].curr_state == CM_INCOMING_STATE ||
            (cm_p->state_info.AllCalls[count].prev_state == CM_INCOMING_STATE &&
             cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE))
            /* End by Julia */
        {
            return cm_p->state_info.AllCalls[count].call_handle;
        }
    }

    PRINT_INFORMATION("\n Incoming call not present @ GetIncomingCallHandle\n");
    return -1;
}

/*****************************************************************************
 * FUNCTION
 *  SetOutgoingCallHandle
 * DESCRIPTION
 *  Sets the call handle for the outgoing call
 * PARAMETERS
 *  handle      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetOutgoingCallHandle(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE)
        {
            cm_p->state_info.AllCalls[count].call_handle = handle;
            cm_p->state_info.AllCalls[count].group_id = GetUnUsedGroupID();
            return;
        }

    }
}


/*****************************************************************************
 * FUNCTION
 *  GetOutgoingCallHandle
 * DESCRIPTION
 *  Helper function to get handle of outgoing call
 * PARAMETERS
 *  void
 *  total(?)        [OUT]       Hold call count
 * RETURNS
 *  CM_CALL_HANDLE
 *****************************************************************************/
CM_CALL_HANDLE GetOutgoingCallHandle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        /* Start by Julia: Drop call refinement - add CM_DISCONNECTING_STATE condition */
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE ||
            (cm_p->state_info.AllCalls[count].prev_state == CM_OUTGOING_STATE &&
             cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE))
            /* End by Julia */
        {
            return cm_p->state_info.AllCalls[count].call_handle;
        }
    }
    return -1;
}


/*****************************************************************************
 * FUNCTION
 *  GetOutgoingCallIndex
 * DESCRIPTION
 *  Helper function to get index of outgoing call
 * PARAMETERS
 *  void
 * RETURNS
 *  CM_CALL_HANDLE
 *****************************************************************************/
S16 GetOutgoingCallIndex(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        /* Start by Julia: Drop call refinement - add CM_DISCONNECTING_STATE condition */
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE ||
            (cm_p->state_info.AllCalls[count].prev_state == CM_OUTGOING_STATE &&
             cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE))
            /* End by Julia */
        {
            return count;
        }
    }
    return -1;
}


/*****************************************************************************
 * FUNCTION
 *  GetOutgoingCallOrigin
 * DESCRIPTION
 *  Helper function to get origin of outgoing call
 * PARAMETERS
 *  void
 * RETURNS
 *  CALL_DIR
 *****************************************************************************/
CALL_DIR GetOutgoingCallOrigin(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE)
        {
            return cm_p->state_info.AllCalls[count].orgination_flag;
        }
    }
    return CM_CALL_NONE;
}


/*****************************************************************************
 * FUNCTION
 *  GetCallHandle
 * DESCRIPTION
 *  This function is a helper to get handle of by seraching on the name or number
 * PARAMETERS
 *  Dispname        [IN]        Name or number
 *  call(?)         [OUT]       Handle
 * RETURNS
 *  CM_CALL_HANDLE
 *****************************************************************************/
CM_CALL_HANDLE GetCallHandle(PU8 Dispname)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].call_handle != -1)
        {
            if (mmi_ucs2strlen((PS8)cm_p->state_info.AllCalls[count].pBname) > 0)
            {
                if (cm_p->state_info.AllCalls[count].pBname == Dispname)
                {
                    return cm_p->state_info.AllCalls[count].call_handle;
                }
            }
            else
            {
                if (cm_p->state_info.AllCalls[count].number == Dispname)
                {
                    return cm_p->state_info.AllCalls[count].call_handle;
                }
            }

        }
    }

    PRINT_INFORMATION("\n Call Structure Corrupted @ GetCallHandle \n");
    return -1;
}


/*****************************************************************************
 * FUNCTION
 *  GetAllDispNameorNum
 * DESCRIPTION
 *  This function fills up the array for the respective calls
 * PARAMETERS
 *  Dispnames           [IN]        // Array of names or numbers
 *  DispStrids          [IN]        // Array of image ids
 *  HighlightIndex      [?]         
 *  Number(?)           [OUT]       Of elements in the array
 * RETURNS
 *  U8
 *****************************************************************************/
U8 GetAllDispNameorNum(PU8 *Dispnames, U16 *DispStrids, U16 *Iconids, S16 *HighlightIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;
    U8 count = 0, count1 = 0, j = 0, i = 0;
    TIMEANDINDEX tmpTimeBuf;
    TIMEANDINDEX tmpArr[MAX_CALLS];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (index = 0; index < MAX_CALLS; index++)
    {
        if ((cm_p->state_info.AllCalls[index].call_handle != -1) &&
            (cm_p->state_info.AllCalls[index].curr_state != CM_IDLE_STATE) &&
            (cm_p->state_info.AllCalls[index].curr_state != CM_INCOMING_STATE))
        {
            if (CM_ACTIVE_STATE == cm_p->state_info.AllCalls[index].curr_state)
            {
                /* Stores the Start Time of the Active Call in tmpArr */
                memcpy(&tmpArr[i].time, &cm_p->state_info.AllCalls[count].start_time, sizeof(MYTIME));
                tmpArr[i].index = count;
                i++;    /* Inrease the Active Call Count by 1 */
            }

            if (mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].pBname) != 0)
            {
                Dispnames[count] = cm_p->state_info.AllCalls[index].pBname;
            }
            else
            {
		/* no name, show number */
                /* hide *31#, #31# prefix string  */
                if ((mmi_ucs2ncmp((PS8) cm_p->state_info.AllCalls[index].number, (PS8) L"*31#", 4) == 0) ||
                    (mmi_ucs2ncmp((PS8) cm_p->state_info.AllCalls[index].number, (PS8) L"#31#", 4) == 0))
                {
                    Dispnames[count] = (U8 *)&cm_p->state_info.AllCalls[index].number[8];
                }
                else
                {
                    Dispnames[count] = (U8 *)&cm_p->state_info.AllCalls[index].number;
                }
            }
            if (CM_DISCONNECTING_STATE == cm_p->state_info.AllCalls[index].curr_state)
            {
                DispStrids[count] = GetImgIdofState(cm_p->state_info.AllCalls[index].prev_state);
            }
            else
            {
                DispStrids[count] = GetImgIdofState(cm_p->state_info.AllCalls[index].curr_state);
            }
            if (Iconids != NULL && isCSPPresent == 1 && !IsResetCSPGroupService(CSP_CPHS_TELESERVICES_SERVICE_GROUP, ALS))
            {
                if (cm_p->state_info.AllCalls[index].call_type == CM_AUX_VOICE_CALL)
                {
                    Iconids[count] = IMG_CM_ICON_LINE2;
                }
                else
                {
                    Iconids[count] = IMG_CM_ICON_LINE1;
                }
            }
            count++;
        }
    }

    /* This loop sorts the Array tmpArr in such a way that
       the oldest call appears at top */
    for (count1 = 0; count1 < i - 1; count1++)
    {
        for (j = 0; j < i - 1 - count1; j++)
        {
            if (FindMaxTime(&tmpArr[j + 1].time, &tmpArr[j].time))
            {
                memcpy(&tmpTimeBuf, &tmpArr[j], sizeof(tmpTimeBuf));
                memcpy(&tmpArr[j], &tmpArr[j + 1], sizeof(tmpTimeBuf));
                memcpy(&tmpArr[j + 1], &tmpTimeBuf, sizeof(tmpTimeBuf));
            }
        }
    }

    /* highlight the latest active call */
    if (i == 0)
    {
        *HighlightIndex = 0;
    }
    else
    {
        *HighlightIndex = tmpArr[i - 1].index;
    }
    return count;
}


/*****************************************************************************
 * FUNCTION
 *  GetAllActDispNameorNum
 * DESCRIPTION
 *  This function fills up the array for all active calls
 * PARAMETERS
 *  Dispnames       [IN]        // Array of names or numbers
 *  Number(?)       [OUT]       Of elements in the array
 * RETURNS
 *  U8
 *****************************************************************************/
U8 GetAllActDispNameorNum(PU8 *Dispnames)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;
    U8 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (index = 0; index < MAX_CALLS; index++)
    {
        if ((cm_p->state_info.AllCalls[index].call_handle != -1) &&
            (cm_p->state_info.AllCalls[index].curr_state == CM_ACTIVE_STATE))
        {
            if (mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].pBname) != 0)
            {
                Dispnames[count] = cm_p->state_info.AllCalls[index].pBname;
            }
            else
            {
                Dispnames[count] = cm_p->state_info.AllCalls[index].number;
            }
            count++;
        }
    }
    return count;
}


/*****************************************************************************
 * FUNCTION
 *  GetImgIdofState
 * DESCRIPTION
 *  This function returns the respective image id as per the call state
 * PARAMETERS
 *  tmpState        [IN]        // Call state
 *  Image(?)        [OUT]       Id
 * RETURNS
 *  U16
 *****************************************************************************/
U16 GetImgIdofState(CALL_STATE tmpState)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 strId = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (tmpState)
    {
        case CM_OUTGOING_STATE:
            strId = IMG_CM_STATE_OUTGOING;
            break;

        case CM_INCOMING_STATE:
            strId = IMG_CM_STATE_INCOMING;
            break;

        case CM_ACTIVE_STATE:
            strId = IMG_CM_STATE_ACTIVE;
            break;

        case CM_HOLD_STATE:
            strId = IMG_CM_STATE_HOLD;
            break;
            /* Start by Julia: Drop call refinement */
        case CM_DISCONNECTING_STATE:
            strId = IMG_CM_STATE_DISCONNECTING;
            break;
            /* End by Julia */
        default:
            PRINT_INFORMATION("\n CM Event State m/c corrupted \n");
            break;
    }
    return strId;
}


/*****************************************************************************
 * FUNCTION
 *  SetCalledNumber
 * DESCRIPTION
 *  Sets Call Abort Flag dpeneding on flag
 * PARAMETERS
 *  index       [IN]        
 *  msg         [?]         
 *  flag(?)     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCalledNumber(S16 index, U8 *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memcpy(
        cm_p->state_info.AllCalls[index].num,
        cm_p->state_info.AllCalls[index].number,
        sizeof(cm_p->state_info.AllCalls[index].num));
    memset(cm_p->state_info.AllCalls[index].number, 0, sizeof(cm_p->state_info.AllCalls[index].number));

    if (*msg)
    {
        mmi_ucs2cpy((S8*) cm_p->state_info.AllCalls[index].number, (S8*) msg);
    }
}

/*****************************************************************************
 * FUNCTION
 *  SetCNAPName
 * DESCRIPTION
 *  Sets CNAP number
 * PARAMETERS
 *  call handle        
 *  msg    
 * RETURNS
 *  void
 *****************************************************************************/
void SetCNAPName(CM_CALL_HANDLE call_handle, U8 dcs, U8 length, U8 *CNAP_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nameLen = 0;
    U8 *tempStr = NULL;
    U16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    for(count = 0; count < MAX_CALLS; count++)
    {
        if(cm_p->state_info.AllCalls[count].call_handle == call_handle)
        {
            memset(cm_p->state_info.AllCalls[count].CNAPname, 0, sizeof(cm_p->state_info.AllCalls[count].CNAPname));
            nameLen = length;

            if (nameLen >= MAX_NAME)
            {
                if(dcs == MMI_UCS2_DCS)
                {
                    nameLen = MAX_NAME - 2;
                }
                else
                {
                    nameLen = MAX_NAME - 1;
                }
            }

            if (dcs == MMI_8BIT_DCS)
            {
                tempStr = CovertStringForPlatform(CNAP_name, length, dcs, &nameLen);
            }
            else
            {
                tempStr = OslMalloc(MAX_NAME);
                memset(tempStr, 0, (MAX_NAME));
                CNAP_name[nameLen] = 0; /*InputboxConvertGSMToDeviceEncoding requirement*/
                CNAP_name[nameLen+1] = 0;
                InputboxConvertGSMToDeviceEncoding(CNAP_name, tempStr, nameLen, (MAX_NAME), dcs, 0, 1);
            }
            if (tempStr != NULL)
            {
                mmi_ucs2ncpy((PS8) cm_p->state_info.AllCalls[count].CNAPname, (PS8) tempStr, (MAX_NAME));
                OslMfree(tempStr);
            }
            return;
        }
    }
    return;
}

/*****************************************************************************
 * FUNCTION
 *  SetCalledNumWithType
 * DESCRIPTION
 *  Sets called number alongwith type field
 * PARAMETERS
 *  index       [IN]        
 *  msg         [?]         
 *  flag(?)     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCalledNumWithTypeAux(S16 index, void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_CONNECT_IND *msgBuf = (MMI_CONNECT_IND*) msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
	/* number changed once, no need to change again */
    if (mmi_ucs2cmp ((PS8)cm_p->state_info.AllCalls[index].num, 
        						  (PS8)cm_p->state_info.AllCalls[index].number) != 0)
    {
		return;
	}

	/* old number -> num
	   new number -> number */
    memcpy(
        cm_p->state_info.AllCalls[index].num,
        cm_p->state_info.AllCalls[index].number,
        sizeof(cm_p->state_info.AllCalls[index].num));
    memset(cm_p->state_info.AllCalls[index].number, 0, sizeof(cm_p->state_info.AllCalls[index].number));

    cm_p->state_info.AllCalls[index].call_type = msgBuf->call_type;

    if (*(msgBuf->num.number))
    {
        if ((msgBuf->num.type) & 0x10)
        {
            mmi_asc_to_ucs2((S8*) cm_p->state_info.AllCalls[index].number, "+");
            mmi_asc_to_ucs2((S8*) (cm_p->state_info.AllCalls[index].number + 2), (S8*) msgBuf->num.number);
        }
        else
        {
            mmi_asc_to_ucs2((S8*) cm_p->state_info.AllCalls[index].number, (S8*) msgBuf->num.number);
        }
    }
    else
    {
        mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].number, (PS8) GetString(STR_UNKNOWN_CALLER));
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetCalledNumWithType
 * DESCRIPTION
 *  Sets called number alongwith type field
 * PARAMETERS
 *  index       [IN]        
 *  msg         [?]         
 *  flag(?)     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCalledNumWithType(S16 index, void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_CONNECT_IND *msgBuf = (MMI_CONNECT_IND*) msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (*(msgBuf->num.number))
    {
    #ifdef __IP_NUMBER__
        if (GetTempUseIPNumber() == FALSE)
    #endif 
        {
        	/* number changed, look up again */
        	if (mmi_ucs2cmp ((PS8)cm_p->state_info.AllCalls[index].num, 
        						  (PS8)cm_p->state_info.AllCalls[index].number) != 0)
        	{
            PHB_CM_INTERFACE phb_data;

            /* IP dial connected number don't search PHB */

            if (gPhoneNumberStruct.dialInList != MMI_PHB_NONE)
            {
                mmi_phb_call_set_dial_from_list(gPhoneNumberStruct.dialInList);
            }

            if (cm_p->redial_info.DialFromPhb != MMI_PHB_NONE)
            {
                mmi_phb_call_set_dial_from_list(cm_p->redial_info.DialFromPhb);
            }
        #ifdef __MMI_DUAL_SIM_MASTER__
            phb_data = mmi_phb_call_get_data_for_call_mgnt(cm_p->state_info.AllCalls[index].number, TRUE, SIM1);
        #else /* __MMI_DUAL_SIM_MASTER__ */
            phb_data = mmi_phb_call_get_data_for_call_mgnt(cm_p->state_info.AllCalls[index].number, TRUE);
        #endif /* __MMI_DUAL_SIM_MASTER__ */
            SetCMPhoneBookStruct(&phb_data);
            	
            	/* use phb name + number */
            cm_p->state_info.AllCalls[index].name_dcs = gPhoneNumberStruct.name_dcs;
            mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].pBname, (PS8) gPhoneNumberStruct.name);
            if (!(gPhoneNumberStruct.number[0] == 0 && gPhoneNumberStruct.number[1] == 0))
            {
                mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].number, (PS8) gPhoneNumberStruct.number);
            }
        }
    }

    }
}


/*****************************************************************************
 * FUNCTION
 *  SetOutgoingNamefromPhonebook
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetOutgoingNamefromPhonebook(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = GetOutgoingCallIndex();
    if (index == -1)
    {
        return;
    }

    memset((PS8) cm_p->state_info.AllCalls[index].pBname, 0, sizeof(cm_p->state_info.AllCalls[index].pBname));

    /* memcpy((PS8)cm_p->state_info.AllCalls[index].pbNumber,(PS8)&gPhoneNumberStruct.number,
       sizeof(cm_p->state_info.AllCalls[index].pbNumber)); */
    memcpy(
        (PS8) cm_p->state_info.AllCalls[index].pBname,
        (PS8) gPhoneNumberStruct.name,
        sizeof(cm_p->state_info.AllCalls[index].pBname));
    cm_p->state_info.AllCalls[index].name_dcs = gPhoneNumberStruct.name_dcs;

    /* if (!(gPhoneNumberStruct.number[0] == 0 && gPhoneNumberStruct.number[1] == 0))
       mmi_ucs2cpy((PS8)cm_p->state_info.AllCalls[index].number,(PS8)gPhoneNumberStruct.number); */
}


/*****************************************************************************
 * FUNCTION
 *  GetOutgoingNumber
 * DESCRIPTION
 *  Returns number for outgoing call
 * PARAMETERS
 *  void
 *  Cause(?)        [OUT]       Value
 * RETURNS
 *  void
 *****************************************************************************/
PU8 GetOutgoingNumber(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE ||
            (cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE &&
             cm_p->state_info.AllCalls[count].prev_state == CM_OUTGOING_STATE))
        {
            return cm_p->state_info.AllCalls[count].number;
        }
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  GetOutgoingName
 * DESCRIPTION
 *  Returns name for outgoing call
 * PARAMETERS
 *  void
 *  Cause(?)        [OUT]       Value
 * RETURNS
 *  void
 *****************************************************************************/
PU8 GetOutgoingName(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE && cm_p->state_info.AllCalls[count].pBname)
        {
            return cm_p->state_info.AllCalls[count].pBname;
        }
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  GetOutgoingCallType
 * DESCRIPTION
 *  Returns the type of outgoing call
 * PARAMETERS
 *  void
 * RETURNS
 *  Call type
 *****************************************************************************/
U8 GetOutgoingCallType(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE)
        {
            return cm_p->state_info.AllCalls[count].call_type;
        }
    }
    return CSMCC_VOICE_CALL;
}

/*****************************************************************************
 * FUNCTION
 *  GetIncomingCallType
 * DESCRIPTION
 *  Returns the type of outgoing call
 * PARAMETERS
 *  void
 * RETURNS
 *  Call type
 *****************************************************************************/
U8 GetIncomingCallType(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_INCOMING_STATE)
        {
            return cm_p->state_info.AllCalls[count].call_type;
        }
    }
    return CSMCC_VOICE_CALL;
}

/*****************************************************************************
 * FUNCTION
 *  GetActiveCallIndex
 * DESCRIPTION
 *  Helper function to get index of outgoing call
 * PARAMETERS
 *  void
 * RETURNS
 *  CM_CALL_HANDLE
 *****************************************************************************/
S16 GetActiveCallIndex(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        /* Start by Julia: Drop call refinement - add CM_DISCONNECTING_STATE condition */
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE ||
            (cm_p->state_info.AllCalls[count].prev_state == CM_ACTIVE_STATE &&
             cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE))
            /* End by Julia */
        {
            return count;
        }
    }
    return -1;
}

#ifdef __MMI_CM_BLACK_LIST__


/*****************************************************************************
 * FUNCTION
 *  BlockedHandle
 * DESCRIPTION
 *  Function to check if the call is in black list
 * PARAMETERS
 *  handle      [IN]        
 * RETURNS
 *  True means the number is blocked, False means it is not
 *****************************************************************************/
pBOOL BlockedHandle(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GetBlackListMode() == TRUE && cm_p->state_info.AllCalls[index].block_flag == TRUE)
    {
        SetClearKeyFlag(FALSE);
        return TRUE;
    }
    else
    {
        SetClearKeyFlag(TRUE);
        return FALSE;
    }
}
#endif /* __MMI_CM_BLACK_LIST__ */ 


/*****************************************************************************
 * FUNCTION
 *  GetCallName
 * DESCRIPTION
 *  Function gets the name or number of incoming call
 * PARAMETERS
 *  handle          [IN]        
 *  Pointer(?)      [OUT]       To buffer containing name or number
 * RETURNS
 *  PS8
 *****************************************************************************/
PU8 GetCallName(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    

    if(mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].num) == 0 && 
       mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].CNAPname) != 0)
    {
	    return cm_p->state_info.AllCalls[index].CNAPname;
    }
    else if (mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].pBname) != 0)
    {
        return cm_p->state_info.AllCalls[index].pBname;
    }
    else if (mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].CNAPname) != 0)
    {
        return cm_p->state_info.AllCalls[index].CNAPname;
    }
    else if (!cm_p->state_info.AllCalls[index].number)
    {
        mmi_ucs2cpy((PS8) cm_p->state_info.AllCalls[index].number, (PS8) GetString(STR_UNKNOWN_CALLER));
        return cm_p->state_info.AllCalls[index].number;
    }
    else
    {
        /* no name, show number */
        /* hide *31#, #31# prefix string  */
        if ((mmi_ucs2ncmp((PS8) cm_p->state_info.AllCalls[index].number, (PS8) L"*31#", 4) == 0) ||
            (mmi_ucs2ncmp((PS8) cm_p->state_info.AllCalls[index].number, (PS8) L"#31#", 4) == 0))
        {
            return (U8 *)&cm_p->state_info.AllCalls[index].number[8];
        }
        else
        {
            return (U8 *)&cm_p->state_info.AllCalls[index].number;

        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCallNumber
 * DESCRIPTION
 *  Returns number for outgoing call
 * PARAMETERS
 *  handle          [IN]        
 *  Cause(?)        [OUT]       Value
 * RETURNS
 *  void
 *****************************************************************************/
PU8 GetCallNumber(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index != -1)
    {
        return cm_p->state_info.AllCalls[index].number;
    }
    else
    {
        return NULL;
    }
}

/*****************************************************************************
 * FUNCTION
 *  GetCallLogNumber
 * DESCRIPTION
 *  Returns number for outgoing call
 * PARAMETERS
 *  handle          [IN]        
 *  Cause(?)        [OUT]       Value
 * RETURNS
 *  void
 *****************************************************************************/
PU8 GetCallLogNumber(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index != -1)
    {
        return cm_p->state_info.AllCalls[index].num;
    }
    else
    {
        return NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCallLogName
 * DESCRIPTION
 *  Returns number for outgoing call
 * PARAMETERS
 *  handle          [IN]        
 *  Cause(?)        [OUT]       Value
 * RETURNS
 *  void
 *****************************************************************************/
PU8 GetCallLogName(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return cm_p->state_info.AllCalls[index].pBname;
}

/*****************************************************************************
 * FUNCTION
 *  GetCallType
 * DESCRIPTION
 *  Function gets the type of incoming call
 * PARAMETERS
 *  handle      [IN]        
 * RETURNS
 *  Call Type
 *****************************************************************************/
U8 GetCallType(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return cm_p->state_info.AllCalls[index].call_type;
}

/*****************************************************************************
 * FUNCTION
 *  GetCallStartTime
 * DESCRIPTION
 *  Function gets the image id for an incoming call
 * PARAMETERS
 *  handle          [IN]        
 *  Image(?)        [OUT]       Id
 * RETURNS
 *  U16
 *****************************************************************************/
MYTIME * GetCallStartTime (CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index >= 0)
	    return &cm_p->state_info.AllCalls[index].start_time;
    else
    	return NULL;
}

/*****************************************************************************
 * FUNCTION
 *  GetCallImgId
 * DESCRIPTION
 *  Function gets the image id for an incoming call
 * PARAMETERS
 *  handle          [IN]        
 *  Image(?)        [OUT]       Id
 * RETURNS
 *  U16
 *****************************************************************************/
U16 GetCallImgId(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_INCOMING_CALL_VIDEO__
    /* incoming call with video set */
    if (cm_p->state_info.AllCalls[index].number && gPhoneNumberStruct.videoId != 0)
    {
        if (gPhoneNumberStruct.videoId & 0x8000)
        {
            /* check file presence before use it */
            S8 *path;
            FS_HANDLE fh;

            path = GetCallVideoPath(handle);
		#ifdef __MMI_AVATAR__
			if (gPhoneNumberStruct.videoId & 0x1000)
            {
                return gPhoneNumberStruct.videoId;
            }
		#endif /* __MMI_AVATAR__ */
            if (path != NULL)
            {
                fh = FS_Open((PU16) path, FS_READ_ONLY);
                if (fh > FS_NO_ERROR)
                {
                    FS_Close(fh);
                    /* use phonebook video if matched */
                    return gPhoneNumberStruct.videoId;
                }
            }
        }
        else
        {
            return gPhoneNumberStruct.videoId;
        }
    }
#endif /* __MMI_INCOMING_CALL_VIDEO__ */ 
    if (cm_p->state_info.AllCalls[index].number && gPhoneNumberStruct.pictureId != 0)
    {
        /* use phonebook image if matched */
        return gPhoneNumberStruct.pictureId;
    }
    else
    {
        /* use default image */
        return IMG_PHB_DEFAULT;
    }
}

#ifdef __MMI_PHB_CALL_SHOW_PICTURE_FROM_FILE__


/*****************************************************************************
 * FUNCTION
 *  GetCallImgPath
 * DESCRIPTION
 *  Function gets the image path for an incoming call
 * PARAMETERS
 *  handle          [IN]        
 *  Image(?)        [OUT]       Path
 * RETURNS
 *  S8 *
 *****************************************************************************/
extern S8 *mmi_phb_image_get_path_from_id(U16 index);

S8 *GetCallImgPath(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 RecordIndex;
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cm_p->state_info.AllCalls[index].number)
    {
        RecordIndex = gPhoneNumberStruct.record_index;
        if (RecordIndex == 0)
        {
            return NULL;
        }
        else
        {
            return mmi_phb_image_get_path_from_id(RecordIndex);
        }
    }
    else if (mmi_ucs2cmp((PS8) cm_p->state_info.AllCalls[index].number, GetString(STR_UNKNOWN_CALLER)))
    {
        return NULL;
    }
    return NULL;
}
#endif /* __MMI_PHB_CALL_SHOW_PICTURE_FROM_FILE__ */ 

#ifdef __MMI_INCOMING_CALL_VIDEO__


/*****************************************************************************
 * FUNCTION
 *  GetCallVideoPath
 * DESCRIPTION
 *  Function gets the video path for an incoming call
 * PARAMETERS
 *  handle          [IN]        
 *  Video(?)        [OUT]       Path
 * RETURNS
 *  S8 *
 *****************************************************************************/
extern S8 *mmi_phb_video_get_path_from_id(U16 record_index);

S8 *GetCallVideoPath(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 RecordIndex;
    S16 index = GetMMIStructIndexof(handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cm_p->state_info.AllCalls[index].number)
    {
        RecordIndex = gPhoneNumberStruct.video_record_index;
        if (RecordIndex == 0)
        {
            return NULL;
        }
        else
        {
            return mmi_phb_video_get_path_from_id(RecordIndex);
        }
    }
    else if (mmi_ucs2cmp((PS8) cm_p->state_info.AllCalls[index].number, GetString(STR_UNKNOWN_CALLER)))
    {
        return NULL;
    }
    return NULL;
}
#endif /* __MMI_INCOMING_CALL_VIDEO__ */ 


/*****************************************************************************
 * FUNCTION
 *  GetActiveCallType
 * DESCRIPTION
 *  Function gets the call type for an active call
 * PARAMETERS
 *  void
 *  call(?)     [OUT]       Type
 * RETURNS
 *  U16
 *****************************************************************************/
U8 GetActiveCallType(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            return cm_p->state_info.AllCalls[count].call_type;
        }
    }
    return CSMCC_VOICE_CALL;
}


/*****************************************************************************
 * FUNCTION
 *  GetDispNameorNum
 * DESCRIPTION
 *  Gets the name or number for a particular call handle
 * PARAMETERS
 *  void
 *  Pointer(?)              [OUT]       To the name or number buffer
 *  CM_CALL_HANDLE(?)       [IN]        NCallIndex, // Call handle
 * RETURNS
 *  PU8
 *****************************************************************************/
PU8 GetDispNameorNum(CM_CALL_HANDLE call_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (index = 0; index < MAX_CALLS; index++)
    {
        if (cm_p->state_info.AllCalls[index].call_handle == call_handle)
        {

            if(mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].num) == 0 && 
                mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].CNAPname) != 0)
            {
	            return cm_p->state_info.AllCalls[index].CNAPname;
            }
            else if (((mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].pBname) == 0)
        #ifdef __IP_NUMBER__
                || (GetTempUseIPNumber() && cm_p->state_info.AllCalls[index].curr_state == CM_OUTGOING_STATE)
        #endif 
                     ) && (mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].CNAPname) == 0)
                )
            {
            	/* no name, show number */
                /* hide *31#, #31# prefix string  */
                if ((mmi_ucs2ncmp((PS8) cm_p->state_info.AllCalls[index].number, (PS8) L"*31#", 4) == 0) ||
                    (mmi_ucs2ncmp((PS8) cm_p->state_info.AllCalls[index].number, (PS8) L"#31#", 4) == 0))
                {
                    return &cm_p->state_info.AllCalls[index].number[8];
                }
                else
                {
                    return cm_p->state_info.AllCalls[index].number;
                }
            }
            else if (mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].pBname) != 0)
            {
                return cm_p->state_info.AllCalls[index].pBname;
            }
            else if (mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].CNAPname) != 0)
            {
                return cm_p->state_info.AllCalls[index].CNAPname;
            }
        }
    }
    return NULL;
}


#ifdef __MMI_CM_BLACK_LIST__
/*****************************************************************************
 * FUNCTION
 *  SetBlackIncomingFlag
 * DESCRIPTION
 *  Sets flag if the incoming call is in black list
 * PARAMETERS
 *  value       [IN]        
 *  TRUE(?)     [IN]        /FALSE
 * RETURNS
 *  void
 *****************************************************************************/
void SetBlackIncomingFlag(pBOOL value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gBlackIncomingFlag = value;
}


/*****************************************************************************
 * FUNCTION
 *  GetBlackIncomingFlag
 * DESCRIPTION
 *  Returns true if this incoming call is in black list
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       /FALSE
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL GetBlackIncomingFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gBlackIncomingFlag;
}
#endif /* __MMI_CM_BLACK_LIST__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetClearKeyFlag
 * DESCRIPTION
 *  it is the derivative function for auto-rejected black list incoming call to determine
 *  if the clear key handler should be called before rejecting a call
 * PARAMETERS
 *  value       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetClearKeyFlag(pBOOL value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gClearKeyFlag = value;
}


/*****************************************************************************
 * FUNCTION
 *  GetClearKeyFlag
 * DESCRIPTION
 *  it is the derivative function for auto-rejected black list incoming call to determine
 *  if the clear key handler should be called before rejecting a call
 * PARAMETERS
 *  void
 * RETURNS
 *  True means the clear key handler should be called, False means it should not
 *****************************************************************************/
pBOOL GetClearKeyFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gClearKeyFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetCCFlag
 * DESCRIPTION
 *  Sets flag is this is normal voice call
 * PARAMETERS
 *  value       [IN]        
 *  TRUE(?)     [IN]        /FALSE
 * RETURNS
 *  void
 *****************************************************************************/
void SetCCFlag(pBOOL value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gIsCCCall = value;
}


/*****************************************************************************
 * FUNCTION
 *  GetCCFlag
 * DESCRIPTION
 *  Returns true if this is voice call
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       /FALSE
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL GetCCFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gIsCCCall;
}


/*****************************************************************************
 * FUNCTION
 *  SetTransitionToActiveFlag
 * DESCRIPTION
 *  Sets flag for get time before enter active call
 *  screen
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        /FALSE
 * RETURNS
 *  void
 *****************************************************************************/
void SetTransitionToActiveFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gGetTimeBeforeActive = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetTransitionToActiveFlag
 * DESCRIPTION
 *  Returns flag for get time before enter active call
 *  screen
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       /FALSE
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL GetTransitionToActiveFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gGetTimeBeforeActive;
}


/*****************************************************************************
 * FUNCTION
 *  SetAnswerMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  mode        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void SetAnswerMode(void *mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mode == NULL)
    {
        memset(&gCMAnsMode, 0, sizeof(MMI_ANSWERING_MODE));
    }
    else
    {
        memcpy(&gCMAnsMode, mode, sizeof(MMI_ANSWERING_MODE));
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetAnswerMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void *GetAnswerMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return &gCMAnsMode;
}


/*****************************************************************************
 * FUNCTION
 *  SetAutoAnswerFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetAutoAnswerFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gAutoAnswerFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetAutoAnswerFlag
 * DESCRIPTION
 *  Gets the AutoAnswerFlag Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetAutoAnswerFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gAutoAnswerFlag;
}

/* Start by Julia: Drop call refinement */


/*****************************************************************************
 * FUNCTION
 *  SetAutoReleaseFlag
 * DESCRIPTION
 *  Set AutoReleaseFlag to determine if auto release is needed
 *  
 *  It is for drop call refinement
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For auto release all disconnecting calls, FALSE otherwise
 * RETURNS
 *  void
 *****************************************************************************/
void SetAutoReleaseFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gAutoReleaseFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetAutoReleaseFlag
 * DESCRIPTION
 *  Gets the AutoReleaseFlag Status
 *  
 *  It if for drop call refinement
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For auto release all disconnecting calls, FALSE otherwise
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetAutoReleaseFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gAutoReleaseFlag;
}

/* End by Julia */


/*****************************************************************************
 * FUNCTION
 *  GetHungUpHandle
 * DESCRIPTION
 *  Helper function to get handle of hungup call
 * PARAMETERS
 *  void
 *  total(?)        [OUT]       Hold call count
 * RETURNS
 *  U16
 *****************************************************************************/
CM_CALL_HANDLE GetHungUpHandle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if ((cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE ||
             cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE ||
             cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE) &&
            (cm_p->state_info.AllCalls[count].status_flag & CM_HANGUP_REQUESTED))
        {
            return cm_p->state_info.AllCalls[count].call_handle;
        }
    }
    return -1;
}


/*****************************************************************************
 * FUNCTION
 *  SetAbortCallRequestedFlag
 * DESCRIPTION
 *  Sets Call Abort Flag dpeneding on flag
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetAbortCallRequestedFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCallAbortRequested = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetAbortCallRequestedFlag
 * DESCRIPTION
 *  Returns Call Abort Flag
 * PARAMETERS
 *  void
 * RETURNS
 *  flag
 *****************************************************************************/
pBOOL GetAbortCallRequestedFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCallAbortRequested;
}


/*****************************************************************************
 * FUNCTION
 *  SetCallAbortReqSentFlag
 * DESCRIPTION
 *  Sets Call Abort sent Flag dpeneding on flag
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCallAbortReqSentFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("[gsm_call_management]SetCallAbortReqSentFlag=%d\n", flag);
    gCallAbortReqSentFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetCallAbortReqSentFlag
 * DESCRIPTION
 *  Returns Call Abort sent Flag
 * PARAMETERS
 *  void
 * RETURNS
 *  flag
 *****************************************************************************/
pBOOL GetCallAbortReqSentFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("[gsm_call_management]GetCallAbortReqSentFlag=%d\n", gCallAbortReqSentFlag);
    return gCallAbortReqSentFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetDropRequestFlag
 * DESCRIPTION
 *  Sets the DropRequest Flag
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetDropRequestFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gDropRequestFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetDropRequestFlag
 * DESCRIPTION
 *  Gets the DropRequest Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetDropRequestFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gDropRequestFlag;
}


/*****************************************************************************
 * FUNCTION
 *  GetIncomingCallDroppedFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
pBOOL GetIncomingCallDroppedFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gIncomingCallDroppedFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetIncomingCallDroppedFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetIncomingCallDroppedFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* remote side of MT call drops */
    gIncomingCallDroppedFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  SetMissedCallFlag
 * DESCRIPTION
 *  Sets the MissedCall Flag
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetMissedCallFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gMissedCallFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetMissedCallFlag
 * DESCRIPTION
 *  Gets the MissedCall Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetMissedCallFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gMissedCallFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetCallWaitFlag
 * DESCRIPTION
 *  Sets Call Wait Flag dpeneding on flag
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCallWaitFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCallWaitFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetCallWaitFlag
 * DESCRIPTION
 *  Returns Call Wait Flag
 * PARAMETERS
 *  void
 * RETURNS
 *  flag
 *****************************************************************************/
pBOOL GetCallWaitFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCallWaitFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetNoTwiceRingFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetNoTwiceRingFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gNoTwiceRingFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetNoTwiceRingFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
pBOOL GetNoTwiceRingFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gNoTwiceRingFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetWait2RingCallFlag
 * DESCRIPTION
 *  Sets Wait To Ring Flag dpeneding on flag
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetWait2RingCallFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gWait2RingCallFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetWait2RingCallFlag
 * DESCRIPTION
 *  Gets Wait To Ring Flag
 * PARAMETERS
 *  void
 * RETURNS
 *  flag
 *****************************************************************************/
pBOOL GetWait2RingCallFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gWait2RingCallFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetCallEndedBeforeConnFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetCallEndedBeforeConnFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCallEndedBeforeConnFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetCallEndedBeforeConnFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetCallEndedBeforeConnFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCallEndedBeforeConnFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetErrorToneFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetErrorToneFlag(U8 flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gErrorToneFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetErrorToneFlag
 * DESCRIPTION
 *  Gets the ErrorToneFlag Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
U8 GetErrorToneFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gErrorToneFlag;
}

extern void reset_call_cost_UI(void);
/*****************************************************************************
 * FUNCTION
 *  SetShowAOC
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetShowAOC(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gShowAOC = flag;
    if (!flag)
    {
         reset_call_cost_UI();
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetShowAOC
 * DESCRIPTION
 *  Gets the ActiveToHold Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetShowAOC(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gShowAOC;
}


/*****************************************************************************
 * FUNCTION
 *  SetDTMFKeyUpFlag
 * DESCRIPTION
 *  Set DTMF Key Up Flag
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetDTMFKeyUpFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gDTMFKeyUpFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetDTMFKeyUpFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
pBOOL GetDTMFKeyUpFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gDTMFKeyUpFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetCMScrnFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetCMScrnFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCMScrnFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetCMScrnFlag
 * DESCRIPTION
 *  Gets the CMScrnFlag Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetCMScrnFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCMScrnFlag;
}


/*****************************************************************************
 * FUNCTION
 *  UpdateActiveCallScrnIfPresent
 * DESCRIPTION
 *  Redraws Active Call Screen if Present
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void UpdateActiveCallScrnIfPresent(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GetExitScrnID() == SCR_CM_ACTIVECALLSCREEN && GetTotalCallCount() > 0)
    {
        MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_INFO_UpdateActiveCallScrnIfPresent);
        EntryScr1002ActiveCall();
    }
    else if ((GetCurrentState() == CM_ACTIVE_STATE || GetCurrentState() == CM_HOLD_STATE)
             && (GetSyncCallFromATFlag() == TRUE))
    {
        GoBackToHistory(SCR_CM_ACTIVECALLSCREEN);
    }
    SetSyncCallFromATFlag(FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  EmergencyCallPresent
 * DESCRIPTION
 *  Check if emergency call is Present
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       /FALSE
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL EmergencyCallPresent(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
    #ifdef __MMI_DUAL_SIM_MASTER__
        if (CheckValidEmergencyNo1((PS8) cm_p->state_info.AllCalls[count].number, SIM1))
    #else /* __MMI_DUAL_SIM_MASTER__ */
        if (CheckValidEmergencyNo1((PS8) cm_p->state_info.AllCalls[count].number))
    #endif /* __MMI_DUAL_SIM_MASTER__ */
        {
            return TRUE;
        }
    }
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  SetWapCallPresent
 * DESCRIPTION
 *  Sets wap call present flag
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetWapCallPresent(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gWapCallPresent = flag;
}

/*****************************************************************************
 * FUNCTION
 *  SetPreviousCallWAP
 * DESCRIPTION
 *  Sets previous call is wap flag
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetPreviousCallWAP(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gPreviousWapCall = flag;
    return;
}


/*****************************************************************************
 * FUNCTION
 *  GetPreviousCallWAP
 * DESCRIPTION
 *  Returns previous call is wap flag
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
pBOOL GetPreviousCallWAP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gPreviousWapCall;
}

/*****************************************************************************
 * FUNCTION
 *  SetCallEndCause
 * DESCRIPTION
 *  Keep call end cause for error display after get time
 * PARAMETERS
 *  cause       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCallEndCause(U16 cause)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCallEndCause = cause;
}


/*****************************************************************************
 * FUNCTION
 *  GetCallEndCause
 * DESCRIPTION
 *  Gets previously saved call end cause for display error
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
U16 GetCallEndCause(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCallEndCause;
}

#ifdef __IP_NUMBER__


/*****************************************************************************
 * FUNCTION
 *  SetTempUseIPNumber
 * DESCRIPTION
 *  Enable/disable temporary IP dialing
 * PARAMETERS
 *  flag        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetTempUseIPNumber(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if(flag == MMI_TRUE)
    {
        gTempUseIPNum++;
    }
    else
    {
        if(gTempUseIPNum != 0)
        {
            gTempUseIPNum--;
        }
    }
    
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"Set IP dial flag %d,(count:%d)", flag, gTempUseIPNum);
}


/*****************************************************************************
 * FUNCTION
 *  GetTempUseIPNumber
 * DESCRIPTION
 *  Check if temporary IP dialing is enabled
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
pBOOL GetTempUseIPNumber(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(gTempUseIPNum > 0)
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"Get IP dial flag 1,(count:%d)", gTempUseIPNum);
        return MMI_TRUE;
    }
    else
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"Get IP dial flag 0,(count:%d)", gTempUseIPNum);
        return MMI_FALSE;
    }
}
#endif /* __IP_NUMBER__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetCMPhoneBookStruct
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pNumberStruct       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void SetCMPhoneBookStruct(PHB_CM_INTERFACE *pNumberStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 temp1[50];
    S8 temp2[50];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2_to_asc((PS8) temp1, (PS8) pNumberStruct->name);
    mmi_ucs2_to_asc((PS8) temp2, (PS8) pNumberStruct->number);
    PRINT_INFORMATION("*** SetCMPhoneBookStruct name=%s, number=%s\n", temp1, temp2);

    memcpy(&gPhoneNumberStruct, pNumberStruct, sizeof(PHB_CM_INTERFACE));
}


/*****************************************************************************
 * FUNCTION
 *  GetCMPhoneBookStruct
 * DESCRIPTION
 *  Gets the CMScrnFlag Flag Status
 * PARAMETERS
 *  void
 *  PHB_CM_INTERFACE(?)     [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
PHB_CM_INTERFACE *GetCMPhoneBookStruct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return &gPhoneNumberStruct;
}


/*****************************************************************************
 * FUNCTION
 *  SetSyncCallFromATFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetSyncCallFromATFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gSyncFromAT = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetSyncCallFromATFlag
 * DESCRIPTION
 *  Gets the CallDeflectFlag Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetSyncCallFromATFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gSyncFromAT;
}


/*****************************************************************************
 * FUNCTION
 *  SetCallDeflectFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetCallDeflectFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCallDeflectFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetCallDeflectFlag
 * DESCRIPTION
 *  Gets the CallDeflectFlag Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetCallDeflectFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCallDeflectFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetActivatedCcbsFlag
 * DESCRIPTION
 *  Sets the CCBS Activated Flag
 * PARAMETERS
 *  ccbsFlag        [IN]        
 *  TRUE(?)         [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetActivatedCcbsFlag(pBOOL ccbsFlag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* activate ccbs */
    gCcbsFlagActivated = ccbsFlag;
}


/*****************************************************************************
 * FUNCTION
 *  GetActivatedCcbsFlag
 * DESCRIPTION
 *  Gets the CCBS activated Flag
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetActivatedCcbsFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCcbsFlagActivated;
}


/*****************************************************************************
 * FUNCTION
 *  SetCCBSFlag
 * DESCRIPTION
 *  Sets the CCBS Flag
 * PARAMETERS
 *  ccbsFlag        [IN]        
 *  TRUE(?)         [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetCCBSFlag(pBOOL ccbsFlag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCcbsFlag = ccbsFlag;
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"SetCCBSFlag:%d", gCcbsFlag);
}


/*****************************************************************************
 * FUNCTION
 *  GetCCBSFlag
 * DESCRIPTION
 *  Gets the CCBS Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetCCBSFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"GetCCBSFlag:%d", gCcbsFlag);
    return gCcbsFlag;
}

/*****************************************************************************
 * FUNCTION
 *   SetCCBSHandle
 * DESCRIPTION
 *  Sets the CCBS Handle
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
void SetCCBSHandle(CM_CALL_HANDLE ccbsHandle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCcbsHandle = ccbsHandle;
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"SetCCBSHandle:%d", gCcbsHandle);
}

/*****************************************************************************
 * FUNCTION
 *  GetCCBSHandle
 * DESCRIPTION
 *  Gets the CCBS Handle
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
CM_CALL_HANDLE GetCCBSHandle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"GetCCBSHandle:%d", gCcbsHandle);
    return gCcbsHandle;
}

/*****************************************************************************
 * FUNCTION
 *   SetCCBSNumber
 * DESCRIPTION
 * 
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
void SetCCBSNumber(U8 *number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(gCcbsNumber, 0, sizeof(gCcbsNumber));
    mmi_ucs2cpy((S8*) gCcbsNumber, (S8*) number);
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"SetCCBSNumber:%s", gCcbsNumber);
}

/*****************************************************************************
 * FUNCTION
 *  GetCCBSNumber
 * DESCRIPTION
 * 
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
PU8 GetCCBSNumber(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G5_CALL,"GetCCBSNumber:%s", gCcbsNumber);
    return gCcbsNumber;
}

/*****************************************************************************
 * FUNCTION
 *  CCBSUpdateCallInfo
 * DESCRIPTION
 *  Updates CCBS Call Info
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void CCBSUpdateCallInfo(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CM_CALL_HANDLE tmp;
    S16 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    tmp = GetIncomingCallHandle();
    index = GetMMIStructIndexof(tmp);
    gtmpOutgoingIndex = index;

    cm_p->state_info.AllCalls[index].orgination_flag = CM_CALL_MO;
    SetCurrentState(CM_OUTGOING_STATE);
    SetCallState(index, CM_OUTGOING_STATE, FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  CMAllowInterrupt
 * DESCRIPTION
 *  Check if call management is in interruptable
 *  state for WAP to display screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 CMAllowInterrupt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count = (U8) GetTotalCallCount();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* idle screen not in history means it's in idle screen */
    if ((mmi_bootup_is_idle_screen_reached() == MMI_TRUE) && (IsScreenPresent(IDLE_SCREEN_ID) == FALSE))
    {
        /* idle screen allows WAP to show screen */
        return TRUE;
    }
    else if (mmi_ucm_app_total_call(MMI_UCM_CSD_CALL_TYPE) == 1 ||
                mmi_ucm_app_total_call(MMI_UCM_CSD_CALL_TYPE_SIM2) == 1)
    {
        /* in WAP call allows WAP to show screen */
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*****************************************************************************
 * FUNCTION
 *  LogCallInfoForCallHistory
 * DESCRIPTION
 *  Keep call info for call log before get time
 * PARAMETERS
 *  handle      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void LogCallInfoForCallHistory(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = GetMMIStructIndexof(handle);
    PRINT_INFORMATION("*** LogCallInfoForCallHistory call handle=%d, index=%d\n", handle, index);

    memcpy(&cm_p->state_info.CallStructureForCallLog, &cm_p->state_info.AllCalls[index], sizeof(CALL_INFO));
}


/*****************************************************************************
 * FUNCTION
 *  UpdateCallStartTimeAndLogCall
 * DESCRIPTION
 *  Helper function to get the call handle of the
 *  recent incoming/outgoing or active call
 * PARAMETERS
 *  handle      [IN]        
 *  t           [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void UpdateCallStartTimeAndLogCall(CM_CALL_HANDLE handle, MYTIME *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = GetMMIStructIndexof(handle);

    /* start call time reminder once call is connected */
    gCtrTime = GetCtrTime();

    memcpy(&cm_p->state_info.AllCalls[index].start_time, t, sizeof(MYTIME));

    /*memcpy(&cm_p->state_info.AllCalls[index].num,
            &cm_p->state_info.AllCalls[index].number,
            sizeof(cm_p->state_info.AllCalls[index].num));*/

    LogCallWithStartTime(&cm_p->state_info.AllCalls[index]);
}


/*****************************************************************************
 * FUNCTION
 *  UpdateCallStartTimeforWapCall
 * DESCRIPTION
 *  CallBack Called after Start Time For Wap Call Recieved from L4
 * PARAMETERS
 *  t       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void UpdateCallStartTimeforWapCall(MYTIME *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GetCallHandleForStartTimeUpdate())
    {
        UpdateCallStartTimeAndLogCall(GetCallHandleForStartTimeUpdate(), t);
        SetCallHandleForStartTimeUpdate(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetCallHandleForStartTimeUpdate
 * DESCRIPTION
 *  Saves the Call Handler for which start time is
 *  to be updated
 * PARAMETERS
 *  handle      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetCallHandleForStartTimeUpdate(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCallHandleForStartTimeUpdate = handle;
}


/*****************************************************************************
 * FUNCTION
 *  GetCallHandleForStartTimeUpdate
 * DESCRIPTION
 *  Returns the Call Handler for which start time is
 *  to be updated
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
CM_CALL_HANDLE GetCallHandleForStartTimeUpdate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCallHandleForStartTimeUpdate;
}


/*****************************************************************************
 * FUNCTION
 *  LogCall
 * DESCRIPTION
 *  Logs Call Duration for Current Call
 * PARAMETERS
 *  void
 *  CM_CALL_HANDLE(?)       [IN]        Of call
 * RETURNS
 *  void
 *****************************************************************************/
void LogCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // drop call refine
    // abort MO call state will be disconnecting, but also need to be logged
    if ((cm_p->state_info.CallStructureForCallLog.curr_state == CM_OUTGOING_STATE) ||
        (cm_p->state_info.CallStructureForCallLog.curr_state == CM_INCOMING_STATE) ||
        ((cm_p->state_info.CallStructureForCallLog.curr_state == CM_DISCONNECTING_STATE) &&
         (cm_p->state_info.CallStructureForCallLog.prev_state == CM_OUTGOING_STATE)))
    {
        /*memcpy(
            &cm_p->state_info.CallStructureForCallLog.num,
            &cm_p->state_info.CallStructureForCallLog.number,
            sizeof(cm_p->state_info.CallStructureForCallLog.num));*/
        LogCallWithStartTime(&cm_p->state_info.CallStructureForCallLog);
    }
}


/*****************************************************************************
 * FUNCTION
 *  LogCallWithStartTime
 * DESCRIPTION
 *  Logs Call with Start Time
 * PARAMETERS
 *  log     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void LogCallWithStartTime(CALL_INFO *log)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (CM_CALL_MO == log->orgination_flag)
    {
        CHISTLogDialedCall(log);
    }
    else if (CM_CALL_MT == log->orgination_flag)
    {
        CHISTLogRecvdCall(log);
    }
    else
    {
        PRINT_INFORMATION(" XXX In LogCallWithStartTime, no need to log\n");
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetEndTimeAndNotifyCallAborted
 * DESCRIPTION
 *  Sets Call Back for Call Aborted Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void GetEndTimeAndNotifyCallAborted(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CMGetExactTime(GetDateTimeAndNotifyCallAbortedCBack);
}


/*****************************************************************************
 * FUNCTION
 *  GetDateTimeAndNotifyCallAbortedCBack
 * DESCRIPTION
 *  Call Back Called after End Time For Call Aborted Retrieved
 * PARAMETERS
 *  t       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void GetDateTimeAndNotifyCallAbortedCBack(MYTIME *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(0);
}


/*****************************************************************************
 * FUNCTION
 *  GetEndTimeAndNotifyCallMissed
 * DESCRIPTION
 *  Sets Call Back for Call Missed Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void GetEndTimeAndNotifyCallMissed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(0);
}


/*****************************************************************************
 * FUNCTION
 *  GetDateTimeAndNotifyCallMissedCBack
 * DESCRIPTION
 *  Call Back Called after End Time For Call Missed Retrieved
 * PARAMETERS
 *  t       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void GetDateTimeAndNotifyCallMissedCBack(MYTIME *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(0);
}


/*****************************************************************************
 * FUNCTION
 *  GetEndTimeAndLogUnconnectedMOCall
 * DESCRIPTION
 *  Sets Call Back for MO Unconnected Call Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void GetEndTimeAndLogUnconnectedMOCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CMGetExactTime(GetDateTimeAndLogUnconnectedMOCallCBack);
}


/*****************************************************************************
 * FUNCTION
 *  GetDateTimeAndLogUnconnectedMOCallCBack
 * DESCRIPTION
 *  Call Back Called after End Time For Unconnected MO Call Retrieved
 * PARAMETERS
 *  t       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void GetDateTimeAndLogUnconnectedMOCallCBack(MYTIME *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memcpy(&cm_p->state_info.CallStructureForCallLog.start_time, t, sizeof(MYTIME));
    memcpy(&cm_p->state_info.CallStructureForCallLog.end_time, t, sizeof(MYTIME));
    LogCall();
}


/*****************************************************************************
 * FUNCTION
 *  GetEndTimeAndNotifyEndCallDuration
 * DESCRIPTION
 *  Sets Call Back for End Time Notify Screen
 * PARAMETERS
 *  handle      [IN]        
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void GetEndTimeAndNotifyEndCallDuration(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memcpy(
        &gTimeStructForEndedCallStartTime,
        &(cm_p->state_info.AllCalls[GetMMIStructIndexof(handle)].start_time),
        sizeof(MYTIME));

    memset(&temp, 0, sizeof(MYTIME));
    /* call end too fast before the call start time is recorded */
    if (!(memcmp(&gTimeStructForEndedCallStartTime, &temp, sizeof(MYTIME)) == 0))
    {
        DTGetRTCTime(&(cm_p->state_info.CallStructureForCallLog.end_time));
        if (CM_CALL_MO == cm_p->state_info.CallStructureForCallLog.orgination_flag ||
            CM_CALL_MO_STK == cm_p->state_info.CallStructureForCallLog.orgination_flag)
        {
            CHISTLogDialedCallDuration(&cm_p->state_info.CallStructureForCallLog);
        }
        else if (CM_CALL_MT == cm_p->state_info.CallStructureForCallLog.orgination_flag)
        {
            CHISTLogRecvdCallDuration(&cm_p->state_info.CallStructureForCallLog);
        }
    }
    
    CMGetExactTime(GetDateTimeAndNotifyEndCallDurationCBack);
}


/*****************************************************************************
 * FUNCTION
 *  GetDateTimeAndNotifyEndCallDurationCBack
 * DESCRIPTION
 *  Call Back Called after End Time For Call Retrieved
 * PARAMETERS
 *  t           [?]         
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void GetDateTimeAndNotifyEndCallDurationCBack(MYTIME *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&temp, 0, sizeof(MYTIME));

    /* call end too fast before the call start time is recorded */
    if (memcmp(&gTimeStructForEndedCallStartTime, &temp, sizeof(MYTIME)) == 0)
    {
        memcpy(&cm_p->state_info.CallStructureForCallLog.start_time, t, sizeof(MYTIME));
        memcpy(&cm_p->state_info.CallStructureForCallLog.end_time, t, sizeof(MYTIME));
        memset(&gTimeStructForCallDuration, 0, sizeof(MYTIME));
        memcpy(
            &cm_p->state_info.CallStructureForCallLog.num,
            &cm_p->state_info.CallStructureForCallLog.number,
            sizeof(cm_p->state_info.CallStructureForCallLog.num));
        LogCallWithStartTime(&cm_p->state_info.CallStructureForCallLog);
    }
    else
    {
        /* overflow 2030/12/31/23:59:59 */
        if (gTimeStructForEndedCallStartTime.nYear == 2030 && 
            t->nYear < gTimeStructForEndedCallStartTime.nYear)
        {
            t->nYear = gTimeStructForEndedCallStartTime.nYear;
            t->nMonth = gTimeStructForEndedCallStartTime.nMonth;
            t->nDay = gTimeStructForEndedCallStartTime.nDay+1;
        }
        if (NULL == GetTimeDifference(t, &gTimeStructForEndedCallStartTime, &gTimeStructForCallDuration))
        {
            MMI_TRACE(MMI_TRACE_G5_CM, MMI_CM_ERROR_CallEnd);
            PRINT_INFORMATION("\nCall Handle: %d", cm_p->state_info.CallStructureForCallLog.call_handle);
            PRINT_INFORMATION("\nCall Current State: %d", cm_p->state_info.CallStructureForCallLog.curr_state);
            PRINT_INFORMATION("\nCall Previous State: %d", cm_p->state_info.CallStructureForCallLog.prev_state);
            PRINT_INFORMATION("\nCall Origin: %d", cm_p->state_info.CallStructureForCallLog.orgination_flag);
            PRINT_INFORMATION("\nStart Time : Hour:%d ,Min:%d ,Sec:%d ", gTimeStructForEndedCallStartTime.nHour,
                               gTimeStructForEndedCallStartTime.nMin, gTimeStructForEndedCallStartTime.nSec);
            PRINT_INFORMATION("\nEnd Time : Hour:%d ,Min:%d ,Sec:%d ", t->nHour, t->nMin, t->nSec);
        }

        memcpy(&cm_p->state_info.CallStructureForCallLog.start_time, &gTimeStructForEndedCallStartTime, sizeof(MYTIME));
        memcpy(&cm_p->state_info.CallStructureForCallLog.end_time, t, sizeof(MYTIME));
        //LogCall();        
    }

    EntryScr1004NotifyEndCallDuration();
    memset(&cm_p->state_info.CallStructureForCallLog, 0, sizeof(CALL_INFO));
}


/*****************************************************************************
 * FUNCTION
 *  CheckCtrExpiry
 * DESCRIPTION
 *  Checks if call-time reminder tone is
 *  to be played
 * PARAMETERS
 *  void
 *  Time(?)     [IN]        Structure t
 * RETURNS
 *  void
 *****************************************************************************/
void CheckCtrExpiry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME curr_time, *start_time, duration;
    U32 duration1, duration2;
    U8 status;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StartTimer(CM_CTR_TIMER, 1000, CheckCtrExpiry);

    DTGetRTCTime(&curr_time);
    start_time = GetStartCallTime();
    if (start_time == NULL)
    {
        return;
    }
    GetTimeDifference(&curr_time, start_time, &duration);

    duration1 =
        cm_p->alert_info.LastCTRTime.nHour * 60 * 60 + cm_p->alert_info.LastCTRTime.nMin * 60 +
        cm_p->alert_info.LastCTRTime.nSec;
    duration2 = duration.nHour * 60 * 60 + duration.nMin * 60 + duration.nSec;

#ifdef __MMI_CH_QUICK_END__
    if (cm_p->alert_info.QuickEndTime > 0 &&
        cm_p->alert_info.QuickEndTime != 0xffff && cm_p->alert_info.QuickEndTime <= duration2)
    {
        StopTimer(CM_CTR_TIMER);
        if (!(GetTotalCallCount() == 1 &&
              (GetCurrentState() == CM_INCOMING_STATE || GetCurrentState() == CM_OUTGOING_STATE)) &&
              !EmergencyCallPresent())
        {
            KbCBackEndAllCallsExceptIncoming();
        }
        return;
    }
#endif /* __MMI_CH_QUICK_END__ */ 

    status = GetCtrStatus();
    if ((status != CTR_OFF) && (duration1 <= duration2))
    {
        if (status == CTR_PERIODIC)
        {
            if ((cm_p->alert_info.LastCTRTime.nSec < gCtrTime) &&
                ((gCtrTime <= duration.nSec) || (cm_p->alert_info.LastCTRTime.nSec > duration.nSec)))
            {
                playRequestedTone(CALL_REMINDER_TONE);
            }
        }
        else
        {
            if (duration1 < gCtrTime && gCtrTime <= duration2)
            {
                if (cm_p->alert_info.QuickEndTime == 0)
                {
                    StopTimer(CM_CTR_TIMER);
                }
                playRequestedTone(CALL_REMINDER_TONE);
            }
        }
    }
    memcpy(&cm_p->alert_info.LastCTRTime, &duration, sizeof(MYTIME));
}


/*****************************************************************************
 * FUNCTION
 *  InitializeTimeStructure
 * DESCRIPTION
 *  Function gets the initialize the time structure before displaying the call
 * PARAMETERS
 *  time        [IN]        Time strucutre to initialize
 *  t           [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void InitializeTimeStructure(TIMEANDINDEX *time, MYTIME *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME tmpTime;
    TIMEANDINDEX tmpTimeBuf;
    TIMEANDINDEX tmpArr[MAX_CALLS];
    U8 validTimes = 0;
    U8 count;
    U8 j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(tmpArr, 0, (sizeof(TIMEANDINDEX) * MAX_CALLS));
    memcpy(&tmpTime, t, sizeof(tmpTime));

    for (count = 0; count != MAX_CALLS; count++)
    {
        // Start by Julia: Drop call refinement - add CM_DISCONNECTING_STATE condition
        // first get diff of all times
        if (cm_p->state_info.AllCalls[count].call_handle != -1 &&
            (cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE ||
             cm_p->state_info.AllCalls[count].curr_state == CM_HOLD_STATE ||
             cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE))
            /* End by Julia */
        {
            if (GetTimeDifference(&tmpTime, &cm_p->state_info.AllCalls[count].start_time, &(tmpArr[validTimes].time)) !=
                NULL)
            {
                tmpArr[validTimes].index = count;
                validTimes++;
            }
        }
    }

    for (count = 0; count < validTimes - 1; count++)
    {
        for (j = 0; j < validTimes - 1 - count; j++)
        {
            if (FindMaxTime(&tmpArr[j].time, &tmpArr[j + 1].time))
            {
                memcpy(&tmpTimeBuf, &tmpArr[j], sizeof(tmpTimeBuf));
                memcpy(&tmpArr[j], &tmpArr[j + 1], sizeof(tmpTimeBuf));
                memcpy(&tmpArr[j + 1], &tmpTimeBuf, sizeof(tmpTimeBuf));
            }
        }
    }
    memcpy(time, &tmpArr[validTimes - 1], sizeof(tmpArr[validTimes - 1]));
    cm_p->state_info.OldestCallIndex = time->index;

    if ((GetCtrStatus() != CTR_OFF && cm_p->alert_info.IsCTRStart == FALSE)
#ifdef __MMI_CH_QUICK_END__
        || cm_p->alert_info.QuickEndTime > 0
#endif 
        )
    {
        /* start call time reminder timer */
        cm_p->alert_info.IsCTRStart = TRUE;
        if (IsMyTimerExist(CM_CTR_TIMER) == MMI_FALSE)
        {
            StartTimer(CM_CTR_TIMER, 1000, CheckCtrExpiry);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetStartCallTime
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
MYTIME *GetStartCallTime(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cm_p->state_info.AllCalls[cm_p->state_info.OldestCallIndex].call_handle == -1)
    {
        TIMEANDINDEX timeStruct;
        MYTIME t;

        DTGetRTCTime(&t);
        InitializeTimeStructure(&timeStruct, &t);
        if (GetTotalCallCount() == 0)
        {
            return NULL;
        }
    }
    return &(cm_p->state_info.AllCalls[cm_p->state_info.OldestCallIndex].start_time);
}


/*****************************************************************************
 * FUNCTION
 *  SetPriorityCall
 * DESCRIPTION
 *  Sets the Priority Call Option
 * PARAMETERS
 *  priority        [IN]        
 *  True(?)         [IN]        If the call is a priority call
 * RETURNS
 *  void
 *****************************************************************************/
void SetPriorityCall(pBOOL priority)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gPriority = priority;
}


/*****************************************************************************
 * FUNCTION
 *  GetPriorityCall
 * DESCRIPTION
 *  Gets the current priority status
 * PARAMETERS
 *  void
 *  TRUE(?)     [IN]        For set FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetPriorityCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gPriority;
}


/*****************************************************************************
 * FUNCTION
 *  SetDialedDigitCalledFlag
 * DESCRIPTION
 *  
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [IN]        For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetDialedDigitCalledFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gDialedDigitCalledFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetDialedDigitCalledFlag
 * DESCRIPTION
 *  Gets the ActiveToHold Flag Status
 * PARAMETERS
 *  void
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetDialedDigitCalledFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gDialedDigitCalledFlag;
}


/*****************************************************************************
 * FUNCTION
 *  SetSATScrnSavedFlag
 * DESCRIPTION
 *  Sets SAT Screen Saved Flag
 * PARAMETERS
 *  flag        [IN]        
 *  TRUE(?)     [OUT]       For set, FALSE for not set
 * RETURNS
 *  void
 *****************************************************************************/
void SetSATScrnSavedFlag(pBOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gSATScrnSavedFlag = flag;
}


/*****************************************************************************
 * FUNCTION
 *  GetSATScrnSavedFlag
 * DESCRIPTION
 *  Returns SAT Screen Saved Flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetSATScrnSavedFlag(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gSATScrnSavedFlag;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ucm_act_req
 * DESCRIPTION
 *  function which is called by UCM
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_ucm_act_req(U8 op_code, void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (op_code)
    {
    	case MMI_UCM_DIAL:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_DIAL);
            mmi_gsm_dial(act_struct);
            break;
			
    	case MMI_UCM_HOLD_AND_DIAL:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_HOLD_AND_DIAL);
            mmi_gsm_hold_and_dial(act_struct);
            break;
			
    	case MMI_UCM_ACCEPT:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_ACCEPT);
            mmi_gsm_accept(act_struct);
            break;

    	case MMI_UCM_HOLD_AND_ACCEPT:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_HOLD_AND_ACCEPT);
            mmi_gsm_hold_and_accept(act_struct);
            break;
			
    	case MMI_UCM_HOLD:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_HOLD);
            mmi_gsm_hold(act_struct);
            break;
			
    	case MMI_UCM_RETRIEVE:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_RETRIEVE);
            mmi_gsm_retrieve(act_struct);
            break;
			
    	case MMI_UCM_SWAP:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_SWAP);
            mmi_gsm_swap(act_struct);
            break;
			
    	case MMI_UCM_CONFERENCE:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_CONFERENCE);
            mmi_gsm_conference(act_struct);
            break;
			
    	case MMI_UCM_SPLIT:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_SPLIT);
            mmi_gsm_split(act_struct);
            break;
			
    	case MMI_UCM_DEFLECT:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_DEFLECT);
            mmi_gsm_deflect(act_struct);
            break;
			
    	case MMI_UCM_END_SINGLE:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_END_SINGLE);
            mmi_gsm_end_single(act_struct);
            break;
			
    	case MMI_UCM_END_CONFERENCE:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_END_CONFERENCE);
            mmi_gsm_end_conference(act_struct);
            break;
			
    	case MMI_UCM_END_ALL:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_END_ALL);
            mmi_gsm_end_all(act_struct);
            break;
			
    	case MMI_UCM_FORCE_RELEASE:
            //cm_p->ucm_sub_operation = MMI_GSM_UCM_FORCE_RELEASE;
            mmi_gsm_force_release(act_struct);
            break;
			
    	case MMI_UCM_AUTO_REJECT:
            cm_p->ucm_sub_operation = MMI_GSM_UCM_AUTO_REJECT;
            mmi_gsm_auto_reject(act_struct);
            break;
			
    	case MMI_UCM_EXPLICT_CALL_TRANSFER:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_EXPLICT_CALL_TRANSFER);
            mmi_gsm_explicit_call_transfer(act_struct);
            break;
			
    	case MMI_UCM_END_ACTIVE_AND_RETRIEVE:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_END_ACTIVE_AND_RETRIEVE);
            mmi_gsm_end_active_and_retrieve(act_struct);
            break;
			
    	case MMI_UCM_END_ACTIVE_AND_ACCEPT:
            SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_END_ACTIVE_AND_ACCEPT);
            mmi_gsm_end_active_and_accept(act_struct);
            break;
			
        case MMI_UCM_START_DTMF:
            //SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_SENDING_DTMF);
            mmi_gsm_start_dtmf(act_struct);
            break;

        case MMI_UCM_STOP_DTMF:
            //SetUCMOperationState(MMI_GSM_UCM_NORMAL, MMI_GSM_UCM_IDLE);
            mmi_gsm_stop_dtmf(act_struct);
            break;
            
    	default:
        	break;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_dial
 * DESCRIPTION
 *  action req: MMI_GSM_UCM_DIAL
 * PARAMETERS
 *  mmi_ucm_dial_req_struct
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_dial(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 dial_number[MAX_NUMBER];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_dial REQ");
    cm_p->ucm_source_id = ((mmi_ucm_dial_req_struct*) act_struct)->source_id;    

    if ((strlen((void *)((mmi_ucm_dial_req_struct*) act_struct)->num_uri) * ENCODING_LENGTH) >= MAX_NUMBER)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_dial REQ: number is too long");
        ShowCallManagementErrorMessage(ERR_INVALID_NUMBER_FORMAT, cm_p->ucm_operation);
        return;
    }
    
    memset(dial_number, 0, MAX_NUMBER);
    mmi_asc_to_ucs2((PS8) dial_number, (PS8)((mmi_ucm_dial_req_struct*) act_struct)->num_uri);

    if(GetCCBSFlag() == TRUE)
    {
        mmi_gsm_ccbs_recall();
        return;
    }
#ifdef __SAT__
    if(((mmi_ucm_dial_req_struct*) act_struct)->module_id == MMI_UCM_FROM_SAT)
    {
        MakeSATCall((PU8)dial_number);
    }
    else
#endif /* __SAT__ */
    if(((mmi_ucm_dial_req_struct*) act_struct)->module_id == MMI_UCM_FROM_ABM)
    {
        MakeCSDForABM((PS8)((mmi_ucm_dial_req_struct*) act_struct)->num_uri, MMI_UCM_MAX_NUM_URI_LEN, CSMCC_CSD_CALL);
    }
    else
    {
        MakeCall((PS8)dial_number);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_dial_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_dial_rsp(BOOL result, U8 opcode, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_dial_act_rsp_struct dial_rsp;
    PHB_CM_INTERFACE *PhoneNumberStruct;
    U16 count,shift;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);
    
    memset(&dial_rsp, 0, sizeof(mmi_ucm_dial_act_rsp_struct));
    
    dial_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(dial_rsp.call_list);

    if(result == FALSE)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: FALSE");
    
        /*Don't send fail outgoing call to UCM*/
        for (count = 0; count < MAX_CALLS; count++)
        {
            if(dial_rsp.call_list->call_info[count].call_state == MMI_UCM_OUTGOING_STATE)
            {
                PRINT_INFORMATION("mmi_gsm_dial_rsp RSP: FALSE, remove fail MO call from call list");
                memset(&(dial_rsp.call_list->call_info[count]), 0, sizeof(mmi_ucm_call_info_struct));
                dial_rsp.call_list->total_num --;

                for(shift = count; shift < MAX_CALLS - 1; shift ++)
                {
                    PRINT_INFORMATION("mmi_gsm_dial_rsp RSP: FALSE, shift call list [%d]call id:%d to [%d]call id:%d", 
                        shift+1, dial_rsp.call_list->call_info[shift + 1].uid_info.call_id, shift, dial_rsp.call_list->call_info[shift].uid_info.call_id);
                    memcpy(&(dial_rsp.call_list->call_info[shift]), &(dial_rsp.call_list->call_info[shift + 1]), sizeof(mmi_ucm_call_info_struct));
                    memset(&(dial_rsp.call_list->call_info[shift + 1]), 0, sizeof(mmi_ucm_call_info_struct));
                }
                break;
            }
        }
        
        dial_rsp.result_info.result = FALSE;
        dial_rsp.result_info.error_msg = error_msg;
        mmi_ucm_dispatch_rsp(MMI_UCM_DIAL, MMI_UCM_VOICE_CALL_TYPE, (void *)&dial_rsp);

    #ifdef __IP_NUMBER__
        SetTempUseIPNumber(FALSE);
    #endif     
    }
    else
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: TRUE");
        
        if(opcode == CC_OPERATION)
	    {
		    dial_rsp.result_info.result = TRUE;
            
            /*remote info*/
            for (count = 0; count < MAX_CALLS; count++)
            {
                if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE)
                {
                    mmi_ucs2_n_to_asc(
                        (S8 *)dial_rsp.remote_info.num_uri,
                        (S8 *)cm_p->state_info.AllCalls[count].number,
                        MMI_UCM_MAX_NUM_URI_LEN);
                    PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: number:%s", dial_rsp.remote_info.num_uri);

                    mmi_ucs2ncpy((S8 *)dial_rsp.remote_info.disp_name,
                                (S8 *)GetDispNameorNum(cm_p->state_info.AllCalls[count].call_handle),
                                MMI_UCM_MAX_DISP_NAME_LEN - 1);
                 
                    PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: display name:%s", dial_rsp.remote_info.disp_name);
                    
                    mmi_ucs2ncpy((S8 *)dial_rsp.remote_info.log_name,
                                (S8*) GetCallLogName(cm_p->state_info.AllCalls[count].call_handle),
                                MAX_PB_NAME_LENGTH);
                    PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: log name:%s", dial_rsp.remote_info.log_name);

                }
            } 

            /*alert info*/
            PhoneNumberStruct = GetCMPhoneBookStruct();
            if (PhoneNumberStruct->pictureId == IMG_PHB_DEFAULT)
            {
            #ifdef __MMI_VIDEO_TELEPHONY__
                if (GetOutCallType() == CSMCC_VIDEO_CALL)
                {
                    dial_rsp.alert_info.image_info.image_id = IMG_ID_VT_OUTGOING_CALL;
                }
                else
            #endif /* __MMI_VIDEO_TELEPHONY__ */
                {
                    dial_rsp.alert_info.image_info.image_id = IMG_CM_STATE_OUTGOING;
                }                
            }
            else
            {
                dial_rsp.alert_info.image_info.image_id = PhoneNumberStruct->pictureId;
            }
            PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: picureID:%d", dial_rsp.alert_info.image_info.image_id);
            dial_rsp.alert_info.image_info.record_index = PhoneNumberStruct->record_index; 
            PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: record_index:%d", dial_rsp.alert_info.image_info.record_index);

            /*Only allow caller image for outgoing call*/
            //dial_rsp.alert_info.image_info.video_id = PhoneNumberStruct->videoId;
            PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: videoId:%d", dial_rsp.alert_info.image_info.video_id);
            //dial_rsp.alert_info.image_info.video_record_index = PhoneNumberStruct->video_record_index;
            PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: video_record_index:%d", dial_rsp.alert_info.image_info.video_record_index);
                        
        #ifdef __IP_NUMBER__
            if (GetTempUseIPNumber() == TRUE && GetCurrIPNumberUCS2() != NULL)
            {
                mmi_ucs2ncpy((S8 *)dial_rsp.alert_info.ip_num, (S8 *)GetCurrIPNumberUCS2(), MMI_UCM_MAX_IP_NUMBER_LEN);
            }
        #endif /* __IP_NUMBER__ */ 

		    mmi_ucm_dispatch_rsp(MMI_UCM_DIAL, MMI_UCM_VOICE_CALL_TYPE, (void *)&dial_rsp);
	    }
	    else if(opcode == SS_OPERATION)
	    {
		    dial_rsp.result_info.result = FALSE;
		    dial_rsp.result_info.error_msg = NULL;
		    mmi_ucm_dispatch_rsp(MMI_UCM_DIAL, MMI_UCM_VOICE_CALL_TYPE, (void *)&dial_rsp);
            
            #ifdef __IP_NUMBER__
                SetTempUseIPNumber(FALSE);
            #endif 
	    }
    }
    OslMfree(dial_rsp.call_list);	
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_dial
 * DESCRIPTION
 *  action req: MMI_GSM_UCM_HOLD_AND_DIAL
 *  action rsp: after ss_parsing_rsp->dial_ind->get_call_list_rsp
 * PARAMETERS
 *  mmi_ucm_hold_n_dial_req_struct
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_hold_and_dial(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 dial_number[MAX_NUMBER];

    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_dial REQ");
    cm_p->ucm_source_id = ((mmi_ucm_hold_n_dial_req_struct*) act_struct)->source_id;
    
    if(GetTotalActiveCallCount() > 0)
    {
        memset(dial_number, 0, MAX_NUMBER);
        mmi_asc_to_ucs2((PS8) dial_number, (PS8)((mmi_ucm_hold_n_dial_req_struct*) act_struct)->num_uri);

        if(GetCCBSFlag() == TRUE)
        {
            mmi_gsm_ccbs_recall();
            return;
        }
    #ifdef __SAT__
        if(((mmi_ucm_hold_n_dial_req_struct*) act_struct)->module_id == MMI_UCM_FROM_SAT)
        {
            MakeSATCall((PU8)dial_number);
        }
        else
    #endif /* __SAT__ */
        {
            MakeCall((PS8)dial_number);
        }
        return;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_hold_and_dial_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_hold_and_dial_rsp(BOOL result, U8 opcode, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_dial_act_rsp_struct hold_and_dial_rsp;
    PHB_CM_INTERFACE *PhoneNumberStruct;
    U16 count, shift;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&hold_and_dial_rsp, 0, sizeof(mmi_ucm_dial_act_rsp_struct));
    
    hold_and_dial_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(hold_and_dial_rsp.call_list);

    if(result == FALSE)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_dial_rsp: FALSE");

        /*Don't send fail outgoing call to UCM*/
        for (count = 0; count < MAX_CALLS; count++)
        {
            if(hold_and_dial_rsp.call_list->call_info[count].call_state == MMI_UCM_OUTGOING_STATE)
            {
                PRINT_INFORMATION("mmi_gsm_hold_and_dial_rsp: FALSE, remove fail MO call from call list");
                memset(&(hold_and_dial_rsp.call_list->call_info[count]), 0, sizeof(mmi_ucm_call_info_struct));
                hold_and_dial_rsp.call_list->total_num --;

                for(shift = count; shift < MAX_CALLS - 1; shift ++)
                {
                    PRINT_INFORMATION("mmi_gsm_hold_and_dial_rsp: FALSE, shift call list [%d]call id:%d to [%d]call id:%d", 
                        shift+1, hold_and_dial_rsp.call_list->call_info[shift + 1].uid_info.call_id, shift, hold_and_dial_rsp.call_list->call_info[shift].uid_info.call_id);
                    memcpy(&(hold_and_dial_rsp.call_list->call_info[shift]), &(hold_and_dial_rsp.call_list->call_info[shift + 1]), sizeof(mmi_ucm_call_info_struct));
                    memset(&(hold_and_dial_rsp.call_list->call_info[shift + 1]), 0, sizeof(mmi_ucm_call_info_struct));
                }
                break;
            }
        }
        
        hold_and_dial_rsp.result_info.result = FALSE;
        hold_and_dial_rsp.result_info.error_msg = error_msg;
        mmi_ucm_dispatch_rsp(MMI_UCM_HOLD_AND_DIAL, MMI_UCM_VOICE_CALL_TYPE, (void *)&hold_and_dial_rsp);

    #ifdef __IP_NUMBER__
        SetTempUseIPNumber(FALSE);
    #endif   
    }
    else if(opcode == CC_OPERATION)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_dial_rsp: TRUE");
        hold_and_dial_rsp.result_info.result = TRUE;

        /*remote info*/
        for (count = 0; count < MAX_CALLS; count++)
        {
            if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE)
            {
                mmi_ucs2_n_to_asc(
                    (S8 *)hold_and_dial_rsp.remote_info.num_uri,
                    (S8 *)cm_p->state_info.AllCalls[count].number,
                    MMI_UCM_MAX_NUM_URI_LEN);
                PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_dial_rsp RSP: number:%s", hold_and_dial_rsp.remote_info.num_uri);

                mmi_ucs2ncpy((S8 *)hold_and_dial_rsp.remote_info.disp_name,
                            (S8 *)GetDispNameorNum(cm_p->state_info.AllCalls[count].call_handle),
                            MMI_UCM_MAX_DISP_NAME_LEN - 1);
                
                PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_dial_rsp RSP: display name:%s", hold_and_dial_rsp.remote_info.disp_name);
                
                mmi_ucs2ncpy((S8 *)hold_and_dial_rsp.remote_info.log_name,
                            (S8*) GetCallLogName(cm_p->state_info.AllCalls[count].call_handle),
                            MAX_PB_NAME_LENGTH);
                PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_dial_rsp RSP: log name:%s", hold_and_dial_rsp.remote_info.log_name);
                
            }
        } 
        
        /*alert info*/
        PhoneNumberStruct = GetCMPhoneBookStruct();
        if (PhoneNumberStruct->pictureId == IMG_PHB_DEFAULT)
        {
        #ifdef __MMI_VIDEO_TELEPHONY__
            if (GetOutCallType() == CSMCC_VIDEO_CALL)
            {
                hold_and_dial_rsp.alert_info.image_info.image_id = IMG_ID_VT_OUTGOING_CALL;
            }
            else
        #endif /* __MMI_VIDEO_TELEPHONY__ */
            {
                hold_and_dial_rsp.alert_info.image_info.image_id = IMG_CM_STATE_OUTGOING;
            }                
        }
        else
        {
            hold_and_dial_rsp.alert_info.image_info.image_id = PhoneNumberStruct->pictureId;
        }
        PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: picureID:%d", hold_and_dial_rsp.alert_info.image_info.image_id);
        hold_and_dial_rsp.alert_info.image_info.record_index = PhoneNumberStruct->record_index; 
        PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: record_index:%d", hold_and_dial_rsp.alert_info.image_info.record_index);

        /*Only allow caller image for outgoing call*/
        //hold_and_dial_rsp.alert_info.image_info.video_id = PhoneNumberStruct->videoId;
        PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: videoId:%d", hold_and_dial_rsp.alert_info.image_info.video_id);
        //hold_and_dial_rsp.alert_info.image_info.video_record_index = PhoneNumberStruct->video_record_index;
        PRINT_INFORMATION("GSM call application: mmi_gsm_dial_rsp RSP: video_record_index:%d", hold_and_dial_rsp.alert_info.image_info.video_record_index);

    #ifdef __IP_NUMBER__
        if (GetTempUseIPNumber() == TRUE && GetCurrIPNumberUCS2() != NULL)
        {
            mmi_ucs2ncpy((S8 *)hold_and_dial_rsp.alert_info.ip_num, (S8 *)GetCurrIPNumberUCS2(), MMI_UCM_MAX_IP_NUMBER_LEN);
        }
    #endif /* __IP_NUMBER__ */ 
    
		mmi_ucm_dispatch_rsp(MMI_UCM_HOLD_AND_DIAL, MMI_UCM_VOICE_CALL_TYPE, (void *)&hold_and_dial_rsp);
	}
	else if(opcode == SS_OPERATION)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_dial_rsp: TRUE");
    
		hold_and_dial_rsp.result_info.result = FALSE;
		hold_and_dial_rsp.result_info.error_msg = NULL;
		mmi_ucm_dispatch_rsp(MMI_UCM_HOLD_AND_DIAL, MMI_UCM_VOICE_CALL_TYPE, (void *)&hold_and_dial_rsp);

        #ifdef __IP_NUMBER__
            SetTempUseIPNumber(FALSE);
        #endif 
	}
    OslMfree(hold_and_dial_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_accept
 * DESCRIPTION
 *  action req: MMI_GSM_UCM_HOLD_AND_DIAL
 *  action rsp: after ata_rsp
 * PARAMETERS
 *  mmi_ucm_single_call_struct
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_accept(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_accept REQ");
    cm_p->ucm_source_id = ((mmi_ucm_single_call_struct*) act_struct)->source_id;
    
    if(GetIncomingCallHandle() != -1)
    {
		//MakePsActiveHold((void*)PsCBackActiveCallsHeld);
        MakePsCallAcceptIncoming((void*)PsCBackIncomingCallAccepted);
        return;
	}
	/*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_accept_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_accept_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_act_rsp_struct accept_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&accept_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    accept_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(accept_rsp.call_list);
	
    if(result == FALSE)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_accept_rsp RSP: FALSE");

        accept_rsp.result_info.result = FALSE;
        accept_rsp.result_info.error_msg = error_msg;
        mmi_ucm_dispatch_rsp(MMI_UCM_ACCEPT, MMI_UCM_VOICE_CALL_TYPE, (void *)&accept_rsp);
    }
    else
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_accept_rsp RSP: TRUE");
    
        accept_rsp.result_info.result = TRUE;

#ifdef __MMI_VIDEO_TELEPHONY__    
    if (GetActiveCallType() == CSMCC_VIDEO_CALL)
    {
        /* Turn on speech */
        mmi_gsm_speech_ind(MMI_TRUE, MDI_AUDIO_SPEECH_APP_ID_3G324M, MMI_UCM_VIDEO_CALL_TYPE);

        if (g_vt_p->setting.answer_mode == MMI_VT_ANSWER_MODE_START_CAMERA)
        {
            mmi_vt_set_camera_status(MMI_TRUE);
        }
        /* for stop and prompt cases  */
        else
        {
            mmi_vt_set_camera_status(MMI_FALSE);
        }
    }
#endif /* __MMI_VIDEO_TELEPHONY__ */

        mmi_ucm_dispatch_rsp(MMI_UCM_ACCEPT, MMI_UCM_VOICE_CALL_TYPE, (void *)&accept_rsp);

#ifdef __MMI_VIDEO_TELEPHONY__
    if (GetActiveCallType() == CSMCC_VIDEO_CALL)
    {
        if (g_vt_p->setting.answer_mode == MMI_VT_ANSWER_MODE_PROMPT)
        {
            mmi_ucm_display_cnf_struct cnf;

            memset(&cnf, 0, sizeof(cnf));

            cnf.content = (U8*)GetString(STR_ID_VT_START_CAMERA_QUERY);
            cnf.lsk_str = STR_GLOBAL_YES;
            cnf.rsk_str = STR_GLOBAL_NO;
            cnf.lsk_hdlr = mmi_vt_start_camera_query_yes;
            cnf.rsk_hdlr = mmi_vt_start_camera_query_no;

            mmi_ucm_dispatch_cnf(MMI_UCM_DISPLAY_CNF, (void*)&cnf);

            StartTimer(VT_START_CAMERA_QUERY_TIMER, MMI_VT_START_CAMERA_QUERY_TIMEOUT, mmi_vt_start_camera_query_timeout);
        }
    }
#endif /* __MMI_VIDEO_TELEPHONY__ */

    }
    OslMfree(accept_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_accept_req_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_accept_req_ind(CM_CALL_HANDLE handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_answer_req_ind_struct accept_req_ind;
    U16 count;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
    memset(&accept_req_ind, 0, sizeof(mmi_ucm_answer_req_ind_struct));
    accept_req_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(accept_req_ind.call_list);

    /* UID info*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if(cm_p->state_info.AllCalls[count].call_handle == handle)
        {
            accept_req_ind.uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
            accept_req_ind.uid_info.group_id= cm_p->state_info.AllCalls[count].group_id;
            accept_req_ind.uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);
        }
    }
	
    mmi_ucm_dispatch_ind(MMI_UCM_ANSWER_REQ_IND, (void *)&accept_req_ind);
    OslMfree(accept_req_ind.call_list);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_hold_and_accept
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_hold_and_accept(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_accept REQ");
    cm_p->ucm_source_id = ((mmi_ucm_multiple_call_struct*) act_struct)->source_id;
    
    MakePsActiveHold((void*)PsCBackActiveCallsHeld);
    return;

    /*if(GetIncomingCallHandle() != -1)
    {
        MakePsActiveHold((void*)PsCBackActiveCallsHeld);
        return;
    }*/
    /*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_hold_and_accept_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_hold_and_accept_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct hold_and_accept_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&hold_and_accept_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    hold_and_accept_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(hold_and_accept_rsp.call_list);
    
	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_accept_rsp: FALSE");
    
		hold_and_accept_rsp.result_info.result = FALSE;
		hold_and_accept_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_HOLD_AND_ACCEPT, MMI_UCM_VOICE_CALL_TYPE, (void *)&hold_and_accept_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_hold_and_accept_rsp: TRUE");
    
		hold_and_accept_rsp.result_info.result = TRUE;
		mmi_ucm_dispatch_rsp(MMI_UCM_HOLD_AND_ACCEPT, MMI_UCM_VOICE_CALL_TYPE, (void *)&hold_and_accept_rsp);
	}
	OslMfree(hold_and_accept_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_hold
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_hold(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_hold REQ");
    cm_p->ucm_source_id = ((mmi_ucm_single_call_struct*) act_struct)->source_id;
    
	if(GetTotalActiveCallCount() > 0)
	{
		MakePsActiveHold((void*)PsCBackActiveCallsHeld);
		return;
	}	
	/*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_hold_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_hold_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct hold_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&hold_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    hold_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(hold_rsp.call_list);
 
	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_hold_rsp: FALSE");
    
		hold_rsp.result_info.result = FALSE;
		hold_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_HOLD, MMI_UCM_VOICE_CALL_TYPE, (void *)&hold_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_hold_rsp: TRUE");
    
		hold_rsp.result_info.result = TRUE;
		mmi_ucm_dispatch_rsp(MMI_UCM_HOLD, MMI_UCM_VOICE_CALL_TYPE, (void *)&hold_rsp);
	}
    OslMfree(hold_rsp.call_list);	
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_retrieve
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_retrieve(void *act_struct)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_retrieve REQ");
    cm_p->ucm_source_id = ((mmi_ucm_single_call_struct*) act_struct)->source_id;
    
	/*Check if there is any held call to retrieve*/
	if(GetTotalHoldCallCount() > 0)
	{
		MakePsActiveHold((void*)RetrieveReqSucess);
		return;
	}
	/*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_retrieve_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_retrieve_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct retrieve_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&retrieve_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    retrieve_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(retrieve_rsp.call_list);

	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_retrieve_rsp: FALSE");
    
		retrieve_rsp.result_info.result = FALSE;
		retrieve_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_RETRIEVE, MMI_UCM_VOICE_CALL_TYPE, (void *)&retrieve_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_retrieve_rsp: TRUE");
    
		retrieve_rsp.result_info.result = TRUE;        
		mmi_ucm_dispatch_rsp(MMI_UCM_RETRIEVE, MMI_UCM_VOICE_CALL_TYPE, (void *)&retrieve_rsp);
	}
	OslMfree(retrieve_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_swap
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_swap(void *act_struct)
{
    /*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_swap REQ");
    cm_p->ucm_source_id = ((mmi_ucm_multiple_call_struct*) act_struct)->source_id;
    
	if(GetTotalActiveCallCount() > 0 && GetTotalHoldCallCount() > 0)
	{
		MakePsSwapCallRequest((void*)SwapReqSucess);
		return;
	}
	/*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_swap_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_swap_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct swap_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&swap_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    swap_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(swap_rsp.call_list);

	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_swap_rsp: FALSE");
    
		swap_rsp.result_info.result = FALSE;
		swap_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_SWAP, MMI_UCM_VOICE_CALL_TYPE, (void *)&swap_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_swap_rsp: TRUE");
    
		swap_rsp.result_info.result = TRUE;
		mmi_ucm_dispatch_rsp(MMI_UCM_SWAP, MMI_UCM_VOICE_CALL_TYPE, (void *)&swap_rsp);
	}
	OslMfree(swap_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_conference
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_conference(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_conference REQ");
    cm_p->ucm_source_id = ((mmi_ucm_conf_req_struct*) act_struct)->source_id;

    SetConfFlag();
    cm_p->state_info.ucm_conf_group_id = (CM_CALL_HANDLE)((mmi_ucm_conf_req_struct*) act_struct)->active_group;
    MakePsConfCallRequest();
    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_conference_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_conference_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct conference_rsp;
    U16 count = 0 ;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&conference_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));
    conference_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));

    if(result == FALSE)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_conference_rsp RSP: FALSE");
    
        conference_rsp.result_info.result = FALSE;
        conference_rsp.result_info.error_msg = error_msg;
        PRINT_INFORMATION("conf fail error msg:%s",error_msg);
        mmi_gsm_get_call_list(conference_rsp.call_list);
        mmi_ucm_dispatch_rsp(MMI_UCM_CONFERENCE, MMI_UCM_VOICE_CALL_TYPE, (void *)&conference_rsp);
    }
    else
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_conference_rsp RSP: TRUE");
    
        /*assign new group id to all calls held->active*/
        for(count = 0; count < MAX_CALLS; count++)
    	{
    	    if((cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE))
            {
                cm_p->state_info.AllCalls[count].group_id = cm_p->state_info.ucm_conf_group_id;
            }   
        }
        conference_rsp.result_info.result = TRUE;
        mmi_gsm_get_call_list(conference_rsp.call_list);
        mmi_ucm_dispatch_rsp(MMI_UCM_CONFERENCE, MMI_UCM_VOICE_CALL_TYPE, (void *)&conference_rsp);
    }
    cm_p->state_info.ucm_conf_group_id = 0;
    OslMfree(conference_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_split
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_split(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("GSM call application: mmi_gsm_split REQ");
    cm_p->ucm_source_id = ((mmi_ucm_split_req_struct*) act_struct)->source_id;
    
    SetCallflag((CM_CALL_HANDLE)((mmi_ucm_split_req_struct*) act_struct)->split_call, CM_SPLIT_REQUESTED, TRUE);
    MakePsSplitRequest(((mmi_ucm_split_req_struct*) act_struct)->split_call);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_split_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_split_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct split_rsp;
    U16 count = 0 ;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);
    memset(&split_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));
    split_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));

    if(result == FALSE)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_split_rsp: FALSE");
 
       split_rsp.result_info.result = FALSE;
        split_rsp.result_info.error_msg = error_msg;
        mmi_gsm_get_call_list(split_rsp.call_list);
        mmi_ucm_dispatch_rsp(MMI_UCM_SPLIT, MMI_UCM_VOICE_CALL_TYPE, (void *)&split_rsp);
    }
    else
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_split_rsp: TRUE");
    
        /*reset group id*/
        for(count = 0; count < MAX_CALLS; count++)
    	{
    	    if((cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE))
            {
                //cm_p->state_info.AllCalls[count].group_id = ((cm_p->state_info.ucm_conf_group_id + 1) % MAX_CALLS) + 1;
                cm_p->state_info.AllCalls[count].group_id = GetUnUsedGroupID();
            }
        }
        split_rsp.result_info.result = TRUE;
        mmi_gsm_get_call_list(split_rsp.call_list);
        mmi_ucm_dispatch_rsp(MMI_UCM_SPLIT, MMI_UCM_VOICE_CALL_TYPE, (void *)&split_rsp);
    }
    OslMfree(split_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_deflect
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_deflect(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_deflect REQ");
    
	if(GetIncomingCallHandle() != -1)
	{
		MakePsCallDeflect((void*)PsCBackCallDeflected, (PU8)((mmi_ucm_cd_or_ct_req_struct*) act_struct)->num_uri);
		return;
	}
	/*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_deflect_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_deflect_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct deflect_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&deflect_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    deflect_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(deflect_rsp.call_list);

	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_deflect_rsp RSP: FALSE");
    
		deflect_rsp.result_info.result = FALSE;
		deflect_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_DEFLECT, MMI_UCM_VOICE_CALL_TYPE, (void *)&deflect_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_deflect_rsp RSP: TRUE");
    
		deflect_rsp.result_info.result = TRUE;        
		mmi_ucm_dispatch_rsp(MMI_UCM_DEFLECT, MMI_UCM_VOICE_CALL_TYPE, (void *)&deflect_rsp);
	}
	OslMfree(deflect_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_single
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_single(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U16 count = 0;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_end_single REQ");
    cm_p->ucm_source_id = ((mmi_ucm_single_call_struct*) act_struct)->source_id;
    
    if(((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_id == MMI_UCM_INVALID_ID)
    {
        SetCallAbortReqSentFlag(TRUE);
        SetCallflag(((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_id, CM_HANGUP_REQUESTED, TRUE);
        MakePsAthRequest((void*)PsCBackOutgoingCallEnded);
        return;
    }
    else if(GetTotalCallCount() == 1 && GetCurrentState() == CM_INCOMING_STATE)
    {
        SetCallflag(((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_id, CM_HANGUP_REQUESTED, TRUE);
        MakePsAthRequest((void*)PsCBackIncomingCallRejected);
        return;
    }
    else
    {
        for(count = 0; count < MAX_CALLS; count++)
    	{
            if(cm_p->state_info.AllCalls[count].call_handle == ((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_id)
            {
                if (GetTotalCallCount() > 1 &&
                    GetCallState(((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_id) == CM_INCOMING_STATE)
                {
                    MakePsSendUDUB((void*)PsCBackIncomingCallRejected);
                    return;
                }
                else
                {
                    MakePsEndSelectiveCall((void*)HangupReqSucess, ((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_id);
                    return;
                }
            }
        }
    }
	/*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_single_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_single_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct end_single_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&end_single_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    end_single_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(end_single_rsp.call_list);

    if(result == FALSE)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_single_rsp: FALSE");
        end_single_rsp.result_info.result = FALSE;
        end_single_rsp.result_info.error_msg = error_msg;
        mmi_ucm_dispatch_rsp(MMI_UCM_END_SINGLE, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_single_rsp);
    }
    else
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_single_rsp: TRUE");
        ResetRedialAttempts();
        end_single_rsp.result_info.result = TRUE;
        mmi_ucm_dispatch_rsp(MMI_UCM_END_SINGLE, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_single_rsp);        
    }
    OslMfree(end_single_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_conference
 * DESCRIPTION
 *  
 * PARAMETERS
 * 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_conference(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_end_conference REQ");
    cm_p->ucm_source_id = ((mmi_ucm_end_conf_req_struct*) act_struct)->source_id;
    
	if(GetTotalActiveCallCount() > 1)
	{
		MakePsHangupallActiveRequest((void*)HangupallActReqSucess);
		return;
	}
	else if (GetTotalHoldCallCount() > 1)
	{
		MakePsSendRelHeld((void*)HangupallHldReqSucess);
		return;
	}
	/*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_conference_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_conference_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct end_conference_rsp;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&end_conference_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    end_conference_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(end_conference_rsp.call_list);

	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_conference_rsp: FALSE");
    
		end_conference_rsp.result_info.result = FALSE;
		end_conference_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_END_CONFERENCE, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_conference_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_conference_rsp: TRUE");
    
		end_conference_rsp.result_info.result = TRUE;
		mmi_ucm_dispatch_rsp(MMI_UCM_END_CONFERENCE, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_conference_rsp);
	}
	OslMfree(end_conference_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_all
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_all(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_end_all REQ");
    
    cm_p->ucm_source_id = ((mmi_ucm_end_all_req_struct*) act_struct)->source_id;

    if(GetTotalCallCount() == 1 && GetOutgoingCallHandle() == MMI_UCM_INVALID_ID)
    {
        SetCallAbortReqSentFlag(TRUE);
        SetCallflag(GetOutgoingCallHandle(), CM_HANGUP_REQUESTED, TRUE);
        MakePsAthRequest((void*)PsCBackOutgoingCallEnded);
        return;
    }
    else if(GetTotalCallCount() == 1 && GetCurrentState() == CM_INCOMING_STATE)
    {
        SetCallflag(GetOutgoingCallHandle(), CM_HANGUP_REQUESTED, TRUE);
        MakePsAthRequest((void*)PsCBackIncomingCallRejected);
        return;
    }
    else if(GetTotalCallCount() > 0)
    {
        MakePsHangupallCallsRequest((void*)HangupallReqSucess);
        return;
    }
    /*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_all_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_all_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct end_all_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&end_all_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));
    
    end_all_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(end_all_rsp.call_list);

    if(result == FALSE)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_all_rsp: FALSE");
        end_all_rsp.result_info.result = FALSE;
        end_all_rsp.result_info.error_msg = error_msg;
        mmi_ucm_dispatch_rsp(MMI_UCM_END_ALL, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_all_rsp);
    }
    else
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_all_rsp: TRUE");
        ResetRedialAttempts();
        end_all_rsp.result_info.result = TRUE;
        mmi_ucm_dispatch_rsp(MMI_UCM_END_ALL, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_all_rsp);
    }
    OslMfree(end_all_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_force_release
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_force_release(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_force_release REQ");
    
    if(GetTotalCallCount() > 0)
    {
        MakePsReleaseCompleteRequest(((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_id);
        return;
    }
    /*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_force_release_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_force_release_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	/*No action rsp for force release*/
	
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_auto_reject
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_auto_reject(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_auto_reject REQ");

    /*don't let UCM know the call id after its request*/
    cm_p->auto_reject_call.ucm_current_uid.call_id = ((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_id;
    cm_p->auto_reject_call.ucm_current_uid.group_id = ((mmi_ucm_single_call_struct*) act_struct)->action_uid.group_id;
    cm_p->auto_reject_call.ucm_current_uid.call_type = GetUCMCallType(((mmi_ucm_single_call_struct*) act_struct)->action_uid.call_type);            
    cm_p->auto_reject_call.state = CM_INCOMING_STATE;

    mmi_gsm_end_single(act_struct);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_auto_reject_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_auto_reject_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	/*No action rsp for force release*/
	
}

void mmi_gsm_explicit_call_transfer(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_explicit_call_transfer REQ");
    cm_p->ucm_source_id = ((mmi_ucm_multiple_call_struct*) act_struct)->source_id;
    
	if(GetOutgoingCallHandle() != -1)
	{
		if(GetTotalActiveCallCount() == 1 || GetTotalHoldCallCount() == 1)
		{
			MakePsEctRequest();
			return;
		}
	}
	else if(GetTotalActiveCallCount() == 1 && GetTotalHoldCallCount() == 1)
	{
		MakePsEctRequest();
		return;
	}
	/*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_auto_reject_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_explicit_call_transfer_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct ect_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&ect_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    ect_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(ect_rsp.call_list);
	
	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_explicit_call_transfer_rsp: FALSE");
    
		ect_rsp.result_info.result = FALSE;
		ect_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_EXPLICT_CALL_TRANSFER, MMI_UCM_VOICE_CALL_TYPE, (void *)&ect_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_explicit_call_transfer_rsp: TRUE");
    
		ect_rsp.result_info.result = TRUE;
		mmi_ucm_dispatch_rsp(MMI_UCM_EXPLICT_CALL_TRANSFER, MMI_UCM_VOICE_CALL_TYPE, (void *)&ect_rsp);
	}
	OslMfree(ect_rsp.call_list);
}

void mmi_gsm_end_active_and_retrieve(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_end_active_and_retrieve REQ");
    cm_p->ucm_source_id = ((mmi_ucm_multiple_call_struct*) act_struct)->source_id;
    
    MakePsHangupallActiveAcceptOtherRequest((void*)PsCBackActiveCallEndedHeldRetrieved);
    
    /*if(GetTotalActiveCallCount() > 0 && GetTotalHoldCallCount() > 0)
    {
        MakePsHangupallActiveAcceptOtherRequest((void*)PsCBackActiveCallEndedHeldRetrieved);
    }*/
    /*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_active_and_retrieve_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_active_and_retrieve_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct end_active_and_retrieve_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&end_active_and_retrieve_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    end_active_and_retrieve_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(end_active_and_retrieve_rsp.call_list);
    
	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_active_and_retrieve_rsp: FALSE");
    
		end_active_and_retrieve_rsp.result_info.result = FALSE;
		end_active_and_retrieve_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_END_ACTIVE_AND_RETRIEVE, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_active_and_retrieve_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_active_and_retrieve_rsp: TRUE");
    
		end_active_and_retrieve_rsp.result_info.result = TRUE;
		mmi_ucm_dispatch_rsp(MMI_UCM_END_ACTIVE_AND_RETRIEVE, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_active_and_retrieve_rsp);
	}
	OslMfree(end_active_and_retrieve_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_active_and_accept
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_active_and_accept(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_end_active_and_accept REQ");
    cm_p->ucm_source_id = ((mmi_ucm_multiple_call_struct*) act_struct)->source_id;
    
    MakePsHangupallActiveAcceptOtherRequest((void*)PsCBackselectedCallEnded);
    SetProtocolEventHandler(PsCBackCheckChldIncomingCallAccepted, PRT_END_CHLD_RSP);
    return;
    
    /*if(GetIncomingCallHandle() != -1 && GetTotalActiveCallCount() > 0)
    {
        MakePsHangupallActiveAcceptOtherRequest((void*)PsCBackselectedCallEnded);
        SetProtocolEventHandler(PsCBackCheckChldIncomingCallAccepted, PRT_END_CHLD_RSP);
        return;
    }*/
    /*ASSERT HERE*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_start_dtmf
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_start_dtmf(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("Start sending DTMF");
    MakePsSendDTMFTone(&(((mmi_ucm_dtmf_struct*) act_struct)->digit));
    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_stop_dtmf
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_stop_dtmf(void *act_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("Stop sending DTMF");
    MakePsStopDTMFTone();
    return;

}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_end_active_and_accept_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  BOOL result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_end_active_and_accept_rsp(BOOL result, U8 *error_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_act_rsp_struct end_active_and_accept_rsp;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);

    memset(&end_active_and_accept_rsp, 0, sizeof(mmi_ucm_act_rsp_struct));

    end_active_and_accept_rsp.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(end_active_and_accept_rsp.call_list);

	if(result == FALSE)
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_active_and_accept_rsp: FALSE");
        
		end_active_and_accept_rsp.result_info.result = FALSE;
		end_active_and_accept_rsp.result_info.error_msg = error_msg;
		mmi_ucm_dispatch_rsp(MMI_UCM_END_ACTIVE_AND_ACCEPT, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_active_and_accept_rsp);
	}
	else
	{
        PRINT_INFORMATION("GSM call application: mmi_gsm_end_active_and_accept_rsp: TRUE");
    
		end_active_and_accept_rsp.result_info.result = TRUE;
		mmi_ucm_dispatch_rsp(MMI_UCM_END_ACTIVE_AND_ACCEPT, MMI_UCM_VOICE_CALL_TYPE, (void *)&end_active_and_accept_rsp);
	}
	OslMfree(end_active_and_accept_rsp.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  GetGSMCallList
 * DESCRIPTION
 *  Gets GSM call list for UCM
 * PARAMETERS
 *        
 * RETURNS
 * 
 *****************************************************************************/
void mmi_gsm_get_call_list(mmi_ucm_sync_call_list_struct *callList)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application call list");
    memset(callList, 0, sizeof(mmi_ucm_sync_call_list_struct));

    callList->call_type = (MMI_UCM_VOICE_CALL_TYPE | MMI_UCM_DATA_CALL_TYPE | MMI_UCM_CSD_CALL_TYPE | MMI_UCM_VIDEO_CALL_TYPE);
    
    for (count = 0; count < MAX_CALLS; count++)
    {
        switch(cm_p->state_info.AllCalls[count].curr_state)
        {
            case CM_OUTGOING_STATE:

                /*UCM has already atuo rejected the call, so don't let her know. Auto reject DATA MO call*/
                if(cm_p->ucm_sub_operation == MMI_GSM_UCM_AUTO_REJECT &&
                    cm_p->auto_reject_call.ucm_current_uid.call_id == cm_p->state_info.AllCalls[count].call_handle)
                {
                    PRINT_INFORMATION("GSM call application: Ignore auto rejected call (MO)");
                    break;
                }

                if((cm_p->ucm_operation == MMI_GSM_UCM_DIAL) ||
                   (cm_p->ucm_operation == MMI_GSM_UCM_HOLD_AND_DIAL) ||
               #ifdef __MMI_DUAL_SIM_MASTER__
                   /*SIM SS request*/
                   (MTPNP_PFAL_GetUCMOPCodeState() == MMI_GSM_UCM_DIAL) ||
                   (MTPNP_PFAL_GetUCMOPCodeState() == MMI_GSM_UCM_HOLD_AND_DIAL) ||
               #endif /* __MMI_DUAL_SIM_MASTER__ */
                   MMI_FALSE
                )
                {
                    PRINT_INFORMATION("Ignore the MO call, no SS_PARSING_STRING_RSP yet");
                    break;
                }

                /*REMOTE INFO*/
                mmi_ucs2_n_to_asc(
                    (S8 *)callList->call_info[callList->total_num].remote_info.num_uri,
                    (S8 *)cm_p->state_info.AllCalls[count].num,
                    MMI_UCM_MAX_NUM_URI_LEN);

                mmi_ucs2ncpy((S8 *)callList->call_info[callList->total_num].remote_info.disp_name,
                            (S8 *)GetDispNameorNum(cm_p->state_info.AllCalls[count].call_handle),
                            MMI_UCM_MAX_DISP_NAME_LEN - 1);
                
                mmi_ucs2ncpy((S8 *)callList->call_info[callList->total_num].remote_info.log_name,
                            (S8*) GetCallLogName(cm_p->state_info.AllCalls[count].call_handle),
                            MAX_PB_NAME_LENGTH);

                callList->call_info[callList->total_num].remote_info.active_icon = 0;
                if(!IsResetCSPGroupService(CSP_CPHS_TELESERVICES_SERVICE_GROUP, ALS))
                {
                    if (cm_p->state_info.AllCalls[count].call_type == CM_AUX_VOICE_CALL)
                    {
                        callList->call_info[callList->total_num].remote_info.active_icon = IMG_CM_ICON_LINE2;
                    }
                    else
                    {
                        callList->call_info[callList->total_num].remote_info.active_icon = IMG_CM_ICON_LINE1;
                    }
                }

                /*UID info*/
                callList->call_info[callList->total_num].uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
                callList->call_info[callList->total_num].uid_info.group_id= cm_p->state_info.AllCalls[count].group_id;
                callList->call_info[callList->total_num].uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);

                /*STATE info*/
                callList->call_info[callList->total_num].call_state = MMI_UCM_OUTGOING_STATE;

                /*print info*/
                PRINT_INFORMATION("[%d]:group_id:%d, call_id:%d, call_type:%d, dispName:", 
                callList->total_num, 
                callList->call_info[callList->total_num].uid_info.group_id,
                callList->call_info[callList->total_num].uid_info.call_id,
                callList->call_info[callList->total_num].uid_info.call_type);

                callList->total_num++;
                break;
				
            case CM_INCOMING_STATE:

                /*UCM has already atuo rejected the call, so don't let her know. Atuo Reject MT call*/
                if(cm_p->ucm_sub_operation == MMI_GSM_UCM_AUTO_REJECT &&
                    cm_p->auto_reject_call.ucm_current_uid.call_id == cm_p->state_info.AllCalls[count].call_handle)
                {
                    PRINT_INFORMATION("GSM call application: Ignore auto rejected call (MT)");
                    break;
                }
                
                /*REMOTE INFO*/
                mmi_ucs2_n_to_asc(
                    (S8 *)callList->call_info[callList->total_num].remote_info.num_uri,
                    (S8 *)cm_p->state_info.AllCalls[count].num,
                    MMI_UCM_MAX_NUM_URI_LEN);
                
                mmi_ucs2ncpy((S8 *)callList->call_info[callList->total_num].remote_info.disp_name,
                            (S8 *)GetDispNameorNum(cm_p->state_info.AllCalls[count].call_handle),
                            MMI_UCM_MAX_DISP_NAME_LEN - 1);
                
                mmi_ucs2ncpy((S8 *)callList->call_info[callList->total_num].remote_info.log_name,
                            (S8*) GetCallLogName(cm_p->state_info.AllCalls[count].call_handle),
                            MAX_PB_NAME_LENGTH);

                callList->call_info[callList->total_num].remote_info.active_icon = 0;
                if(!IsResetCSPGroupService(CSP_CPHS_TELESERVICES_SERVICE_GROUP, ALS))
                {
                    if (cm_p->state_info.AllCalls[count].call_type == CM_AUX_VOICE_CALL)
                    {
                        callList->call_info[callList->total_num].remote_info.active_icon = IMG_CM_ICON_LINE2;
                    }
                    else
                    {
                        callList->call_info[callList->total_num].remote_info.active_icon = IMG_CM_ICON_LINE1;
                    }
                }
				
                /*UID info*/
                callList->call_info[callList->total_num].uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
                callList->call_info[callList->total_num].uid_info.group_id= cm_p->state_info.AllCalls[count].group_id;
                callList->call_info[callList->total_num].uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);

                /*STATE info*/
                callList->call_info[callList->total_num].call_state = MMI_UCM_INCOMING_STATE;

                /*print info*/
                PRINT_INFORMATION("[%d]:group_id:%d, call_id:%d, call_type:%d", 
                callList->total_num, 
                callList->call_info[callList->total_num].uid_info.group_id,
                callList->call_info[callList->total_num].uid_info.call_id,
                callList->call_info[callList->total_num].uid_info.call_type);
                
                callList->total_num++;
                break;
				
            case CM_ACTIVE_STATE:
                /*REMOTE INFO*/
                mmi_ucs2_n_to_asc(
                    (S8 *)callList->call_info[callList->total_num].remote_info.num_uri,
                    (S8 *)cm_p->state_info.AllCalls[count].num,
                    MMI_UCM_MAX_NUM_URI_LEN);
                
                mmi_ucs2ncpy((S8 *)callList->call_info[callList->total_num].remote_info.disp_name,
                            (S8 *)GetDispNameorNum(cm_p->state_info.AllCalls[count].call_handle),
                            MMI_UCM_MAX_DISP_NAME_LEN - 1);
                
                mmi_ucs2ncpy((S8 *)callList->call_info[callList->total_num].remote_info.log_name,
                            (S8*) GetCallLogName(cm_p->state_info.AllCalls[count].call_handle),
                            MAX_PB_NAME_LENGTH);

                callList->call_info[callList->total_num].remote_info.active_icon = 0;
                if(!IsResetCSPGroupService(CSP_CPHS_TELESERVICES_SERVICE_GROUP, ALS))
                {
                    if (cm_p->state_info.AllCalls[count].call_type == CM_AUX_VOICE_CALL)
                    {
                        callList->call_info[callList->total_num].remote_info.active_icon = IMG_CM_ICON_LINE2;
                    }
                    else
                    {
                        callList->call_info[callList->total_num].remote_info.active_icon = IMG_CM_ICON_LINE1;
                    }
                }
                
                /*UID info*/
                callList->call_info[callList->total_num].uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
                callList->call_info[callList->total_num].uid_info.group_id= cm_p->state_info.AllCalls[count].group_id;
                callList->call_info[callList->total_num].uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);

                /*STATE info*/
                callList->call_info[callList->total_num].call_state = MMI_UCM_ACTIVE_STATE;
                
                /*print info*/
                PRINT_INFORMATION("[%d]:group_id:%d, call_id:%d, call_type:%d", 
                callList->total_num, 
                callList->call_info[callList->total_num].uid_info.group_id,
                callList->call_info[callList->total_num].uid_info.call_id,
                callList->call_info[callList->total_num].uid_info.call_type);
                
                callList->total_num++;
                break;
				
            case CM_HOLD_STATE:
                /*REMOTE INFO*/
                mmi_ucs2_n_to_asc(
                    (S8 *)callList->call_info[callList->total_num].remote_info.num_uri,
                    (S8 *)cm_p->state_info.AllCalls[count].num,
                    MMI_UCM_MAX_NUM_URI_LEN);

                mmi_ucs2ncpy((S8 *)callList->call_info[callList->total_num].remote_info.disp_name,
                            (S8 *)GetDispNameorNum(cm_p->state_info.AllCalls[count].call_handle),
                            MMI_UCM_MAX_DISP_NAME_LEN - 1);
                
                mmi_ucs2ncpy((S8 *)callList->call_info[callList->total_num].remote_info.log_name,
                            (S8*) GetCallLogName(cm_p->state_info.AllCalls[count].call_handle),
                            MAX_PB_NAME_LENGTH);

                callList->call_info[callList->total_num].remote_info.active_icon = 0;
                if(!IsResetCSPGroupService(CSP_CPHS_TELESERVICES_SERVICE_GROUP, ALS))
                {
                    if (cm_p->state_info.AllCalls[count].call_type == CM_AUX_VOICE_CALL)
                    {
                        callList->call_info[callList->total_num].remote_info.active_icon = IMG_CM_ICON_LINE2;
                    }
                    else
                    {
                        callList->call_info[callList->total_num].remote_info.active_icon = IMG_CM_ICON_LINE1;
                    }
                }
                
				/*UID info*/
				callList->call_info[callList->total_num].uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
                callList->call_info[callList->total_num].uid_info.group_id= cm_p->state_info.AllCalls[count].group_id;
				callList->call_info[callList->total_num].uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);

				/*STATE info*/
				callList->call_info[callList->total_num].call_state = MMI_UCM_HOLD_STATE;

                /*print info*/
                PRINT_INFORMATION("[%d]:group_id:%d, call_id:%d, call_type:%d", 
                callList->total_num, 
                callList->call_info[callList->total_num].uid_info.group_id,
                callList->call_info[callList->total_num].uid_info.call_id,
                callList->call_info[callList->total_num].uid_info.call_type);
                
                callList->total_num++;
                break;
				
            default:
                if(cm_p->state_info.AllCalls[count].call_handle != 0)
                {
                    //ASSERT HERE
                }
                break;
        }
    }
    return;
}

/*****************************************************************************
 * FUNCTION
 *  GetDisplayName
 * DESCRIPTION
 *  Gets the name or number for a particular call handle
 * PARAMETERS
 *
 *  CM_CALL_HANDLE(?)       [IN]        NCallIndex, // Call handle
 * RETURNS
 *  PU8
 *****************************************************************************/
PU8 GetDisplayName(CM_CALL_HANDLE callID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (index = 0; index < MAX_CALLS; index++)
    {
        /* Start by Julia: Drop call refinement - add CM_DISCONNECTING_STATE condition */
        if (cm_p->state_info.AllCalls[index].call_handle == callID)
        {
            if ((mmi_ucs2strlen((PS8) cm_p->state_info.AllCalls[index].pBname) == 0)
        #ifdef __IP_NUMBER__
                || GetTempUseIPNumber()
        #endif 
                )
            {
            	/* no name, show number */
                /* hide *31#, #31# prefix string  */
                if ((mmi_ucs2ncmp((PS8) cm_p->state_info.AllCalls[index].number, (PS8) L"*31#", 4) == 0) ||
                    (mmi_ucs2ncmp((PS8) cm_p->state_info.AllCalls[index].number, (PS8) L"#31#", 4) == 0))
                {
                    return &cm_p->state_info.AllCalls[index].number[8];
                }
                else
                {
                    return cm_p->state_info.AllCalls[index].number;
                }
            }
            else
            {
                return cm_p->state_info.AllCalls[index].pBname;
            }
        }
    }
    return NULL;
}

/*****************************************************************************
 * FUNCTION
 *  GetUCMCallType
 * DESCRIPTION
 *  
 * PARAMETERS
 *
 * RETURNS
 * 
 *****************************************************************************/
mmi_ucm_call_type_enum GetUCMCallType(csmcc_call_type_enum call_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(call_type)
    {
        case CSMCC_VOICE_CALL:
             return MMI_UCM_VOICE_CALL_TYPE;
             
        case CSMCC_AUX_VOICE_CALL:
             return MMI_UCM_VOICE_CALL_TYPE;
             
        case CSMCC_DATA_CALL:
             return MMI_UCM_DATA_CALL_TYPE;
             
        case CSMCC_FAX_CALL:
             return MMI_UCM_DATA_CALL_TYPE;
             
        case CSMCC_CSD_CALL:
             return MMI_UCM_CSD_CALL_TYPE;
             
        case CSMCC_SAT_DATA_CALL:
             return MMI_UCM_DATA_CALL_TYPE;

        case CSMCC_VIDEO_CALL:
             return MMI_UCM_VIDEO_CALL_TYPE;
    }
    PRINT_INFORMATION("It is not correct call type");
    //ASSERT HERE
    return 0;
}

/*****************************************************************************
 * FUNCTION
 *  GetUnUsedGroupID
 * DESCRIPTION
 *  
 * PARAMETERS
 *
 * RETURNS
 *  
 *****************************************************************************/
CM_CALL_HANDLE GetUnUsedGroupID()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index = 0;
    U16 count = 0;
    U16 group_id = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	for (group_id = 1; group_id < (MAX_CALLS + 1); group_id++)
    {
        for (index = 0; index < MAX_CALLS; index++)
        {
            if(cm_p->state_info.AllCalls[index].group_id != group_id)
            {
                count++;
		    }
        }
        if(count == MAX_CALLS)
        {
            return group_id;
        }
        count = 0;
	}
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  SetUCMOperationState
 * DESCRIPTION
 *  
 * PARAMETERS
 *
 * RETURNS
 *  
 *****************************************************************************/
void SetUCMOperationState(mmi_gsm_ucm_act_type_enum op_type, mmi_gsm_ucm_act_opcode_enum op_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cm_p->ucm_action_type = op_type;
    cm_p->ucm_operation = op_code;
    PRINT_INFORMATION("GSM call app: set UCM operation state:%d",cm_p->ucm_operation);
}



/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_sync_call_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_sync_call_list_ind()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_sync_call_list_struct *call_list;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /*call list*/
    call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(call_list);
	mmi_ucm_dispatch_ind(MMI_UCM_SYNC_CALL_LIST, (void *)call_list);
    OslMfree(call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_alert_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_alert_ind(CM_CALL_HANDLE call_handle, U8 gen_tone)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_alert_ind_struct alert_ind;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&alert_ind, 0, sizeof(mmi_ucm_alert_ind_struct));

    /*generate tone or not*/
    alert_ind.local_gen = gen_tone;

    /*call list*/
    alert_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(alert_ind.call_list);
	mmi_ucm_dispatch_ind(MMI_UCM_ALERT_IND, (void *)&alert_ind);
    OslMfree(alert_ind.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_connect_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_connect_ind(CM_CALL_HANDLE call_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_connect_ind_struct connect_ind;
    U16 count;
    PU8 displayName = NULL;
    PU8 logName = NULL;
    PU8 number = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&connect_ind, 0, sizeof(mmi_ucm_connect_ind_struct));

    /*uid info*/
    for (count = 0; count < MAX_CALLS; count++)
    {
    	if(cm_p->state_info.AllCalls[count].call_handle== call_handle)
        {
            connect_ind.uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
            connect_ind.uid_info.group_id= cm_p->state_info.AllCalls[count].group_id;
            connect_ind.uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);
        }
    }
    
    /*remote info*/
    displayName = GetCallName(call_handle);
    mmi_ucs2ncpy((S8*) connect_ind.remote_info.disp_name, (S8*) displayName, MMI_UCM_MAX_DISP_NAME_LEN);
    logName = GetCallLogName(call_handle);
    mmi_ucs2ncpy((S8*) connect_ind.remote_info.log_name, (S8*) logName, MAX_PB_NAME_LENGTH);
    number = GetCallLogNumber(call_handle);
    mmi_ucs2_n_to_asc((S8*) connect_ind.remote_info.num_uri, (S8*) number, MMI_UCM_MAX_NUM_URI_LEN);

    /*call list*/
    connect_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(connect_ind.call_list);

#ifdef __MMI_VIDEO_TELEPHONY__
    /* Turn on speech */
    if (connect_ind.uid_info.call_type == MMI_UCM_VIDEO_CALL_TYPE)
    {
        mmi_gsm_speech_ind(MMI_TRUE, MDI_AUDIO_SPEECH_APP_ID_3G324M, MMI_UCM_VIDEO_CALL_TYPE);

        /* for auto redial case */  
        DeleteScreenIfPresent(SCR_ID_VT_MO_FAIL_POST_ACTION); 
    }
#endif /* __MMI_VIDEO_TELEPHONY__ */

    mmi_ucm_dispatch_ind(MMI_UCM_CONNECT_IND, (void *)&connect_ind);
    OslMfree(connect_ind.call_list);

#ifdef __IP_NUMBER__
    SetTempUseIPNumber(FALSE);
#endif 

    ResetRedialAttempts();

}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_notify_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_notify_ind(U8 *error_msg, U16 image_id, U16 tone_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_notify_ind_struct notify_ind;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&notify_ind, 0, sizeof(mmi_ucm_notify_ind_struct));

    /*display*/
    notify_ind.disp_msg = error_msg;
    notify_ind.image_id = image_id;
    notify_ind.tone_id = tone_id;
    
    /*call list*/
    notify_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
	mmi_gsm_get_call_list(notify_ind.call_list);
	mmi_ucm_dispatch_ind(MMI_UCM_NOTIFY_IND, (void *)&notify_ind);
    OslMfree(notify_ind.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_speech_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_speech_ind(BOOL speech, U8 rat, U8 call_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_speech_ind_struct speech_ind;
    mmi_ucm_session_ind_struct session_ind;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&speech_ind, 0, sizeof(mmi_ucm_speech_ind_struct));
    memset(&session_ind, 0, sizeof(mmi_ucm_session_ind_struct));

    /*call type*/
    speech_ind.call_type = call_type;

    /*session type*/
    speech_ind.session_type = rat;
    session_ind.session_type = rat;
    
    /*switch*/
    speech_ind.local_switch = speech;
    speech_ind.remote_switch = speech;
    session_ind.session_switch = speech;

    /*call list*/
    speech_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
	mmi_gsm_get_call_list(speech_ind.call_list);
    session_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
	mmi_gsm_get_call_list(session_ind.call_list);

    if(speech == TRUE)
    {  
        /*start session*/
        mmi_ucm_dispatch_ind(MMI_UCM_SESSION_IND, (void *)&session_ind);
        OslMfree(session_ind.call_list);
        
        /*turn on codec*/
        mmi_ucm_dispatch_ind(MMI_UCM_SPEECH_IND, (void *)&speech_ind);
        OslMfree(speech_ind.call_list);
        
        /*start auto sound recorder*/
    #ifdef __MMI_SOUND_RECORDER__
        PRINT_INFORMATION("mmi_sndrec_auto_record_switch(MDI_AUDIO_SPEECH_APP_ID_GSM, MMI_TRUE);");
        mmi_sndrec_auto_record_switch(MDI_AUDIO_SPEECH_APP_ID_GSM, MMI_TRUE);
    #endif
    }
    else
    {
         /*stop auto sound recorder*/
    #ifdef __MMI_SOUND_RECORDER__
        PRINT_INFORMATION("mmi_sndrec_auto_record_switch(MDI_AUDIO_SPEECH_APP_ID_GSM, MMI_FALSE);");
        mmi_sndrec_auto_record_switch(MDI_AUDIO_SPEECH_APP_ID_GSM, MMI_FALSE);
    #endif
 
        /*turn off codec*/
        mmi_ucm_dispatch_ind(MMI_UCM_SPEECH_IND, (void *)&speech_ind);
        OslMfree(speech_ind.call_list);

        /*stop session*/
        mmi_ucm_dispatch_ind(MMI_UCM_SESSION_IND, (void *)&session_ind);
        OslMfree(session_ind.call_list);
    }
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ring_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_ring_ind()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_ring_ind_struct ring_ind;
    PHB_CM_INTERFACE *PhoneNumberStruct;
    PU8 displayName = NULL;
    PU8 logName = NULL;
    PU8 number = NULL;
    U16 count;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&ring_ind, 0, sizeof(mmi_ucm_ring_ind_struct));

    PhoneNumberStruct = GetCMPhoneBookStruct();

	/*alert info*/
    if (cm_p->alert_info.AlertType == MMI_ALERT_NONE)
    {
        ring_ind.alert_info.alert_type = GetMtCallAlertTypeEnum();
    }
    else
    {
        ring_ind.alert_info.alert_type = cm_p->alert_info.AlertType;
    }

    ring_ind.alert_info.image_info.video_id = PhoneNumberStruct->videoId;
    PRINT_INFORMATION("mmi_gsm_ring_ind: videoId:%d", ring_ind.alert_info.image_info.video_id);
    ring_ind.alert_info.image_info.video_record_index = PhoneNumberStruct->video_record_index;
    PRINT_INFORMATION("mmi_gsm_ring_ind: video_record_index:%d", ring_ind.alert_info.image_info.video_record_index);
    ring_ind.alert_info.image_info.image_id = PhoneNumberStruct->pictureId;
    PRINT_INFORMATION("mmi_gsm_ring_ind: picureID:%d", ring_ind.alert_info.image_info.image_id);
    ring_ind.alert_info.image_info.record_index = PhoneNumberStruct->record_index; 
    PRINT_INFORMATION("mmi_gsm_ring_ind: record_index:%d", ring_ind.alert_info.image_info.record_index);

    ring_ind.alert_info.light_id = cm_p->alert_info.BacklightPatternId;
    PRINT_INFORMATION("mmi_gsm_ring_ind: light id:%d", ring_ind.alert_info.light_id);

    ring_ind.alert_info.line_icon = IMG_CM_ICON_LINE1;

    if (IsResetCSPGroupService(CSP_CPHS_TELESERVICES_SERVICE_GROUP, ALS))
    {
        ring_ind.alert_info.line_icon = 0;
    }
    else
    {
        if (GetIncomingCallType() == CM_AUX_VOICE_CALL)
        {
            ring_ind.alert_info.line_icon = IMG_CM_ICON_LINE2;
        }
    }

    /*display info*/
    displayName = GetCallName(GetIncomingCallHandle());
    mmi_ucs2ncpy((S8*) ring_ind.display_info.disp_name, (S8*) displayName, MMI_UCM_MAX_DISP_NAME_LEN);
    logName = GetCallLogName(GetIncomingCallHandle());
    mmi_ucs2ncpy((S8*) ring_ind.display_info.log_name, (S8*) logName, MMI_UCM_MAX_DISP_NAME_LEN);
    number = GetCallLogNumber(GetIncomingCallHandle());
    mmi_ucs2_n_to_asc((S8*) ring_ind.display_info.num_uri, (S8*) number, MMI_UCM_MAX_NUM_URI_LEN);

    /*uid info*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if(cm_p->state_info.AllCalls[count].curr_state == CM_INCOMING_STATE)
        {
            ring_ind.uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
            ring_ind.uid_info.group_id= cm_p->state_info.AllCalls[count].group_id;
            ring_ind.uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);

            /*For L4C information*/
            ring_ind.l4c_info.l4c_type = cm_p->state_info.AllCalls[count].call_type;
            memcpy(&ring_ind.l4c_info.l4c_number, &cm_p->l4c_number, sizeof(cm_p->l4c_number));
        }
    }


    /* ringtone */
    if(PhoneNumberStruct->ringtoneId == 0)
    {
    #ifdef __MMI_VIDEO_TELEPHONY__
        if (ring_ind.uid_info.call_type == MMI_UCM_VIDEO_CALL_TYPE)
        {
            ring_ind.alert_info.tone_id = GetVideoCallToneID();
        }
        else
    #endif /* __MMI_VIDEO_TELEPHONY__ */
        {
            ring_ind.alert_info.tone_id = GetRingToneID();
        }
    }
    else
    {
        ring_ind.alert_info.tone_id = PhoneNumberStruct->ringtoneId; 
    }
    /*call list*/
    ring_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(ring_ind.call_list);
    mmi_ucm_dispatch_ind(MMI_UCM_RING_IND, (void *)&ring_ind);
    OslMfree(ring_ind.call_list);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_release_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_release_ind( U16 error_cause)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_release_ind_struct release_ind;
    U16 count;
    BOOL auto_reject_done = TRUE;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&release_ind, 0, sizeof(mmi_ucm_release_ind_struct));

    /*uid info*/
    release_ind.uid_info.call_id = cm_p->disc_call.ucm_current_uid.call_id;
    release_ind.uid_info.group_id = cm_p->disc_call.ucm_current_uid.group_id;
    release_ind.uid_info.call_type = cm_p->disc_call.ucm_current_uid.call_type;
    PRINT_INFORMATION("GSM call application: call release uid: ");
    PRINT_INFORMATION("[group_id]:%d ", cm_p->disc_call.ucm_current_uid.group_id);
    PRINT_INFORMATION("[call_id]:%d, ", cm_p->disc_call.ucm_current_uid.call_id);
    PRINT_INFORMATION("[call_type]:%d, ", cm_p->disc_call.ucm_current_uid.call_type);
    PRINT_INFORMATION("[state]:%d, ", cm_p->disc_call.state);
    
    /*reset sub operation state*/
    if(cm_p->auto_reject_call.ucm_current_uid.call_id == cm_p->disc_call.ucm_current_uid.call_id)
    {
        PRINT_INFORMATION("It is auto rejected call");
        cm_p->ucm_sub_operation = MMI_GSM_UCM_IDLE;
        memset(&cm_p->auto_reject_call, 0, sizeof(mmi_gsm_disc_call_struct));
        SetCallAbortReqSentFlag(FALSE);
    }
    
    /*display info*/
    release_ind.image_id = IMG_ERROR_NOTIFY;
    release_ind.tone_id = CALL_DROP_TONE;

    switch (error_cause)
    {
        case ERR_UNASSIGNED_NUM:
            release_ind.tone_id = NUM_UNOBTAIN_TONE;
        case ERR_INVALID_NUMBER_FORMAT:
            release_ind.disp_msg = (U8 *)GetString(ERROR_UNRECOGNIZED_NUMBER);
            break;

        case ERR_SWITCH_EQUIPMENT_CONGESTION:
            release_ind.tone_id = CONGESTION_TONE;
        case ERR_CALL_REJECTED:
            release_ind.tone_id= AUTH_FAIL_TONE;
        case ERR_CHANNEL_UN_ACCP:
        case ERR_NETWORK_OUT_OF_ORDER:
        case ERR_QOS_UNAVAIL:
        case ERR_INVALID_TRANSIT_NW_SEL:
        case ERR_CSMCC_NO_RESPONSE_FROM_NW:
        case ERR_NETWORK_FAILURE:
        case ERR_CM_MM_RR_CONN_RELEASE:
        case ERR_IMSI_UNKNOWN_IN_VLR:
            release_ind.disp_msg = (U8 *)GetString(ERROR_NETWORK_FAIL);
            break;
            
        case ERR_NO_CIRCUIT_CHANNEL_AVAIL:
        case ERR_REQUESTED_CKT_CHANEL_NOT_AVIL:
        case ERR_RESOURCE_UNAVAIL_UNSPECIFIED:
            release_ind.disp_msg = (U8 *)GetString(ERROR_BUSY_NETWORK);
            break;

        case ERR_OPR_DTR_BARRING:
        case ERR_CALL_BARRED:
        case ERR_IC_BAR_CUG:
        case ERR_BEARER_CAP_NOT_AVAIL:
        case ERR_CM_MM_ACCESS_BARRED:
            release_ind.disp_msg = (U8 *)GetString(ERROR_BARRED_CALL);
            break;
        
        case ERR_NO_USER_RESPONDING:
            release_ind.disp_msg = (U8 *)GetString(ERROR_NOT_RESPONDING);
            break;
        
        case ERR_NO_ANSWER_ON_ALERT:
            release_ind.disp_msg = (U8 *)GetString(ERROR_NO_ANSWER);
            break;
        
        case ERR_REQ_FACILITY_UNAVAIL:
        case ERR_IE_NOT_IMPLEMENTED:
        case ERR_CONDITIONAL_MM_IE_ERROR:
        case ERR_CM_MM_ASSIGNMENT_REJECT:
            release_ind.disp_msg = (U8 *)GetString(ERROR_UNAVAILABLE);
            break;
        
        case ERR_IMSI_UNKNOWN_IN_HLR:
        case ERR_CM_MM_IMSI_DETACH:
        case ERR_CM_MM_AUTH_FAILURE:
        case ERR_CM_MM_STATE_NOT_ALLOWED_CM:
            release_ind.disp_msg = (U8 *)GetString(ERROR_FAIL);
            break;
        
        case ERR_IMEI_NOT_ACCEPTED:
            release_ind.disp_msg = (U8 *)GetString(ERROR_IMEI_ERROR);
            break;
        
        case ERR_REQ_FAC_NOT_SUBS:
        case ERR_PLMN_NOT_ALLOWED:
        case ERR_LOCATION_AREA_NOT_ALLOWED:
        case ERR_ROAMING_AREA_NOT_ALLOWED:
        case ERR_GPRS_NOT_ALLOWED_IN_PLMN:
        case ERR_NO_SUITABLE_CELLS_IN_LA:
        case ERR_MSC_TEMP_NOT_REACHABLE:
        case ERR_CM_MM_ABORT_BY_NW:
        case ERR_BEARER_CAP_NOT_AUTHORISED:
        case ERR_SERV_OPTION_TEMP_OUT_OF_ORDER:
            release_ind.disp_msg = (U8 *)GetString(ERROR_NETWORK_NOT_ALLOWED);
            break;
        
        case ERR_SERV_OPTION_NOT_SUPPORTED:
        case ERR_REQ_SERV_OPTION_NOT_SUBSCRIBED:
        case ERR_CALL_CANNOT_BE_IDENTIFIED:
            release_ind.disp_msg = (U8 *)GetString(ERROR_COMMAND_NOT_SUPPORTED);
            break;
        
        case ERR_ACM_EXCEEDED:
            release_ind.disp_msg = (U8 *)GetString(ERROR_ACM_EXCEEDED);
            break;
        
        case ERR_USER_BUSY:
            release_ind.disp_msg = (U8 *)GetString(ERROR_USER_BUSY);
            release_ind.tone_id = TONE_BUSY_CALL_GSM;
            break;

        case ERR_L4C_FDN_FAIL:
            release_ind.disp_msg = (U8 *)GetString(ERROR_FDN_FAIL);
            break;

        default:
            /*drop call before call is connected*/
            if(GetCallEndedBeforeConnFlag() == TRUE &&
                (cm_p->ucm_operation == MMI_GSM_UCM_END_SINGLE ||cm_p->ucm_operation == MMI_GSM_UCM_END_ALL))
            {
                release_ind.disp_msg = (U8 *)GetString(STR_CALL_ABORTED);
            }
            /*Dial indication fial, not call release*/
            else if(cm_p->disc_call.ucm_current_uid.call_id == MMI_UCM_INVALID_ID)
            {
                release_ind.disp_msg = (U8 *)GetString(INCOMING_DEFAULT_ERROR);
            }
            /*normal call end*/
            else
            {
                release_ind.disp_msg = (U8 *)GetString(STR_CALL_ENDED); 
            }
            release_ind.image_id = IMG_CM_STATE_ENDED;
            break;
    }
    
    if(GetCallEndedBeforeConnFlag() == TRUE)
    {
        SetCallEndedBeforeConnFlag(FALSE);
    }
    
    if (GetTotalCallCount() > 0 || 
        release_ind.uid_info.call_type == MMI_UCM_DATA_CALL_TYPE ||
        release_ind.uid_info.call_type == MMI_UCM_CSD_CALL_TYPE)
    {
        release_ind.tone_id = 0;
    }

#ifdef __IP_NUMBER__
    if(GetOutgoingCallHandle() == -1 && mmi_ucm_app_outgoing_call(MMI_UCM_SIM1_CALL_TYPE_ALL) > 0)
    {
        SetTempUseIPNumber(FALSE);
    }
#endif /* __IP_NUMBER__ */

    /*call list*/
    release_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(release_ind.call_list);
    mmi_ucm_dispatch_ind(MMI_UCM_RELEASE_IND, (void *)&release_ind);
    OslMfree(release_ind.call_list);

    /*Cancel auto dtmf confirm if the call is released*/
    if(cm_p->ucm_auto_dtmf_uid.call_id == cm_p->disc_call.ucm_current_uid.call_id)
    {
        mmi_gsm_auto_dtmf_conf_cancel();
        memset(&cm_p->ucm_auto_dtmf_uid, 0, sizeof(mmi_ucm_id_info_struct));
    }
    
    /*Cancel ccbs activation confirm if the call is released*/
    if(GetCCBSFlag() == TRUE)
    {
        mmi_gsm_ccbs_activation_conf_cancel();
    }

    /*clear the call info since the call is released*/
    memset(&cm_p->disc_call, 0, sizeof(mmi_gsm_disc_call_struct));
    
    SetCallEndCause(0);

#ifdef __MMI_VIDEO_TELEPHONY__    
    if (release_ind.uid_info.call_type == MMI_UCM_VIDEO_CALL_TYPE)
    {
        /* Turn off speech */
        mmi_gsm_speech_ind(MMI_FALSE, MDI_AUDIO_SPEECH_APP_ID_3G324M, MMI_UCM_VIDEO_CALL_TYPE);

        /* Display post action screen after MO video call fails */
        if (cm_p->disc_call.state == CM_OUTGOING_STATE &&
            mmi_ucm_app_total_call(MMI_UCM_VOICE_CALL_TYPE | MMI_UCM_VOIP_CALL_TYPE | MMI_UCM_VIDEO_CALL_TYPE) == 0 &&
            (cm_p->ucm_operation == MMI_GSM_UCM_IDLE && cm_p->ucm_action_type == MMI_GSM_UCM_NO_ACTION))
        {
            if (GetExitScrnID() == SCR_ID_UCM_CALL_END)
            {
                DeleteScreenIfPresent(SCR_ID_VT_MO_FAIL_POST_ACTION); /* for auto redial case */
                mmi_vt_mo_fail_post_action_add_to_history();
            }
            else
            {
                mmi_vt_entry_mo_fail_post_action();
                DeleteScreenIfPresent(SCR_ID_VT_MO_FAIL_POST_ACTION); /* for auto redial case */           
            }
        }
    }
#endif /* __MMI_VIDEO_TELEPHONY__ */

    if(GetTotalCallCount() == 0)
    {
        gSumACMValue = 0;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_call_cost_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_call_cost_ind(CM_CALL_HANDLE call_handle, PU8 symbol, PU8 value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_call_cost_struct call_cost_ind;
    U16 count;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&call_cost_ind, 0, sizeof(mmi_ucm_call_cost_struct));

    call_cost_ind.symbol = symbol;
    call_cost_ind.cost = value;

    /*UID info*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if(cm_p->state_info.AllCalls[count].call_handle == call_handle)
        {
            call_cost_ind.uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
            call_cost_ind.uid_info.group_id= cm_p->state_info.AllCalls[count].group_id;
            call_cost_ind.uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);
        }
    }
    
    mmi_ucm_dispatch_ind(MMI_UCM_CALL_COST_IND, (void *)&call_cost_ind);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_auto_redial_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_auto_redial_ind()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_auto_redial_struct auto_redial_ind;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&auto_redial_ind, 0, sizeof(mmi_ucm_auto_redial_struct));
    memcpy((S8 *)auto_redial_ind.display_msg, (S8 *)&gRedialMsgTemp, MMI_UCM_MAX_AUTO_REDIAL_MSG_LEN);
    auto_redial_ind.abort_hdlr = (FuncPtr)ResetRedialAttempts;
    
    mmi_ucs2_n_to_asc(
        (S8 *)auto_redial_ind.num_uri,
        (S8 *)cm_p->redial_info.RedialNum,
        MMI_UCM_MAX_NUM_URI_LEN);

    auto_redial_ind.call_type = GetUCMCallType(cm_p->redial_info.call_type); /* __MMI_VIDEO_TELEPHONY__ */ 
    auto_redial_ind.attempt = cm_p->redial_info.CurrentAttempt; 
    auto_redial_ind.time = cm_p->redial_info.Timer;
    
    mmi_ucm_dispatch_ind(MMI_UCM_AUTO_REDIAL_IND, (void *)&auto_redial_ind);

#ifdef __IP_NUMBER__
    while(GetTempUseIPNumber())
    {
        SetTempUseIPNumber(FALSE);
    }
#endif /* __IP_NUMBER__ */
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_csd_call_approve
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_csd_call_approve(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_CSD_APPROVE_REQ *msg;
    PU8 start;
    U8 number[MAX_DIGIT];
    S8 uniinput_string[MAX_NUMBER];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("mmi_gsm_csd_call_approve");

    msg = (MMI_CSD_APPROVE_REQ*) MsgStruct;

#ifdef __MMI_DUAL_SIM_MASTER__
    if (msg->sim_info == 2)
    {
        MTPNP_PFAL_csd_call_approve(MsgStruct);
        return;
    }
#endif	/* __MMI_DUAL_SIM_MASTER__ */

    memset((PS8) number, 0, MAX_DIGIT);
    start = number;

    if (msg->call_num_type & 0x10)
    {
        number[0] = '+';
        start++;
    }

    if (msg->call_num_len < MAX_DIGIT)
    {
        strncpy((PS8) start, (PS8) msg->call_num, msg->call_num_len);
    }
    else
    {
        strcpy((PS8) start, (PS8) msg->call_num);
    }

    memset(uniinput_string, 0, MAX_NUMBER);
    mmi_asc_to_ucs2((PS8) uniinput_string, (PS8) number);

    if(mmi_ucm_app_make_call_with_source(MMI_UCM_FROM_ABM, MMI_UCM_CSD_CALL_TYPE, (U8 *)uniinput_string))
    {
        mmi_gsm_csd_call_confirm(MMI_TRUE, msg);
    }
    else
    {
        mmi_gsm_csd_call_confirm(MMI_FALSE, msg);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_csd_call_confirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_csd_call_confirm(MMI_BOOL result, void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYQUEUE Message;
    MMI_CSD_APPROVE_CNF *csd_cnf;
    MMI_CSD_APPROVE_REQ *info = (MMI_CSD_APPROVE_REQ*) msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("mmi_gsm_csd_call_confirm");

    Message.oslSrcId = MOD_MMI;
    Message.oslDestId = MOD_ABM;
    Message.oslMsgId = PRT_CSD_CALL_APPROVE_CNF;

    csd_cnf = (MMI_CSD_APPROVE_CNF*) OslConstructDataPtr(sizeof(MMI_CSD_APPROVE_CNF));

    csd_cnf->prof_id = info->prof_id;
    csd_cnf->sim_info = info->sim_info;
    csd_cnf->result = result;

    Message.oslDataPtr = (oslParaType*) csd_cnf;
    Message.oslPeerBuffPtr = NULL;

    OslMsgSendExtQueue(&Message);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_start_processing_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_start_processing_ind()

{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_start_processing_struct start_processing_ind;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&start_processing_ind, 0, sizeof(mmi_ucm_start_processing_struct));

    start_processing_ind.content = (U8 *)GetString(STR_ID_UCM_PROCESSING);

	mmi_ucm_dispatch_ind(MMI_UCM_START_PROCESSING_IND, (void *)&start_processing_ind);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_stop_processing_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_stop_processing_ind(U8 *disp_msg, U16 image_id, U16 tone_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_stop_processing_struct stop_processing_ind;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&stop_processing_ind, 0, sizeof(mmi_ucm_stop_processing_struct));
    
    stop_processing_ind.disp_msg = disp_msg;
    stop_processing_ind.image_id = image_id;
    stop_processing_ind.tone_id = tone_id;
    
	mmi_ucm_dispatch_ind(MMI_UCM_STOP_PROCESSING_IND, (void *)&stop_processing_ind);
    
    SetUCMOperationState(MMI_GSM_UCM_NO_ACTION, MMI_GSM_UCM_IDLE);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_auto_dtmf_conf
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_auto_dtmf_conf_display(U8 *disp_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_display_cnf_struct auto_dtmf_conf;
    U16 count;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_auto_dtmf_conf_display REQ");

    memset(&auto_dtmf_conf, 0, sizeof(mmi_ucm_display_cnf_struct));

    auto_dtmf_conf.content = disp_msg;
    auto_dtmf_conf.end_hdlr = NULL;
    auto_dtmf_conf.rsk_hdlr = NULL;
    auto_dtmf_conf.rsk_str = STR_GLOBAL_NO;
    auto_dtmf_conf.send_hdlr = NULL;
    auto_dtmf_conf.lsk_hdlr =(FuncPtr)ConfirmDTMFString;
    auto_dtmf_conf.lsk_str = STR_GLOBAL_YES;
    auto_dtmf_conf.cancel_hdlr = NULL;

    /*UID info*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if(cm_p->state_info.AllCalls[count].curr_state == CM_ACTIVE_STATE)
        {
            cm_p->ucm_auto_dtmf_uid.call_id = cm_p->state_info.AllCalls[count].call_handle;
            cm_p->ucm_auto_dtmf_uid.call_id = cm_p->state_info.AllCalls[count].group_id;
            cm_p->ucm_auto_dtmf_uid.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);
        }
    }
    
    mmi_ucm_dispatch_cnf(MMI_UCM_DISPLAY_CNF, (void *)&auto_dtmf_conf);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ccbs_activation_conf
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_ccbs_activation_conf(U8 *disp_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_display_cnf_struct ccbs_activation_conf;
    U16 count;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_ccbs_activation_conf REQ");
    SetCCBSFlag(TRUE);
    memset(&ccbs_activation_conf, 0, sizeof(mmi_ucm_display_cnf_struct));

    ccbs_activation_conf.content = disp_msg;
    ccbs_activation_conf.end_hdlr = (FuncPtr)IgnoreCCBS;
    ccbs_activation_conf.rsk_hdlr = (FuncPtr)IgnoreCCBS;
    ccbs_activation_conf.rsk_str = STR_GLOBAL_NO;
    ccbs_activation_conf.send_hdlr = NULL;
    ccbs_activation_conf.lsk_hdlr =(FuncPtr)ActivateCCBS;
    ccbs_activation_conf.lsk_str = STR_GLOBAL_YES;
    ccbs_activation_conf.cancel_hdlr = (FuncPtr)IgnoreCCBS;
    ccbs_activation_conf.disp_condition = MMI_UCM_DISP_OUTGOING; /*show confirm popup in outgoing call screen*/

    mmi_ucm_dispatch_cnf(MMI_UCM_DISPLAY_CNF, (void *)&ccbs_activation_conf);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ccbs_activation_conf_cancel
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_ccbs_activation_conf_cancel()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_display_cnf_struct ccbs_activation_conf;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("mmi_gsm_ccbs_activation_conf_cancel");

    SetCCBSFlag(FALSE);
    
    memset(&ccbs_activation_conf, 0, sizeof(mmi_ucm_display_cnf_struct));
    
    mmi_ucm_dispatch_cnf(MMI_UCM_CANCEL_CNF, (void *)&ccbs_activation_conf);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ccbs_recall_conf
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_ccbs_recall_conf(U8 *number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_display_cnf_struct ccbs_recall_conf;
    U16 count;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("mmi_gsm_ccbs_activation_conf");
    SetCCBSFlag(TRUE);
    memset(&ccbs_recall_conf, 0, sizeof(mmi_ucm_display_cnf_struct));

    ccbs_recall_conf.content = number;
    ccbs_recall_conf.end_hdlr = (FuncPtr)ProcessCCBSRejectRequest;
    ccbs_recall_conf.rsk_hdlr = (FuncPtr)ProcessCCBSRejectRequest;
    ccbs_recall_conf.rsk_str = STR_GLOBAL_NO;
    ccbs_recall_conf.send_hdlr = NULL;
    ccbs_recall_conf.lsk_hdlr =(FuncPtr)ProcessCCBSDialRequest;
    ccbs_recall_conf.lsk_str = STR_GLOBAL_DIAL;
    ccbs_recall_conf.cancel_hdlr = (FuncPtr)ProcessCCBSRejectRequest;
    ccbs_recall_conf.disp_condition = 0;
 
    mmi_ucm_dispatch_cnf(MMI_UCM_DISPLAY_CNF, (void *)&ccbs_recall_conf);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ccbs_recall_conf_cancel
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_ccbs_recall_conf_cancel()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_display_cnf_struct ccbs_recall_conf;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("mmi_gsm_ccbs_activation_conf_cancel");

    SetCCBSFlag(FALSE);
    SetCCBSHandle(-1);
    
    memset(&ccbs_recall_conf, 0, sizeof(mmi_ucm_display_cnf_struct));
    
    mmi_ucm_dispatch_cnf(MMI_UCM_CANCEL_CNF, (void *)&ccbs_recall_conf);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ccbs_recall
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_ccbs_recall()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_display_cnf_struct ccbs_recall_conf;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("mmi_gsm_ccbs_recall");
    
    MakePsActiveHold((void*)CCBSDialResponse);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_auto_dtmf_conf_cancel
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_auto_dtmf_conf_cancel()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_ucm_display_cnf_struct auto_dtmf_conf;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("GSM call application: mmi_gsm_auto_dtmf_conf_cancel REQ");
    
    memset(&auto_dtmf_conf, 0, sizeof(mmi_ucm_display_cnf_struct));
    
    mmi_ucm_dispatch_cnf(MMI_UCM_CANCEL_CNF, (void *)&auto_dtmf_conf);
}

#ifdef __MMI_CH_QUICK_END__
/*****************************************************************************
 * FUNCTION
 *  autoQuickEnd
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 *
 * RETURNS
 *
 *****************************************************************************/
void autoQuickEnd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("autoQuickEnd");
    StopTimer(CM_AUTO_QUICK_END_TIMER);
    
    if (!(GetTotalCallCount() == 1 && (GetCurrentState() == CM_INCOMING_STATE || GetCurrentState() == CM_OUTGOING_STATE))
        && EmergencyCallPresent() == FALSE && GetTotalCallCount() > 0)
    {
        PRINT_INFORMATION("autoQuickEnd:start processing");
        /*let call release ind happens naturally*/
        /*chld rsp fail will cause cm show error messages*/
        SetUCMOperationState(MMI_GSM_UCM_CRSS, MMI_GSM_UCM_AUTO_QUICK_END);
        mmi_gsm_start_processing_ind();
        MakePsHangupallRequest(NULL);
    }
    return;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_dial_req_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_dial_req_ind()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_ucm_ring_ind_struct dial_req_ind;
    PHB_CM_INTERFACE *PhoneNumberStruct;
    U16 count;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    memset(&dial_req_ind, 0, sizeof(mmi_ucm_ring_ind_struct));
    
    dial_req_ind.call_list = OslMalloc(sizeof(mmi_ucm_sync_call_list_struct));
    mmi_gsm_get_call_list(dial_req_ind.call_list);
    PRINT_INFORMATION("GSM call application: mmi_gsm_dial_req_ind");

#ifdef __MMI_DUAL_SIM_MASTER__
    MTPNP_AD_Set_Channel(MTPNP_AD_CALL_CHANNEL, MTPNP_AD_CHANNEL_MASTER);
#endif /* __MMI_DUAL_SIM_MASTER__ */

    /*remote info*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_OUTGOING_STATE)
        {
            mmi_ucs2_n_to_asc(
            (S8 *)dial_req_ind.display_info.num_uri,
            (S8 *)cm_p->state_info.AllCalls[count].number,
            MMI_UCM_MAX_NUM_URI_LEN);
            PRINT_INFORMATION("GSM call application: mmi_gsm_dial_req_ind: number:%s", dial_req_ind.display_info.num_uri);

            mmi_ucs2ncpy((S8 *)dial_req_ind.display_info.disp_name,
                        (S8 *)GetDispNameorNum(cm_p->state_info.AllCalls[count].call_handle),
                        MMI_UCM_MAX_DISP_NAME_LEN);
            
            PRINT_INFORMATION("GSM call application: mmi_gsm_dial_req_ind: display name:%s", dial_req_ind.display_info.disp_name);
                    
            mmi_ucs2ncpy((S8 *)dial_req_ind.display_info.log_name,
                        (S8*) GetCallLogName(cm_p->state_info.AllCalls[count].call_handle),
                        MMI_UCM_MAX_DISP_NAME_LEN);
            PRINT_INFORMATION("GSM call application: mmi_gsm_dial_req_ind: log name:%s", dial_req_ind.display_info.log_name);

            /*uid info*/
            dial_req_ind.uid_info.call_id = cm_p->state_info.AllCalls[count].call_handle;
            dial_req_ind.uid_info.group_id = GetUnUsedGroupID();
            dial_req_ind.uid_info.call_type = GetUCMCallType(cm_p->state_info.AllCalls[count].call_type);

        }
    } 

    /*alert info*/
    PhoneNumberStruct = GetCMPhoneBookStruct();
    dial_req_ind.alert_info.image_info.image_id = PhoneNumberStruct->pictureId;
    PRINT_INFORMATION("GSM call application: mmi_gsm_dial_req_ind: picureID:%d", dial_req_ind.alert_info.image_info.image_id);
    dial_req_ind.alert_info.image_info.record_index = PhoneNumberStruct->record_index; 
    PRINT_INFORMATION("GSM call application: mmi_gsm_dial_req_ind: record_index:%d", dial_req_ind.alert_info.image_info.record_index);

    /*Only allow caller image for outgoing call*/
    //dial_rsp.alert_info.image_info.video_id = PhoneNumberStruct->videoId;
    PRINT_INFORMATION("GSM call application: mmi_gsm_dial_req_ind: videoId:%d", dial_req_ind.alert_info.image_info.video_id);
    //dial_rsp.alert_info.image_info.video_record_index = PhoneNumberStruct->video_record_index;
    PRINT_INFORMATION("GSM call application: mmi_gsm_dial_req_ind: video_record_index:%d", dial_req_ind.alert_info.image_info.video_record_index);
                        
    mmi_ucm_dispatch_ind(MMI_UCM_DIAL_REQ_IND, (void *)&dial_req_ind);

    OslMfree(dial_req_ind.call_list);	
}

#ifdef __CTM_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ctm_is_open
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_gsm_ctm_open(BOOL ctm_open)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(ctm_open == TRUE)
    {
        PRINT_INFORMATION("mmi_gsm_ctm_open:TRUE");
        
        /* open ctm after turn on speech */
        if (ctm_p->status == TRUE && 
            (ctm_p->state == MMI_CTM_STATE_IDLE || 
            ctm_p->state == MMI_CTM_STATE_CLOSING))
        {
            S8 mode = 0xff;
    
            if (ctm_p->tty_status == TRUE)
            {
                /* with TTY, open as TTY */
                switch (ctm_p->mode_setting)
                {
                    case MMI_CTM_SETTING_HCO:
                        mode = CTM_HCO_MODE;
                        break;
                    case MMI_CTM_SETTING_VCO:
                        mode = CTM_VCO_MODE;
                        break;
                    case MMI_CTM_SETTING_BAUDOT:
                        mode = CTM_BAUDOT_MODE;
                        break;
                    default:
                          /* CTM ON, earphone in, direct mode => no CTM function, take it as earphone */
                          mode = CTM_DIRECT_MODE;
                        break;
                }
            }
            else
            {
                switch (ctm_p->mode_setting)
                {
                    case MMI_CTM_SETTING_AUTO_DIRECT:
                    case MMI_CTM_SETTING_MANUAL_DIRECT:
                        /* no TTY, open as direct */
                        mode = CTM_DIRECT_MODE;
                        break;
                    default:
                        break;
                }
            }
            if (mode != 0xff)
            {
                mmi_ctm_send_open_req(mode);
                mmi_ctm_set_state(MMI_CTM_STATE_OPENING);
            }
        }
    }
    else
    {
        PRINT_INFORMATION("mmi_gsm_ctm_open:FALSE");
       
        /* close ctm before turn off speech */
        if (ctm_p->state == MMI_CTM_STATE_OPENED ||
            ctm_p->state == MMI_CTM_STATE_CONNECTING ||
            ctm_p->state == MMI_CTM_STATE_CONNECTED ||
            ctm_p->state == MMI_CTM_STATE_SENDING)
        {
            mmi_ctm_send_close_req();
            mmi_ctm_set_state(MMI_CTM_STATE_CLOSING);
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ctm_is_open
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL mmi_gsm_ctm_is_open()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("Mick debig:call count:%d",GetTotalActiveCallCount());
    PRINT_INFORMATION("Mick debig:ctm state:%d",ctm_p->state);
    PRINT_INFORMATION("Mick debig:mode:%d",ctm_p->mode_activated);
    if ((GetTotalActiveCallCount() > 0) &&
          (ctm_p->state == MMI_CTM_STATE_OPENED) && (ctm_p->mode_activated == CTM_DIRECT_MODE))
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_ctm_is_open? yes");
        return TRUE;
    }
    PRINT_INFORMATION("GSM call application: mmi_gsm_ctm_is_open? no");
    return FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ctm_is_on
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL mmi_gsm_ctm_is_on()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (ctm_p->status == TRUE)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_ctm_is_open? yes");
        return TRUE;
    }
    PRINT_INFORMATION("GSM call application: mmi_gsm_ctm_is_open? no");
    return FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_gsm_ctm_is_connected
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL mmi_gsm_ctm_is_connected()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (ctm_p->state == MMI_CTM_STATE_CONNECTED ||
        ctm_p->state == MMI_CTM_STATE_CONNECTING ||
        ctm_p->state == MMI_CTM_STATE_SENDING)
    {
        PRINT_INFORMATION("GSM call application: mmi_gsm_ctm_is_connected? yes");
        return TRUE;
    }
    PRINT_INFORMATION("GSM call application: mmi_gsm_ctm_is_connected? no");
    return FALSE;
}

#endif /* __CTM_SUPPORT__*/

#endif /* __MMI_UCM__ */
