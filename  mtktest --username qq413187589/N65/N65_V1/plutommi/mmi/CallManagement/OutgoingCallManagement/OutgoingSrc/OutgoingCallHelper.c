/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*******************************************************************************
 *  Modification Notice:
 *  --------------------------
 *  This software is modified by MediaTek Inc. and the information contained
 *  herein is confidential. The software may not be copied and the information
 *  contained herein may not be used or disclosed except with the written
 *  permission of MediaTek Inc. (C) 2001
 *
 *******************************************************************************/

 /*******************************************************************************
 * Filename:
 * ---------
 *   OutgoingCallHelper.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *  .......
 *
 * Author:
 * -------
 * -------
 *
 *------------------------------------------------------------------------------
 * $Log$
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * created by clearfsimport
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * created by clearfsimport
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * created by clearfsimport
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * 
 *
 * removed!
 * removed!
 * Register callback function fop dialing icon
 *
 *******************************************************************************/

/**
 * Copyright Notice
 * ?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */

/**************************************************************

   FILENAME : OutgoingCallHelper.c

   PURPOSE     : Call Management application

   REMARKS     : nil

   AUTHOR      : Subramanya BG

   DATE     : Nov 12,02

**************************************************************/
#include "MMI_include.h"

#ifndef __MMI_UCM__

#include "ProtocolEvents.h"
#include "CommonScreens.h"
#include "wgui.h"
#include "Wgui_status_icons.h"

#include "BootUp.h"
#include "PowerOnChargerProt.h"
#include "PhonebookDef.h"
#include "PhoneBookTypes.h"
#include "PhoneBookGprot.h"
#include "CallSetUpEnum.h"
#include "SimDetectionGexdcl.h"
#include "SimDetectionGprot.h"
#include "AlarmFrameworkProt.h"
#include "DateTimeGprot.h"

#include "CallmanagementIdDef.h"
#include "CallManagementStruct.h"
#include "CallStructureManagementProt.h"
#include "CmErrorTypes.h"
#include "CmErrorHandlersProt.h"
#include "CommonStubsProt.h"
#include "HistoryHelperProt.h"
#include "PsCallHelperDef.h"
#include "mmiapi_struct.h"
#include "PsCallHelperGprot.h"
#include "RedialHelperGProt.h"
#include "CallManagementGprot.h"
#include "IncomingCallManagementProt.h"
#include "OutgoingCallManagementProt.h"

#include "CallsGProts.h"

#include "OutgoingCallHelperGProt.h"
#include "OutgoingCallHelperProt.h"
#include "gpioInc.h"

#include "VolumeHandler.h"

#ifdef __MMI_VOIP__
#include "VoIPGProt.h"
#endif

#if defined(__MMI_WLAN_FEATURES__) && defined(__MMI_VOIP__)
#include "NetworkSetupDefs.h"
#endif

#if defined(__MMI_BG_SOUND_EFFECT__)
#include "BGSoundGProt.h"
#endif 

#ifdef __MMI_BT_PROFILE__
#include "mdi_datatype.h"
#include "mdi_audio.h"
void mmi_profiles_bt_call_start_callback(void);
#endif /* __MMI_BT_PROFILE__ */ 

#if defined (JATAAYU_SUPPORT) && defined (WAP_SUPPORT)
#include "ddl.h"
#include "jcutils.h"
#include "jcerror.h"
#include "jdd_tapi.h"
#endif

static CM_CALL_HANDLE gMyhandle;

/* static U16 curKeyCode, curKeyType; */
static pBOOL gCheckDialIndEndOutgoing = FALSE;

S8 DTMFPadCallBuffer[MAX_DIGITS_USSD];
#ifdef __MTK_TARGET__
__align(2)
#endif /* __MTK_TARGET__ */ 
S8 UnicodeDTMFPadCallBuffer[MAX_DIGITS_USSD * ENCODING_LENGTH];
PU8 gCallDeflectNumber;

extern U16 gtmpOutgoingIndex;
extern void SSCHandleIMEI(void);

const U16 CMIdleScreenDigits[MAX_CM_SCREEN_DIGITS] = 
{
    KEY_0, KEY_1, KEY_2, KEY_3,
    KEY_4, KEY_5, KEY_6, KEY_7,
    KEY_8, KEY_9, KEY_STAR,
    KEY_POUND
};


/*****************************************************************************
 * FUNCTION
 *  MakeCallEx
 * DESCRIPTION
 *  Wrapper which checks to see if the call to be made is
 *  O/G or USSD
 *  
 *  This function is exported to others applications
 * PARAMETERS
 *  strNumber       [IN]        
 *  pre_check       [IN]        
 *  Number(?)       [IN]        Which needs to be sent to network
 * RETURNS
 *  void
 *****************************************************************************/
void MakeCallEx(PS8 strNumber, BOOL pre_check)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check low battery */
    if (!CHECK_MO_ALLOW())
    {
        ChgrPlayLowBatTone();
        BatteryIndicationPopup(STR_LOW_BATTERY_MT_PROHIBIT);
        return;
    }
#ifdef __MMI_VOIP__
    /* cannot dial gsm call when voip call exists */
    if (mmi_voip_app_total_call() != 0)
    {
        ShowCallManagementErrorMessage(ERR_REQ_FACILITY_UNAVAIL);
        return;
    }
#endif /* __MMI_VOIP__ */

    if (IS_LOW_BATTERY())
    {
        ChgrPlayLowBatTone();
        if (g_charbat_context.LowBatteryTxProhibitFlag)
        {
            SET_LOW_BATTERY_ALARM_THRESHOLD(LBAT_TALK_DURCNT_PROHIBIT);
        }
        else
        {
            SET_LOW_BATTERY_ALARM_THRESHOLD(LBAT_TALK_DURCNT_NORMAL);
        }
    }

    SetNoSave();

    if (!GetDialedDigitCalledFlag())
    {
        ClearDtmfBuf();
        FillDtmfBuff((PU8) strNumber);
    }
    else
    {
        SetDialedDigitCalledFlag(FALSE);
    }

    if (!pre_check)
    {
        if (NULL == strNumber)
        {
            SetCallDeflectFlag(FALSE);
            ShowCallManagementErrorMessage(ERR_INVALID_NUMBER_FORMAT);
            return;
        }
        else if (0 == *strNumber)
        {
            SetCallDeflectFlag(FALSE);
            ShowCallManagementErrorMessage(ERR_INVALID_NUMBER_FORMAT);
            return;
        }

	if (!CheckValidEmergencyNo1(strNumber))
	{
        if (UCS2StrFirstPositionSearch(strNumber) == FALSE)
        {
            SetCallDeflectFlag(FALSE);
            ShowCallManagementErrorMessage(ERR_INVALID_NUMBER_FORMAT);
            return;
        }
        if (UCS2StrNoFirstPositionSearch(strNumber, 'p') == FALSE)
        {
            SetCallDeflectFlag(FALSE);
            ShowCallManagementErrorMessage(ERR_INVALID_NUMBER_FORMAT);
            return;
        }
        if (UCS2StrNoFirstPositionSearch(strNumber, 'w') == FALSE)
        {
            SetCallDeflectFlag(FALSE);
            ShowCallManagementErrorMessage(ERR_INVALID_NUMBER_FORMAT);
            return;
        }
        }
    }

    CheckShortCutOrCall();
}


/*****************************************************************************
 * FUNCTION
 *  MakeCall
 * DESCRIPTION
 *  Check if the background sound is turn on
 *  
 *  This function is exported to others applications
 * PARAMETERS
 *  strNumber       [IN]        
 *  Number(?)       [IN]        Which needs to be sent to network
 * RETURNS
 *  void
 *****************************************************************************/
void MakeCall(PS8 strNumber)
{
#if defined(__MMI_BG_SOUND_EFFECT__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 scr_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((!CheckValidEmergencyNo1(strNumber)) && (!mmi_bootup_is_sim_valid()))
    {
        DisplayPopup((U8*) GetString(STR_NOT_SOS_NUMBER), IMG_GLOBAL_ERROR, 0, 2000, (U8) ERROR_TONE);
        return;
    }
    
#if defined(__MMI_WLAN_FEATURES__) && defined(__MMI_VOIP__)
    if (mmi_netset_get_active_preferred_mode() == 1 /*&& ref_prefer_mode == MMI_TRUE*/)
    {
        /* preferred mode = WLAN only */
        DisplayPopup(
            (PU8)GetString(STR_GLOBAL_UNFINISHED),
            IMG_GLOBAL_UNFINISHED,
            1,
            CS_NOTIFYDURATION,
            (U8)ERROR_TONE);
        mmi_phb_call_set_dial_from_list(MMI_PHB_NONE);  /* reset dial from phonebook flag */
        CHISTSetDialFromCallLogFlag(0);                 /* reset dial from call history flag */
        return;
    }
#endif /* defined(__MMI_WLAN_FEATURES__) && defined(__MMI_VOIP__) */

    /* Don't enter background sound in the call setup screen */
    scr_id = GetActiveScreenId();
    SetNoSave();

    /* Do check in advance to avoid some screen problem. */
    if (!(scr_id >= SCR_ID_CALLSET_BARRING_MAIN && scr_id <= SCR_SETTING_BLACK_LIST_NUM) &&
        (strNumber != NULL) &&
        (*strNumber != 0) &&
	( ( CheckValidEmergencyNo1(strNumber) ) ||
        (UCS2StrFirstPositionSearch(strNumber) == TRUE) &&
        (UCS2StrNoFirstPositionSearch(strNumber, 'p') == TRUE) &&
        (UCS2StrNoFirstPositionSearch(strNumber, 'w') == TRUE) ) &&
        (CHECK_MO_ALLOW()) &&
        (mmi_bgsnd_mo_call_check_last_char(strNumber, '#') == MMI_FALSE))  /* Not SS string */
    {
        /* Already check the number correctness, no need to check in MakeCallEx() again */
        if (mmi_bgsnd_mo_call_use_effect(strNumber) == FALSE)
        {
            MakeCallEx(strNumber, TRUE);
        }
    }
    else
    {
        /* Check number correctness fail, let it check again and popup error message in the MakeCallEx() */
#if defined(__MMI_WLAN_FEATURES__) && defined(__MMI_VOIP__)
    if (mmi_netset_get_active_preferred_mode() == 1 /*&& ref_prefer_mode == MMI_TRUE*/)
    {
        /* preferred mode = WLAN only */
        DisplayPopup(
            (PU8) GetString(STR_GLOBAL_UNFINISHED),
            IMG_GLOBAL_UNFINISHED,
            1,
            CS_NOTIFYDURATION,
            (U8) ERROR_TONE);
        mmi_phb_call_set_dial_from_list(MMI_PHB_NONE);  /* reset dial from phonebook flag */
        CHISTSetDialFromCallLogFlag(0);                 /* reset dial from call history flag */
        return;
    }
#endif /* defined(__MMI_WLAN_FEATURES__) && defined(__MMI_VOIP__) */

        MakeCallEx(strNumber, FALSE);
    }

#else /* defined(__MMI_BG_SOUND_EFFECT__) */ 

    MakeCallEx(strNumber, FALSE);

#endif /* defined(__MMI_BG_SOUND_EFFECT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  CheckShortCutOrCall
 * DESCRIPTION
 *  Helper function to check if the key is shortcut or not
 *  if not it makes a call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void CheckShortCutOrCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 dtmfBuf;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetNoSave();
    dtmfBuf = GetDtmfBuffer();

    if (GetCallDeflectFlag() == FALSE)
    {
        if (IsStandardGsmSS(dtmfBuf))
        {
            return;
        }
    }

    if (GetCallDeflectFlag() == TRUE)
    {
        PRINT_INFORMATION("XXX Call Deflection\n");
        SetCallDeflectFlag(FALSE);
        OutgoingProcessCMEvent(CM_KB_CALL_DEFLECT_REQ, dtmfBuf);
        /* return; */
    }
    else if (IsSimControlProcedure(dtmfBuf) == TRUE)
    {
        PRINT_INFORMATION("XXX Sim Specifc Control\n");
        return;
    }
    else if (IsManufactuerSpecific(dtmfBuf) == TRUE)
    {
        PRINT_INFORMATION("XXX Manufacture Specific Control \n");
        return;
    }
    else if (isHashString(dtmfBuf))
    {
        MakeMyCall((PS8) dtmfBuf);
    }
    else if (isShortString(dtmfBuf))
    {
        MakeMyCall((PS8) dtmfBuf);
    }
    else    /* if (AllowMoreCalls()) */
    {
        MakeMyCall((PS8) dtmfBuf);
    }
    /* else
       {
       ShowCallManagementErrorMessage(ERR_CSMCC_CMD_NOT_ALLOW);
       } */

    ClearDtmfBuf();
}


/*****************************************************************************
 * FUNCTION
 *  MakeMyCall
 * DESCRIPTION
 *  Helper function to make a outgoingcall of a given number.
 *  
 *  This converts the number to OUTGOING_CALL structure which is necessary for State m/c.
 * PARAMETERS
 *  strNumber       [IN]        
 *  Number(?)       [IN]        Which needs to make the outgoing call.
 * RETURNS
 *  void
 *****************************************************************************/
void MakeMyCall(PS8 strNumber)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    OUTGOING_CALL outCall;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&outCall, 0, sizeof(OUTGOING_CALL));
    if ((strlen((void*)strNumber) * ENCODING_LENGTH) > MAX_CM_NUMBER)
    {
        PRINT_INFORMATION("XXX Number too long XXX \n");
        ShowCallManagementErrorMessage(ERR_INVALID_NUMBER_FORMAT);
        return;
    }
#ifdef __MMI_USSD_REPLY_UCS2__
    strcpy((void*)outCall.Number, (void*)DTMFPadCallBuffer);
#else
    mmi_ucs2cpy((void*)outCall.Number, (void*)UnicodeDTMFPadCallBuffer);
#endif
    MakeOutgoingcall(outCall);
}

#ifdef __MMI_USSD_REPLY_UCS2__
void MakeReplyUSSRCall(PS8 strNumber)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    OUTGOING_CALL outCall;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&outCall, 0, sizeof(OUTGOING_CALL));
    if ((strlen((void*)strNumber) * ENCODING_LENGTH) > MAX_CM_NUMBER)
    {
        PRINT_INFORMATION("XXX Number too long XXX \n");
        ShowCallManagementErrorMessage(ERR_INVALID_NUMBER_FORMAT);
        return;
    }
    mmi_ucs2cpy((void*)outCall.Number, (void*)UnicodeDTMFPadCallBuffer);
    outCall.bIsUcs2 = TRUE;
    MakeOutgoingcall(outCall);
}
#endif
/*****************************************************************************
 * FUNCTION
 *  MakeOutgoingcall
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_OUTGOINGCALL with the OUTGOING_CALL structure.
 *  
 *  This invokes the function to process the CM_KB_OUTGOINGCALL event in the state m/c.
 * PARAMETERS
 *  MsgStruct           [IN]        
 *  structure(?)        [IN]        Contains the calling number and name if present corresponding to that number.
 * RETURNS
 *  void
 *****************************************************************************/
void MakeOutgoingcall(OUTGOING_CALL MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OutgoingProcessCMEvent(CM_KB_OUTGOINGCALL, &MsgStruct);
}


/*****************************************************************************
 * FUNCTION
 *  IsStandardGsmSS
 * DESCRIPTION
 *  Helper function for interpreting user code
 * PARAMETERS
 *  dtmfBuf         [IN]        
 *  true(?)         [OUT]       Or false on the basis of interepretaion of SS
 *  buffer(?)       [IN]        For interpretation
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL IsStandardGsmSS(PU8 dtmfBuf)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 tmpBuf = dtmfBuf;
    CM_CALL_HANDLE callVal;
    S32 bufLen;
    pBOOL valid = FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GetTotalCallCount() == 0)
    {
        return FALSE;
    }

    /* second digit must be NULL, *, or 0~9 */
    if ((*(tmpBuf + 1) == 0) || (*(tmpBuf + 1) == '*') || ((*(tmpBuf + 1) >= '0') && (*(tmpBuf + 1) <= '9')))
    {
        valid = TRUE;
    }

    if (valid == TRUE)
    {
        switch (*tmpBuf)
        {
            case '0':
                if ('\0' == *(tmpBuf + 1))
                {
                    /* 0 send */
                    if (-1 != GetIncomingCallHandle())
                    {
                        /* incoming call present => reject waiting call */
                        if (GetTotalCallCount() > 1)
                        {
                            PRINT_INFORMATION("\n *** Reject Waiting Call\n");
                            KbCBackCallIncomingRejected();
                            return TRUE;
                        }
                        else
                        {
                            valid = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        /* no incoming call, drop held call */
                        if ((GetTotalHoldCallCount() > 0) ||
                            ((GetTotalActiveCallCount() > 0) && (GetCurrentState() == CM_OUTGOING_STATE)))
                        {
                            PRINT_INFORMATION("\n *** Hanging Up All Hold\n");
                            HangupallHeld();
                            return TRUE;
                        }
                        else
                        {
                            valid = TRUE;
                            break;
                        }
                    }
                }
                valid = FALSE;
                break;

            case '1':
                if ('\0' == *(tmpBuf + 1))
                {
                    /* 1 send */
                    if (GetCurrentState() == CM_INCOMING_STATE)
                    {
                        if (GetTotalCallCount() == 1)
                        {
                            valid = TRUE;
                            break;
                        }
                        else
                        {
                            KbCBackEndActiveAcceptIncomingCall();
                            return TRUE;
                        }
                    }
                    else if (GetCurrentState() == CM_OUTGOING_STATE)
                    {
                        valid = TRUE;
                        break;
                    }
                    else
                    {
                        if (GetTotalCallCount() > 0)
                        {
                            ProcessIncomingEvents(CM_KB_END_ALL_ACTIVE_RETRIEVE_HELD, NULL);
                            return TRUE;
                        }
                        else
                        {
                            valid = TRUE;
                            break;
                        }
                    }
                }
                else if ('\0' == *(tmpBuf + 2))
                {
                    /* 1X send */
                    PRINT_INFORMATION("\n *** Hanging Up Active call \n");

                    callVal = (CM_CALL_HANDLE) atoi((void*)(tmpBuf + 1));

                    if (callVal != 0 && GetCallState(callVal) == CM_ACTIVE_STATE &&
                        GetCurrentState() != CM_OUTGOING_STATE)
                    {
                        HangupCall(callVal);
                        return TRUE;
                    }
                    else
                    {
                        valid = TRUE;
                        break;
                    }
                }
                valid = FALSE;
                break;

            case '2':
                if ('\0' == *(tmpBuf + 1))
                {
                    /* 2 send */
                    if (GetWapCallPresent())
                    {
                        valid = TRUE;
                        break;
                    }
                    if (CM_INCOMING_STATE == GetCurrentState())
                    {
                        KbCBackCallIncomingAccepted();
                        return TRUE;
                    }
                    else if (GetCurrentState() == CM_OUTGOING_STATE)
                    {
                        valid = TRUE;
                        break;
                    }

                    OutgoingProcessCMEvent(CM_KB_SWAPREQ, NULL);
                    return TRUE;
                }
                else if ('\0' == *(tmpBuf + 2))
                {
                    /* 2X send */
                    callVal = (CM_CALL_HANDLE) atoi((void*)(tmpBuf + 1));

                    if (callVal == 0 || (GetCallState(callVal) != CM_ACTIVE_STATE))
                    {
                        valid = TRUE;
                        break;
                    }
                    if ((GetTotalActiveCallCount() > 1) &&
                        (GetTotalHoldCallCount() == 0) && (GetCurrentState() != CM_OUTGOING_STATE))
                    {
                        PRINT_INFORMATION("\n *** Splitting Call \n");
                        SplitCall(callVal);
                        return TRUE;
                    }
                    else
                    {
                        valid = TRUE;
                        break;
                    }
                }
                valid = FALSE;
                break;

            case '3':
                if ('\0' == *(tmpBuf + 1))
                {
                    /* 3 send */
                    if ((GetTotalActiveCallCount() < MAX_HOLD) &&
                        (GetTotalHoldCallCount() < MAX_HOLD) &&
                        ((GetTotalActiveCallCount() > 0 && GetTotalHoldCallCount() > 0)))
                    {
                        PRINT_INFORMATION("\n *** Conferencing Call \n");
                        ConferenceCall();
                        return TRUE;
                    }
                    else
                    {
                        valid = TRUE;
                        break;
                    }
                }
                valid = FALSE;
                break;

            case '4':
                if ('*' == *(tmpBuf + 1))
                {
                    /* 4* send */
                    if ((-1 != GetIncomingCallHandle()))
                    {
                        bufLen = strlen((PS8) tmpBuf);
                        if (tmpBuf[bufLen - 1] >= '0' && tmpBuf[bufLen - 1] <= '9')
                        {
                            PRINT_INFORMATION("\n *** Call Deflection\n");
                            gCallDeflectNumber = tmpBuf + 2;
                            OutgoingProcessCMEvent(CM_KB_CALL_DEFLECT_REQ, gCallDeflectNumber);
                            return TRUE;
                        }
                    }
                    else
                    {
                        //PRINT_INFORMATION (("\n *** Not a valid action \n"));
                        //ShowCallManagementErrorMessage(NO_ACTIVE_CALL);
                        //return TRUE;
                        valid = FALSE;
                        break;
                    }
                }
                else if ('\0' == *(tmpBuf + 1))
                {
                    /* 4 send */
                    if ((GetTotalActiveCallCount() == 1 && (-1 != GetOutgoingCallHandle())) ||
                        (GetTotalHoldCallCount() == 1 && (-1 != GetOutgoingCallHandle())) ||
                        (GetTotalActiveCallCount() == 1 && GetTotalHoldCallCount() == 1))
                    {
                        PRINT_INFORMATION("\n *** Explicit Call Transfer\n");
                        TransferCall();
                        return TRUE;
                    }
                    else
                    {
                        valid = TRUE;
                        break;
                    }
                }
                valid = FALSE;
                break;

            case '5':
                if ('\0' == *(tmpBuf + 1))
                {
                    /* 5 send */
                #ifdef __MMI_CM_CCBS_SUPPORT__
                    if(IsScreenPresent(ITEM_SCR_CCBS_IND))
                #else
                    if (GetCCBSFlag() == TRUE)
                #endif /*__MMI_CM_CCBS_SUPPORT__*/  
                    {
                        PRINT_INFORMATION("\n *** CCBS Activation\n");
                        ActivateCCBS();
                        return TRUE;
                    }
                    else
                    {
                        valid = TRUE;
                        break;
                    }
                }
                valid = FALSE;
                break;

            default:
                valid = FALSE;
                break;

        }
    }

    if (GetTotalCallCount() == 1 && GetCurrentState() == CM_INCOMING_STATE)
    {
        /* answer */
        KbCBackCallIncomingAccepted();
        /* ProcessIncomingEvents (CM_KB_INCOMING_CALL_ACCEPT,NULL); */
        return TRUE;
    }
    else if (valid == TRUE)
    {
        PRINT_INFORMATION("\n Not a valid action\n");
        ShowCallManagementErrorMessage(NO_ACTIVE_CALL);
        return TRUE;
    }
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  isHashString
 * DESCRIPTION
 *  Helper function to check is this is a # string
 * PARAMETERS
 *  buf             [IN]        
 *  Buffer(?)       [IN]        Containing USSD string
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL isHashString(PU8 buf)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while ('\0' != buf[count])
    {
        if ('#' == buf[count])
        {
            return TRUE;
        }
        if (count >= MAX_DIGIT)
        {
            return FALSE;
        }
        count++;

    }
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  isShortString
 * DESCRIPTION
 *  Helper function to check is this is a short string
 * PARAMETERS
 *  buf             [IN]        
 *  Buffer(?)       [IN]        Containing USSD string
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL isShortString(PU8 buf)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while ('\0' != buf[count++])
        if (count > 2)
        {
            return FALSE;
        }

    return TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  UCS2StrNoFirstPositionSearch
 * DESCRIPTION
 *  Search for a character in string for only first position
 * PARAMETERS
 *  strNumber           [IN]        
 *  charToSearch        [IN]        
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL UCS2StrNoFirstPositionSearch(PS8 strNumber, S8 charToSearch)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 pos;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("\nIn UCS2StrNoFirstPositionSearch\n");

    if (strNumber[0] == charToSearch)
    {
        return FALSE;
    }
    else
    {
        pos = 2;
        while (strNumber[pos] != '\0')
        {
            if (strNumber[pos] == charToSearch)
            {
		if (strNumber[pos+2] != '*' && strNumber[pos+2] != '#')
                    return TRUE;
		else
		    return FALSE;
            }
            pos = pos + 2;
        }
        return TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  UCS2StrFirstPositionSearch
 * DESCRIPTION
 *  Search for a '+' character in string for only first position
 * PARAMETERS
 *  strNumber       [IN]        
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL UCS2StrFirstPositionSearch(PS8 strNumber)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 pos;
    pBOOL secondFlag = FALSE;
    S8 charToSearch = '+';
    U8 length;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("\nIn UCS2StrFirstPositionSearch\n");

    if ((mmi_ucs2ncmp((PS8) strNumber, (PS8) L"*31#", 4) == 0) ||
        (mmi_ucs2ncmp((PS8) strNumber, (PS8) L"#31#", 4) == 0))
    {
        length = mmi_ucs2strlen(strNumber) - 4;
        pos = 10;
    }
    else
    {
        length = mmi_ucs2strlen(strNumber);
        pos = 2;
    }

    while (strNumber[pos] != '\0')
    {
        if ((strNumber[pos] == charToSearch) && 
            ((strNumber[pos - 2] != '#' && strNumber[pos - 2] != '*') ||
             ((strNumber[(length-1)<<1] != '#') &&
			 ((mmi_ucs2ncmp((PS8) strNumber, (PS8) L"*31#", 4) != 0) &&
			 (mmi_ucs2ncmp((PS8) strNumber, (PS8) L"#31#", 4) != 0)))||
             (strNumber[0] == charToSearch)))
        {
            secondFlag = TRUE;
            break;
        }
        pos = pos + 2;
    }

    if (secondFlag == FALSE)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  ShowOutgoingIndicationScreen
 * DESCRIPTION
 *  Shows only outgoing call screen and takes control
 * PARAMETERS
 *  number          [IN]        
 *  Number(?)       [IN]        To show on screen
 * RETURNS
 *  void
 *****************************************************************************/
void ShowOutgoingIndicationScreen(PU8 number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* for SAT MO only  */
#ifdef __SAT__
    SetSATScrnSavedFlag(FALSE);

    SetPreviousState((CALL_STATE) GetCurrentState());
    SetCurrentState(CM_OUTGOING_STATE);

    gtmpOutgoingIndex = GetFirstFreeIndex();
    AddNewCallInfo(
        number,
        (CALL_STATE) GetCurrentState(),
        CM_IDLE_STATE,
        CM_CALL_MO_STK,
        (CM_CALL_HANDLE) (gtmpOutgoingIndex + 1),
        CSMCC_VOICE_CALL);

    OutgoingProcessCMEvent(CM_PS_SHOW_OUTGOING_CALL_SCREEN, NULL);
    SetSATScrnSavedFlag(TRUE);
#endif /* __SAT__ */
}


/*****************************************************************************
 * FUNCTION
 *  RemoveOutgoingIndicationScreen
 * DESCRIPTION
 *  Removes outgoing call screen
 * PARAMETERS
 *  void
 *  Number(?)       [IN]        To show on screen
 * RETURNS
 *  void
 *****************************************************************************/
void RemoveOutgoingIndicationScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CM_CALL_HANDLE handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* SAT MO fail case */
    handle = GetOutgoingCallHandle();
    if (handle == -1)
    {
        return;
    }

    SetCallState(handle, CM_IDLE_STATE, TRUE);
    SetCurrentState(GetPreviousState());
    SetPreviousState(CM_OUTGOING_STATE);

    if (FALSE == GetSATScrnSavedFlag())
    {
        EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
        SetSATScrnSavedFlag(TRUE);
    }
    SetCallEndedBeforeConnFlag(FALSE);
    /* GoBackfromNotifyScr(); */
    ShowCallManagementErrorMessage(ERR_L4C_GEN_CAUSE);
}


/*****************************************************************************
 * FUNCTION
 *  PsCBackSetCallFeatures
 * DESCRIPTION
 *  This Sets the features of the call as per
 * PARSING STR RSP
 *  
 *  
 *  PARSING_STRING_RSP from PS
 * PARAMETERS
 *  info        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void PsCBackSetCallFeatures(void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_PARSE_STR_RSP *rsp;
    CM_CALL_HANDLE handle = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("XXX In PsCBackSetCallFeatures \n");

    rsp = (MMI_PARSE_STR_RSP*) info;

    if (TRUE == DeriveAndSetCallFeatures(info))
    {
        if (GetCCFlag() == TRUE)
        {
            PHB_CM_INTERFACE PhoneNumberStruct;

            /* MO call */
        #ifdef __MMI_BT_PROFILE__
            /* stop audio background play before sco link */
            mdi_audio_suspend_background_play();
            /* establish sco link here */
            mmi_profiles_bt_call_start_callback();
        #endif /* __MMI_BT_PROFILE__ */ 
            /* look up dialed number from phonebook first anyway */

            /* auto redial and dial from list */
            if (cm_p->redial_info.DialFromPhb != MMI_PHB_NONE)
            {
                mmi_phb_call_set_dial_from_list(cm_p->redial_info.DialFromPhb);
            }

            PhoneNumberStruct = mmi_phb_call_get_data_for_call_mgnt(GetOutgoingNumber(), TRUE);
            SetCMPhoneBookStruct(&PhoneNumberStruct);
            /* PhoneNumberStruct = GetCMPhoneBookStruct(); */

            if (CHISTGetDialFromCallLogFlag() == 0)
            {
                /* not dial from call log => use phonebook data and name */
                PRINT_INFORMATION("*** In PsCBackSetCallFeatures, set MO name from PHB1 ***\n");
                SetOutgoingNamefromPhonebook();
            }
            else if (mmi_ucs2cmp((PS8) PhoneNumberStruct.name, (PS8) GetOutgoingName()) != 0)
            {
                /* dial from call log but phonebook name not match => don't use phonebook data */
                PRINT_INFORMATION("*** In PsCBackSetCallFeatures, set MO name from Call Log ***\n");
                memset(&PhoneNumberStruct, 0, sizeof(PHB_CM_INTERFACE));
                PhoneNumberStruct.pictureId = IMG_PHB_DEFAULT;
                SetCMPhoneBookStruct(&PhoneNumberStruct);
            }
            else
            {
                /* dial from call log but still use phonebook data */
                PRINT_INFORMATION("*** In PsCBackSetCallFeatures, set MO name from PHB2 ***\n");
            }

            AlmDisableExpiryHandler();
            OutgoingProcessCMEvent(CM_PS_SHOW_OUTGOING_CALL_SCREEN, NULL);
            CHISTSetDialFromCallLogFlag(0);
            return;
        }
        else if (rsp->info.opcode == SS_OPERATION)
        {
            /* SS string */
            if (GetCurrentState() == CM_INCOMING_STATE)
            {
                //history ss_scr;
                //S16 nHistory = 0;
                if (!IsScreenPresent(SCR_CM_REQUESTINGUSSD))
                {
                    /*ss_scr.scrnID = SCR_CM_REQUESTINGUSSD;
                    ss_scr.entryFuncPtr = EntryScrUSSDReq;
                    mmi_ucs2cpy((S8*) ss_scr.inputBuffer, (S8*) & nHistory);
                    InsertHistoryBeforeThisScrnReference(CM_SCR_MARKER, &ss_scr);*/
                    insert_screen_before_call_marker(SCR_CM_REQUESTINGUSSD, EntryScrUSSDReq);
                }
            }
            else
            {
                OutgoingProcessCMEvent(CM_PS_SHOW_REQUESTING_CALL_SCREEN, NULL);
            }
        }
        else
        {
            /* must be SIM operation */
            /* OutgoingProcessCMFailureEvent(CM_PS_CALLCONNECTED, ERR_INVALID_NUMBER_FORMAT); */
        }
    }
    else if ((rsp->result.flag == 0) && (rsp->info.opcode == SIM_OPERATION))
    {
        DisplayPopup((PU8) GetString(STR_GLOBAL_NOT_DONE), IMG_GLOBAL_UNFINISHED, 0, CS_NOTIFYDURATION, ERROR_TONE);
    }
    else if ((rsp->result.flag == 0) && (rsp->info.opcode == INVALID_OPERATION))
    {
        if (rsp->result.cause == PHB_L4C_ERROR)
        {
            OutgoingProcessCMFailureEvent(CM_PS_CALLCONNECTED, ERR_L4C_FDN_FAIL);
        }
        else if (rsp->result.cause == L4C_CMD_CONFLICT)
        {
            OutgoingProcessCMFailureEvent(CM_PS_CALLCONNECTED, ERR_L4C_GEN_CAUSE);
        }
        else
        {
            OutgoingProcessCMFailureEvent(CM_PS_CALLCONNECTED, ERR_INVALID_NUMBER_FORMAT);
        }
    }
    else
    {
        OutgoingProcessCMFailureEvent(CM_PS_CALLCONNECTED, ERROR_FAIL);
        RemoveSSReqScr();
    }

    g_phb_cntx.dial_from_list = MMI_PHB_NONE;
    PurgeOutgoingCallsStructure();
    SetCallEndedBeforeConnFlag(FALSE);
    CHISTSetDialFromCallLogFlag(0);

    SetCurrentState(GetPreviousState());
    if (GetPreviousState() == CM_INCOMING_STATE)
    {
        if (GetTotalCallCount() == 1)
        {
            SetPreviousState(CM_IDLE_STATE);
        }
        else if (GetTotalActiveCallCount() == GetTotalCallCount() - 1)
        {
            SetPreviousState(CM_ACTIVE_STATE);
        }
        else if (GetTotalHoldCallCount() == GetTotalCallCount() - 1)
        {
            SetPreviousState(CM_HOLD_STATE);
        }
    }

    /* reset phb data */
    if (GetCurrentState() == CM_INCOMING_STATE)
    {
        handle = GetIncomingCallHandle();
    }
    else if (GetCurrentState() == CM_OUTGOING_STATE)
    {
        handle = GetOutgoingCallHandle();
    }
    if (handle != -1)
    {
        PHB_CM_INTERFACE phb_data;

        phb_data = mmi_phb_call_get_data_for_call_mgnt(GetCallNumber(handle), FALSE);
    #ifdef __MMI_INCOMING_CALL_VIDEO__
        /* waiting call and ccbs invoke can't use video for display */
        if (GetTotalCallCount() > 0 || GetCCBSFlag() == TRUE)
        {
            phb_data.videoId = 0;
        }
    #endif /* __MMI_INCOMING_CALL_VIDEO__ */ 
        SetCMPhoneBookStruct(&phb_data);
    }
    SetDefaultVolumeKeyHandlers();
    return;
}


/*****************************************************************************
 * FUNCTION
 *  PsCbackOutgoingCallIdSync
 * DESCRIPTION
 *  Helper function to get call list from PS to sync with MMI
 *  
 *  DIAL_IND from PS.
 * PARAMETERS
 *  MsgStruct       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void PsCbackOutgoingCallIdSync(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CM_CALL_HANDLE handle;
    U16 response;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("XXX - In PsCbackOutgoingCallIdSync XXX\n");

    handle = DeriveOutgoingCallIdRsp(MsgStruct, &response);
    if (handle == -1 || handle > MAX_CALLS)
    {
        if (GetDialIndication() == TRUE)
        {
            ShowCallManagementErrorMessage(NO_ACTIVE_CALL);
            return;
        }

        PRINT_INFORMATION("Error in making outgoing call %d", response);
        /* keep MO fail cause for later display if notify ss is ongoing */
        SetCallEndCause(response);

        /* MO fail */
        /* SyncCallList(); */
        SetDialIndication(FALSE);

        LogCallInfoForCallHistory(GetOutgoingCallHandle());
        GetEndTimeAndLogUnconnectedMOCall();

        if (IsRedialSet())
        {
            SetRedialNumber();
        }

        OutgoingProcessCMFailureEvent(CM_PS_CALLCONNECTED, response);
        /* reset call end before conn flag for next call */
        SetCallEndedBeforeConnFlag(FALSE);
    }
    else
    {
        SetOutgoingCallHandle(handle);
        SetDialIndication(TRUE);
        if (GetTotalCallCount() > 1)
        {
            SyncCallList();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  OutgoingCallConnected
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_CALLCONNECTED
 *  with the Structure containing CM_CALL_HANDLE.
 *  
 *  We could have mapped void* to CM_CALL_HANDLE and passed it to the
 *  state m/c. CONNECT_IND from PS
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains CM_CALL_HANDLE passed by the stack when call is connected)
 * RETURNS
 *  void
 *****************************************************************************/
void OutgoingCallConnected(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_CONNECT_IND *msg;
    CM_CALL_HANDLE handle;
    MYTIME t;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined (JATAAYU_SUPPORT) && defined (WAP_SUPPORT)
		mmi_jdd_tapi_make_call_result(JC_OK);
#endif

    msg = (MMI_CONNECT_IND*) MsgStruct;

    PRINT_INFORMATION("XXX - In OutgoingCallConnected XXX\n");

    if (GetInternalAlert() == TRUE)
    {
        StopInternalOutgoingTone();
    }

    SetSpeechFlag(FALSE);

    if (CM_CSD_CALL == (msg->call_type))
    {
        SetWapCallPresent(TRUE);
    }

    if (GetTotalCallCount() <= 1)
    {
    #ifdef __MMI_CONNECT_NOTICE__
        /* play connect notice according to user defined style */
        PlayConnectNotice();
    #else /* __MMI_CONNECT_NOTICE__ */ 
        playRequestedTone(CONNECT_TONE);
    #endif /* __MMI_CONNECT_NOTICE__ */ 
    }

#ifdef __SAT__
    if (GetOutgoingCallOrigin() == CM_CALL_MO_STK)
    {
        /* STK call doesn't have DIAL_IND, so need to set call id in CONNECT_IND */
        SetOutgoingCallHandle(msg->call_id);
    }
#endif /* __SAT__ */

    handle = GetOutgoingCallHandle();

    /* log MO call with original number and name */
    SetCalledNumWithTypeAux(GetMMIStructIndexof(handle), MsgStruct);
    DTGetRTCTime(&t);
    UpdateCallStartTimeAndLogCall(handle, &t);
    
    /* set MO name for display in case number is changed by PS */
    SetCalledNumWithType(GetMMIStructIndexof(handle), MsgStruct);

#ifdef __IP_NUMBER__
    SetTempUseIPNumber(FALSE);
#endif 

    OutgoingProcessCMEvent(CM_PS_CALLCONNECTED, &handle);
}


/*****************************************************************************
 * FUNCTION
 *  PsCBackOutgoingCallEnded
 * DESCRIPTION
 *  Call Back function for ATH_SUCCESS to hangup outgoing call
 *  
 *  ATH_RSP from PS
 * PARAMETERS
 *  MsgStruct       [?]         
 *  expected(?)     [IN]        NULL
 * RETURNS
 *  void
 *****************************************************************************/
void PsCBackOutgoingCallEnded(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CM_CALL_HANDLE handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined (JATAAYU_SUPPORT) && defined (WAP_SUPPORT)
		mmi_jdd_tapi_make_call_result(JC_ERR_UNKNOWN);
#endif

    SetCallAbortReqSentFlag(FALSE);

    if (GetCurrentState() == CM_IDLE_STATE)
    {
        PRINT_INFORMATION("XXX - In PsCBackOutgoingCallEnded no call to drop XXX\n");
        /* SetDropRequestFlag(FALSE); */
        return;
    }

    if ((handle = GetOutgoingCallHandle()) == -1)
    {
        /* MO call already got connected before it's aborted */
        handle = GetHungUpHandle();
        if (handle == -1)
        {
            PRINT_INFORMATION("XXX - In PsCBackOutgoingCallEnded call already dropped XXX\n");
            return;
        }
    }

    OutgoingProcessCMEvent(CM_PS_HANGUPSUC, (void*)&handle);
    SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
}


/*****************************************************************************
 * FUNCTION
 *  PsCBackUSSDResponse
 * DESCRIPTION
 *  This function is called back by the protocol stack when USSD data is recieved by n/w
 *  
 *  info is
 * PARAMETERS
 *  info        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void PsCBackUSSDResponse(void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("XXX - In PsCBackUSSDResponse XXX\n");
    OutgoingProcessCMEvent(CM_PS_USSD_RECVD, info);
    /* ProcessIncomingEvents (CM_PS_USSD_RECVD, info); */
}

/* Start by Julia: Drop call refinement */


/*****************************************************************************
 * FUNCTION
 *  ReleaseCall
 * DESCRIPTION
 *  Invokes the helper function to make the disconnecting call released complete
 *  
 *  This is invoked whenever the user press END key in the disconnecting call screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ReleaseCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 count;
    CM_CALL_HANDLE handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; count < MAX_CALLS; count++)
    {
        if (cm_p->state_info.AllCalls[count].curr_state == CM_DISCONNECTING_STATE)
        {
            handle = cm_p->state_info.AllCalls[count].call_handle;
            MakePsReleaseCompleteRequest(handle);
            OutgoingProcessCMEvent(CM_PS_HANGUPSUC, (void*)&handle);
            if (GetAutoReleaseFlag() == FALSE)
            {
                return;
            }
        }
    }
    SetAutoReleaseFlag(FALSE);
}

/* End by Julia */


/*****************************************************************************
 * FUNCTION
 *  DropRequest
 * DESCRIPTION
 *  Invokes the helper function to hangup or disconnect the call
 *  which is yet to connect.
 *  
 *  This is invoked whenever the User press LSK in the outgoingcallscreen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DropRequest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CM_CALL_HANDLE handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("*** In Drop Request\n");

    if (GetNotifySSFlag())
    {
        StopTimer(CM_NOTIFYDURATION_TIMER);
    }

    if (FALSE == GetAbortCallRequestedFlag())
    {
        handle = GetOutgoingCallHandle();
        if ((GetCallflag(handle, TRUE) & CM_HANGUP_REQUESTED) == 0)
        {
            SetDropRequestFlag(TRUE);
            SetAbortCallRequestedFlag(TRUE);
            HangupCall(handle);
            if (GetExitScrnID() == SCR1001_CM_OUTGOINGCALLSCREEN)
            {
                MOMTHideAnimation();
            }
        }
    }
    else
    {
        PRINT_INFORMATION("*** In   DropRequest .. Not calling drop\n");
    }
}


/*****************************************************************************
 * FUNCTION
 *  HangupCall
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_HANGUPREQ with the OUTGOING_CALL structure.
 *  
 *  This invokes the function to process the CM_KB_HANGUPREQ event in the state m/c.
 * PARAMETERS
 *  CallHandle      [IN]        
 *  contains(?)     [IN]        The call handle of the call that needs to be dropped.
 * RETURNS
 *  void
 *****************************************************************************/
void HangupCall(CM_CALL_HANDLE CallHandle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("*** In HangupCall\n");
    OutgoingProcessCMEvent(CM_KB_HANGUPREQ, &CallHandle);
}


/*****************************************************************************
 * FUNCTION
 *  HangupReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_HANGUPSUC
 *  with the Structure containing CM_CALL_HANDLE.
 *  
 *  We are assuming that the protocol stack sends the sucess response for the hangup request
 *  with the CM_CALL_HANDLE. CHLD RELEASE_SPECIFIC => RELEASE_IND from PS
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains CM_CALL_HANDLE passed by the stack when call drop is success)
 * RETURNS
 *  void
 *****************************************************************************/
void HangupReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CM_CALL_HANDLE handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("XXX - In HangupReqSucess XXX\n");

    handle = DeriveCallHandle(MsgStruct);

    OutgoingProcessCMEvent(CM_PS_HANGUPSUC, (void*)&handle);
    SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
}


/*****************************************************************************
 * FUNCTION
 *  HangupAll
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_HANGUPALLREQ with the NULL structure.
 *  
 *  This invokes the function to process the CM_KB_HANGUPALLREQ event in the state m/c.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HangupAll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 scrId;
    U8 flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    flag = GetAllCallFlags();

#ifdef __MMI_CLAMSHELL__
    if (GetCurrentState() == CM_INCOMING_STATE && GetTotalCallCount() > 1)
    {
        KbCBackCallIncomingRejected();
        return;
    }
#endif /* __MMI_CLAMSHELL__ */ 

    if (GetTotalActiveCallCount() > 0 && GetTotalHoldCallCount() > 0 &&
        ((flag & CM_SWAP_REQUESTED) == 0) && ((flag & CM_CONF_REQUESTED) == 0) && ((flag & CM_ECT_REQUESTED) == 0))
    {
        /* swapping can't decide which call is active and held, 
           issue rel all req instead */

        /* rel active and accept */
        ProcessIncomingEvents(CM_KB_END_ALL_ACTIVE_RETRIEVE_HELD, NULL);
    }
    else
    {
        OutgoingProcessCMEvent(CM_KB_HANGUPALLREQ, (void*)NULL);
    }

    scrId = GetExitScrnID();
    if (scrId == SCR1001_CM_OUTGOINGCALLSCREEN || (scrId == SCR_CM_ACTIVECALLSCREEN && GetTotalCallCount() == 1))
    {
        MOMTHideAnimation();
    }
    /* else
       EntryScr1002ActiveCall(); */

}


/*****************************************************************************
 * FUNCTION
 *  HangupallReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_HANGUPALLSUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the Hangup all calls request
 *  without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void HangupallReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gMyhandle = DeriveCallHandle(MsgStruct);
    PRINT_INFORMATION("XXX - In HangupallReqSucess XXX\n");
    OutgoingProcessCMEvent(CM_PS_HANGUPALLSUC, (void*)&gMyhandle);
    SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
}


/*****************************************************************************
 * FUNCTION
 *  HangupallActive
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_HANGUPALLACTREQ with the NULL structure.
 *  
 *  This invokes the function to process the CM_KB_HANGUPALLACTREQ event in the state m/c.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HangupallActive(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OutgoingProcessCMEvent(CM_KB_HANGUPALLACTREQ, (void*)NULL);
}


/*****************************************************************************
 * FUNCTION
 *  HangupallActReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_HANGUPALLACTSUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the Hangup all Active calls
 *  request without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void HangupallActReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gMyhandle = DeriveCallHandle(MsgStruct);
    PRINT_INFORMATION("XXX - In HangupallActReqSucess XXX\n");
    OutgoingProcessCMEvent(CM_PS_HANGUPALLACTSUC, (void*)&gMyhandle);
    SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
}


/*****************************************************************************
 * FUNCTION
 *  HangupallHeld
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_HANGUPALLHLDREQ with the NULL structure.
 *  
 *  This invokes the function to process the CM_KB_HANGUPALLHLDREQ event in the state m/c.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HangupallHeld(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OutgoingProcessCMEvent(CM_KB_HANGUPALLHLDREQ, (void*)NULL);
}


/*****************************************************************************
 * FUNCTION
 *  HangupallHldReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_HANGUPALLHLDSUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the Hangup all Held calls
 *  request without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void HangupallHldReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gMyhandle = DeriveCallHandle(MsgStruct);
    PRINT_INFORMATION("XXX - In HangupallHldReqSucess XXX\n");
    OutgoingProcessCMEvent(CM_PS_HANGUPALLHLDSUC, (void*)&gMyhandle);
    SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
}


/*****************************************************************************
 * FUNCTION
 *  MakeActiveCallHold
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_HOLDREQ with the NULL structure.
 *  
 *  This invokes the function to process the CM_KB_HOLDREQ event in the state m/c.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void MakeActiveCallHold(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OutgoingProcessCMEvent(CM_KB_HOLDREQ, (void*)NULL);
}


/*****************************************************************************
 * FUNCTION
 *  HoldReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_HOLDSUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the Hold request
 *  without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void HoldReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (CheckChldRequestSuccess(MsgStruct, &result))
    {
        PRINT_INFORMATION("XXX - In HoldReqSucess XXX\n");
        OutgoingProcessCMEvent(CM_PS_HOLDSUC, (void*)MsgStruct);
    }
    else
    {
        PRINT_INFORMATION("Error in Making Hold call in protocol stack cause %d", result);
        SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
        ResetHoldFlag();
        OutgoingProcessCMFailureEvent(CM_PS_HOLDSUC, result);
    }
}


/*****************************************************************************
 * FUNCTION
 *  RetrieveHeldCall
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_RETRIEVEREQ with the NULL structure.
 *  
 *  This invokes the function to process the CM_KB_RETRIEVEREQ event in the state m/c.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RetrieveHeldCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OutgoingProcessCMEvent(CM_KB_RETRIEVEREQ, (void*)NULL);
}


/*****************************************************************************
 * FUNCTION
 *  RetrieveReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_RETRIEVESUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the retrieve request
 *  without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void RetrieveReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (CheckChldRequestSuccess(MsgStruct, &result))
    {
        PRINT_INFORMATION("XXX - In RetrieveReqSucess XXX\n");
        OutgoingProcessCMEvent(CM_PS_RETRIEVESUC, (void*)MsgStruct);
    }
    else
    {
        PRINT_INFORMATION("Error in Retriving Hold Call in protocol stack cause %d", result);
        SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
        ResetRetrieveFlag();
        OutgoingProcessCMFailureEvent(CM_PS_RETRIEVESUC, result);
    }
}


/*****************************************************************************
 * FUNCTION
 *  SwapCall
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_SWAPREQ with the NULL structure.
 *  
 *  This invokes the function to process the CM_KB_SWAPREQ event in the state m/c.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SwapCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OutgoingProcessCMEvent(CM_KB_SWAPREQ, (void*)NULL);
}


/*****************************************************************************
 * FUNCTION
 *  SwapReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_SWAPSUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the Swap request
 *  without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void SwapReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (CheckChldRequestSuccess(MsgStruct, &result))
    {
        PRINT_INFORMATION("XXX - In SwapReqSucess XXX\n");
        OutgoingProcessCMEvent(CM_PS_SWAPSUC, (void*)MsgStruct);
    }
    else
    {
        PRINT_INFORMATION("Error in swapping resuest in PS cause: %d\n", result);
        SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
        ResetSwapFlag();
        OutgoingProcessCMFailureEvent(CM_PS_SWAPSUC, result);
    }
}


/*****************************************************************************
 * FUNCTION
 *  ConferenceCall
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_CONFREQ with the NULL structure.
 *  
 *  This invokes the function to process the CM_KB_CONFREQ event in the state m/c.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ConferenceCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((GetTotalActiveCallCount() < MAX_HOLD) &&
        (GetTotalHoldCallCount() < MAX_HOLD) && ((GetTotalActiveCallCount() > 0 && GetTotalHoldCallCount() > 0)))
    {
        OutgoingProcessCMEvent(CM_KB_CONFREQ, (void*)NULL);
    }
    else
    {
        ShowCallManagementErrorMessage(NO_ACTIVE_CALL);
    }
}


/*****************************************************************************
 * FUNCTION
 *  ConfReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_CONFSUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the Conference request
 *  without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void ConfReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (CheckChldRequestSuccess(MsgStruct, &result))
    {
        PRINT_INFORMATION("XXX - In ConfReqSucess XXX\n");
        OutgoingProcessCMEvent(CM_PS_CONFSUC, (void*)MsgStruct);
    }
    else
    {
        PRINT_INFORMATION("Error in Conferencing resquest in PS cause: %d\n", result);
        ResetConfFlag();
        SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
        OutgoingProcessCMFailureEvent(CM_PS_CONFSUC, result);
    }
}


/*****************************************************************************
 * FUNCTION
 *  SplitCall
 * DESCRIPTION
 *  Helper function to generate Keybrd Event CM_KB_SPLITREQ with the NULL structure.
 *  
 *  This invokes the function to process the CM_KB_SPLITREQ event in the state m/c.
 * PARAMETERS
 *  CallHandle      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SplitCall(CM_CALL_HANDLE CallHandle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OutgoingProcessCMEvent(CM_KB_SPLITREQ, &CallHandle);
}


/*****************************************************************************
 * FUNCTION
 *  SplitReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_SPLITSUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the Split
 *  request without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void SplitReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (CheckChldRequestSuccess(MsgStruct, &result))
    {
        PRINT_INFORMATION("XXX - In SplitReqSucess XXX\n");
        OutgoingProcessCMEvent(CM_PS_SPLITSUC, (void*)MsgStruct);
    }
    else
    {
        PRINT_INFORMATION("Error in Split in protocol stack cause %d", result);
        SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
        ResetSplitFlag();
        OutgoingProcessCMFailureEvent(CM_PS_SPLITSUC, result);
    }
}


/*****************************************************************************
 * FUNCTION
 *  TransferCall
 * DESCRIPTION
 *  This function performs Explicit Call Transfer.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TransferCall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OutgoingProcessCMEvent(CM_KB_ECT_REQ, (void*)NULL);
}


/*****************************************************************************
 * FUNCTION
 *  EctReqSucess
 * DESCRIPTION
 *  Helper function to Generate CM known Stack Event CM_PS_SPLITSUC
 *  with the Structure containing NULL.
 *  
 *  We are assuming that the protocol stack sends the Sucess response for the Split
 *  request without any structure.
 * PARAMETERS
 *  MsgStruct       [?]         
 *  This(?)         [IN]        Contains Null)
 * RETURNS
 *  void
 *****************************************************************************/
void EctReqSucess(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (CheckChldRequestSuccess(MsgStruct, &result))
    {
        PRINT_INFORMATION("XXX - In EctReqSucess XXX\n");
        OutgoingProcessCMEvent(CM_PS_ECT_SUC, (void*)MsgStruct);
    }
    else
    {
        PRINT_INFORMATION("Error in ECT in protocol stack cause %d", result);
        SetProtocolEventHandler(PsCBackNetworkCallDropped, PRT_NWRK_CALL_RELEASE);
        ResetEctFlag();
        OutgoingProcessCMFailureEvent(CM_PS_ECT_SUC, result);
    }
}


/*****************************************************************************
 * FUNCTION
 *  EnterScreenAndHandleDigit
 * DESCRIPTION
 *  Helper function to initiate sending DTMF tone and
 *  display screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EnterScreenAndHandleDigit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearDtmfBuf();
    SetCMScrnFlag(FALSE);

    if ((GetTotalActiveCallCount() > 0 || GetCurrentState() == CM_OUTGOING_STATE) && (GetDTMFFlag()))
    {
        EntryScrDisplayDialedDigits();
        HandleDTMFScreenDigits();
    }
    else
    {
        EntryScrDisplayDialedDigits();
        UpdateDialedDigitDisplay();
    }
}


/*****************************************************************************
 * FUNCTION
 *  EntryScrDisplayDialedDigits
 * DESCRIPTION
 *  Shows the dialled digits in dtmf
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryScrDisplayDialedDigits(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *historyBuffer;
    U16 lskStrShow = STR_GLOBAL_SAVE;
    U8 *tmp = GetCurrInputBuffer(DTMF_SCR_DISPLAY_ID);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(DTMF_SCR_DISPLAY_ID, ExitScrDisplayDialedDigits, NULL, NULL);

    cm_p->history_info.IsSave = TRUE;

    if (tmp)
    {
        mmi_ucs2cpy((S8*) UnicodeDTMFPadCallBuffer, (S8*) tmp);
    }
    else
    {
		  memset (UnicodeDTMFPadCallBuffer, 0, sizeof (UnicodeDTMFPadCallBuffer));
    }

    historyBuffer = GetCurrGuiBuffer(DTMF_SCR_DISPLAY_ID);

    /* delete any previous intance of screen if present */
    if (GetCurrScrnId() != DTMF_SCR_DISPLAY_ID)
    {
        DeleteScreenIfPresent(DTMF_SCR_DISPLAY_ID);
    }

    if ((GetCurrScrnId() == SCR1001_CM_OUTGOINGCALLSCREEN && GetTotalCallCount() == 1) || EmergencyCallPresent())
    {
        lskStrShow = 0;
        SetNoSave();
    }
    
    if (lskStrShow != 0)
    {
        RegisterInputBoxEmptyFunction(DialDigitScreenEmpty);
        RegisterInputBoxNotEmptyFunction(DialDigitScreenNotEmpty);
    }

#if ( defined (__MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__))
    if (mmi_bootup_get_active_flight_mode() != 1)
    {
        EnableCenterSoftkey(0, IMG_CSK_DIAL_ICON);
    }
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)) */ 

    ShowCategory16Screen(
        lskStrShow,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (PU8) UnicodeDTMFPadCallBuffer,
        MAX_DIGIT,
        historyBuffer);

    wgui_save_key_handlers();

	if (lskStrShow == 0)
    {
        /* no icon, no center key */
    #if ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) )
    #if defined  (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)
        SetDialingKeypadCallHandler(UI_dummy_function);
        SetDialingKeypadPhonebookHandler(UI_dummy_function);
    #else /* defined  (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
    	ResetCenterSoftkey();
		redraw_center_softkey(); 
    #endif /* defined  (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
    #endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) ) */ 
    }

    /* LSK, RSK */
    SetCategory16RightSoftkeyFunction(CheckBeforeGoBackHistory, KEY_EVENT_UP);

    if (lskStrShow != 0)
    {
        SetLeftSoftkeyFunction(CallMgmtSavePhoneBook, KEY_EVENT_UP);
    }

    /* SEND, END key */
    if (GetCurrentState() == CM_INCOMING_STATE)
    {
        if (GetTotalCallCount() == 1)
        {
            SetKeyHandler(KbCBackCallIncomingRejected, KEY_END, KEY_EVENT_DOWN);
        }
        else
        {
        #ifdef __MMI_CLAMSHELL__
            SetKeyHandler(KbCBackCallIncomingRejected, KEY_END, KEY_EVENT_DOWN);
        #else 
            SetKeyHandler(KbCBackEndAllCallsExceptIncoming, KEY_END, KEY_EVENT_DOWN);
        #endif 
        }

    }
    else if (CM_IDLE_STATE != GetCurrentState())
    {
        SetKeyHandler(HangupAll, KEY_END, KEY_EVENT_DOWN);
    }

    /* group key */
    if ((GetTotalActiveCallCount() > 0 || GetCurrentState() == CM_OUTGOING_STATE) && (GetDTMFFlag()))
    {
        SetGroupKeyHandler(HandleDTMFScreenDigits, (PU16) CMIdleScreenDigits, MAX_CM_SCREEN_DIGITS - 1, KEY_EVENT_DOWN);
        SetGroupKeyHandler(HandleDTMFScreenStopTone, (PU16) CMIdleScreenDigits, MAX_CM_SCREEN_DIGITS - 1, KEY_EVENT_UP);
        SetGroupKeyHandler(MMI_dummy_function, (PU16) CMIdleScreenDigits, MAX_CM_SCREEN_DIGITS - 1, KEY_REPEAT);
    }
    else
    {
        SetGroupKeyHandler(
            UpdateDialedDigitDisplay,
            (PU16) CMIdleScreenDigits,
            MAX_CM_SCREEN_DIGITS - 1,
            KEY_EVENT_DOWN);
        SetGroupKeyHandler(MMI_dummy_function, (PU16) CMIdleScreenDigits, MAX_CM_SCREEN_DIGITS - 1, KEY_REPEAT);
    }

    /* side key */
    SetSideVolumeKeysForCM();
}


/*****************************************************************************
 * FUNCTION
 *  ExitScrDisplayDialedDigits
 * DESCRIPTION
 *  Shows the dialed digits in dtmf
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitScrDisplayDialedDigits(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /*special case: touch pad,single hold call, the key tone never ends*/
#if defined (__MMI_TOUCH_DIAL_SCREEN__)
    PlayDialKeyPadTone(KEY_EVENT_UP);
#endif
    
    if (cm_p->history_info.IsSave)
    {
        history Scr1001;

        Scr1001.scrnID = DTMF_SCR_DISPLAY_ID;
        Scr1001.entryFuncPtr = EntryScrDisplayDialedDigits;
        mmi_ucs2cpy((S8*) Scr1001.inputBuffer, (S8*) UnicodeDTMFPadCallBuffer);
        GetCategoryHistory(Scr1001.guiBuffer);
        AddHistory(Scr1001);
    }
    else
    {
        cm_p->history_info.IsSave = TRUE;
    }

    if (GetDTMFKeyUpFlag() == TRUE)
    {
        HandleDTMFScreenStopTone();
    }

#if ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) )
#if defined  (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)
    SetDialingKeypadCallHandler(UI_dummy_function);
#else 
    ResetCenterSoftkey();
#endif 
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) ) */ 

}


/*****************************************************************************
 * FUNCTION
 *  DialDigitScreenEmpty
 * DESCRIPTION
 *  register function when screen is empty for call deflection
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DialDigitScreenEmpty(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearKeyHandler(KEY_SEND, KEY_EVENT_UP);

#if ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) )
#if defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)
    /* grey call, phb icon */
    SetDialingKeypadCallHandler(UI_dummy_function);
    SetDialingKeypadPhonebookHandler(mmi_phb_list_enter_first_from_active_call);
#else /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
    SetCenterSoftkeyFunction(UI_dummy_function, KEY_EVENT_UP);
#endif /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) ) */ 
}


/*****************************************************************************
 * FUNCTION
 *  DialDigitScreenNotEmpty
 * DESCRIPTION
 *  register function when screen is not empty for call deflection
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DialDigitScreenNotEmpty(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(MakeCallFromDTMFScr, KEY_SEND, KEY_EVENT_DOWN);

#if ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) )
#if defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)
    SetDialingKeypadCallHandler(MakeCallFromDTMFScr);
    SetDialingKeypadPhonebookHandler(mmi_phb_list_enter_first_from_active_call);
#else /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
    SetCenterSoftkeyFunction(MakeCallFromDTMFScr, KEY_EVENT_UP);
#endif /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) ) */ 
}

/**************************************************************

   FUNCTION NAME     : StoreAndKeepKeyCode

   PURPOSE           : Helper to store current key press

   INPUT PARAMETERS  : void

   OUTPUT PARAMETERS : nil

   RETURNS           : void

   REMARKS           : This is needed since the key repeat event rewrites it in the framework

**************************************************************/
/*
 * void StoreAndKeepKeyCode (U16 keycode, U16 keytype)
 * {
 * curKeyCode = keycode;
 * curKeyType = keytype;
 * }
 */


/*****************************************************************************
 * FUNCTION
 *  InCallSSCParsing
 * DESCRIPTION
 *  Helper function to check if the string is IMEI
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InCallSSCParsing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 stringIMEI[20];
    S8 newstringIMEI[MAX_DIGITS_USSD * ENCODING_LENGTH];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    strcpy((S8*) stringIMEI, "*#06#");
    mmi_asc_to_ucs2((PS8) newstringIMEI, (PS8) stringIMEI);

    if (mmi_ucs2cmp((S8*) newstringIMEI, (S8*) UnicodeDTMFPadCallBuffer) == 0)
    {
        SSCHandleIMEI();
        return;
    }
}


/*****************************************************************************
 * FUNCTION
 *  is_valid_dtmf_key
 * DESCRIPTION
 *  Helper function to make an send dtmf tones over the network or
 *  dial a call in case of user clicking send
 * PARAMETERS
 *  keycode     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL is_valid_dtmf_key(U16 keycode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MAX_CM_SCREEN_DIGITS; i++)
    {
        if (keycode == CMIdleScreenDigits[i])
        {
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  HandleDTMFScreenDigits
 * DESCRIPTION
 *  Helper function to make an send dtmf tones over the network or
 *  dial a call in case of user clicking send
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleDTMFScreenDigits(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 keycode, keytype;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("\n **** HandleDTMFScreenDigits\n");
    PRINT_INFORMATION("\n **** Sending DTMF Tone\n");
    /* SetProtocolEventHandler(DtmfSendSuccess, PRT_DTMF_START_RES); */

    SetDTMFKeyUpFlag(TRUE);

    GetkeyInfo(&keycode, &keytype);
    /* StoreAndKeepKeyCode(keycode, keytype); */

    /* enter dial pad from New Call menu item */
    if (!IsScreenPresent(SCR1003_CM_ACTIVECALLOPTIONS) && is_valid_dtmf_key(keycode))
    {
        MuteOnMicrophone();
    #ifdef __MMI_WGUI_CSK_ENABLE__
        if (keycode != KEY_CSK)
    #endif 
            MakePsSendDTMFTone(&keycode);
    }
    wgui_execute_key_handler(keycode, keytype);
}


/*****************************************************************************
 * FUNCTION
 *  UpdateDialedDigitDisplay
 * DESCRIPTION
 *  Helper function to update dial screen with only digits
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void UpdateDialedDigitDisplay(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 keycode, keytype;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GetkeyInfo(&keycode, &keytype);
    /* StoreAndKeepKeyCode(keycode, keytype); */
    wgui_execute_key_handler(keycode, keytype);
    HandleDisplayDialedDigits();
    InCallSSCParsing();
}


/*****************************************************************************
 * FUNCTION
 *  HandleDTMFScreenStopTone
 * DESCRIPTION
 *  Helper function to make an send dtmf tones over the network or
 *  dial a call in case of user clicking send
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleDTMFScreenStopTone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 keycode, keytype;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("\n **** HandleDTMFScreenStopTone\n");

    MakePsStopDTMFTone();
    if (IsPhoneInMute() == MMI_FALSE)
    {
        MuteOffMicrophone();
    }
    HandleDisplayDialedDigits();
    SetDTMFKeyUpFlag(FALSE);

    GetkeyInfo(&keycode, &keytype);
    /* StoreAndKeepKeyCode(keycode, keytype); */
    wgui_execute_key_handler(keycode, keytype);
    InCallSSCParsing();
}


/*****************************************************************************
 * FUNCTION
 *  HandleDisplayDialedDigits
 * DESCRIPTION
 *  Handles drawing of category screen and display digits
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleDisplayDialedDigits(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((GetTotalActiveCallCount() > 0 || GetCurrentState() == CM_OUTGOING_STATE) && (GetDTMFFlag()))
    {
        SetGroupKeyHandler(HandleDTMFScreenDigits, (PU16) CMIdleScreenDigits, MAX_CM_SCREEN_DIGITS - 1, KEY_EVENT_DOWN);
        SetGroupKeyHandler(HandleDTMFScreenStopTone, (PU16) CMIdleScreenDigits, MAX_CM_SCREEN_DIGITS - 1, KEY_EVENT_UP);
        SetGroupKeyHandler(MMI_dummy_function, (PU16) CMIdleScreenDigits, MAX_CM_SCREEN_DIGITS - 1, KEY_REPEAT);
    }
    else
    {
        /* wgui_execute_key_handler(curKeyCode, curKeyType); */
        SetGroupKeyHandler(
            UpdateDialedDigitDisplay,
            (PU16) CMIdleScreenDigits,
            MAX_CM_SCREEN_DIGITS - 1,
            KEY_EVENT_DOWN);
    }

	if (GetCurrentState() != CM_OUTGOING_STATE && !EmergencyCallPresent())
    {
        SetKeyHandler(MakeCallFromDTMFScr, KEY_SEND, KEY_EVENT_DOWN);
        SetLeftSoftkeyFunction(CallMgmtSavePhoneBook, KEY_EVENT_UP);
    }
    if (GetCurrentState() == CM_INCOMING_STATE)
    {
        if (GetTotalCallCount() == 1)
        {
            SetKeyHandler(KbCBackCallIncomingRejected, KEY_END, KEY_EVENT_DOWN);
        }
        else
        {
        #ifdef __MMI_CLAMSHELL__
            SetKeyHandler(KbCBackCallIncomingRejected, KEY_END, KEY_EVENT_DOWN);
        #else 
            SetKeyHandler(KbCBackEndAllCallsExceptIncoming, KEY_END, KEY_EVENT_DOWN);
        #endif 
        }

    }
    else if (CM_IDLE_STATE == GetCurrentState())
    {
        SetKeyHandler(CheckBeforeGoBackHistory, KEY_END, KEY_EVENT_DOWN);
    }
    else
    {
        SetKeyHandler(HangupAll, KEY_END, KEY_EVENT_DOWN);
    }

    RegisterCategory16NavigationKeys();

    SetCategory16RightSoftkeyFunction(CheckBeforeGoBackHistory, KEY_EVENT_UP);

    SetSideVolumeKeysForCM();
}


/*****************************************************************************
 * FUNCTION
 *  MakeCallFromDTMFScr
 * DESCRIPTION
 *  Clear the DTMF buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void MakeCallFromDTMFScr(void)
{
#ifdef __MMI_TOUCH_DIAL_SCREEN__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* no input */
    if (UnicodeDTMFPadCallBuffer[0] == 0 && UnicodeDTMFPadCallBuffer[1] == 0)
    {
        return;
    }
#endif /* __MMI_TOUCH_DIAL_SCREEN__ */ 
    SetDialedDigitCalledFlag(TRUE);
    MakeCall(UnicodeDTMFPadCallBuffer);
}


/*****************************************************************************
 * FUNCTION
 *  CallMgmtSavePhoneBook
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void CallMgmtSavePhoneBook(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetCMScrnFlag(FALSE);
    SaveNumberFromIdleScrn(UnicodeDTMFPadCallBuffer, 0);
}


/*****************************************************************************
 * FUNCTION
 *  ClearDtmfBuf
 * DESCRIPTION
 *  Clear the DTMF buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ClearDtmfBuf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(UnicodeDTMFPadCallBuffer, 0, sizeof(UnicodeDTMFPadCallBuffer));
    memset(DTMFPadCallBuffer, 0, sizeof(DTMFPadCallBuffer));
}


/*****************************************************************************
 * FUNCTION
 *  FillDtmfBuff
 * DESCRIPTION
 *  Fills up DTMF Buffer for access later
 * PARAMETERS
 *  buf     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void FillDtmfBuff(PU8 buf)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2cpy(UnicodeDTMFPadCallBuffer, (void*)buf);
}


/*****************************************************************************
 * FUNCTION
 *  GetDtmfBuffer
 * DESCRIPTION
 *  Return the DTMF buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
PU8 GetDtmfBuffer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2_to_asc(DTMFPadCallBuffer, UnicodeDTMFPadCallBuffer);
    return (PU8) DTMFPadCallBuffer;
}


/*****************************************************************************
 * FUNCTION
 *  SetDialIndication
 * DESCRIPTION
 *  to set the dial indication flag as per argument
 * PARAMETERS
 *  truth       [IN]        
 *  TRUE(?)     [IN]        /FALSE
 * RETURNS
 *  void
 *****************************************************************************/
void SetDialIndication(pBOOL truth)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCheckDialIndEndOutgoing = truth;
}


/*****************************************************************************
 * FUNCTION
 *  GetDialIndication
 * DESCRIPTION
 *  To Get the dial indication flag
 * PARAMETERS
 *  void
 *  TRUE(?)     [IN]        /FALSE
 * RETURNS
 *  void
 *****************************************************************************/
pBOOL GetDialIndication(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gCheckDialIndEndOutgoing;
}

/*****************************************************************************
 * FUNCTION
 *  MakeCallReqInd
 * DESCRIPTION
 *  Helper function to make call when PRT_MMI_MAKE_CALL_REQ_IND comes.
 * PARAMETERS
 * MsgStruct(?)       [IN]        Which needs to make the outgoing call.              
 * RETURNS
 *  void
 *****************************************************************************/
void MakeCallReqInd(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION("XXX - In MakeCallReqInd XXX\n");

    MakeCall((PS8)((MMI_MAKE_CALL_REQ_IND*) MsgStruct)->strNumber);
}
#endif /* __MMI_UCM__ */