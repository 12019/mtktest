/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  UCMUI.c
 *
 * Project:
 * -------- 
 *  MAUI
 *
 * Description:
 * ------------
 *  Coding Template source file
 *
 * Author:
 * -------
 * -------
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_include.h"

#ifdef __MMI_UCM__
#include "ProtocolEvents.h"
#include "CommonScreens.h"
#include "SettingProfile.h"
#include "custom_nvram_editor_data_item.h"
#include "custom_data_account.h"

#include "App_datetime.h"
#ifdef __MMI_BT_HP_SUPPORT__
#include "BTMMIHPGprots.h"
#endif
#ifdef __MMI_BT_SUPPORT__
#include "BTMMIScrGprots.h"
#endif
#include "GpioInc.h"
#include "mdi_datatype.h"
#include "mdi_audio.h"
#include "MessagesExDcl.h"
#include "PhoneBookDef.h"
#include "PhoneBookGprot.h"
#include "PowerOnChargerProt.h"
#include "ProfileGprots.h"
#include "VoIPResDef.h"
#include "VolumeHandler.h"
#include "NetworkSetupDefs.h"
#include "wgui_status_icons.h"
#include "SATGProts.h"
#include "SoundRecorderProt.h"
#include "BGSoundGProt.h"
#include "USBDeviceGprot.h"
#include "SimDetectionGprot.h"

#include "UCMResDef.h"
#include "UCMGProt.h"
#include "UCMCallProt.h"
#include "UCMProt.h"

#include "SettingGprots.h"

#ifdef __MMI_VIDEO_TELEPHONY__
#include "VTResDef.h"
#include "VTGProt.h"
#include "VTProt.h"
#endif /* __MMI_VIDEO_TELEPHONY__ */

#ifdef __CTM_SUPPORT__
#include "TextPhoneProt.h"
#endif /* __CTM_SUPPORT__ */

#ifdef __MMI_DUAL_SIM_MASTER__
#include "MTPNP_PFAL_CC_UCM.h"
#include "MTPNP_AD_resdef.h"
#include "MTPNP_PFAL_CC.h"
#endif  /* __MMI_DUAL_SIM_MASTER__ */
#include "IdleAppProt.h"

#define MMI_UCM_DEFAULT_MOMT_IMAGE (IMG_PHB_DEFAULT)
#define MMI_UCM_CALL_TYPE_WO_INCALL_SCR    (MMI_UCM_CSD_CALL_TYPE_ALL)

const U16 mmi_ucm_idle_screen_digits[MMI_UCM_SCREEN_DIGITS] = 
{
    KEY_0, KEY_1, KEY_2, KEY_3,
    KEY_4, KEY_5, KEY_6, KEY_7,
    KEY_8, KEY_9, KEY_STAR,
    KEY_POUND
};

#if defined(__MMI_DUAL_SIM_MASTER__)
static U8 mmi_ucm_display_buf[MMI_UCM_MAX_DISP_NAME_LEN * ENCODING_LENGTH];
#endif  /* __MMI_DUAL_SIM_MASTER__ */

#ifdef __MMI_SOUND_RECORDER__
extern void mmi_sndrec_entry_from_call(void);
#endif 
/* from History.c */
extern S32 mmi_is_redrawing_bk_screens(void);


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_init_highlight_handler
 * DESCRIPTION
 *  Initialize highlight handlers.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_init_highlight_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* set the incoming option menu highlight handlers */
    SetHiliteHandler(MENU_ID_UCM_INCOMING_OPTION_ANSWER, mmi_ucm_highlight_incoming_opt_answer);
    SetHiliteHandler(MENU_ID_UCM_INCOMING_OPTION_DEFLECT, mmi_ucm_highlight_incoming_opt_deflect);
    SetHiliteHandler(MENU_ID_UCM_INCOMING_OPTION_REPLACE, mmi_ucm_highlight_incoming_opt_replace);
#ifdef __MMI_UCM_REDIAL_FROM_OTHER_SIM__
    SetHiliteHandler(MENU_ID_UCM_INCOMING_OPTION_REDIAL_FROM_OTHER_SIM, mmi_ucm_highlight_incoming_opt_redial_from_other_sim);
#endif /* __MMI_UCM_REDIAL_FROM_OTHER_SIM__ */
    SetHiliteHandler(MENU_ID_UCM_INCOMING_OPTION_END_ALL_ACTIVE, mmi_ucm_highlight_incoming_opt_end_all_active);
    SetHiliteHandler(MENU_ID_UCM_INCOMING_OPTION_END_ALL_HELD, mmi_ucm_highlight_incoming_opt_end_all_held);

    SetHiliteHandler(MENU_ID_UCM_INCOMING_OPTION_BACKGROUND_SOUND, mmi_ucm_highlight_incoming_opt_background_sound);
    SetHiliteHandler(MENU_ID_UCM_INCOMING_OPTION_SWITCH_AUDIO_PATH, mmi_ucm_highlight_switch_audio_path);

    /* set the incall option menu highlight handlers */
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_HOLD_SINGLE, mmi_ucm_highlight_incall_opt_hold_single);
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_HOLD_CONF, mmi_ucm_highlight_incall_opt_hold_conf);
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_RETRIEVE_SINGLE, mmi_ucm_highlight_incall_opt_retrieve_single);
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_RETRIEVE_CONF, mmi_ucm_highlight_incall_opt_retrieve_conf);
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_SWAP, mmi_ucm_highlight_incall_opt_swap);
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_CONF, mmi_ucm_highlight_incall_opt_conf);
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_SPLIT, mmi_ucm_highlight_incall_opt_split);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_END_SINGLE, mmi_ucm_highlight_incall_opt_end_single);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_END_CONF, mmi_ucm_highlight_incall_opt_end_conf);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_END_ALL, mmi_ucm_highlight_incall_opt_end_all);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_TRANSFER, mmi_ucm_highlight_incall_opt_transfer);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_NEW_CALL, mmi_ucm_highlight_incall_opt_new_call);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_PHONEBOOK, mmi_ucm_highlight_incall_opt_phonebook);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_SMS, mmi_ucm_highlight_incall_opt_sms);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_SOUND_RECORDER, mmi_ucm_highlight_incall_opt_sound_recorder);
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_BACKGROUND_SOUND, mmi_ucm_highlight_incall_opt_bkg_sound);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_MUTE, mmi_ucm_highlight_incall_opt_mute);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_DTMF, mmi_ucm_highlight_incall_opt_dtmf);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_SWITCH_AUDIO_PATH, mmi_ucm_highlight_switch_audio_path);
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_CONNECT_LAST_BT_DEVICE, mmi_ucm_highlight_connect_last_bt_device);
#ifdef __CTM_SUPPORT__
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_CTM_CONNECT, mmi_ucm_highlight_ctm_connect);
#endif /* __CTM_SUPPORT__ */

    /* New call option */        
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_NEW_CALL_VOICE, mmi_ucm_highlight_newcall_opt_voice);    
    SetHiliteHandler(MENU_ID_UCM_INCALL_OPTION_NEW_CALL_VOIP, mmi_ucm_highlight_newcall_opt_voip);    

    
    /* New call editor option */
    SetHiliteHandler(MENU_ID_UCM_NEW_CALL_OPTION_DIAL, mmi_ucm_highlight_newcall_opt_dial);    
#ifdef __MMI_DUAL_SIM_MASTER__
    SetHiliteHandler(MENU_ID_UCM_NEW_CALL_OPTION_DIAL_SIM2, mmi_ucm_highlight_newcall_opt_sim2_dial); 
#endif  /* __MMI_DUAL_SIM_MASTER__ */
    SetHiliteHandler(MENU_ID_UCM_NEW_CALL_OPTION_SAVE, mmi_ucm_highlight_newcall_opt_save);    

    /* call center */
    SetHiliteHandler(MAIN_MENU_CALL_HISTORY, mmi_ucm_highlight_call_history);
    SetHiliteHandler(MENU_ID_UCM_CALL_SETTING, mmi_ucm_highlight_general_call_setting);
    SetHiliteHandler(MENU_ID_UCM_CALL_SETTING_MORE, mmi_ucm_highlight_general_call_setting_more);

#ifdef __MMI_BG_SOUND_EFFECT__    
    SetHiliteHandler(MENU_ID_UCM_CALL_SETTING_BGS, mmi_bgsnd_highlight_call_setup);
#endif /* __MMI_BG_SOUND_EFFECT__ */    

#ifdef __MMI_DUAL_SIM_MASTER__
    SetHiliteHandler(MENU_ID_UCM_CALL_SETTING_SIM1, mmi_ucm_highlight_general_call_setting_sim1);
#endif  /* __MMI_DUAL_SIM_MASTER__ */

    /* dial call type */
    SetHiliteHandler(MENU_ID_UCM_CALL_TYPE_VOICE, mmi_ucm_highlight_call_type_voice);
    SetHiliteHandler(MENU_ID_UCM_CALL_TYPE_VOIP, mmi_ucm_highlight_call_type_voip);
    SetHiliteHandler(MENU_ID_UCM_CALL_TYPE_VIDEO, mmi_ucm_highlight_call_type_video);
#ifdef __MMI_DUAL_SIM_MASTER__    
    SetHiliteHandler(MENU_ID_UCM_CALL_TYPE_VOICE_SIM2, mmi_ucm_highlight_call_type_voice_sim2);
#endif  /* __MMI_DUAL_SIM_MASTER__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_init_hint_handler
 * DESCRIPTION
 *  Initialize hint handlers.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_init_hint_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetHintHandler(MENU_ID_UCM_INCALL_OPTION_MUTE, mmi_ucm_hint_mute);
    SetHintHandler(MENU_ID_UCM_INCALL_OPTION_DTMF, mmi_ucm_hint_dtmf_in_call);
    SetHintHandler(MENU_ID_UCM_INCALL_OPTION_CONNECT_LAST_BT_DEVICE, mmi_ucm_hint_connect_last_bt_device);        
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_outgoing_call
 * DESCRIPTION
 *  Shows the outgoing call screen
 *  
 *  This is invoked whenever the User requests for a outgoing call.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_outgoing_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_phb_caller_image_info_struct* image_info = NULL;
    S32 outgoing_group_index = 0;
    U8* guiBuffer = NULL;
    U16* file_path = NULL;
    U16* display_name = NULL;
    U16* ip_num = NULL;
    U16 calling_str_id = STR_ID_UCM_CALLING;
    U16 line_icon = 0;    
    U16 image_id = 0;
    MMI_BOOL is_video_sound = MMI_FALSE;
    MMI_BOOL is_video_update = MMI_FALSE;
    U8 image_type = WGUI_CATE_MOMT_RES_TYPE_IMAGE_ID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    image_info = OslMalloc(sizeof(mmi_phb_caller_image_info_struct));
    
    EntryNewScreen(SCR_ID_UCM_OUTGOING, mmi_ucm_exit_outgoing_call, mmi_ucm_entry_outgoing_call, NULL);
    DeleteScreenIfPresent(SCR_ID_UCM_OUTGOING); /* ensure no two outgoing call screens in the history */
    PRINT_INFORMATION("\n[mmi_ucm_entry_outgoing_call] Outgoing Call Screen\n");
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_OUTGOING);

    outgoing_group_index = mmi_ucm_get_group_index_by_call_state(MMI_UCM_OUTGOING_STATE);
    MMI_ASSERT(outgoing_group_index >= 0);

    display_name = (U16*)g_ucm_p->call_list.group_info[outgoing_group_index].call_info[0].remote_info.disp_name;

    /* calling string */
    if (MMI_FALSE == (mmi_ucm_is_sos_number(g_ucm_p->call_list.group_info[outgoing_group_index].call_type, 
                                            (U8*) g_ucm_p->call_list.group_info[outgoing_group_index].call_info[0].remote_info.num_uri)))
    {
    #ifdef __MMI_DUAL_SIM_MASTER__
        if (g_ucm_p->call_list.group_info[outgoing_group_index].call_type & MMI_UCM_SIM1_CALL_TYPE_ALL)
        {
            calling_str_id = STRING_MTPNP_CALL_SIM1;
        }
        else if (g_ucm_p->call_list.group_info[outgoing_group_index].call_type & MMI_UCM_SIM2_CALL_TYPE_ALL)
        {
            calling_str_id = STRING_MTPNP_CALL_SIM2;
        }
    #endif  /* __MMI_DUAL_SIM_MASTER__ */
    #ifdef __MMI_VOIP__
        if (g_ucm_p->call_list.group_info[outgoing_group_index].call_type == MMI_UCM_VOIP_CALL_TYPE)
        {
            calling_str_id = STR_ID_UCM_VOIP_CALLING;
        }
    #endif /* __MMI_VOIP__ */
    #ifdef __MMI_VIDEO_TELEPHONY__
        if (g_ucm_p->call_list.group_info[outgoing_group_index].call_type == MMI_UCM_VIDEO_CALL_TYPE)
        {       
            calling_str_id = STR_ID_UCM_DIALING_VIDEO_CALL;
        }
    #endif /* __MMI_VIDEO_TELEPHONY__ */
    }
    
    /* line icon */
    if (g_ucm_p->mo_mt_display.line_icon)
    {
        line_icon = g_ucm_p->mo_mt_display.line_icon;
    }

    /* ip number */
    if (mmi_ucs2strlen((S8*)g_ucm_p->mo_mt_display.ip_num))
    {
        ip_num = g_ucm_p->mo_mt_display.ip_num;
    }

    /* image info */
    memset(image_info, 0x00, sizeof(mmi_phb_caller_image_info_struct));

#ifdef __SAT__
    if (g_ucm_p->call_list.group_info[outgoing_group_index].call_info[0].module_id == MMI_UCM_FROM_SAT &&
        mmi_sat_is_icon2_available())
    {
        image_id = 0;
        image_type = WGUI_CATE_MOMT_RES_TYPE_IMAGE_FILE;
        is_video_sound = MMI_FALSE;
        mmi_ucs2cpy((S8*) g_ucm_p->mo_mt_display.image_path, (S8*) SAT_ICON2_FILEPATH);
    }
    else
#endif /* __SAT__ */
    {
        g_ucm_p->mo_mt_display.image_info.call_type = (U8)mmi_ucm_get_phb_call_type(g_ucm_p->call_list.group_info[outgoing_group_index].call_type);
        mmi_phb_get_caller_image_info(&g_ucm_p->mo_mt_display.image_info, image_info);

        image_id = image_info->new_image_id;
        image_type = image_info->image_type;
        is_video_sound = image_info->is_video_sound;
        memcpy(g_ucm_p->mo_mt_display.image_path, image_info->image_path, sizeof(g_ucm_p->mo_mt_display.image_path));
    }

    switch (image_type)
    {
        case WGUI_CATE_MOMT_RES_TYPE_IMAGE_ID:
        case WGUI_CATE_MOMT_RES_TYPE_VIDEO_ID:
        case WGUI_CATE_MOMT_RES_TYPE_SWFLASH_ID:
        {

        }
        break;

        case WGUI_CATE_MOMT_RES_TYPE_AVATAR_FILE:
        {
            file_path = (U16*)(image_info->image_path[0]<<24);
            file_path = (U16*)(((U32)file_path) | (image_info->image_path[1]<<16));
            file_path = (U16*)(((U32)file_path) | (image_info->image_path[2]<<8));
            file_path = (U16*)(((U32)file_path) | (image_info->image_path[3]));
        }
        break;
        
        case WGUI_CATE_MOMT_RES_TYPE_IMAGE_FILE:
        case WGUI_CATE_MOMT_RES_TYPE_VIDEO_FILE:
        case WGUI_CATE_MOMT_RES_TYPE_SWFLASH_FILE:
        {
            file_path = (U16*)g_ucm_p->mo_mt_display.image_path;

            if (mmi_ucm_is_file_valid((U16*)file_path) == MMI_FALSE)
            {
                image_id = MMI_UCM_DEFAULT_MOMT_IMAGE;
                file_path = NULL;
            }
        }
        break;

        default:
            MMI_ASSERT(0);
    
    }

    OslMfree(image_info);

#if defined (__MMI_CLAMSHELL__) && !defined (__MMI_SLIDE__)
    /* show sub before main LCD */
    if (!IsClamClose())
    {
        /* show static sub LCD */
        is_video_update = MMI_TRUE;
    }
#endif /* __MMI_CLAMSHELL__ */
    
    ShowCategory17Screen(
            0,   /* title_id */
            0,                   /* left_softkey */
            0,                   /* left_softkey_icon */
            STR_GLOBAL_ABORT,    /* right_softkey */
            0,                   /* right_softkey_icon */
            calling_str_id,                   /* NotificationStringId */ 
            (U8*)display_name, /* NameOrNumber */
            (U8*) ip_num,                /* IP_Number */
            line_icon,             /* line icon */
            IMG_PHB_DEFAULT,     /*default_image_id */
            image_id,               /* resource_id */
            (S8*)file_path,             /* resource_filename */
            image_type,          /* resource_type */
            0,                   /* repeat_count, video/swflash only, repeat_count, 0 = infinite */
            is_video_update,        /* is_visaul_update, video/swflash only, update to LCM or not */
            MMI_FALSE,          /* is_video_aud, video/swflash only, play video's audio */
            MMI_FALSE,         /* is_play_aud_when_start */
            guiBuffer); 

    if (mmi_ucm_app_outgoing_call(MMI_UCM_VOICE_CALL_TYPE_ALL | MMI_UCM_VOIP_CALL_TYPE | MMI_UCM_VIDEO_CALL_TYPE) > 0)
    {
        /* group key */
        SetGroupKeyHandler(
            mmi_ucm_pre_send_dtmf, 
            (U16*) mmi_ucm_idle_screen_digits,
            MMI_UCM_SCREEN_DIGITS - 1,
            KEY_EVENT_DOWN);

        /* In ExecuteCurrKeyHandler(), KEY_REPEAT would be taken as KEY_EVENT_DOWN. tricky! */
        SetGroupKeyHandler(
            MMI_dummy_function, 
            (U16*) mmi_ucm_idle_screen_digits,
            MMI_UCM_SCREEN_DIGITS - 1,
            KEY_REPEAT);

    #if ( (defined  __MMI_WGUI_CSK_ENABLE__) && (defined __MMI_TOUCH_SCREEN__) )
        EnableCenterSoftkey(0, IMG_CSK_DIAL_ICON);
        SetCenterSoftkeyFunction(mmi_ucm_pre_entry_dtmf_editor, KEY_EVENT_UP);
        redraw_center_softkey();    
    #endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && (defined __MMI_TOUCH_SCREEN__) ) */
    }

    SetRightSoftkeyFunction(mmi_ucm_outgoing_call_endkey, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_outgoing_call_endkey, KEY_END, KEY_EVENT_DOWN);
    
    if (g_ucm_p->call_list.group_info[outgoing_group_index].call_type & (~(MMI_UCM_CALL_TYPE_DATA_CSD_ALL | MMI_UCM_VIDEO_CALL_TYPE)))
    {
        mmi_ucm_set_sidekey();
    }

    ForceSubLCDScreen(mmi_ucm_entry_outgoing_call_sublcd);

    TurnOnBacklight(1);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_outgoing_call
 * DESCRIPTION
 *  Exit function for outgoing call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_outgoing_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ucm_get_group_index_by_call_state(MMI_UCM_OUTGOING_STATE) < 0)
    {
        DeleteSubLCDScreen(SCR_ID_UCM_OUTGOING_SUBLCD);

        if (GetCurrSubLCDScreenExitFunc() == mmi_ucm_exit_outgoing_call_sublcd)
        {
            GoBackSubLCDHistory();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_outgoing_call_sublcd
 * DESCRIPTION
 *  Entry screen for Sub Lcd OutGoing Call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_outgoing_call_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 outgoing_group_index = 0;
    U16* display_name = NULL;
#ifdef __MMI_DUAL_SIM_MASTER__
    U32 buffer_char_num = 0;
#endif  /* __MMI_DUAL_SIM_MASTER__ */
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    outgoing_group_index = mmi_ucm_get_group_index_by_call_state(MMI_UCM_OUTGOING_STATE);
    
    if (outgoing_group_index >= 0)
    {
        display_name = (U16*)g_ucm_p->call_list.group_info[outgoing_group_index].call_info[0].remote_info.disp_name;
    }
#ifdef __MMI_DUAL_SIM_MASTER__
    buffer_char_num = sizeof(mmi_ucm_display_buf) / ENCODING_LENGTH;

    memset(mmi_ucm_display_buf, 0x00, sizeof(mmi_ucm_display_buf));

    if(mmi_ucm_get_outgoing_group(MMI_UCM_VOICE_CALL_TYPE, g_ucm_p->call_misc.index_list) > 0)
    {
       mmi_ucs2ncpy((S8*)mmi_ucm_display_buf, (S8*)GetString(STRING_MTPNP_CALL_SIM1), (buffer_char_num - 1));
    }
    else if(mmi_ucm_get_outgoing_group(MMI_UCM_VOICE_CALL_TYPE_SIM2, g_ucm_p->call_misc.index_list) > 0)
    {
       mmi_ucs2ncpy((S8*)mmi_ucm_display_buf,(S8*)GetString(STRING_MTPNP_CALL_SIM2), (buffer_char_num - 1));	
    }

    if (mmi_ucs2strlen((S8*)mmi_ucm_display_buf) < buffer_char_num)
    {    
        mmi_ucs2ncat((S8*)mmi_ucm_display_buf,
                    (S8*)display_name, 
                    (U32)(buffer_char_num - mmi_ucs2strlen((S8*)mmi_ucm_display_buf) - 1));
    }
    
    display_name = (U16*)mmi_ucm_display_buf;
#endif  /* __MMI_DUAL_SIM_MASTER__ */

    ExecSubLCDCurrExitHandler();
    ShowCategory311Screen((U8*)display_name, IMG_ID_UCM_SUBLCD_CALLING, NULL);

    SetSubLCDExitHandler(mmi_ucm_exit_outgoing_call_sublcd);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_outgoing_call_sublcd
 * DESCRIPTION
 *  Exit Handler for Sub Lcd OutGoing Call Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_outgoing_call_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ucm_get_group_index_by_call_state(MMI_UCM_OUTGOING_STATE) >= 0 && 
        !IsSubLCDScreenPresent(SCR_ID_UCM_OUTGOING_SUBLCD))
    {
        SubLCDHistoryNode SubLCDHistory;

        SubLCDHistory.entryFuncPtr = mmi_ucm_entry_outgoing_call_sublcd;
        AddSubLCDHistoryWithScrID(&SubLCDHistory, SCR_ID_UCM_OUTGOING_SUBLCD);
    }
}

#if defined(G_SENSOR_SUPPORT)
//Huyanwei Add it 
extern void Process_SIM2InComingCall_G_Sensor(void);
#endif
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_incoming_call
 * DESCRIPTION
 *  Shows the incoming call screen
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_incoming_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_phb_caller_image_info_struct* image_info = NULL;
    MMI_ANSWERING_MODE ans_mode;    
    S32 incoming_group_index = 0;
    U8* guiBuffer = NULL;
    U16* file_path = NULL;
    U16* display_name = NULL;
    U16 notification_str_id = 0;
    U16 line_icon = 0;    
    U16 image_id = 0;
    U16 lsk_str = 0;
    U16 lsk_icon = 0;
    MMI_BOOL is_play_now = MMI_FALSE;
    MMI_BOOL is_video_sound = MMI_FALSE;
    MMI_BOOL is_video_update = MMI_FALSE;
    U8 image_type = WGUI_CATE_MOMT_RES_TYPE_IMAGE_ID;
    MMI_ALERT_TYPE alert_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */

    image_info = OslMalloc(sizeof(mmi_phb_caller_image_info_struct));
        
    memcpy(&ans_mode, GetAnsweringMode(), sizeof(MMI_ANSWERING_MODE));
    
    EntryNewScreen(SCR_ID_UCM_INCOMING, mmi_ucm_exit_incoming_call, mmi_ucm_entry_incoming_call, NULL);
    DeleteScreenIfPresent(SCR_ID_UCM_INCOMING); /* ensure no two incoming call screens in the history */
    PRINT_INFORMATION("\n[mmi_ucm_entry_incoming_call] Incoming Call Screen\n");
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_INCOMING);

    if (IS_LOW_BATTERY())
    {
        ChgrPlayLowBatTone();
    }
    
    incoming_group_index = mmi_ucm_get_group_index_by_call_state(MMI_UCM_INCOMING_STATE);
    MMI_ASSERT(incoming_group_index >= 0);

    display_name = (U16*)g_ucm_p->call_list.group_info[incoming_group_index].call_info[0].remote_info.disp_name;
	
#ifdef __MMI_DUAL_SIM_MASTER__
    if(mmi_ucm_get_incoming_group(MMI_UCM_VOICE_CALL_TYPE, g_ucm_p->call_misc.index_list) > 0)
    {
        notification_str_id = STRING_MTPNP_INCOMING_SIM1;
    }
    else if(mmi_ucm_get_incoming_group(MMI_UCM_VOICE_CALL_TYPE_SIM2, g_ucm_p->call_misc.index_list) > 0)
    {
        notification_str_id = STRING_MTPNP_INCOMING_SIM2;
    }
#endif  /* __MMI_DUAL_SIM_MASTER__ */

#ifdef __MMI_VIDEO_TELEPHONY__
    if (g_ucm_p->call_list.group_info[incoming_group_index].call_type == MMI_UCM_VIDEO_CALL_TYPE)
    {
        notification_str_id = STR_ID_UCM_VIDEO_CALL;
    }
#endif /* __MMI_VIDEO_TELEPHONY__ */    

    /* line icon */
    if (g_ucm_p->mo_mt_display.line_icon)
    {
        line_icon = g_ucm_p->mo_mt_display.line_icon;
    }

    /* image info */
    memset(image_info, 0x00, sizeof(mmi_phb_caller_image_info_struct));
    g_ucm_p->mo_mt_display.image_info.call_type = (U8)mmi_ucm_get_phb_call_type(g_ucm_p->call_list.group_info[incoming_group_index].call_type);
    mmi_phb_get_caller_image_info(&g_ucm_p->mo_mt_display.image_info, image_info);

    image_id = image_info->new_image_id;
    image_type = image_info->image_type;
    is_video_sound = image_info->is_video_sound;
    memcpy(g_ucm_p->mo_mt_display.image_path, image_info->image_path, sizeof(g_ucm_p->mo_mt_display.image_path));

    switch (image_info->image_type)
    {
        case WGUI_CATE_MOMT_RES_TYPE_IMAGE_ID:
        case WGUI_CATE_MOMT_RES_TYPE_VIDEO_ID:
        case WGUI_CATE_MOMT_RES_TYPE_SWFLASH_ID:
        {

        }
        break;
	    
        case WGUI_CATE_MOMT_RES_TYPE_AVATAR_FILE:
        {
            file_path = (U16*)(image_info->image_path[0]<<24);
            file_path = (U16*)(((U32)file_path) | (image_info->image_path[1]<<16));
            file_path = (U16*)(((U32)file_path) | (image_info->image_path[2]<<8));
            file_path = (U16*)(((U32)file_path) | (image_info->image_path[3]));
        }
        break;

        case WGUI_CATE_MOMT_RES_TYPE_IMAGE_FILE:
        case WGUI_CATE_MOMT_RES_TYPE_VIDEO_FILE:
        case WGUI_CATE_MOMT_RES_TYPE_SWFLASH_FILE:
        {
            file_path = (U16*)g_ucm_p->mo_mt_display.image_path;

            if (mmi_ucm_is_file_valid((U16*)file_path) == MMI_FALSE)
            {
                image_id = MMI_UCM_DEFAULT_MOMT_IMAGE;
                file_path = NULL;
            }
        }
        break;

        default:
            MMI_ASSERT(0);
    
    }

    OslMfree(image_info);

#if defined (__MMI_CLAMSHELL__) && !defined (__MMI_SLIDE__)
    /* show sub before main LCD */
    if (IsClamClose())
    {
        /* show animated sub LCD */
        ForceSubLCDScreen(mmi_ucm_entry_incoming_call_sublcd);
    }
    else
#endif /* __MMI_CLAMSHELL__ */ 
    {
        /* show static sub LCD */
        is_video_update = MMI_TRUE;
        ForceSubLCDScreen(mmi_ucm_entry_incoming_call_static_sublcd);
    }
    
    alert_type = g_ucm_p->mo_mt_display.alert_type;

    if (alert_type == MMI_RING ||
        alert_type == MMI_VIBRATION_AND_RING ||
        alert_type == MMI_VIBRATION_THEN_RING )
    {
        is_play_now = MMI_TRUE;
    }

    if (mmi_ucm_get_group_index_by_call_state_and_type(MMI_UCM_ACTIVE_STATE, MMI_UCM_CALL_TYPE_ALL) >= 0 ||
        mmi_ucm_get_group_index_by_call_state_and_type(MMI_UCM_HOLD_STATE, MMI_UCM_CALL_TYPE_ALL) >= 0)
    {
        is_video_sound = MMI_FALSE;
        is_play_now = MMI_FALSE;
    }

#ifdef __MMI_SIDEKEY_SUPPRESS_RING__
    if (g_ucm_p->call_misc.is_ringtone_suppress)
    {
        is_video_sound = MMI_FALSE;
        is_play_now = MMI_FALSE;            
    }
#endif /* __MMI_SIDEKEY_SUPPRESS_RING__ */ 

    if (mmi_ucm_incoming_call_show_option())
    {
        lsk_str = STR_GLOBAL_OPTIONS;
        lsk_icon = IMG_GLOBAL_OPTIONS;
    }
    else
    {
        lsk_str = STR_ID_UCM_ANSWER;
    }

    ShowCategory17Screen(
            0,   /* title_id */
            lsk_str,                   /* left_softkey */
            lsk_icon,                   /* left_softkey_icon */
            STR_ID_UCM_REJECT,    /* right_softkey */
            0,                   /* right_softkey_icon */
            notification_str_id,                   /* NotificationStringId */ 
            (U8*)display_name, /* NameOrNumber */
            NULL,                /* IP_Number */
            line_icon,             /* line icon */
            IMG_PHB_DEFAULT,     /*default_image_id */
            image_id,               /* resource_id */
            (S8*)file_path,             /* resource_filename */
            image_type,          /* resource_type */
            0,                   /* repeat_count, video/swflash only, repeat_count, 0 = infinite */
            is_video_update,        /* is_visaul_update, video/swflash only, update to LCM or not */
            is_video_sound,      /* is_video_aud, video/swflash only, play video's audio */
            is_play_now,         /* is_play_aud_when_start */
            guiBuffer); 

    if (mmi_ucm_app_total_call((MMI_UCM_VOICE_CALL_TYPE_ALL | MMI_UCM_VOIP_CALL_TYPE)) > 1)
    {
        /* group key */
        SetGroupKeyHandler(
            mmi_ucm_pre_send_dtmf,
            (U16*) mmi_ucm_idle_screen_digits,
            MMI_UCM_SCREEN_DIGITS - 1,
            KEY_EVENT_DOWN);
        
    #if ( (defined  __MMI_WGUI_CSK_ENABLE__) && (defined __MMI_TOUCH_SCREEN__) )
		EnableCenterSoftkey(0, IMG_CSK_DIAL_ICON);
    	SetCenterSoftkeyFunction(mmi_ucm_pre_entry_dtmf_editor, KEY_EVENT_UP);
		redraw_center_softkey();    
	#endif

        if (mmi_ucm_app_active_call(MMI_UCM_VOICE_CALL_TYPE_ALL | MMI_UCM_VOIP_CALL_TYPE) > 0)
        {
            mmi_ucm_set_sidekey();
        }
    }
    else /* no other call */
    {        
        /* group key */
        if (ans_mode.anyKey == TRUE)
        {
            SetGroupKeyHandler(
                mmi_ucm_incoming_call_sendkey, 
                (U16*) PresentAllKeys, 
                TOTAL_KEYS, 
                KEY_EVENT_DOWN);
        }


    #ifdef __MMI_SIDEKEY_SUPPRESS_RING__
        if (g_ucm_p->call_misc.is_ringtone_suppress == MMI_FALSE &&
            mmi_ucm_app_incoming_call(MMI_UCM_CALL_TYPE_NO_CSD) == mmi_ucm_app_total_call(MMI_UCM_CALL_TYPE_NO_CSD))
        {
            SetKeyHandler(mmi_ucm_suppress_incoming_tone, KEY_VOL_DOWN, KEY_EVENT_DOWN);
            SetKeyHandler(mmi_ucm_set_side_key_after_suppress_ring, KEY_VOL_DOWN, KEY_EVENT_UP);
        }
    #endif /* __MMI_SIDEKEY_SUPPRESS_RING__ */ 

        /* side key */
    #ifdef __MMI_CLAMSHELL__
    #ifdef __MMI_SIDEKEY_SUPPRESS_RING__
        SetKeyHandler(mmi_ucm_incoming_call_endkey, KEY_VOL_DOWN, KEY_EVENT_LONG_PRESS);
    #else /* __MMI_SIDEKEY_SUPPRESS_RING__ */    
        SetKeyHandler(mmi_ucm_incoming_call_sendkey, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_ucm_incoming_call_endkey, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    #endif /* __MMI_SIDEKEY_SUPPRESS_RING__ */    
    #endif /* __MMI_CLAMSHELL__ */
    }

    if (mmi_ucm_incoming_call_show_option())
    {
        SetLeftSoftkeyFunction(mmi_ucm_entry_incoming_call_option, KEY_EVENT_UP);
    }
    else
    {
        SetLeftSoftkeyFunction(mmi_ucm_incoming_call_sendkey, KEY_EVENT_UP);
    }

    SetRightSoftkeyFunction(mmi_ucm_incoming_call_endkey, KEY_EVENT_UP);

    SetKeyHandler(mmi_ucm_incoming_call_sendkey, KEY_SEND, KEY_EVENT_DOWN);

    SetKeyHandler(mmi_ucm_incoming_call_endkey, KEY_END, KEY_EVENT_DOWN);

    TurnOnBacklight(1);

    mmi_ucm_play_incoming_tone();

#if defined(G_SENSOR_SUPPORT)
//Huyanwei Add it 
#if defined(NOKE_DEBUG)
	noke_dbg_printf("\r\n Huyanwei Debug mmi_ucm_entry_incoming_call() \r\n");
#endif
	Process_SIM2InComingCall_G_Sensor();
#endif



}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_incoming_call
 * DESCRIPTION
 *  Exit function for incoming call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_incoming_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ucm_get_group_index_by_call_state(MMI_UCM_INCOMING_STATE) < 0)
    {
        DeleteSubLCDScreen(SCR_ID_UCM_INCOMING_SUBLCD);
        DeleteSubLCDScreen(SCR_ID_UCM_INCOMING_SUBLCD_STATIC);
        
        if (GetCurrSubLCDScreenExitFunc() == mmi_ucm_exit_incoming_call_sublcd ||
            GetCurrSubLCDScreenExitFunc() == mmi_ucm_exit_incoming_call_static_sublcd )
        {
            GoBackSubLCDHistory();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_outgoing_call_sublcd
 * DESCRIPTION
 *  Entry screen for Sub Lcd OutGoing Call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_incoming_call_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32  group_index = 0;
    U16* display_name = NULL;
#ifdef __MMI_DUAL_SIM_MASTER__
    U32 buffer_char_num = 0;
#endif  /* __MMI_DUAL_SIM_MASTER__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    group_index = mmi_ucm_get_group_index_by_call_state(MMI_UCM_INCOMING_STATE);
    
    if (group_index >= 0)
    {
        display_name = (U16*)g_ucm_p->call_list.group_info[group_index].call_info[0].remote_info.disp_name;
    }
	
#ifdef __MMI_DUAL_SIM_MASTER__
    buffer_char_num = sizeof(mmi_ucm_display_buf) / ENCODING_LENGTH;

    memset(mmi_ucm_display_buf, 0x00, sizeof(mmi_ucm_display_buf));

    if(mmi_ucm_get_incoming_group(MMI_UCM_VOICE_CALL_TYPE, g_ucm_p->call_misc.index_list) > 0)
    {
       mmi_ucs2ncpy((S8*)mmi_ucm_display_buf, (S8*)GetString(STRING_MTPNP_CALL_SIM1), (buffer_char_num - 1));
    }
    else if(mmi_ucm_get_incoming_group(MMI_UCM_VOICE_CALL_TYPE_SIM2, g_ucm_p->call_misc.index_list) > 0)
    {
       mmi_ucs2ncpy((S8*)mmi_ucm_display_buf,(S8*)GetString(STRING_MTPNP_CALL_SIM2), (buffer_char_num - 1));	
    }

    if (mmi_ucs2strlen((S8*)mmi_ucm_display_buf) < buffer_char_num)
    {    
        mmi_ucs2ncat((S8*)mmi_ucm_display_buf,
                    (S8*)display_name, 
                    (U32)(buffer_char_num - mmi_ucs2strlen((S8*)mmi_ucm_display_buf) - 1));
    }
    
    display_name = (U16*)mmi_ucm_display_buf;
#endif  /* __MMI_DUAL_SIM_MASTER__ */

    ExecSubLCDCurrExitHandler();
    ShowCategory311Screen((U8*)display_name, IMG_ID_UCM_SUBLCD_CALLING, NULL);

    SetSubLCDExitHandler(mmi_ucm_exit_incoming_call_sublcd);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_incoming_call_sublcd
 * DESCRIPTION
 *  Exit Handler for Sub Lcd OutGoing Call Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_incoming_call_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ucm_get_group_index_by_call_state(MMI_UCM_INCOMING_STATE) >= 0 && 
        !IsSubLCDScreenPresent(SCR_ID_UCM_INCOMING_SUBLCD))
    {
        SubLCDHistoryNode SubLCDHistory;

        SubLCDHistory.entryFuncPtr = mmi_ucm_entry_incoming_call_sublcd;
        AddSubLCDHistoryWithScrID(&SubLCDHistory, SCR_ID_UCM_INCOMING_SUBLCD);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_incoming_call_static_sublcd
 * DESCRIPTION
 *  Entry screen for Sub Lcd Incoming Call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_incoming_call_static_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecSubLCDCurrExitHandler();

    ShowCategory332Screen(IMG_ID_UCM_CONNECTED);
    SetSubLCDExitHandler(mmi_ucm_exit_incoming_call_static_sublcd);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_incoming_call_static_sublcd
 * DESCRIPTION
 *  Exit Handler for Sub Lcd Incoming Call Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_incoming_call_static_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ucm_get_group_index_by_call_state(MMI_UCM_INCOMING_STATE) >= 0 && 
        !IsSubLCDScreenPresent(SCR_ID_UCM_INCOMING_SUBLCD_STATIC))
    {
        SubLCDHistoryNode SubLCDHistory;

        SubLCDHistory.entryFuncPtr = mmi_ucm_entry_incoming_call_static_sublcd;
        AddSubLCDHistoryWithScrID(&SubLCDHistory, SCR_ID_UCM_INCOMING_SUBLCD_STATIC);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_handle_incoming_option
 * DESCRIPTION
 *  Sample code
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_handle_incoming_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (mmi_ucm_answer_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCOMING_OPTION_ANSWER);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCOMING_OPTION_ANSWER);
    }

    if (mmi_ucm_deflect_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCOMING_OPTION_DEFLECT);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCOMING_OPTION_DEFLECT);
    }

    if (mmi_ucm_replace_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCOMING_OPTION_REPLACE);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCOMING_OPTION_REPLACE);
    }
    
#ifdef __MMI_UCM_REDIAL_FROM_OTHER_SIM__
    if (mmi_ucm_redial_from_other_sim_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCOMING_OPTION_REDIAL_FROM_OTHER_SIM);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCOMING_OPTION_REDIAL_FROM_OTHER_SIM);
    }
#endif /* __MMI_UCM_REDIAL_FROM_OTHER_SIM__ */

    if (mmi_ucm_end_all_active_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCOMING_OPTION_END_ALL_ACTIVE);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCOMING_OPTION_END_ALL_ACTIVE);
    }

    if (mmi_ucm_end_all_held_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCOMING_OPTION_END_ALL_HELD);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCOMING_OPTION_END_ALL_HELD);
    }

    if (mmi_ucm_bk_sound_incoming_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCOMING_OPTION_BACKGROUND_SOUND);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCOMING_OPTION_BACKGROUND_SOUND);
    }

    if (mmi_ucm_swap_bt_audio_path_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCOMING_OPTION_SWITCH_AUDIO_PATH);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCOMING_OPTION_SWITCH_AUDIO_PATH);
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_incoming_call_option
 * DESCRIPTION
 *  Shows the incoming call option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_incoming_call_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 numItems = 0;
    U16 nStrItemList[MAX_SUB_MENUS];
    U16 lsk_string = STR_GLOBAL_OK;
    U16 lsk_image = IMG_GLOBAL_OK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_INCOMING_OPTION, NULL, mmi_ucm_entry_incoming_call_option, NULL);
    PRINT_INFORMATION("\n[mmi_ucm_entry_incoming_call_option] Incoming Call Option Screen\n");
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_INCOMING_OPTION);

    mmi_ucm_handle_incoming_option();

    numItems = GetNumOfChild_Ext(MENU_ID_UCM_INCOMING_OPTION);
    GetSequenceStringIds_Ext(MENU_ID_UCM_INCOMING_OPTION, nStrItemList);    
    SetParentHandler(MENU_ID_UCM_INCOMING_OPTION);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    if (numItems == 0)
    {
        lsk_string = 0;
        lsk_image = 0;
    }

    ShowCategory52Screen(
        STR_GLOBAL_OPTIONS,
        0,
        lsk_string,
        lsk_image,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        numItems,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        NULL,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
    SetKeyHandler(mmi_ucm_incoming_call_endkey, KEY_END, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_incoming_call_sendkey, KEY_SEND, KEY_EVENT_DOWN);

    /* must set KEY_EVENT_DOWN function to overwrite original side key handler of category 52 */
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incoming_opt_answer
 * DESCRIPTION
 *  Funtion is called when answer menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incoming_opt_answer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    SetLeftSoftkeyFunction(mmi_ucm_incoming_call_sendkey, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incoming_opt_deflect
 * DESCRIPTION
 *  Funtion is called when deflect menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incoming_opt_deflect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {
        /* To prevent the dial_pad_buffer is reset incorrectly */
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
    
    memset(g_ucm_p->mo_info.dial_pad_buffer, 0, sizeof(g_ucm_p->mo_info.dial_pad_buffer));
    SetLeftSoftkeyFunction(mmi_ucm_entry_deflect, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_entry_deflect, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incoming_opt_replace
 * DESCRIPTION
 *  Funtion is called when replace menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incoming_opt_replace(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ucm_replace, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_replace, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}


#ifdef __MMI_UCM_REDIAL_FROM_OTHER_SIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incoming_opt_redial_from_other_sim
 * DESCRIPTION
 *  Funtion is called when redial from other sim menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incoming_opt_redial_from_other_sim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ucm_redial_from_other_sim, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_redial_from_other_sim, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}
#endif /* __MMI_UCM_REDIAL_FROM_OTHER_SIM__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incoming_opt_end_all_active
 * DESCRIPTION
 *  Funtion is called when end all active menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incoming_opt_end_all_active(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ucm_end_all_active_action, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_end_all_active_action, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incoming_opt_end_all_held
 * DESCRIPTION
 *  Funtion is called when end all held menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incoming_opt_end_all_held(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ucm_end_all_held_action, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_end_all_held_action, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incoming_opt_background_sound
 * DESCRIPTION
 *  Funtion is called when deflect menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incoming_opt_background_sound(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
#ifdef __MMI_BG_SOUND_EFFECT__    
    SetLeftSoftkeyFunction(mmi_ucm_entry_bgs_effect_select, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_entry_bgs_effect_select, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
#endif /* __MMI_BG_SOUND_EFFECT__ */

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_switch_audio_path
 * DESCRIPTION
 *  Funtion is called when switch audio path menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_switch_audio_path(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_bt_set_audio_path, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_bt_set_audio_path, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_connect_last_bt_device
 * DESCRIPTION
 *  Funtion is called when connect to last BT device menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_connect_last_bt_device(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
#if defined(__MMI_BT_SUPPORT__) && defined(__MMI_HFP_SUPPORT__)    
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_bt_connect_last_headset, KEY_EVENT_UP);
    SetKeyHandler(mmi_bt_connect_last_headset, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
#endif /* defined(__MMI_BT_SUPPORT__) && defined(__MMI_HFP_SUPPORT__) */    
    return;
}

#ifdef __CTM_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_ctm_connect
 * DESCRIPTION
 *  Funtion is called when ctm connect menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_ctm_connect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ctm_connect, KEY_EVENT_UP);
    SetKeyHandler(mmi_ctm_connect, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}
#endif /* __CTM_SUPPORT__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_handle_incall_option
 * DESCRIPTION
 *  Sample code
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_handle_incall_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_ucm_hold_single_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_HOLD_SINGLE);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_HOLD_SINGLE);
    }

    if (mmi_ucm_hold_conference_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_HOLD_CONF);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_HOLD_CONF);
    }

    if (mmi_ucm_retrieve_single_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_RETRIEVE_SINGLE);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_RETRIEVE_SINGLE);
    }

    if (mmi_ucm_retrieve_conference_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_RETRIEVE_CONF);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_RETRIEVE_CONF);
    }

    if (mmi_ucm_swap_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_SWAP);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_SWAP);
    }

    if (mmi_ucm_conference_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_CONF);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_CONF);
    }

    if (mmi_ucm_split_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_SPLIT);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_SPLIT);
    }

    if (mmi_ucm_end_single_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_END_SINGLE);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_END_SINGLE);
    }

    if (mmi_ucm_end_conference_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_END_CONF);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_END_CONF);
    }

    if (mmi_ucm_end_all_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_END_ALL);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_END_ALL);
    }

    if (mmi_ucm_transfer_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_TRANSFER);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_TRANSFER);
    }

    if (mmi_ucm_new_call_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_NEW_CALL);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_NEW_CALL);
    }

    if (mmi_ucm_phonebook_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_PHONEBOOK);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_PHONEBOOK);
    }

    if (mmi_ucm_sms_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_SMS);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_SMS);
    }

    if (mmi_ucm_sound_recorder_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_SOUND_RECORDER);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_SOUND_RECORDER);
    }

    if (mmi_ucm_bk_sound_in_call_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_BACKGROUND_SOUND);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_BACKGROUND_SOUND);
    }

    if (mmi_ucm_mute_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_MUTE);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_MUTE);
    }

    if (mmi_ucm_dtmf_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_DTMF);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_DTMF);
    }

    if (mmi_ucm_swap_bt_audio_path_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_SWITCH_AUDIO_PATH);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_SWITCH_AUDIO_PATH);
    }
    
    if (mmi_ucm_connect_bt_default_headset_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_CONNECT_LAST_BT_DEVICE);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_CONNECT_LAST_BT_DEVICE);
    }

    if (mmi_ucm_ctm_option() == TRUE)
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_INCALL_OPTION_CTM_CONNECT);
    }
    else
    {
        mmi_frm_hide_menu_item(MENU_ID_UCM_INCALL_OPTION_CTM_CONNECT);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_incall_option
 * DESCRIPTION
 *  Shows the incall option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_incall_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 numItems = 0;
    U16 nStrItemList[MAX_SUB_MENUS];
    U8 *popUpList[MAX_SUB_MENUS];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    EntryNewScreen(SCR_ID_UCM_IN_CALL_OPTION, NULL, mmi_ucm_entry_incall_option, NULL);
    PRINT_INFORMATION("\n[mmi_ucm_entry_incall_option] In-Call Option Screen\n");
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_IN_CALL_OPTION);

    mmi_ucm_handle_incall_option();

    numItems = GetNumOfChild_Ext(MENU_ID_UCM_INCALL_OPTION);
    GetSequenceStringIds_Ext(MENU_ID_UCM_INCALL_OPTION, nStrItemList);    
    SetParentHandler(MENU_ID_UCM_INCALL_OPTION);

    ConstructHintsList(MENU_ID_UCM_INCALL_OPTION, popUpList);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory52Screen(
        STR_GLOBAL_OPTIONS,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        numItems,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        (U8 **) popUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_hold_single
 * DESCRIPTION
 *  Funtion is called when hold single menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_hold_single(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_hold_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_hold_conf
 * DESCRIPTION
 *  Funtion is called when hold conf menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_hold_conf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_hold_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_retrieve_single
 * DESCRIPTION
 *  Funtion is called when retrieve single menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_retrieve_single(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_retrieve_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_retrieve_conf
 * DESCRIPTION
 *  Funtion is called when retrieve conf menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_retrieve_conf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_retrieve_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_swap
 * DESCRIPTION
 *  Funtion is called when swap menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_swap(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_swap_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_conf
 * DESCRIPTION
 *  Funtion is called when conf menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_conf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_conference_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_split
 * DESCRIPTION
 *  Funtion is called when split menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_split(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_split_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_end_single
 * DESCRIPTION
 *  Funtion is called when end single menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_end_single(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_end_single_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_end_conf
 * DESCRIPTION
 *  Funtion is called when end conf menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_end_conf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_end_conference_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_end_all
 * DESCRIPTION
 *  Funtion is called when end all menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_end_all(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_ucm_end_all_action, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_transfer
 * DESCRIPTION
 *  Funtion is called when transfer menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_transfer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 hiliteTab = g_ucm_p->call_misc.hilite_tab;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {
        /* To prevent the dial_pad_buffer is reset incorrectly */
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    memset(g_ucm_p->mo_info.dial_pad_buffer, 0, sizeof(g_ucm_p->mo_info.dial_pad_buffer));
    if (g_ucm_p->call_list.group_info[hiliteTab].call_type & MMI_UCM_VOICE_CALL_TYPE_ALL)
    {
        SetLeftSoftkeyFunction(mmi_ucm_explict_call_transfer_action, KEY_EVENT_UP); 
        SetKeyHandler(mmi_ucm_explict_call_transfer_action, KEY_RIGHT_ARROW, KEY_EVENT_DOWN); 
    }
    else if (g_ucm_p->call_list.group_info[hiliteTab].call_type == MMI_UCM_VOIP_CALL_TYPE)
    {
    SetLeftSoftkeyFunction(mmi_ucm_entry_transfer, KEY_EVENT_UP); 
    SetKeyHandler(mmi_ucm_entry_transfer, KEY_RIGHT_ARROW, KEY_EVENT_DOWN); 
    }
    else
    {
        MMI_ASSERT(0);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_new_call
 * DESCRIPTION
 *  Funtion is called when new call menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_new_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {
        /* To prevent the dial_pad_buffer is reset incorrectly */
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    memset(g_ucm_p->mo_info.dial_pad_buffer, 0, sizeof(g_ucm_p->mo_info.dial_pad_buffer));

    if (GetNumOfChild_Ext(MENU_ID_UCM_INCALL_OPTION_NEW_CALL) > 1)
    {    
        SetLeftSoftkeyFunction(mmi_ucm_entry_new_call_opt, KEY_EVENT_UP);
        SetKeyHandler(mmi_ucm_entry_new_call_opt, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    }
    else
    {
    #ifdef __MMI_VOIP__
        SetLeftSoftkeyFunction(mmi_ucm_entry_voip_dialer_screen, KEY_EVENT_UP);
        SetKeyHandler(mmi_ucm_entry_voip_dialer_screen, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    #else /* __MMI_VOIP__ */
        SetLeftSoftkeyFunction(mmi_ucm_entry_voice_dialer_screen, KEY_EVENT_UP);
        SetKeyHandler(mmi_ucm_entry_voice_dialer_screen, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    #endif /* __MMI_VOIP__ */
    }
    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_phonebook
 * DESCRIPTION
 *  Funtion is called when phonebook menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_phonebook(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(mmi_phb_call_enter_from_active_call, KEY_EVENT_UP);
    SetKeyHandler(mmi_phb_call_enter_from_active_call, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_sms
 * DESCRIPTION
 *  Funtion is called when sms menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_sms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(PreEntryScrMessagesMenuList, KEY_EVENT_UP);
    SetKeyHandler(PreEntryScrMessagesMenuList, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_sound_recorder
 * DESCRIPTION
 *  Funtion is called when sound recorder menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_sound_recorder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
#ifdef __MMI_SOUND_RECORDER__
    SetLeftSoftkeyFunction(mmi_sndrec_entry_in_call, KEY_EVENT_UP);
    SetKeyHandler(mmi_sndrec_entry_in_call, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
#endif /* __MMI_SOUND_RECORDER__ */
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_bkg_sound
 * DESCRIPTION
 *  Funtion is called when background sound menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_bkg_sound(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
#ifdef __MMI_BG_SOUND_EFFECT__    
    mmi_bgsnd_highlight_call_manage();
#endif /* __MMI_BG_SOUND_EFFECT__ */    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_mute
 * DESCRIPTION
 *  Funtion is called when mute menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_mute(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (g_ucm_p->call_misc.is_mute == TRUE)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, IMG_GLOBAL_OK);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, IMG_GLOBAL_OK);
    }
    
    SetLeftSoftkeyFunction(mmi_ucm_set_mute, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_incall_opt_dtmf
 * DESCRIPTION
 *  Highlight handler of Call Option\DTMF
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_incall_opt_dtmf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ucm_p->call_misc.is_dtmf == TRUE)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, IMG_GLOBAL_OK);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, IMG_GLOBAL_OK);
    }
    
    ChangeRightSoftkey(STR_GLOBAL_BACK, IMG_GLOBAL_BACK);
    
    SetLeftSoftkeyFunction(mmi_ucm_set_dtmf_in_call, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_hint_mute
 * DESCRIPTION
 *  Hint handler of Call Option\Mute
 * PARAMETERS
 *  index       [IN]        Current selected index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_hint_mute(U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(hintData[index], 0, MAX_SUB_MENU_SIZE);
    if (g_ucm_p->call_misc.is_mute == TRUE)
    {
        mmi_ucs2cpy((S8*) hintData[index], (S8*) GetString(STR_GLOBAL_ON));
    }
    else
    {
        mmi_ucs2cpy((S8*) hintData[index], (S8*) GetString(STR_GLOBAL_OFF));
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_hint_dtmf_in_call
 * DESCRIPTION
 *  Hint handler of Call Option\DTMF
 * PARAMETERS
 *  index       [IN]        Current selected index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_hint_dtmf_in_call(U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(hintData[index], 0, MAX_SUB_MENU_SIZE);
    if (g_ucm_p->call_misc.is_dtmf == TRUE)
    {
        mmi_ucs2cpy((S8*) hintData[index], (S8*) GetString(STR_GLOBAL_ON));
    }
    else
    {
        mmi_ucs2cpy((S8*) hintData[index], (S8*) GetString(STR_GLOBAL_OFF));
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_hint_connect_last_bt_device
 * DESCRIPTION
 *  Hint handler of Connect last bt device
 * PARAMETERS
 *  index       [IN]        Current selected index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_hint_connect_last_bt_device(U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_BT_SUPPORT__) && defined(__MMI_HFP_SUPPORT__)
    
    U16 len = (mmi_ucs2strlen((S8*)mmi_bt_get_default_headset_device_name()) < (MAX_SUB_MENU_SIZE - 1)) ? 
                mmi_ucs2strlen((S8*)mmi_bt_get_default_headset_device_name()) : (MAX_SUB_MENU_SIZE - 1);

#endif /* defined(__MMI_BT_SUPPORT__) && defined(__MMI_HFP_SUPPORT__) */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(hintData[index], 0, MAX_SUB_MENU_SIZE);

#if defined(__MMI_BT_SUPPORT__) && defined(__MMI_HFP_SUPPORT__)    
    if (len > 0)
    {
        mmi_ucs2ncpy((S8*) hintData[index], (S8*) mmi_bt_get_default_headset_device_name(), len);
    }
#endif /* defined(__MMI_BT_SUPPORT__) && defined(__MMI_HFP_SUPPORT__) */    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_set_mute
 * DESCRIPTION
 *  Turn on and turn off microphone in call option.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_set_mute(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ucm_p->call_misc.is_mute == TRUE)
    {
        UnMutethePhone();
        mmi_ucs2cpy((S8*) hintData[GetCurrHiliteID()], (S8*) GetString(STR_GLOBAL_OFF));
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) GetString(STR_GLOBAL_OFF));
        ChangeLeftSoftkey(STR_GLOBAL_ON, IMG_GLOBAL_OK);
    }
    else
    {
        MutethePhone();
        mmi_ucs2cpy((S8*) hintData[GetCurrHiliteID()], (S8*) GetString(STR_GLOBAL_ON));
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) GetString(STR_GLOBAL_ON));
        ChangeLeftSoftkey(STR_GLOBAL_OFF, IMG_GLOBAL_OK);
    }
    RedrawCategoryFunction();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_set_dtmf_in_call
 * DESCRIPTION
 *  Temporarily turn on and turn off DTMF in call option.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_set_dtmf_in_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ucm_p->call_misc.is_dtmf == TRUE)
    {
        g_ucm_p->call_misc.is_dtmf = FALSE;
        mmi_ucs2cpy((S8*) hintData[GetCurrHiliteID()], (S8*) GetString(STR_GLOBAL_OFF));
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) GetString(STR_GLOBAL_OFF));
        ChangeLeftSoftkey(STR_GLOBAL_ON, IMG_GLOBAL_OK);
    }
    else
    {
        g_ucm_p->call_misc.is_dtmf = TRUE;
        mmi_ucs2cpy((S8*) hintData[GetCurrHiliteID()], (S8*) GetString(STR_GLOBAL_ON));
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) GetString(STR_GLOBAL_ON));
        ChangeLeftSoftkey(STR_GLOBAL_OFF, IMG_GLOBAL_OK);
    }
    RedrawCategoryFunction();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_is_allow_dtmf
 * DESCRIPTION
 *  Determine to send DTMF or not based on current state.
 * PARAMETERS
 *  void
 * RETURNS
 *  BOOL
 *****************************************************************************/
BOOL mmi_ucm_is_allow_dtmf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 currhiliteTab = 0, callState = 0;
    S32 call_type = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currhiliteTab = g_ucm_p->call_misc.hilite_tab;
    callState = g_ucm_p->call_list.group_info[currhiliteTab].call_state;
    call_type = g_ucm_p->call_list.group_info[currhiliteTab].call_type;

    PRINT_INFORMATION("\n[mmi_ucm_is_allow_dtmf] is_dtmf: %d call_type: %d, call_state: %d\n", 
                        g_ucm_p->call_misc.is_dtmf, call_type, callState);

    if ((g_ucm_p->call_misc.is_dtmf == MMI_TRUE) &&
        (((call_type & MMI_UCM_VOICE_CALL_TYPE_ALL) && (callState == MMI_UCM_ACTIVE_STATE)) ||
         (call_type == MMI_UCM_VOIP_CALL_TYPE && callState == MMI_UCM_ACTIVE_STATE) ||
         ((mmi_ucm_get_outgoing_group(MMI_UCM_VOICE_CALL_TYPE_ALL, g_ucm_p->call_misc.index_list) != 0) &&
          (g_ucm_p->call_misc.is_speech == MMI_TRUE))))
    {
        PRINT_INFORMATION("\n[mmi_ucm_is_allow_dtmf] TRUE \n");        
        return MMI_TRUE;
    }
    else
    {
        PRINT_INFORMATION("\n[mmi_ucm_is_allow_dtmf] FALSE \n");
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_pre_send_dtmf
 * DESCRIPTION
 *  Determine to send DTMF or not based on current state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_pre_send_dtmf(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 keyCode = 0, keyType = 0;
    mmi_ucm_dtmf_struct start_dtmf;
    S32 group_index = 0;
    mmi_ucm_call_type_enum call_type = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(g_ucm_p->call_misc.disp_dtmf, 0, sizeof(g_ucm_p->call_misc.disp_dtmf));
    memset(g_ucm_p->call_misc.input_dtmf, 0, sizeof(g_ucm_p->call_misc.input_dtmf));

    PRINT_INFORMATION("\n[mmi_ucm_pre_send_dtmf] is_dtmf: %d\n", g_ucm_p->call_misc.is_dtmf);

    GetkeyInfo(&keyCode, &keyType);
    memset(&start_dtmf, 0, sizeof(mmi_ucm_dtmf_struct));
    start_dtmf.digit = keyCode;
    
    mmi_ucm_pre_entry_dtmf_editor();
    
    if (mmi_ucm_is_allow_dtmf())
    {        
        /* get current active call type */
        group_index = mmi_ucm_get_group_index_by_call_state_and_type(MMI_UCM_ACTIVE_STATE, MMI_UCM_CALL_TYPE_NO_CSD);
        
        if (group_index != -1)
        {
            call_type = g_ucm_p->call_list.group_info[group_index].call_type;
        }
        else
        {
            /* get current active call type */
            group_index = mmi_ucm_get_group_index_by_call_state_and_type(MMI_UCM_OUTGOING_STATE, MMI_UCM_CALL_TYPE_NO_CSD);

            if (group_index != -1)
            {
                call_type = g_ucm_p->call_list.group_info[group_index].call_type;
            }
        }

        if (call_type)
        {
            if (g_ucm_p->call_misc.is_mute == MMI_FALSE)
            {
                MuteOnMicrophone();
            }
            
            mmi_ucm_send_req(MMI_UCM_START_DTMF, call_type, (void *)&start_dtmf);
        }
    }
    
    wgui_execute_key_handler(keyCode, keyType);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_dtmf_editor
 * DESCRIPTION
 *  Exit function of dtmf editor in call.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_dtmf_editor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_ucm_p->call_misc.is_dtmf_start == MMI_TRUE)
    {
        PRINT_INFORMATION("[mmi_ucm_exit_dtmf_editor] Send_Stop_DTMF, call_type: %d", g_ucm_p->call_misc.dtmf.call_type);
        mmi_ucm_send_req(MMI_UCM_STOP_DTMF, g_ucm_p->call_misc.dtmf.call_type, (void *)&g_ucm_p->call_misc.dtmf);
    }

    /* Prevent the mic is mute because of sending DTMF but not unmute later. */
    if (g_ucm_p->call_misc.is_mute == MMI_FALSE)
    {
        MuteOffMicrophone();
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_pre_entry_dtmf_editor
 * DESCRIPTION
 *  Pre-entry function of dtmf editor in call.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_pre_entry_dtmf_editor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Avoid re-entry of DTMF editor */
    DeleteScreenIfPresent(SCR_ID_UCM_DTMF_EDITOR);
    memset(g_ucm_p->call_misc.disp_dtmf, 0, sizeof(g_ucm_p->call_misc.disp_dtmf));
    
    mmi_ucm_entry_dtmf_editor();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_dtmf_editor
 * DESCRIPTION
 *  Entry function of dtmf editor in call.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_dtmf_editor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U8 *inputStr = GetCurrInputBuffer(SCR_ID_UCM_DTMF_EDITOR);
    S32 inputLen = 0;
    U16 lsk_string = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_DTMF_EDITOR, mmi_ucm_exit_dtmf_editor, mmi_ucm_entry_dtmf_editor, NULL);
    
    PRINT_INFORMATION("\n[mmi_ucm_entry_dtmf_editor] \n");
    
    if (mmi_ucs2strlen((S8*)inputStr) != 0)
    {
        inputLen = (MMI_UCM_DTMF_LEN >= mmi_ucs2strlen((S8*)inputStr)) ? 
            (mmi_ucs2strlen((S8*)inputStr)) : (MMI_UCM_DTMF_LEN);
        
        memset(g_ucm_p->call_misc.disp_dtmf, 0, sizeof(g_ucm_p->call_misc.disp_dtmf));
        mmi_ucs2ncpy((S8*)g_ucm_p->call_misc.disp_dtmf, (S8*)inputStr, inputLen);
    }
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_DTMF_EDITOR);

    if (mmi_ucm_in_call_show_option())
    {
        lsk_string = STR_GLOBAL_SAVE;
    }

#if ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) )
#if defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)
    SetDialingKeypadCallHandler(mmi_ucm_make_voice_call_from_dtmf_editor);

    if (mmi_ucm_app_incoming_call(MMI_UCM_CALL_TYPE_ALL) ||
        mmi_ucm_app_outgoing_call(MMI_UCM_CALL_TYPE_ALL))
    {
        SetDialingKeypadPhonebookHandler(NULL);
    }
    else if (mmi_ucm_in_call_show_option())
    {
        SetDialingKeypadPhonebookHandler(mmi_phb_list_enter_first_from_active_call);
    }
    else
    {
        SetDialingKeypadPhonebookHandler(NULL);
    }
#else /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
    EnableCenterSoftkey(0, IMG_CSK_DIAL_ICON);
#endif /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) ) */
    
    ShowCategory16Screen(
        lsk_string,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        g_ucm_p->call_misc.disp_dtmf,
        (MMI_UCM_DTMF_LEN + 1),
        guiBuffer);
    
    wgui_save_key_handlers();

    if (mmi_ucm_in_call_show_option())
    {
        SetLeftSoftkeyFunction(mmi_ucm_entry_save_phonebook, KEY_EVENT_UP); 
    }
    else
    {
        SetLeftSoftkeyFunction(MMI_dummy_function, KEY_EVENT_UP);
    }
    
    SetCategory16RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP); 

    SetGroupKeyHandler(mmi_ucm_dtmf_key_down, (U16*)mmi_ucm_idle_screen_digits, MMI_UCM_SCREEN_DIGITS - 1, KEY_EVENT_DOWN);
    SetGroupKeyHandler(mmi_ucm_dtmf_key_up, (U16*)mmi_ucm_idle_screen_digits, MMI_UCM_SCREEN_DIGITS - 1, KEY_EVENT_UP);
    SetGroupKeyHandler(MMI_dummy_function, (U16*)mmi_ucm_idle_screen_digits, MMI_UCM_SCREEN_DIGITS - 1, KEY_EVENT_REPEAT);

    if (mmi_ucm_get_group_index_by_call_state(MMI_UCM_INCOMING_STATE) >= 0)
    {
        SetKeyHandler(mmi_ucm_incoming_call_endkey, KEY_END, KEY_EVENT_DOWN);
    }
    else if (mmi_ucm_get_group_index_by_call_state(MMI_UCM_OUTGOING_STATE) >= 0)
    {
        SetKeyHandler(mmi_ucm_outgoing_call_endkey, KEY_END, KEY_EVENT_DOWN);
    }
    else
    {
        SetKeyHandler(mmi_ucm_in_call_endkey, KEY_END, KEY_EVENT_DOWN);
    }
    
    
#ifdef __MMI_DUAL_SIM_MASTER__
    MTPNP_PFAL_CC_HandleSendKeys(mmi_ucm_make_voice_call_from_dtmf_editor,KEY_EVENT_DOWN);
#else /* __MMI_DUAL_SIM_MASTER__ */
    SetKeyHandler(mmi_ucm_make_voice_call_from_dtmf_editor, KEY_SEND, KEY_EVENT_DOWN);
#endif /* __MMI_DUAL_SIM_MASTER__ */ 

    /* must set KEY_EVENT_DOWN function to overwrite original side key handler of category 52 */
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_DOWN, KEY_EVENT_DOWN);

#if (defined (__MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__))
#ifdef __MMI_DUAL_SIM_MASTER__
     MTPNP_PFAL_CC_SetCenterFunc(mmi_ucm_make_voice_call_from_dtmf_editor);
     SetCenterSoftkeyFunction(MTPNP_PFAL_CC_CSKHandler, KEY_EVENT_UP);
#else  /* __MMI_DUAL_SIM_MASTER__ */
    SetCenterSoftkeyFunction(mmi_ucm_make_voice_call_from_dtmf_editor, KEY_EVENT_UP);
#endif  /* __MMI_DUAL_SIM_MASTER__ */
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)) */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_dtmf_key_down
 * DESCRIPTION
 *  Send DTMF sound to remote side.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_dtmf_key_down(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 keyCode = 0, keyType = 0;
    mmi_ucm_dtmf_struct start_dtmf;
    S32 group_index = 0;
    mmi_ucm_call_type_enum call_type = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("[mmi_ucm_dtmf_key_down]");
    
    GetkeyInfo(&keyCode, &keyType);

    if (mmi_ucm_is_allow_dtmf())
    {
        memset(&start_dtmf, 0, sizeof(mmi_ucm_dtmf_struct));
        start_dtmf.digit = keyCode;

        /* get current active call type */
        group_index = mmi_ucm_get_group_index_by_call_state_and_type(MMI_UCM_ACTIVE_STATE, MMI_UCM_CALL_TYPE_NO_CSD);
        
        if (group_index != -1)
        {
            call_type = g_ucm_p->call_list.group_info[group_index].call_type;
        }
        else if ((mmi_ucm_get_outgoing_group(MMI_UCM_VOICE_CALL_TYPE, g_ucm_p->call_misc.index_list) != 0) &&
                 (g_ucm_p->call_misc.is_speech == MMI_TRUE))
        {
            call_type = MMI_UCM_VOICE_CALL_TYPE;
        }
#ifdef __MMI_DUAL_SIM_MASTER__
        else if ((mmi_ucm_get_outgoing_group(MMI_UCM_VOICE_CALL_TYPE_SIM2, g_ucm_p->call_misc.index_list) != 0) &&
                 (g_ucm_p->call_misc.is_speech == MMI_TRUE))
        {
            call_type = MMI_UCM_VOICE_CALL_TYPE_SIM2;
        }
#endif /* __MMI_DUAL_SIM_MASTER__ */
        if (call_type)
        {
            if (g_ucm_p->call_misc.is_mute == MMI_FALSE)
            {
                MuteOnMicrophone();
            }

            PRINT_INFORMATION("[mmi_ucm_dtmf_key_down] Send_Start_DTMF, call_type: %d", call_type);
            
            /* call start dtmf API */    
            mmi_ucm_send_req(MMI_UCM_START_DTMF, call_type, (void *)&start_dtmf);
        }
    }
  
    wgui_execute_key_handler(keyCode, keyType);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_dtmf_key_up
 * DESCRIPTION
 *  Stop sending DTMF sound to remote side.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_dtmf_key_up(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 keycode, keytype;
    mmi_ucm_dtmf_struct stop_dtmf;
    S32 group_index = 0;
    mmi_ucm_call_type_enum call_type = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    

    memset(&stop_dtmf, 0, sizeof(mmi_ucm_dtmf_struct));

    PRINT_INFORMATION("[mmi_ucm_dtmf_key_up]");
    GetkeyInfo(&keycode, &keytype);

    if (mmi_ucm_is_allow_dtmf())
    {
        stop_dtmf.digit = keycode;

        /* get current active call type */
        group_index = mmi_ucm_get_group_index_by_call_state_and_type(MMI_UCM_ACTIVE_STATE, MMI_UCM_CALL_TYPE_NO_CSD);
        
        if (group_index != -1)
        {
            call_type = g_ucm_p->call_list.group_info[group_index].call_type;
        }
        else if ((mmi_ucm_get_outgoing_group(MMI_UCM_VOICE_CALL_TYPE, g_ucm_p->call_misc.index_list) != 0) &&
                 (g_ucm_p->call_misc.is_speech == MMI_TRUE))
        {
            call_type = MMI_UCM_VOICE_CALL_TYPE;
        }
#ifdef __MMI_DUAL_SIM_MASTER__
        else if ((mmi_ucm_get_outgoing_group(MMI_UCM_VOICE_CALL_TYPE_SIM2, g_ucm_p->call_misc.index_list) != 0) &&
                 (g_ucm_p->call_misc.is_speech == MMI_TRUE))
        {
            call_type = MMI_UCM_VOICE_CALL_TYPE_SIM2;
        }
#endif /* __MMI_DUAL_SIM_MASTER__ */
        
        if (call_type)
        {
            PRINT_INFORMATION("[mmi_ucm_dtmf_key_down] Send_Stop_DTMF, call_type: %d", call_type);

            mmi_ucm_send_req(MMI_UCM_STOP_DTMF, call_type, (void *)&stop_dtmf);
        }
                    
        if (g_ucm_p->call_misc.is_mute == MMI_FALSE)
        {
            MuteOffMicrophone();
        }

    }

    wgui_execute_key_handler(keycode, keytype);
    mmi_ucm_in_call_ssc_parse();    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_save_phonebook
 * DESCRIPTION
 *  Entry function of saving number to Phonebook
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_save_phonebook(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* save dtmf digits to phonebook in call */
    if (GetExitScrnID() == SCR_ID_UCM_DTMF_EDITOR)
    {
        SaveNumberFromIdleScrn((S8*)g_ucm_p->call_misc.disp_dtmf, 0);
    }
#if defined (__MMI_VOIP__)    
    /* save uri address to phonebook in call */
    else if (IsScreenPresent(SCR_ID_UCM_VOIP_DIALER))
    {
        mmi_phb_save_entry_for_service_field(NULL, (S8*)g_ucm_p->mo_info.dial_pad_buffer, MMI_PHB_ENTER_FROM_VOIP);        
    }
#endif /* __MMI_VOIP__ */
    else
    {
        SaveNumberFromIdleScrn((S8*)g_ucm_p->mo_info.dial_pad_buffer, 0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_set_loud_speaker
 * DESCRIPTION
 *  Turn on and turn off loud speaker in call.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_set_loud_speaker(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ucm_p->call_misc.is_loud == TRUE)
    {
        g_ucm_p->call_misc.is_loud = FALSE;
        if (GetExitScrnID() == SCR_ID_UCM_IN_CALL)
        {
            ChangeRightSoftkey(STR_ID_UCM_HAND_FREE, 0);
        }
        DisbleHandsFree();
        SetLoudSpeaker(FALSE);
        DisplayPopup(
            (U8*)GetString(STR_ID_UCM_LOUD_SPEAKER_OFF),
            IMG_GLOBAL_ACTIVATED,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            0);
    }
    else
    {
        g_ucm_p->call_misc.is_loud = TRUE;
        if (GetExitScrnID() == SCR_ID_UCM_IN_CALL)
        {
            ChangeRightSoftkey(STR_ID_UCM_HAND_HELD, 0);
        }
        EnableHandsFree();
        SetLoudSpeaker(TRUE);
        DisplayPopup(
            (U8*)GetString(STR_ID_UCM_LOUD_SPEAKER_ON),
            IMG_GLOBAL_ACTIVATED,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_in_call
 * DESCRIPTION
 *  Entry function of in call screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_in_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 call_icon[MMI_UCM_MAX_NUM_INDEX];
    U8 *gui_buffer = NULL;
    U8* title = NULL;
    U16 rsk_str = 0, num_items = 0;
    U16 lsk_str = 0;
    U16 lsk_icon = 0;
    S32 curr_hilite_tab = 0, i = 0, j = 0;
    MYTIME curr_time, duration;
    U8 num_group = g_ucm_p->call_list.num_group;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
    
    EntryNewScreen(SCR_ID_UCM_IN_CALL, mmi_ucm_exit_in_call, mmi_ucm_entry_in_call, NULL);
    DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL); /* ensure no two active call screens in the history */
    PRINT_INFORMATION("\n[mmi_ucm_entry_in_call] in-call Screen\n");
    gui_buffer = GetCurrGuiBuffer(SCR_ID_UCM_IN_CALL);
    if (mmi_ucm_loud_option())
    {
        rsk_str = (g_ucm_p->call_misc.is_loud == TRUE) ? (STR_ID_UCM_HAND_HELD) : (STR_ID_UCM_HAND_FREE);
    }

    /* number of group */
    for (i = 0; i < g_ucm_p->call_list.num_group; i++)
    {
        if (g_ucm_p->call_list.group_info[i].call_type & MMI_UCM_CALL_TYPE_WO_INCALL_SCR)
        {
            PRINT_INFORMATION("\n[mmi_ucm_entry_in_call] Call type NOT displayed in in-call screen \n");
            num_group--;
            
        }
    }

    /* icon and text of each tab */
    for (i = 0, j = 0; i < g_ucm_p->call_list.num_group; i++)
    {
        if (g_ucm_p->call_list.group_info[i].call_type & MMI_UCM_CALL_TYPE_WO_INCALL_SCR)
        {
            /* skip this group */
        }
        else
        {           
            if (g_ucm_p->call_list.group_info[i].call_state == MMI_UCM_ACTIVE_STATE)
            {
                MMI_tab_bar_items[j].icon = get_image(IMG_ID_UCM_CALL_STATE_ACTIVE);
            }
            else if (g_ucm_p->call_list.group_info[i].call_state == MMI_UCM_HOLD_STATE)
            {
                MMI_tab_bar_items[j].icon = get_image(IMG_ID_UCM_CALL_STATE_HOLD);            
            }
            else
            {
                PRINT_INFORMATION("\n[mmi_ucm_entry_in_call] Call State should either MMI_UCM_ACTIVE_STATE or MMI_UCM_HOLD_STATE\n");
            }            

            MMI_tab_bar_items[j].text = NULL;        
            MMI_tab_bar_items[j].flags = 0; /* no blink */

            j++;
        }
    }
    
    curr_hilite_tab = g_ucm_p->call_misc.hilite_tab;

    if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_type == MMI_UCM_VOICE_CALL_TYPE)
    {
        if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_state == MMI_UCM_ACTIVE_STATE)
        {
        #ifdef __MMI_DUAL_SIM_MASTER__
            title = (U8*)GetString(STR_ID_UCM_SIM1_VOICE_ACTIVE);
        #else /* __MMI_DUAL_SIM_MASTER__ */
            title = (U8*)GetString(STR_ID_UCM_VOICE_ACTIVE);
        #endif /* __MMI_DUAL_SIM_MASTER__ */
        }
        else if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_state == MMI_UCM_HOLD_STATE)
        {
        #ifdef __MMI_DUAL_SIM_MASTER__
            title = (U8*)GetString(STR_ID_UCM_SIM1_VOICE_HOLD);
        #else /* __MMI_DUAL_SIM_MASTER__ */
            title = (U8*)GetString(STR_ID_UCM_VOICE_HOLD);
        #endif /* __MMI_DUAL_SIM_MASTER__ */            
        }
        else
        {
            MMI_ASSERT(0); /* call state either active or hold */
        }
    }
#ifdef __MMI_DUAL_SIM_MASTER__
    else if(g_ucm_p->call_list.group_info[curr_hilite_tab].call_type == MMI_UCM_VOICE_CALL_TYPE_SIM2)
    {
	if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_state == MMI_UCM_ACTIVE_STATE)
        {
            title = (U8*)GetString(STRING_MTPNP_ID_UCM_VOICE_ACTIVE);
        }
        else if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_state == MMI_UCM_HOLD_STATE)
        {
            title = (U8*)GetString(STRING_MTPNP_ID_UCM_VOICE_HOLD);
        }
        else
        {
            MMI_ASSERT(0); /* call state either active or hold */
        }
    }
#endif /* __MMI_DUAL_SIM_MASTER__ */
    else if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_type == MMI_UCM_VOIP_CALL_TYPE)
    {
        
        if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_state == MMI_UCM_ACTIVE_STATE)
        {
            title = (U8*)GetString(STR_ID_UCM_VOIP_ACTIVE);
        }
        else if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_state == MMI_UCM_HOLD_STATE)
        {
            title = (U8*)GetString(STR_ID_UCM_VOIP_HOLD);
        }
        else
        {
            MMI_ASSERT(0); /* call state either active or hold */
        }
        
    }
    else if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_type & MMI_UCM_DATA_CALL_TYPE_ALL)
    {
        
        if (g_ucm_p->call_list.group_info[curr_hilite_tab].call_state == MMI_UCM_ACTIVE_STATE)
        {
            title = (U8*)GetString(STR_ID_UCM_ACTIVE);
        }
        else
        {
            
            MMI_ASSERT(0); /* Data call state should be only active */
        }        
    }
    else
    {
        MMI_ASSERT(0);
    }

    /* Normally the start time should be determined at accept_rsp and conn_ind.
       However, for the race condition cases, GSM protocol would hold and retrieve the calls in hold operation 
       so that for UCM, the MT call is accepted without answer action. */
    mmi_ucm_validate_start_time();
    
    DTGetRTCTime(&curr_time);

    /* duration of current tab */
    num_items = g_ucm_p->call_list.group_info[curr_hilite_tab].num_call;
    
    applib_get_time_difference_ext(
        (applib_time_struct*)&curr_time, 
        (applib_time_struct*)&g_ucm_p->call_list.group_info[curr_hilite_tab].call_info[0].start_time, 
        (applib_time_struct*)&duration);

    /* display name and icon of each items of current tab */        
    for (i = 0; i < num_items; i++)
    {
        U32 char_num = ((MAX_SUB_MENU_SIZE / ENCODING_LENGTH) < MMI_UCM_MAX_DISP_NAME_LEN)?
                        (MAX_SUB_MENU_SIZE / ENCODING_LENGTH): MMI_UCM_MAX_DISP_NAME_LEN;
            
        subMenuDataPtrs[i] = subMenuData[i];
        memset((S8*)subMenuDataPtrs[i], 0, MAX_SUB_MENU_SIZE);
        mmi_ucs2ncpy(
            (S8*)subMenuDataPtrs[i],
            (S8*)g_ucm_p->call_list.group_info[curr_hilite_tab].call_info[i].remote_info.disp_name,
            char_num);

        call_icon[i] = g_ucm_p->call_list.group_info[curr_hilite_tab].call_info[i].remote_info.active_icon;

        if (call_icon[i] == 0)
        {
            call_icon[i] = IMG_ID_UCM_ACTIVE_CALL;
        }
    }
    
#if ((defined __MMI_WGUI_CSK_ENABLE__) && (defined __MMI_TOUCH_SCREEN__))
    EnableCenterSoftkey(0, IMG_CSK_DIAL_ICON);
#endif

    if (mmi_ucm_in_call_show_option())
    {
        lsk_str = STR_GLOBAL_OPTIONS;
        lsk_icon = IMG_GLOBAL_OPTIONS;
    }

    RegisterHighlightHandler(mmi_ucm_highlight_in_call_item);

    ForceSubLCDScreen(mmi_ucm_entry_in_call_sublcd);

    ShowCategory403Screen(
        title,
        0,
        lsk_str,
        lsk_icon,
        rsk_str,
        0,
        (S8)num_group,
        (S8)g_ucm_p->call_misc.hilite_tab,
        MMI_tab_bar_items,
        &duration,
        0,
        subMenuDataPtrs,
        call_icon,
        num_items,
        (U16)g_ucm_p->call_misc.hilite_index,
        gui_buffer);
    
    SetCategory403TabSelectCallback(mmi_ucm_tab_jump);
    SetKeyHandler(mmi_ucm_tab_prev, KEY_LEFT_ARROW, KEY_EVENT_DOWN);   /* move to previous tab */
    SetKeyHandler(mmi_ucm_tab_next, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);  /* move to next tab */

    if (mmi_ucm_in_call_show_option())
    {
        SetLeftSoftkeyFunction(mmi_ucm_entry_incall_option, KEY_EVENT_UP);
    }

    if (mmi_ucm_loud_option())
    {
        SetRightSoftkeyFunction(mmi_ucm_set_loud_speaker, KEY_EVENT_UP);
    }

#if ((defined __MMI_WGUI_CSK_ENABLE__) && (defined __MMI_TOUCH_SCREEN__))
    SetCenterSoftkeyFunction(mmi_ucm_pre_entry_dtmf_editor, KEY_EVENT_UP);
#endif 

    SetGroupKeyHandler(mmi_ucm_pre_send_dtmf, (U16*)mmi_ucm_idle_screen_digits, MMI_UCM_SCREEN_DIGITS - 1, KEY_EVENT_DOWN);
    
    SetKeyHandler(mmi_ucm_in_call_sendkey, KEY_SEND, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_in_call_endkey, KEY_END, KEY_EVENT_DOWN);

    /* must set KEY_EVENT_DOWN function to overwrite original side key handler of category 52 */
    if ((g_ucm_p->call_list.group_info[curr_hilite_tab].call_type & MMI_UCM_DATA_CALL_TYPE_ALL) == 0)
    {

#ifdef __MMI_NO_VOL_KEYS__ 
	//Huyanwei Modify It 
        SetKeyHandler(mmi_ucm_set_sidekey, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_ucm_set_sidekey, KEY_DOWN_ARROW, KEY_EVENT_DOWN);         
#else
        SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_DOWN, KEY_EVENT_DOWN);       
#endif	
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_in_call
 * DESCRIPTION
 *  Exit function of in call screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_in_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if ((defined __MMI_WGUI_CSK_ENABLE__) && (defined __MMI_TOUCH_SCREEN__))
    ResetCenterSoftkey();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_in_call_sublcd
 * DESCRIPTION
 *  Entry screen for Sub Lcd Active Call
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_in_call_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecSubLCDCurrExitHandler();

    ShowCategory304Screen(IMG_ID_UCM_CONNECTED, NULL);
    SetSubLCDExitHandler(mmi_ucm_exit_in_call_sublcd);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_in_call_sublcd
 * DESCRIPTION
 *  Exit Handler for Sub Lcd Active Call Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_in_call_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!IsSubLCDScreenPresent(SCR_ID_UCM_IN_CALL_SUBLCD))
    {
        SubLCDHistoryNode SubLCDHistory;

        SubLCDHistory.entryFuncPtr = mmi_ucm_entry_in_call_sublcd;
        AddSubLCDHistoryWithScrID(&SubLCDHistory, SCR_ID_UCM_IN_CALL_SUBLCD);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_in_call_item
 * DESCRIPTION
 *  Highlight index in the active call screen.
 * PARAMETERS
 *  index       [IN]        Current highlight index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_in_call_item(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ucm_p->call_misc.hilite_index = index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_tab_jump
 * DESCRIPTION
 *  Jump to tab based on index for Category403.
 * PARAMETERS
 *  index       [IN]        Current highlight tab
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_tab_jump(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ucm_p->call_misc.hilite_tab = index;

    while (g_ucm_p->call_list.group_info[g_ucm_p->call_misc.hilite_tab].call_type & MMI_UCM_CALL_TYPE_WO_INCALL_SCR)
    {
        PRINT_INFORMATION("\n[mmi_ucm_tab_jump] Skip one call group \n");
        if (g_ucm_p->call_misc.hilite_tab == g_ucm_p->call_list.num_group - 1)
        {
            g_ucm_p->call_misc.hilite_tab = 0;
        }
        else
        {
            g_ucm_p->call_misc.hilite_tab++;
        }        
    }
    
    g_ucm_p->call_misc.hilite_index = 0;
    mmi_ucm_entry_in_call();
    DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_tab_prev
 * DESCRIPTION
 *  Move to previous tab for Category403.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_tab_prev(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ucm_p->call_misc.hilite_tab == 0)
    {
        g_ucm_p->call_misc.hilite_tab = g_ucm_p->call_list.num_group - 1;
    }
    else
    {
        g_ucm_p->call_misc.hilite_tab--;
    }

    while (g_ucm_p->call_list.group_info[g_ucm_p->call_misc.hilite_tab].call_type & MMI_UCM_CALL_TYPE_WO_INCALL_SCR)
    {
        PRINT_INFORMATION("\n[mmi_ucm_tab_prev] Skip one call group \n");        
        if (g_ucm_p->call_misc.hilite_tab == 0)
        {
            g_ucm_p->call_misc.hilite_tab = g_ucm_p->call_list.num_group - 1;
        }
        else
        {
            g_ucm_p->call_misc.hilite_tab--;
        }
    }
    
    g_ucm_p->call_misc.hilite_index = 0;
    mmi_ucm_entry_in_call();
    DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_tab_next
 * DESCRIPTION
 *  Move to next tab for Category403.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_tab_next(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ucm_p->call_misc.hilite_tab == g_ucm_p->call_list.num_group - 1)
    {
        g_ucm_p->call_misc.hilite_tab = 0;
    }
    else
    {
        g_ucm_p->call_misc.hilite_tab++;
    }

    while (g_ucm_p->call_list.group_info[g_ucm_p->call_misc.hilite_tab].call_type & MMI_UCM_CALL_TYPE_WO_INCALL_SCR)
    {
        PRINT_INFORMATION("\n[mmi_ucm_tab_next] Skip one call group \n");
        if (g_ucm_p->call_misc.hilite_tab == g_ucm_p->call_list.num_group - 1)
        {
            g_ucm_p->call_misc.hilite_tab = 0;
        }
        else
        {
            g_ucm_p->call_misc.hilite_tab++;
        }
    }

    g_ucm_p->call_misc.hilite_index = 0;
    mmi_ucm_entry_in_call();
    DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_tab_highlight
 * DESCRIPTION
 *  Adjust highlight tab for Category403.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_tab_highlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 callId = 0;
    S32 init_tab_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    callId = mmi_ucm_get_group_index_by_call_state_and_type(MMI_UCM_ACTIVE_STATE, MMI_UCM_CALL_TYPE_NO_CSD);        
    
    /* active call exists, highlight on active call */
    if (callId != -1)
    {
        g_ucm_p->call_misc.hilite_tab = callId;
        g_ucm_p->call_misc.hilite_index = 0;
    }
    /* no active call, highlight on original call */
    else
    {
        /* original call doesn't exist, highlight on last call */
        if (g_ucm_p->call_misc.hilite_tab > g_ucm_p->call_list.num_group - 1)
        {
            g_ucm_p->call_misc.hilite_tab = g_ucm_p->call_list.num_group - 1;
            g_ucm_p->call_misc.hilite_index = 0;
        }
        else
        {
            g_ucm_p->call_misc.hilite_tab = 0;
            g_ucm_p->call_misc.hilite_index = 0;
        }
    }

    init_tab_id = g_ucm_p->call_misc.hilite_tab;
    
    while (g_ucm_p->call_list.group_info[g_ucm_p->call_misc.hilite_tab].call_type & MMI_UCM_CALL_TYPE_WO_INCALL_SCR)
    {
        PRINT_INFORMATION("\n[mmi_ucm_tab_highlight] Skip one call group \n");
        if (g_ucm_p->call_misc.hilite_tab == g_ucm_p->call_list.num_group - 1)
        {
            g_ucm_p->call_misc.hilite_tab = 0;
        }
        else
        {
            g_ucm_p->call_misc.hilite_tab++;
        }

        /* no call needs incall screen */
        if (init_tab_id == g_ucm_p->call_misc.hilite_tab)
        {
            PRINT_INFORMATION("\n[mmi_ucm_tab_highlight] No call needs incall screen \n");
            break;
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_set_sidekey
 * DESCRIPTION
 *  Handle side key for UCM call screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_set_sidekey(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_NO_VOL_KEYS__ 
	//sc.wu __MMI_NO_VOL_KEYS__
	//Huyanwei Modify it .Have Side Key 
        SetKeyHandler(SetKeyPadVolUp, KEY_UP_ARROW, KEY_EVENT_UP);
        SetKeyHandler(MMI_dummy_function, KEY_UP_ARROW, KEY_EVENT_LONG_PRESS);
        SetKeyHandler(MMI_dummy_function, KEY_UP_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(SetKeyPadVolDown, KEY_DOWN_ARROW, KEY_EVENT_UP);
        SetKeyHandler(MMI_dummy_function, KEY_DOWN_ARROW, KEY_EVENT_LONG_PRESS);
        SetKeyHandler(MMI_dummy_function, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);  
#else
        SetKeyHandler(SetKeyPadVolUp, KEY_VOL_UP, KEY_EVENT_UP);
        SetKeyHandler(MMI_dummy_function, KEY_VOL_UP, KEY_EVENT_LONG_PRESS);
        SetKeyHandler(MMI_dummy_function, KEY_VOL_UP, KEY_EVENT_REPEAT);
        SetKeyHandler(SetKeyPadVolDown, KEY_VOL_DOWN, KEY_EVENT_UP);
        SetKeyHandler(MMI_dummy_function, KEY_VOL_DOWN, KEY_EVENT_LONG_PRESS);
        SetKeyHandler(MMI_dummy_function, KEY_VOL_UP, KEY_EVENT_REPEAT);
#endif	


#ifdef __MMI_SOUND_RECORDER__
if (mmi_ucm_app_active_call(MMI_UCM_CALL_TYPE_ALL) > 0)
{
#ifdef __CTM_SUPPORT__
    /*if (ctm_p->status == FALSE)*/ // TODO: CTM support
#endif /* __CTM_SUPPORT__ */ 
    {
        SetKeyHandler(mmi_sndrec_entry_from_call, KEY_VOL_UP, KEY_LONG_PRESS);
    }    
}
#endif /* __MMI_SOUND_RECORDER__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_multi_held_call_item
 * DESCRIPTION
 *  Highlight index in the mutliple held calls screen.
 * PARAMETERS
 *  index       [IN]        Current highlight index.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_multi_held_call_item(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ucm_p->call_misc.hilite_multi_held_index = index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_held_call_selected
 * DESCRIPTION
 *  Select the specific held call and get ready to process swap or conference action.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_held_call_selected(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 groupIndex = 0, hiliteTab = g_ucm_p->call_misc.hilite_tab;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (g_ucm_p->proc_scr.title_string == STR_ID_UCM_SWAP)
    {
        g_ucm_p->call_misc.curr_action = MMI_UCM_SWAP;
        mmi_ucm_reset_index_list();
        
        mmi_ucm_get_held_group(MMI_UCM_CALL_TYPE_ALL, FALSE, g_ucm_p->call_misc.index_list);
        groupIndex = g_ucm_p->call_misc.index_list[g_ucm_p->call_misc.hilite_multi_held_index].group_index;
        
        mmi_ucm_swap_action_with_index(hiliteTab, groupIndex); 
    }
    else if (g_ucm_p->proc_scr.title_string == STR_ID_UCM_CONFERENCE)
    {
        g_ucm_p->call_misc.curr_action = MMI_UCM_CONFERENCE;
        
        mmi_ucm_reset_index_list();
        mmi_ucm_get_held_group(MMI_UCM_VOIP_CALL_TYPE, TRUE, g_ucm_p->call_misc.index_list);
        
        groupIndex = g_ucm_p->call_misc.index_list[g_ucm_p->call_misc.hilite_multi_held_index].group_index;

        mmi_ucm_conference_action_with_index(hiliteTab, groupIndex);
    }
    else
    {
        MMI_ASSERT(0);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_multi_held_call
 * DESCRIPTION
 *  Entry function of call option\Swap or Conference
 *  if more than one held calls can be selected.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_multi_held_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    S32 i = 0, held_group = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
    
    EntryNewScreen(SCR_ID_UCM_MULTI_HELD_CALL, NULL, mmi_ucm_entry_multi_held_call, NULL);
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_MULTI_HELD_CALL);

    mmi_ucm_reset_index_list();

    if (g_ucm_p->proc_scr.title_string == STR_ID_UCM_SWAP)
    {
        held_group = mmi_ucm_get_held_group(MMI_UCM_CALL_TYPE_ALL, FALSE, g_ucm_p->call_misc.index_list);
    }
    else if (g_ucm_p->proc_scr.title_string == STR_ID_UCM_CONFERENCE)
    {
        held_group = mmi_ucm_get_held_group(MMI_UCM_VOIP_CALL_TYPE, TRUE, g_ucm_p->call_misc.index_list);
    }
    else
    {
        MMI_ASSERT(0);
    }

    for (i = 0; i < held_group; i++)
    {
        U32 char_num = ((MAX_SUB_MENU_SIZE / ENCODING_LENGTH) < MMI_UCM_MAX_DISP_NAME_LEN)?
                        (MAX_SUB_MENU_SIZE / ENCODING_LENGTH): MMI_UCM_MAX_DISP_NAME_LEN;
            
        subMenuDataPtrs[i] = subMenuData[i];
        memset(subMenuDataPtrs[i], 0, MAX_SUB_MENU_SIZE);
        mmi_ucs2ncpy(
            (S8*)subMenuDataPtrs[i],
            (S8*)g_ucm_p->call_list.group_info[g_ucm_p->call_misc.index_list[i].group_index].call_info[0].remote_info.disp_name,
            char_num);
    } 
    
    RegisterHighlightHandler(mmi_ucm_highlight_multi_held_call_item);
    ShowCategory6Screen(
        STR_GLOBAL_OPTIONS,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        held_group,
        subMenuDataPtrs,
        NULL,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(mmi_ucm_entry_held_call_selected, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    SetKeyHandler(mmi_ucm_in_call_endkey, KEY_END, KEY_EVENT_DOWN);

    /* must set KEY_EVENT_DOWN function to overwrite original side key handler of category 52 */
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_DOWN, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_call_end
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_call_end(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 MessageString[MMI_UCM_END_TEXT_LEN];
    U8 newline[4] = { '\n', '\0', '\0', '\0' }; /* \n */
    S8 TimeString[32];
    S32 str_len = 0;
    U16 img_id = 0;
    U16 tone_id = 0;
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("\n[mmi_ucm_entry_call_end] Call End Screen\n");

    EntryNewScreen(SCR_ID_UCM_CALL_END, mmi_ucm_exit_call_end, NULL, NULL);

    img_id = g_ucm_p->call_end.image_id;
    tone_id = g_ucm_p->call_end.tone_id;

    mmi_ucs2ncpy((S8*)MessageString, (S8*) g_ucm_p->call_end.disp_msg, MMI_UCM_END_TEXT_LEN);
    str_len = mmi_ucs2strlen((S8*)MessageString);

    if ((MMI_UCM_END_TEXT_LEN - str_len) > mmi_ucs2strlen((S8*)newline))
    {
        mmi_ucs2ncat((S8*) MessageString, (S8*)newline, (MMI_UCM_END_TEXT_LEN - str_len));
    }
    str_len = mmi_ucs2strlen((S8*)MessageString);
    
	if (tone_id == TONE_BUSY_CALL_GSM)
	{
		AudioPlayReq(TONE_BUSY_CALL_GSM, DEVICE_AUDIO_PLAY_INFINITE);
	}
	else if (tone_id != 0)
	{
      	playRequestedTone(tone_id);
	}
    
    if ((g_ucm_p->call_end.call_duration.nDay + 
        g_ucm_p->call_end.call_duration.nHour +  
        g_ucm_p->call_end.call_duration.nMin + 
        g_ucm_p->call_end.call_duration.nSec) != 0)
    {
        duration_string(
            (UI_time*) & g_ucm_p->call_end.call_duration,
            (UI_string_type) TimeString,
            DT_ACTIVE_CALL_SCREEN);

        if ((MMI_UCM_END_TEXT_LEN - str_len) > mmi_ucs2strlen((S8*)TimeString))
        {
            mmi_ucs2ncat((S8*) MessageString, (S8*)TimeString, (MMI_UCM_END_TEXT_LEN - str_len));
        }
    }

    ShowCategory63Screen((U8*) MessageString, img_id, NULL);

    TurnOnBacklight(1);

    ClearInputEventHandler(MMI_DEVICE_ALL);

    SetKeyHandler(GoBackHistory, KEY_END, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_END, KEY_EVENT_UP);
    ClearKeyHandler(KEY_END, KEY_LONG_PRESS);
    ClearKeyHandler(KEY_END, KEY_REPEAT);

    StartTimer(UCM_NOTIFY_DURATION_TIMER, MMI_UCM_NOTIFY_TIMEOUT, mmi_ucm_call_end_timeout_handler);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_exit_call_end
 * DESCRIPTION
 *  This just stops timer which was started in the entry function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_exit_call_end(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    StopTimer(UCM_NOTIFY_DURATION_TIMER);

    if (g_ucm_p->call_end.tone_id == TONE_BUSY_CALL_GSM)
    {
        AudioStopReq(TONE_BUSY_CALL_GSM);
    }
    else if (g_ucm_p->call_end.tone_id > 0)
    {
        stopRequestedTone(g_ucm_p->call_end.tone_id);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_call_end_timeout_handler
 * DESCRIPTION
 *  ucm call end timeout handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_call_end_timeout_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StopTimer(UCM_NOTIFY_DURATION_TIMER);

    if (GetExitScrnID() == SCR_ID_UCM_CALL_END)
    {
        GoBackHistory();
    }
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_newcall_opt_voip
 * DESCRIPTION
 *  Funtion is called when voip menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_newcall_opt_voip(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ucm_entry_voip_dialer_screen, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_entry_voip_dialer_screen, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_newcall_opt_voice
 * DESCRIPTION
 *  Funtion is called when voice call menu item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_newcall_opt_voice(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ucm_entry_voice_dialer_screen, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_entry_voice_dialer_screen, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}
    
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_new_call_opt
 * DESCRIPTION
 *  Shows the new call option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_new_call_opt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 numItems = 0;
    U16 nStrItemList[MAX_SUB_MENUS];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    EntryNewScreen(SCR_ID_UCM_NEW_CALL_OPTION, NULL, mmi_ucm_entry_new_call_opt, NULL);
    PRINT_INFORMATION("\n[mmi_ucm_entry_new_call_opt] New Call Option Screen\n");
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_NEW_CALL_OPTION);

    numItems = GetNumOfChild_Ext(MENU_ID_UCM_INCALL_OPTION_NEW_CALL);
    GetSequenceStringIds_Ext(MENU_ID_UCM_INCALL_OPTION_NEW_CALL, nStrItemList);    
    SetParentHandler(MENU_ID_UCM_INCALL_OPTION_NEW_CALL);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory52Screen(
        STR_GLOBAL_OPTIONS,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        numItems,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        NULL,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_voip_dialer_screen
 * DESCRIPTION
 *  voip dialer screen entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_voip_dialer_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_VOIP_DIALER, NULL, mmi_ucm_entry_voip_dialer_screen, NULL);
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_VOIP_DIALER);

#if (defined (__MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__))
    EnableCenterSoftkey(0, IMG_CSK_DIAL_ICON);
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)) */ 

    ShowCategory404Screen(
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        IMG_ID_VOIP_CALL_EDITOR,
        g_ucm_p->mo_info.dial_pad_buffer,
        MMI_UCM_MAX_NUM_URI_LEN,
        guiBuffer);

    SetLeftSoftkeyFunction(mmi_ucm_entry_dialer_option, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
    SetKeyHandler(mmi_ucm_make_voip_call_from_incall_dialer, KEY_SEND, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_in_call_endkey, KEY_END, KEY_EVENT_DOWN);

#if (defined (__MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__))
    SetCenterSoftkeyFunction(mmi_ucm_make_voip_call_from_incall_dialer, KEY_EVENT_UP);
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)) */ 

    /* must set KEY_EVENT_DOWN function to overwrite original side key handler of category 52 */
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_DOWN, KEY_EVENT_DOWN);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_voice_dialer_screen
 * DESCRIPTION
 *  voice dialer screen entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_voice_dialer_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U8 *inputStr = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_VOICE_DIALER, NULL, mmi_ucm_entry_voice_dialer_screen, NULL);    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_VOICE_DIALER);
    inputStr = GetCurrInputBuffer(SCR_ID_UCM_VOICE_DIALER);

#if ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) )
#if defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)
    SetDialingKeypadCallHandler(mmi_ucm_make_voice_call_from_incall_dialer);

    if (mmi_ucm_in_call_show_option())
    {
        SetDialingKeypadPhonebookHandler(mmi_phb_list_enter_first_from_active_call);
    }
    else
    {
        SetDialingKeypadPhonebookHandler(NULL);
    }
#else /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
    EnableCenterSoftkey(0, IMG_CSK_DIAL_ICON);
#endif /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) ) */

    ShowCategory16Screen(
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        g_ucm_p->mo_info.dial_pad_buffer,
        (MMI_UCM_DTMF_LEN + 1),
        guiBuffer);
    
    SetLeftSoftkeyFunction(mmi_ucm_entry_dialer_option, KEY_EVENT_UP);
    SetCategory16RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP); 

    
#ifdef __MMI_DUAL_SIM_MASTER__
    MTPNP_PFAL_CC_HandleSendKeys(mmi_ucm_make_voice_call_from_incall_dialer,KEY_EVENT_DOWN);
#else /* __MMI_DUAL_SIM_MASTER__ */
    SetKeyHandler(mmi_ucm_make_voice_call_from_incall_dialer, KEY_SEND, KEY_EVENT_DOWN);
#endif /* __MMI_DUAL_SIM_MASTER__ */ 
    SetKeyHandler(mmi_ucm_in_call_endkey, KEY_END, KEY_EVENT_DOWN);

#if (defined (__MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__))
#ifdef __MMI_DUAL_SIM_MASTER__
     MTPNP_PFAL_CC_SetCenterFunc(mmi_ucm_make_voice_call_from_incall_dialer);
     SetCenterSoftkeyFunction(MTPNP_PFAL_CC_CSKHandler, KEY_EVENT_UP);
#else  /* __MMI_DUAL_SIM_MASTER__ */
    SetCenterSoftkeyFunction(mmi_ucm_make_voice_call_from_incall_dialer, KEY_EVENT_UP);
#endif  /* __MMI_DUAL_SIM_MASTER__ */
#endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)) */ 

    /* must set KEY_EVENT_DOWN function to overwrite original side key handler of category 52 */
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_DOWN, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_dialer_option
 * DESCRIPTION
 *  Shows the new call dialer option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_dialer_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 numItems = 0;
    U16 nStrItemList[MAX_SUB_MENUS];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    EntryNewScreen(SCR_ID_UCM_NEW_CALL_DIALER_OPTION, NULL, mmi_ucm_entry_dialer_option, NULL);
    PRINT_INFORMATION("\n[mmi_ucm_entry_dialer_option] Dialer Option Screen\n");
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_NEW_CALL_DIALER_OPTION);
    
#ifdef __MMI_DUAL_SIM_MASTER__
    if(MTPNP_AD_SIMCARD1_USABLE == MTPNP_AD_Get_UsableSide())
    {
    	mmi_frm_unhide_menu_item(MENU_ID_UCM_NEW_CALL_OPTION_DIAL);
    	mmi_frm_hide_menu_item(MENU_ID_UCM_NEW_CALL_OPTION_DIAL_SIM2);
    }
    else if(MTPNP_AD_SIMCARD2_USABLE == MTPNP_AD_Get_UsableSide())
    {
    	mmi_frm_hide_menu_item(MENU_ID_UCM_NEW_CALL_OPTION_DIAL);
    	mmi_frm_unhide_menu_item(MENU_ID_UCM_NEW_CALL_OPTION_DIAL_SIM2);
    }
    else
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_NEW_CALL_OPTION_DIAL);
    	mmi_frm_unhide_menu_item(MENU_ID_UCM_NEW_CALL_OPTION_DIAL_SIM2);
    }
#endif /* __MMI_DUAL_SIM_MASTER__ */

    numItems = GetNumOfChild_Ext(MENU_ID_UCM_NEW_CALL_OPTION);
    GetSequenceStringIds_Ext(MENU_ID_UCM_NEW_CALL_OPTION, nStrItemList);    
    SetParentHandler(MENU_ID_UCM_NEW_CALL_OPTION);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory52Screen(
        STR_GLOBAL_OPTIONS,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        numItems,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        NULL,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_newcall_opt_dial
 * DESCRIPTION
 *  Funtion is called when dial item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_newcall_opt_dial(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (IsScreenPresent(SCR_ID_UCM_VOIP_DIALER))
    {
        SetLeftSoftkeyFunction(mmi_ucm_make_voip_call_from_incall_dialer, KEY_EVENT_UP);
        SetKeyHandler(mmi_ucm_make_voip_call_from_incall_dialer, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    }
    else
    {
    #ifdef __MMI_DUAL_SIM_MASTER__
    	 MTPNP_AD_Set_Channel(MTPNP_AD_CALL_CHANNEL,MTPNP_AD_CHANNEL_MASTER);
    #endif /* __MMI_DUAL_SIM_MASTER__ */
        SetLeftSoftkeyFunction(mmi_ucm_make_voice_call_from_incall_dialer, KEY_EVENT_UP);
        SetKeyHandler(mmi_ucm_make_voice_call_from_incall_dialer, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    }
    return;
}

#ifdef __MMI_DUAL_SIM_MASTER__
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_newcall_opt_sim2_dial
 * DESCRIPTION
 *  Funtion is called when card2 dial item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_newcall_opt_sim2_dial(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (IsScreenPresent(SCR_ID_UCM_VOIP_DIALER))
    {
        SetLeftSoftkeyFunction(mmi_ucm_make_voip_call_from_incall_dialer, KEY_EVENT_UP);
        SetKeyHandler(mmi_ucm_make_voip_call_from_incall_dialer, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    }
    else
    {
        MTPNP_AD_Set_Channel(MTPNP_AD_CALL_CHANNEL,MTPNP_AD_CHANNEL_SLAVE);
        SetLeftSoftkeyFunction(mmi_ucm_make_voice_call_from_incall_dialer, KEY_EVENT_UP);
        SetKeyHandler(mmi_ucm_make_voice_call_from_incall_dialer, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    }
    return;
}
#endif /* __MMI_DUAL_SIM_MASTER__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_newcall_opt_save
 * DESCRIPTION
 *  Funtion is called when save item selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_newcall_opt_save(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_ucm_entry_save_phonebook, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_entry_save_phonebook, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_transfer
 * DESCRIPTION
 *  Transfer screen entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_transfer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U8 *inputStr = NULL;
    mmi_ucm_call_type_enum call_type = 0;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_TRANSFER, NULL, mmi_ucm_entry_transfer, NULL);    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_TRANSFER);
    inputStr = GetCurrInputBuffer(SCR_ID_UCM_TRANSFER);
    
    call_type = g_ucm_p->call_list.group_info[g_ucm_p->call_misc.hilite_tab].call_type;

    if (call_type == MMI_UCM_VOIP_CALL_TYPE)
    {
        ShowCategory404Screen(
            STR_GLOBAL_OK,
            IMG_GLOBAL_OK,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            IMG_ID_VOIP_CALL_EDITOR,
            g_ucm_p->mo_info.dial_pad_buffer,
            MMI_UCM_MAX_NUM_URI_LEN,
            guiBuffer);
    }
    else
    {
        MMI_ASSERT(0);
    }
    
    SetLeftSoftkeyFunction(mmi_ucm_transfer, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    SetKeyHandler(mmi_ucm_transfer, KEY_SEND, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_in_call_endkey, KEY_END, KEY_EVENT_DOWN);

    /* must set KEY_EVENT_DOWN function to overwrite original side key handler of category 52 */
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_DOWN, KEY_EVENT_DOWN);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_transfer
 * DESCRIPTION
 *  Transfer function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_transfer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ucs2strlen((S8*)g_ucm_p->mo_info.dial_pad_buffer) == 0)
    {
        DisplayPopup(
            (PU8) GetString(STR_GLOBAL_EMPTY),
            IMG_GLOBAL_UNFINISHED,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            (U8) ERROR_TONE);
         
        return;
    }

    mmi_ucs2_n_to_asc((S8*) g_ucm_p->mo_info.dial_num.num_uri, 
                    (S8*)g_ucm_p->mo_info.dial_pad_buffer, 
                    MMI_UCM_MAX_NUM_URI_LEN);

    mmi_ucm_deflect_action();
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_deflect
 * DESCRIPTION
 *  Deflect screen entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_deflect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U8 *inputStr = NULL;
    S32 index = 0;
    mmi_ucm_call_type_enum call_type = 0;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
    
    EntryNewScreen(SCR_ID_UCM_DEFLECT, NULL, mmi_ucm_entry_deflect, NULL);    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_DEFLECT);
    inputStr = GetCurrInputBuffer(SCR_ID_UCM_DEFLECT);

    index = mmi_ucm_get_group_index_by_call_state(MMI_UCM_INCOMING_STATE);
    MMI_ASSERT(index >= 0);

    call_type = g_ucm_p->call_list.group_info[index].call_type;

    if (call_type == MMI_UCM_VOIP_CALL_TYPE)
    {
        ShowCategory404Screen(
            STR_GLOBAL_OK,
            IMG_GLOBAL_OK,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            IMG_ID_VOIP_CALL_EDITOR,
            g_ucm_p->mo_info.dial_pad_buffer,
            MMI_UCM_MAX_NUM_URI_LEN,
            guiBuffer);
    }
    else
    {

    #if ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) )
    #if defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)
        SetDialingKeypadCallHandler(mmi_ucm_deflect);
        
        if (mmi_ucm_incoming_call_show_option())
        {
            SetDialingKeypadPhonebookHandler(mmi_phb_call_enter_from_deflect_option);
        }
        else
        {
            SetDialingKeypadPhonebookHandler(NULL);
        }
    #else /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */ 
        EnableCenterSoftkey(0, IMG_CSK_DIAL_ICON);
    #endif /* defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__) */
    #endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) ) */
                
        ShowCategory16Screen(
            STR_GLOBAL_OK,
            IMG_GLOBAL_OK,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            g_ucm_p->mo_info.dial_pad_buffer,
            (MMI_UCM_DTMF_LEN + 1),
            guiBuffer);

    #if (defined (__MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__))
        SetCenterSoftkeyFunction(mmi_ucm_deflect, KEY_EVENT_UP);
    #endif /* ( (defined  __MMI_WGUI_CSK_ENABLE__) && defined (__MMI_TOUCH_SCREEN__) && !defined (__MMI_TOUCH_DIAL_SCREEN_WITH_FUNCTION__)) */
    }
    
    SetLeftSoftkeyFunction(mmi_ucm_deflect, KEY_EVENT_UP);
    SetCategory16RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP); 

    SetKeyHandler(mmi_ucm_deflect, KEY_SEND, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_incoming_call_endkey, KEY_END, KEY_EVENT_DOWN);

    /* must set KEY_EVENT_DOWN function to overwrite original side key handler of category 52 */
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_ucm_set_sidekey, KEY_VOL_DOWN, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_deflect
 * DESCRIPTION
 *  Deflect function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_deflect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucm_transfer();   
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_replace
 * DESCRIPTION
 *  Deflect function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_replace(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucm_end_active_and_accept_action();   
}

#ifdef __MMI_UCM_REDIAL_FROM_OTHER_SIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_redial_from_other_sim
 * DESCRIPTION
 *  Redial from other sim function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_redial_from_other_sim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 numIncoming = 0;
    S32 numTotal = 0;
    S32 groupIndex = 0;
    mmi_ucm_call_type_enum call_type = MMI_UCM_VOICE_CALL_TYPE;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    numIncoming = mmi_ucm_get_incoming_group(MMI_UCM_CALL_TYPE_NO_CSD, g_ucm_p->call_misc.index_list);
    numTotal = mmi_ucm_app_total_call(MMI_UCM_CALL_TYPE_NO_CSD);

    MMI_ASSERT(numIncoming == 1 && numTotal == 1);
    
    groupIndex = g_ucm_p->call_misc.index_list[0].group_index;
    call_type = g_ucm_p->call_list.group_info[groupIndex].call_type;

    g_ucm_p->mo_info.module_id = MMI_UCM_FROM_IDLE;

    if (call_type == MMI_UCM_VOICE_CALL_TYPE)
    {
        g_ucm_p->mo_info.dial_type = MMI_UCM_VOICE_CALL_TYPE_SIM2;
        MTPNP_AD_Set_Channel(MTPNP_AD_CALL_CHANNEL, MTPNP_AD_CHANNEL_SLAVE);
    }
    else if (call_type == MMI_UCM_VOICE_CALL_TYPE_SIM2)
    {
        g_ucm_p->mo_info.dial_type = MMI_UCM_VOICE_CALL_TYPE;
        MTPNP_AD_Set_Channel(MTPNP_AD_CALL_CHANNEL, MTPNP_AD_CHANNEL_MASTER);
    }
    else
    {
        MMI_ASSERT(0);
    }

    memcpy(g_ucm_p->mo_info.dial_num.num_uri, 
           g_ucm_p->call_list.group_info[groupIndex].call_info[0].remote_info.num_uri, 
           sizeof(g_ucm_p->mo_info.dial_num.num_uri));

    g_ucm_p->mo_info.is_wait_dial = TRUE;
    mmi_ucm_end_all_action();
    
}
#endif /* __MMI_UCM_REDIAL_FROM_OTHER_SIM__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_confirm_delete_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  in_param        [?]     
 * RETURNS
 *  U8
 *****************************************************************************/
U8 mmi_ucm_entry_confirm_delete_callback(void *in_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FuncPtr callback = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    PRINT_INFORMATION("\n[mmi_ucm_entry_confirm_delete_callback]\n");

    callback = g_ucm_p->cnf_scr.cancel_hdlr;

    if (callback != NULL)
    {
        PRINT_INFORMATION("\n[mmi_ucm_entry_confirm_delete_callback] Execute callback \n");
        (*callback)();
    }

    if (g_ucm_p->cnf_scr.content != NULL)
    {
        OslMfree(g_ucm_p->cnf_scr.content);
        g_ucm_p->cnf_scr.content = NULL;
    }
    
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_confirm
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_confirm (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_CONFIRM, NULL, mmi_ucm_entry_confirm, NULL);

    ShowCategoryDummyScreen();

    SetDelScrnIDCallbackHandler(SCR_ID_UCM_CONFIRM, (HistoryDelCBPtr) mmi_ucm_entry_confirm_delete_callback);

    StartTimer(UCM_CONFIRM_TIMER_ID, 1,  mmi_ucm_display_confirm);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_display_confirm
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_display_confirm (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("\n[mmi_ucm_entry_confirm] Display Confirm Screen\n");
    
    DisplayConfirm
        (g_ucm_p->cnf_scr.lsk_str, 
         0, 
         g_ucm_p->cnf_scr.rsk_str,
         0, 
         (UI_string_type)g_ucm_p->cnf_scr.content, 
         IMG_GLOBAL_QUESTION, 
         WARNING_TONE);

    SetLeftSoftkeyFunction(mmi_ucm_execute_confirm_hdlr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_ucm_execute_confirm_hdlr, KEY_EVENT_UP);

    SetKeyHandler(mmi_ucm_execute_confirm_hdlr, KEY_SEND, KEY_EVENT_DOWN); 
    SetKeyHandler(mmi_ucm_execute_confirm_hdlr, KEY_END, KEY_EVENT_DOWN);

    TurnOnBacklight(1);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_execute_confirm_hdlr
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_execute_confirm_hdlr (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    U16 keycode, keytype;
    FuncPtr callback = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    GetkeyInfo(&keycode, &keytype);

    PRINT_INFORMATION("\n[mmi_ucm_execute_confirm_hdlr] keycode: %d keytype: %d\n", keycode, keytype);

    if ((keycode == KEY_LSK || keycode == KEY_ENTER) && (keytype == KEY_EVENT_UP))
    {
        callback = g_ucm_p->cnf_scr.lsk_hdlr;
    }
    else if ((keycode == KEY_RSK) && (keytype == KEY_EVENT_UP))
    {
        callback = g_ucm_p->cnf_scr.rsk_hdlr;
    }
#if defined( __MMI_DUAL_SIM_MASTER__) && defined(__SENDKEY2_SUPPORT__)
    else if(((keycode == KEY_SEND) || (keycode == KEY_SEND2)) && (keytype == KEY_EVENT_DOWN))
#else /*defined( __MMI_DUAL_SIM_MASTER__) && defined(__SENDKEY2_SUPPORT__)*/
    else if ((keycode == KEY_SEND) && (keytype == KEY_EVENT_DOWN))
#endif /*defined( __MMI_DUAL_SIM_MASTER__) && defined(__SENDKEY2_SUPPORT__)*/
    {
        callback = g_ucm_p->cnf_scr.send_hdlr;
    }
    else if ((keycode == KEY_END) && (keytype == KEY_EVENT_DOWN))
    {
        callback = g_ucm_p->cnf_scr.end_hdlr;
    }
    else
    {
        PRINT_INFORMATION("\n[mmi_ucm_execute_confirm_hdlr] ignore!\n");
        return;        
    }

    if (callback != NULL)
    {
        PRINT_INFORMATION("\n[mmi_ucm_execute_confirm_hdlr] Execute callback \n");        
        (*callback)();
    }

    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
    ClearDelScrnIDCallbackHandler(SCR_ID_UCM_CONFIRM, NULL);
    DeleteScreenIfPresent(SCR_ID_UCM_CONFIRM);

    if (g_ucm_p->cnf_scr.content != NULL)
    {
        OslMfree(g_ucm_p->cnf_scr.content);
        g_ucm_p->cnf_scr.content = NULL;
    }
    
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_set_processing_parameter
 * DESCRIPTION
 *  Set processing screen parameter.
 * PARAMETERS
 *  titleStr            [IN]        Title string
 *  bodyStr             [IN]        Body string
 *  animationImg        [IN]        Animation image
 *  lskStr              [IN]        LSK display string
 *  lskFunc             [IN]        LSK function pointer
 *  rskStr              [IN]        RSK display string
 *  rskFunc             [IN]        RSK function pointer
 *  sendFunc            [IN]        SEND key function pointer
 *  endFunc             [IN]        END key function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_set_processing_parameter(
        U16 titleStr,
        U16 bodyStr,
        U16 animationImg,
        U16 lskStr,
        FuncPtr lskFunc,
        U16 rskStr,
        FuncPtr rskFunc,
        FuncPtr sendFunc,
        FuncPtr endFunc)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ucm_p->proc_scr.title_string = titleStr;
    g_ucm_p->proc_scr.body_string = bodyStr;
    g_ucm_p->proc_scr.body_string_pointer = NULL;
    g_ucm_p->proc_scr.animation_image = animationImg;
    g_ucm_p->proc_scr.lsk_string = lskStr;
    g_ucm_p->proc_scr.lsk_funcPtr = lskFunc;
    g_ucm_p->proc_scr.rsk_string = rskStr;
    g_ucm_p->proc_scr.rsk_funcPtr = rskFunc;
    g_ucm_p->proc_scr.send_funcPtr = sendFunc;
    g_ucm_p->proc_scr.end_funcPtr = endFunc;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_set_processing_parameter_with_body_string_pointer
 * DESCRIPTION
 *  Set processing screen parameter.
 * PARAMETERS
 *  titleStr            [IN]        Title string
 *  bodyStr             [IN]        Body string
 *  animationImg        [IN]        Animation image
 *  lskStr              [IN]        LSK display string
 *  lskFunc             [IN]        LSK function pointer
 *  rskStr              [IN]        RSK display string
 *  rskFunc             [IN]        RSK function pointer
 *  sendFunc            [IN]        SEND key function pointer
 *  endFunc             [IN]        END key function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_set_processing_parameter_with_body_string_p(
        U16 titleStr,
        U8* bodyStrP,
        U16 animationImg,
        U16 lskStr,
        FuncPtr lskFunc,
        U16 rskStr,
        FuncPtr rskFunc,
        FuncPtr sendFunc,
        FuncPtr endFunc)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ucm_p->proc_scr.title_string = titleStr;
    g_ucm_p->proc_scr.body_string = 0;
    g_ucm_p->proc_scr.body_string_pointer = bodyStrP;
    g_ucm_p->proc_scr.animation_image = animationImg;
    g_ucm_p->proc_scr.lsk_string = lskStr;
    g_ucm_p->proc_scr.lsk_funcPtr = lskFunc;
    g_ucm_p->proc_scr.rsk_string = rskStr;
    g_ucm_p->proc_scr.rsk_funcPtr = rskFunc;
    g_ucm_p->proc_scr.send_funcPtr = sendFunc;
    g_ucm_p->proc_scr.end_funcPtr = endFunc;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_add_processing_to_history
 * DESCRIPTION
 *  Add processing screen to history
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_add_processing_to_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&currHistory, 0, sizeof(currHistory));
    currHistory.scrnID = SCR_ID_UCM_PROCESSING;
    currHistory.entryFuncPtr = mmi_ucm_entry_processing_screen;
    memset((S8*) currHistory.inputBuffer, 0, ENCODING_LENGTH);

    AddHistory(currHistory);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_processing_screen
 * DESCRIPTION
 *  General entry function of processing screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_processing_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U8 *body_string_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_PROCESSING, NULL, mmi_ucm_entry_processing_screen, NULL);
    
    PRINT_INFORMATION("\n[mmi_ucm_entry_processing_screen] Processing Screen\n");
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_PROCESSING);

    if (g_ucm_p->proc_scr.body_string_pointer != NULL)
    {
        body_string_p = g_ucm_p->proc_scr.body_string_pointer;
    }
    else
    {
        body_string_p = (U8*) GetString(g_ucm_p->proc_scr.body_string);
    }
    
    ShowCategory66Screen(
        g_ucm_p->proc_scr.title_string,
        0,
        g_ucm_p->proc_scr.lsk_string,
        0,
        g_ucm_p->proc_scr.rsk_string,
        0,
        body_string_p ,
        g_ucm_p->proc_scr.animation_image,
        NULL);
    
    SetLeftSoftkeyFunction(g_ucm_p->proc_scr.lsk_funcPtr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(g_ucm_p->proc_scr.rsk_funcPtr, KEY_EVENT_UP);

    SetKeyHandler(g_ucm_p->proc_scr.send_funcPtr, KEY_SEND, KEY_EVENT_DOWN);
    SetKeyHandler(g_ucm_p->proc_scr.end_funcPtr, KEY_END, KEY_EVENT_DOWN);
    
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_go_back_screen_check
 * DESCRIPTION
 *  Go back to screen based on current state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_go_back_screen_check(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 curr_scr_id = GetExitScrnID();
    mmi_ucm_call_type_enum incall_type = (MMI_UCM_VOICE_CALL_TYPE_ALL | MMI_UCM_VOIP_CALL_TYPE | MMI_UCM_DATA_CALL_TYPE_ALL | MMI_UCM_VIDEO_CALL_TYPE);
    U16 ucm_ctr_status = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* pending action exists, do not adjust history */
    if ((mmi_ucm_get_process_state(MMI_UCM_WAIT_PROCESS_STATE, g_ucm_p->call_misc.index_list) == 0) && 
        (mmi_ucm_get_process_state(MMI_UCM_DO_PROCESS_STATE, g_ucm_p->call_misc.index_list) == 0) && 
        (mmi_ucm_get_process_state(MMI_UCM_COMP_PROCESS_STATE, g_ucm_p->call_misc.index_list) == 0))
    {
        if (mmi_ucm_get_incoming_group(MMI_UCM_CALL_TYPE_ALL,  g_ucm_p->call_misc.index_list) > 0)
        {
            if (!IsScreenPresent(SCR_ID_UCM_INCOMING))
            {
                if (!IsScreenPresent(SCR_ID_UCM_MARKER))
                {
                    mmi_ucm_entry_marker();
                }
                
                mmi_ucm_entry_incoming_call();
            }
            
            /* force to add processing screen to history when current screen is processing screen.
               it is to prevent no popup case so that processing screen is not deleted */
            else if ((curr_scr_id == SCR_ID_UCM_PROCESSING) || (curr_scr_id == SCR_ID_UCM_OUTGOING))
            {
                EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
            }

            mmi_ucm_delete_common_screens();
            
            DeleteScreenIfPresent(SCR_ID_UCM_OUTGOING);
            DeleteScreenIfPresent(SCR_ID_UCM_INCOMING_OPTION);
            DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL_OPTION);
            
    
            if (GetExitScrnID() == GLOBAL_SCR_DUMMY)
            {
                DeleteUptoScrID(SCR_ID_UCM_INCOMING);
                GoBackHistory(); /* go back to incoming call screen */
            }

        }
        else if (mmi_ucm_get_outgoing_group(MMI_UCM_CALL_TYPE_ALL, g_ucm_p->call_misc.index_list) > 0)
        {
            if (!IsScreenPresent(SCR_ID_UCM_OUTGOING))
            {
                if (!IsScreenPresent(SCR_ID_UCM_MARKER))
                {
                    mmi_ucm_entry_marker();
                }
                
                mmi_ucm_entry_outgoing_call();
            }
            
            /* force to add processing screen to history when current screen is processing screen.
               it is to prevent no popup case so that processing screen is not deleted */
            else if ((curr_scr_id == SCR_ID_UCM_PROCESSING) || (curr_scr_id == SCR_ID_UCM_OUTGOING))
            {
                EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
            }
            
            mmi_ucm_delete_common_screens();
            
            DeleteScreenIfPresent(SCR_ID_UCM_INCOMING);
            DeleteScreenIfPresent(SCR_ID_UCM_INCOMING_OPTION);
            DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL);
            DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL_OPTION);
    
            if (GetExitScrnID() == GLOBAL_SCR_DUMMY)
            {
                DeleteUptoScrID(SCR_ID_UCM_OUTGOING);
                GoBackHistory(); /* go back to outgoing call screen */
            }
        }
        else
        {
            mmi_ucm_tab_highlight(); /* no matter call exists or not, adjust tab highlight */
            if ((mmi_ucm_get_active_group(incall_type, FALSE, g_ucm_p->call_misc.index_list) > 0) || 
                (mmi_ucm_get_held_group(incall_type, FALSE, g_ucm_p->call_misc.index_list) > 0))
            {
                S32 group_index = mmi_ucm_get_group_index_by_call_state(MMI_UCM_ACTIVE_STATE);
                mmi_ucm_call_type_enum active_call_type = 0;

                if (group_index != -1)
                {
                    active_call_type = g_ucm_p->call_list.group_info[group_index ].call_type;
                }

            #ifdef __MMI_VIDEO_TELEPHONY__
                if (MMI_UCM_VIDEO_CALL_TYPE == active_call_type)
                {
                    /* delete VT screens before incall */
                    if (mmi_ucm_check_if_scr_older(SCR_ID_VT_INCALL, SCR_ID_UCM_MARKER))
                    {
                        U16 end_scr = 0;
                        
                        GetPreviousScrnIdOf(SCR_ID_UCM_MARKER, &end_scr);
                        if (end_scr == SCR_ID_VT_INCALL)
                        {
                            DeleteScreenIfPresent(SCR_ID_VT_INCALL);
                        }
                        else
                        {
                            DeleteBetweenScreen(SCR_ID_VT_INCALL, end_scr);
                        }
                    }
                    
                    if (!IsScreenPresent(SCR_ID_VT_INCALL))
                    {
                        mmi_vt_init_incall_setting();
                        
                        if (((curr_scr_id < UCM_SCREEN_BASE) || (curr_scr_id >= SCR_ID_UCM_TOTAL)) &&
                            ((curr_scr_id <= VT_BASE) || (curr_scr_id >= SCR_ID_VT_TOTAL)))
                        {
                            mmi_vt_add_incall_to_history();
                        }
                        else
                        {
                            mmi_vt_entry_in_call();
                        }
                    }
                    /* force to add processing screen to history when current screen is processing screen.
                   it is to prevent no popup case so that processing screen is not deleted */
                    else if ((curr_scr_id == SCR_ID_UCM_PROCESSING) || (curr_scr_id == SCR_ID_UCM_OUTGOING))
                    {
                        EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
                    }
                }
                else
            #endif /* __MMI_VIDEO_TELEPHONY__ */
                {
                    if (!IsScreenPresent(SCR_ID_UCM_IN_CALL))
                    {
                        /* Do not cover call end screen */
                        if (GetExitScrnID() == SCR_ID_UCM_CALL_END)
                        {
                            DeleteUptoScrID(SCR_ID_UCM_MARKER);
                            mmi_ucm_add_incall_to_history();
                        }
                        else
                        {
                            mmi_ucm_entry_in_call();
                            DeleteUptoScrID(SCR_ID_UCM_MARKER);
                        }

                        /*If CTR setting is on*/
                        ucm_ctr_status = GetCtrStatus();
                        if(ucm_ctr_status != CTR_OFF)
                        {
                            if(IsMyTimerExist(CM_CTR_TIMER) == MMI_FALSE)
                            {
                                StartTimer(CM_CTR_TIMER, (1000 * GetCtrTime()), mmi_ucm_call_time_reminder);
                            }
                        }
                    }
                    /* force to add processing screen to history when current screen is processing screen.
                       it is to prevent no popup case so that processing screen is not deleted */
                    else if ((curr_scr_id == SCR_ID_UCM_PROCESSING) || (curr_scr_id == SCR_ID_UCM_OUTGOING))
                    {
                        EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
                    }
                }

                mmi_ucm_delete_common_screens();
                
                DeleteScreenIfPresent(SCR_ID_UCM_INCOMING);
                DeleteScreenIfPresent(SCR_ID_UCM_INCOMING_OPTION);
                DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL_OPTION);
                DeleteScreenIfPresent(SCR_ID_UCM_OUTGOING);

			
            #ifdef __MMI_VIDEO_TELEPHONY__            
                if (MMI_UCM_VIDEO_CALL_TYPE == active_call_type)
                {
                    DeleteScreenIfPresent(SCR_ID_VT_INCALL_OPTION);
                    DeleteScreenIfPresent(SCR_ID_VT_ADVANCE);
                    DeleteScreenIfPresent(SCR_ID_VT_VIDEO_QUALITY);
                }                
            #endif /* __MMI_VIDEO_TELEPHONY__ */
            
                if (GetExitScrnID() == GLOBAL_SCR_DUMMY)
                {
                #ifdef __MMI_VIDEO_TELEPHONY__            
                    if (MMI_UCM_VIDEO_CALL_TYPE == active_call_type)
                    {
                        DeleteUptoScrID(SCR_ID_VT_INCALL);
                    }
                    else
                #endif /* __MMI_VIDEO_TELEPHONY__ */
                    {
                        DeleteUptoScrID(SCR_ID_UCM_IN_CALL);
                    }
                    GoBackHistory(); /* go back to active call screen */
                }
            }
            else
            {
                /* force to add processing screen to history when current screen is processing screen.
                   it is to prevent no popup case so that processing screen is not deleted */
                if ((curr_scr_id == SCR_ID_UCM_PROCESSING) || (curr_scr_id == SCR_ID_UCM_OUTGOING))
                {
                    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
                }

                mmi_ucm_delete_common_screens();

            #ifdef __MMI_VIDEO_TELEPHONY__
                if (!mmi_ucm_check_if_scr_older(SCR_ID_VT_INCALL, SCR_ID_UCM_MARKER))
                {
                    DeleteScreenIfPresent(SCR_ID_VT_INCALL);
                    DeleteScreenIfPresent(SCR_ID_VT_INCALL_OPTION);
                    DeleteScreenIfPresent(SCR_ID_VT_ADVANCE);
                    DeleteScreenIfPresent(SCR_ID_VT_VIDEO_QUALITY);
                }
            #endif /* __MMI_VIDEO_TELEPHONY__ */                
                
                DeleteScreenIfPresent(SCR_ID_UCM_INCOMING);
                DeleteScreenIfPresent(SCR_ID_UCM_INCOMING_OPTION);
                DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL);
                DeleteScreenIfPresent(SCR_ID_UCM_IN_CALL_OPTION);
                DeleteScreenIfPresent(SCR_ID_UCM_OUTGOING);
                DeleteScreenIfPresent(SCR_ID_UCM_MARKER);

                mmi_ucm_delete_sublcd_screens();
                
                if (GetExitScrnID() == GLOBAL_SCR_DUMMY)
                {
                    GoBackHistory();
                }
            }
        }
    }
    else
    {
        PRINT_INFORMATION("\n[mmi_ucm_go_back_screen_check] Pending Action Exists!\n");

        /* Waiting call is allowed when pending actions exist */
        if (IsScreenPresent(SCR_ID_UCM_INCOMING) || GetExitScrnID() == SCR_ID_UCM_INCOMING)
        {
            /* Waiting call is disconnected when pending actions exist */
            if (mmi_ucm_app_incoming_call(MMI_UCM_CALL_TYPE_ALL) == 0)
            {
                if (IsScreenPresent(SCR_ID_UCM_PROCESSING))
                {
                    /* Delete incoming call screen and go back to processing call screen */
                    if (GetExitScrnID() == SCR_ID_UCM_INCOMING)
                    {
                        EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
                        DeleteUptoScrID(SCR_ID_UCM_PROCESSING);
                        GoBackHistory();   
                    }
                    else /* both incoming screen and processing screen are in history */
                    {
                        if (mmi_ucm_check_if_scr_older(SCR_ID_UCM_PROCESSING, SCR_ID_UCM_INCOMING))
                        {
                            DeleteUptoScrID(SCR_ID_UCM_PROCESSING);
                        }
                    }
                }
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_add_incall_to_history
 * DESCRIPTION
 *  Add incall screen to history
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_add_incall_to_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&currHistory, 0, sizeof(currHistory));
    currHistory.scrnID = SCR_ID_UCM_IN_CALL;
    currHistory.entryFuncPtr = mmi_ucm_entry_in_call;
    memset((S8*) currHistory.inputBuffer, 0, ENCODING_LENGTH);

    AddHistory(currHistory);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_delete_common_screens
 * DESCRIPTION
 *  delete common screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_delete_common_screens(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DeleteScreenIfPresent(SCR_ID_UCM_PROCESSING);
    DeleteScreenIfPresent(SCR_ID_UCM_DTMF_EDITOR);
    DeleteScreenIfPresent(SCR_ID_UCM_MULTI_HELD_CALL);
    DeleteScreenIfPresent(SCR_ID_UCM_NEW_CALL_OPTION);
    DeleteScreenIfPresent(SCR_ID_UCM_VOIP_DIALER);
    DeleteScreenIfPresent(SCR_ID_UCM_VOICE_DIALER);
    DeleteScreenIfPresent(SCR_ID_UCM_TRANSFER);

    if (IsScreenPresent(SCR_ID_UCM_DEFLECT))
    {
        /* delete phonebook list screen for category 16 touch panel projects */
        DeleteUptoScrID(SCR_ID_UCM_DEFLECT);
        DeleteScreenIfPresent(SCR_ID_UCM_DEFLECT);
    }
    
    DeleteScreenIfPresent(SCR_ID_UCM_NEW_CALL_DIALER_OPTION);

#ifdef __MMI_BG_SOUND_EFFECT__    
    DeleteScreenIfPresent(SCR_ID_UCM_BGS_EFFECT_SELECT);
#endif /* __MMI_BG_SOUND_EFFECT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_delete_sublcd_screens
 * DESCRIPTION
 *  delete sublcd screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_delete_sublcd_screens(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DeleteSubLCDScreen(SCR_ID_UCM_INCOMING_SUBLCD);
    DeleteSubLCDScreen(SCR_ID_UCM_INCOMING_SUBLCD_STATIC);    
    DeleteSubLCDScreen(SCR_ID_UCM_OUTGOING_SUBLCD);
    DeleteSubLCDScreen(SCR_ID_UCM_IN_CALL_SUBLCD);
    
    if (GetCurrSubLCDScreenExitFunc() == mmi_ucm_exit_incoming_call_sublcd ||
        GetCurrSubLCDScreenExitFunc() == mmi_ucm_exit_incoming_call_static_sublcd ||        
        GetCurrSubLCDScreenExitFunc() == mmi_ucm_exit_outgoing_call_sublcd ||
        GetCurrSubLCDScreenExitFunc() == mmi_ucm_exit_in_call_sublcd)
    {
        GoBackSubLCDHistory();
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_add_auto_redial_to_history
 * DESCRIPTION
 *  Add auto redial screen to history
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_add_auto_redial_to_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&currHistory, 0, sizeof(currHistory));
    currHistory.scrnID = SCR_ID_UCM_AUTO_REDIAL;
    currHistory.entryFuncPtr = mmi_ucm_entry_auto_redial;
    memset((S8*) currHistory.inputBuffer, 0, ENCODING_LENGTH);

    AddHistory(currHistory);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_auto_redial
 * DESCRIPTION
 *  Auto redial entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_auto_redial(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_AUTO_REDIAL, NULL, mmi_ucm_entry_auto_redial, NULL);

    PRINT_INFORMATION("[mmi_ucm_entry_auto_redial] \n");

    ClearDelScrnIDCallbackHandler(SCR_ID_UCM_AUTO_REDIAL, NULL);
    DeleteScreenIfPresent(SCR_ID_UCM_AUTO_REDIAL);

    ShowCategory141Screen(0, 0, 0, 0, STR_GLOBAL_ABORT, 0, (U8*)g_ucm_p->auto_redial.display_msg, 0, NULL);

    SetRightSoftkeyFunction(mmi_ucm_auto_redial_abort, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_auto_redial_abort, KEY_END, KEY_EVENT_DOWN);

    SetDelScrnIDCallbackHandler(SCR_ID_UCM_AUTO_REDIAL, (HistoryDelCBPtr) mmi_ucm_auto_redial_delete_callback);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_auto_redial_abort
 * DESCRIPTION
 *  Auto redial abort function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_auto_redial_abort(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("[mmi_ucm_auto_redial_abort] \n");
    
    if (g_ucm_p->auto_redial.abort_hdlr)
    {
        StopTimer(UCM_AUTO_REDIAL_TIMER);
        g_ucm_p->auto_redial.abort_hdlr();
        memset(&g_ucm_p->auto_redial, 0, sizeof(mmi_ucm_auto_redial_struct));
    }
    GoBackHistory();
}

    
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_auto_redial_timeout_handler
 * DESCRIPTION
 *  Auto redial timeout function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_auto_redial_timeout_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (mmi_ucm_app_total_call(MMI_UCM_CALL_TYPE_ALL) == 0)
    {
        U8 str_len = strlen((S8*)g_ucm_p->auto_redial.num_uri);
        U8 num_len = (MMI_UCM_MAX_NUM_URI_LEN > str_len) ? (str_len) : (MMI_UCM_MAX_NUM_URI_LEN - 1);

        PRINT_INFORMATION("[mmi_ucm_auto_redial_timeout_handler] Make Call\n");   

        g_ucm_p->mo_info.module_id = MMI_UCM_FROM_IDLE;
        g_ucm_p->mo_info.dial_type = g_ucm_p->auto_redial.call_type;
        memset(g_ucm_p->mo_info.dial_num.num_uri, 0, MMI_UCM_MAX_NUM_URI_LEN);
        strncpy((S8*)g_ucm_p->mo_info.dial_num.num_uri, (S8*)g_ucm_p->auto_redial.num_uri, num_len);
        mmi_ucm_outgoing_call_sendkey();
        
        ClearDelScrnIDCallbackHandler(SCR_ID_UCM_AUTO_REDIAL, NULL);

        if (GetExitScrnID() == SCR_ID_UCM_AUTO_REDIAL)
        {
            EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
        }
        
        DeleteScreenIfPresent(SCR_ID_UCM_AUTO_REDIAL);
    }
    else
    {
        PRINT_INFORMATION("[mmi_ucm_auto_redial_timeout_handler] Abort \n");   
        
        if (g_ucm_p->auto_redial.abort_hdlr)
        {
            g_ucm_p->auto_redial.abort_hdlr();
            memset(&g_ucm_p->auto_redial, 0, sizeof(mmi_ucm_auto_redial_struct));            
        }

        if (GetExitScrnID() == SCR_ID_UCM_AUTO_REDIAL)
        {
            GoBackHistory();
        }
        else
        {
            ClearDelScrnIDCallbackHandler(SCR_ID_UCM_AUTO_REDIAL, NULL);
            DeleteScreenIfPresent(SCR_ID_UCM_AUTO_REDIAL);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_auto_redial_delete_callback
 * DESCRIPTION
 *  Auto redial delete callback function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_ucm_auto_redial_delete_callback(void *in_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("[mmi_ucm_auto_redial_delete_callback]\n");   
    
    if (g_ucm_p->auto_redial.abort_hdlr)
    {
        PRINT_INFORMATION("[mmi_ucm_auto_redial_delete_callback] Abort \n");   
        g_ucm_p->auto_redial.abort_hdlr();
        memset(&g_ucm_p->auto_redial, 0, sizeof(mmi_ucm_auto_redial_struct));            
    }
    
    StopTimer(UCM_AUTO_REDIAL_TIMER);
    
    return FALSE;
}    


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_bt_set_audio_path
 * DESCRIPTION
 *  BT set audio path function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_bt_set_audio_path(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_BT_HP_SUPPORT__) || defined(__MMI_BT_SUPPORT__)
    if (mmi_bt_is_incall_aud_swap2bt() == MMI_TRUE)
    {
        PRINT_INFORMATION("[mmi_ucm_bt_set_audio_path] transfer to AG \n");   
    
        /* Current voice path in BT, shall transfer to AG */
        mmi_bt_switch_voice_path_incall(MMI_FALSE);
    }
    else
    {
        PRINT_INFORMATION("[mmi_ucm_bt_set_audio_path] transfer to BT \n");   
        
        /* Current voice path in AG, shall transfer to BT */
        mmi_bt_switch_voice_path_incall(MMI_TRUE);
    }
#endif /* defined(__MMI_BT_HP_SUPPORT__) || defined(__MMI_BT_SUPPORT__) */

}    


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_marker
 * DESCRIPTION
 *  entry marker function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_marker(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_MARKER, NULL, mmi_ucm_entry_marker, NULL);

    PRINT_INFORMATION("[mmi_ucm_entry_marker] \n");

    ShowCategoryDummyScreen();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_app_entry_dial_option_internal
 * DESCRIPTION
 *  General dial call type option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_app_entry_dial_option_internal(U8 *num_uri, mmi_ucm_callback_func_ptr callback_after_dial, void* callback_para)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 unicodeLen = 0;
    U8* ascii_num = NULL;
#ifdef __MMI_DUAL_SIM_MASTER__
    E_MTPNP_AD_SIMCARD_USABLE_SIDE state = MTPNP_AD_Get_UsableSide();
#endif /* __MMI_DUAL_SIM_MASTER__ */    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    PRINT_INFORMATION("\n[mmi_ucm_app_entry_dial_option] \n");

    unicodeLen = (MMI_UCM_MAX_NUM_URI_LEN > mmi_ucs2strlen((S8*)num_uri)) ? (mmi_ucs2strlen((S8*)num_uri)) : (MMI_UCM_MAX_NUM_URI_LEN - 1);

    ascii_num = OslMalloc(unicodeLen + 1);
    memset(ascii_num, 0, unicodeLen + 1);
    mmi_ucs2_n_to_asc((S8*)ascii_num, (S8*)num_uri, unicodeLen * ENCODING_LENGTH);

    if (mmi_ucm_check_gsm_number((S8*)num_uri))
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE);
        
    #ifdef __MMI_DUAL_SIM_MASTER__
        mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE_SIM2);
    #endif /* __MMI_DUAL_SIM_MASTER__ */

    #ifdef __MMI_VIDEO_TELEPHONY__
        mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VIDEO);
    #endif /* __MMI_VIDEO_TELEPHONY__ */    
    }        
    else
    {
        PRINT_INFORMATION("\n[mmi_ucm_app_entry_dial_option] Invalid gsm number\n");
        
        mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE);
        
    #ifdef __MMI_DUAL_SIM_MASTER__
        mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE_SIM2);
    #endif /* __MMI_DUAL_SIM_MASTER__ */

    #ifdef __MMI_VIDEO_TELEPHONY__
        mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VIDEO);
    #endif /* __MMI_VIDEO_TELEPHONY__ */    
    }

#ifdef __MMI_DUAL_SIM_MASTER__
    switch (state)
    {
        case MTPNP_AD_DUALSIM_USABLE:
        {       
            /* do nothing */
        }
        break;
        
        case MTPNP_AD_SIMCARD1_USABLE:
        {
            mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE_SIM2);
        }
        break;
        
        case MTPNP_AD_SIMCARD2_USABLE:
        {
            mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE);
        }
        break;

        default:
        {
            mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE);
            mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE_SIM2);
        }
        break;
    }
#endif /* __MMI_DUAL_SIM_MASTER__ */

#ifdef __MMI_WLAN_FEATURES__
#ifdef __MMI_VOIP__
    if (mmi_ucm_is_sos_number(MMI_UCM_VOIP_CALL_TYPE, (U8*)ascii_num))
    {
        mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOIP);
    }            
#endif /* __MMI_VOIP__ */
#endif /* __MMI_WLAN_FEATURES__ */

    if (mmi_ucm_is_sos_number(MMI_UCM_VOICE_CALL_TYPE, (U8*)ascii_num) ||
    #ifdef __MMI_DUAL_SIM_MASTER__
        mmi_ucm_is_sos_number(MMI_UCM_VOICE_CALL_TYPE_SIM2, (U8*)ascii_num) ||
    #endif /* __MMI_DUAL_SIM_MASTER__ */
        MMI_FALSE)
    {        
    #ifdef __MMI_DUAL_SIM_MASTER__
        switch (state)
        {
            case MTPNP_AD_DUALSIM_UNUSABLE:
            {       
                /* do nothing */
            }
            break;
            
            case MTPNP_AD_SIMCARD2_USABLE:
            case MTPNP_AD_SIMCARD2_NOSIM_USABLE: 
            {
                mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE_SIM2);                    
            }
            break;

            case MTPNP_AD_DUALSIM_USABLE:
            case MTPNP_AD_SIMCARD1_USABLE:
            case MTPNP_AD_SIMCARD1_NOSIM_USABLE:
            default:
            {       
                mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE);
            }
            break;
        }
    #else /* __MMI_DUAL_SIM_MASTER__ */
    
        mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE);
    
    #endif /* __MMI_DUAL_SIM_MASTER__ */
    }

    OslMfree(ascii_num);
        
#ifdef __MMI_WLAN_FEATURES__
    if (mmi_netset_get_active_preferred_mode() == P_WLAN_ONLY) /* WLAN only */ 
    {
        PRINT_INFORMATION("\n[mmi_ucm_app_entry_dial_option] WLAN only \n");
        
        mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE);
        
    #ifdef __MMI_DUAL_SIM_MASTER__
        mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE_SIM2);
    #endif /* __MMI_DUAL_SIM_MASTER__ */

    #ifdef __MMI_VIDEO_TELEPHONY__
        mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VIDEO);
    #endif /* __MMI_VIDEO_TELEPHONY__ */    
    }
    else if (mmi_netset_get_active_preferred_mode() == P_GSM_ONLY)
    {
        PRINT_INFORMATION("\n[mmi_ucm_app_entry_dial_option] GSM only \n");
        
    #ifdef __MMI_VOIP__
        mmi_frm_hide_menu_item(MENU_ID_UCM_CALL_TYPE_VOIP);
    #endif /* __MMI_VOIP__ */
    }
#endif /* __MMI_WLAN_FEATURES__ */

  	/* No proper call type */
	if (mmi_bootup_get_active_flight_mode() ||
            GetNumOfChild_Ext(MENU_ID_UCM_CALL_TYPE) == 0)
    {
        DisplayPopup(
            (U8*)GetString(STR_ID_UCM_NOT_ALLOW_TO_DIAL),
            IMG_GLOBAL_UNFINISHED,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            ERROR_TONE);
        return;
    }

    DeleteScreenIfPresent(SCR_ID_UCM_DIAL_CALL_TYPE_MENU);
    g_ucm_p->mo_info.callback = callback_after_dial;
    g_ucm_p->mo_info.callback_para = callback_para;
    
    /* Dial call directly if only one call type */
    if (GetNumOfChild_Ext(MENU_ID_UCM_CALL_TYPE) == 1)
    {
        U16 call_menu_id = GetSeqItemId_Ext(MENU_ID_UCM_CALL_TYPE, 0); 

        switch (call_menu_id) 
        { 
            case MENU_ID_UCM_CALL_TYPE_VOIP: 
            { 
                mmi_ucm_app_make_call(MMI_UCM_VOIP_CALL_TYPE , num_uri); 
            } 
            break; 

            case MENU_ID_UCM_CALL_TYPE_VIDEO: 
            { 
                mmi_ucm_app_make_call(MMI_UCM_VIDEO_CALL_TYPE , num_uri); 
            } 
            break; 

            case MENU_ID_UCM_CALL_TYPE_VOICE: 
            { 
                mmi_ucm_app_make_call(MMI_UCM_VOICE_CALL_TYPE , num_uri);
            } 
            break; 

            case MENU_ID_UCM_CALL_TYPE_VOICE_SIM2: 
            { 
                mmi_ucm_app_make_call(MMI_UCM_VOICE_CALL_TYPE_SIM2 , num_uri);
            } 
            break; 

            default: 
            { 
                MMI_ASSERT(0); 
            } 
            break; 
        }         

        if (g_ucm_p->mo_info.callback != NULL)
        {
            g_ucm_p->mo_info.callback((void*)g_ucm_p->mo_info.callback_para);
        }
    }
    else
    {
        memset(g_ucm_p->mo_info.dial_num.num_uri, 0, MMI_UCM_MAX_NUM_URI_LEN);
        mmi_ucs2_n_to_asc((S8*)g_ucm_p->mo_info.dial_num.num_uri, (S8*)num_uri, unicodeLen * ENCODING_LENGTH);
    
        mmi_ucm_entry_call_type();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_app_entry_dial_option
 * DESCRIPTION
 *  General dial call type option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_app_entry_dial_option(U8 *num_uri, mmi_ucm_callback_func_ptr callback_after_dial, void* callback_para)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ucm_p->call_misc.entry_type = MMI_UCM_ENTRY_MENU;
        
    mmi_ucm_app_entry_dial_option_internal(num_uri, callback_after_dial, callback_para);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_dial_option_by_sendkey
 * DESCRIPTION
 *  General dial call type option by send key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_dial_option_by_sendkey(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ucm_p->call_misc.entry_type = MMI_UCM_ENTRY_SEND_KEY;

    mmi_ucm_dial_option_unhide_menu_item();
    mmi_ucm_entry_call_type();
 }


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_dial_option_by_centerkey
 * DESCRIPTION
 *  General dial call type option by center key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_dial_option_by_centerkey(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ucm_p->call_misc.entry_type = MMI_UCM_ENTRY_CENTER_KEY;
    
    mmi_ucm_dial_option_unhide_menu_item();
    mmi_ucm_entry_call_type();
 }


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_dial_option_unhide_menu_item
 * DESCRIPTION
 *  Unhide menu items of dial option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_dial_option_unhide_menu_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE);
        
#ifdef __MMI_DUAL_SIM_MASTER__
    mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOICE_SIM2);
#endif /* __MMI_DUAL_SIM_MASTER__ */
    
#ifdef __MMI_VOIP__
    mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VOIP);
#endif /* __MMI_VOIP__ */

#ifdef __MMI_VIDEO_TELEPHONY__
    mmi_frm_unhide_menu_item(MENU_ID_UCM_CALL_TYPE_VIDEO);
#endif /* __MMI_VIDEO_TELEPHONY__ */
        
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_call_type_voice
 * DESCRIPTION
 *  Funtion is called when voice call is selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_call_type_voice(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_ucm_p->call_misc.entry_type)
    {
        case MMI_UCM_ENTRY_MENU:
        {
            g_ucm_p->mo_info.dial_type = MMI_UCM_VOICE_CALL_TYPE;
            SetLeftSoftkeyFunction(mmi_ucm_dial_option_make_call, KEY_EVENT_UP);
        }
        break;

        case MMI_UCM_ENTRY_SEND_KEY:
        case MMI_UCM_ENTRY_CENTER_KEY:
        {
        #ifdef __MMI_DUAL_SIM_MASTER__
            mmi_ucm_set_call_channel(MMI_UCM_VOICE_CALL_TYPE);
        #endif /* __MMI_DUAL_SIM_MASTER__ */
            SetLeftSoftkeyFunction(mmi_ucm_dial_option_make_call_exec_callback, KEY_EVENT_UP);
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
    return;
}

#ifdef __MMI_DUAL_SIM_MASTER__
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_call_type_voice_sim2
 * DESCRIPTION
 *  Funtion is called when sim2 voice call is selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_call_type_voice_sim2(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_ucm_p->call_misc.entry_type)
    {
        case MMI_UCM_ENTRY_MENU:
        {
            g_ucm_p->mo_info.dial_type = MMI_UCM_VOICE_CALL_TYPE_SIM2;
            SetLeftSoftkeyFunction(mmi_ucm_dial_option_make_call, KEY_EVENT_UP);
        }
        break;

        case MMI_UCM_ENTRY_SEND_KEY:
        case MMI_UCM_ENTRY_CENTER_KEY:
        {
            mmi_ucm_set_call_channel(MMI_UCM_VOICE_CALL_TYPE_SIM2);
            SetLeftSoftkeyFunction(mmi_ucm_dial_option_make_call_exec_callback, KEY_EVENT_UP);
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
    return;
}
#endif /* __MMI_DUAL_SIM_MASTER__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_call_type_voip
 * DESCRIPTION
 *  Funtion is called when voip call is selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_call_type_voip(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_ucm_p->call_misc.entry_type)
    {
        case MMI_UCM_ENTRY_MENU:
        {
            g_ucm_p->mo_info.dial_type = MMI_UCM_VOIP_CALL_TYPE;
            SetLeftSoftkeyFunction(mmi_ucm_dial_option_make_call, KEY_EVENT_UP);
        }
        break;

        case MMI_UCM_ENTRY_SEND_KEY:
        case MMI_UCM_ENTRY_CENTER_KEY:
        {
        #ifdef __MMI_DUAL_SIM_MASTER__    
            mmi_ucm_set_call_channel(MMI_UCM_VOIP_CALL_TYPE);
        #endif /* __MMI_DUAL_SIM_MASTER__ */
            SetLeftSoftkeyFunction(mmi_ucm_dial_option_make_call_exec_callback, KEY_EVENT_UP);
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);        
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_highlight_call_type_video
 * DESCRIPTION
 *  Funtion is called when video call is selected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_highlight_call_type_video(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_ucm_p->call_misc.entry_type)
    {
        case MMI_UCM_ENTRY_MENU:
        {
            g_ucm_p->mo_info.dial_type = MMI_UCM_VIDEO_CALL_TYPE;
            SetLeftSoftkeyFunction(mmi_ucm_dial_option_make_call, KEY_EVENT_UP);
        }
        break;

        case MMI_UCM_ENTRY_SEND_KEY:
        case MMI_UCM_ENTRY_CENTER_KEY:
        {
        #ifdef __MMI_DUAL_SIM_MASTER__    
            mmi_ucm_set_call_channel(MMI_UCM_VIDEO_CALL_TYPE);
        #endif /* __MMI_DUAL_SIM_MASTER__ */
            SetLeftSoftkeyFunction(mmi_ucm_dial_option_make_call_exec_callback, KEY_EVENT_UP);
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_call_type
 * DESCRIPTION
 *  Shows the call type selection screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_call_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 numItems = 0;
    U16 nStrItemList[MAX_SUB_MENUS];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_DIAL_CALL_TYPE_MENU, NULL, mmi_ucm_entry_call_type, NULL);
    PRINT_INFORMATION("\n[mmi_ucm_entry_call_type] Call type Screen\n");
    
    guiBuffer = GetCurrGuiBuffer(SCR_ID_UCM_DIAL_CALL_TYPE_MENU);

    numItems = GetNumOfChild_Ext(MENU_ID_UCM_CALL_TYPE);
    GetSequenceStringIds_Ext(MENU_ID_UCM_CALL_TYPE, nStrItemList);    
    SetParentHandler(MENU_ID_UCM_CALL_TYPE);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory52Screen(
        STR_GLOBAL_DIAL,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        numItems,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        NULL,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_dial_option_make_call
 * DESCRIPTION
 *  Funtion is called when make call from dial option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_dial_option_make_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* num_ucs2 = NULL;
    U32 num_len = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
    DeleteScreenIfPresent(SCR_ID_UCM_DIAL_CALL_TYPE_MENU);

    g_ucm_p->mo_info.module_id = MMI_UCM_FROM_IDLE;

    num_ucs2 = OslMalloc(MMI_UCM_MAX_NUM_URI_LEN * ENCODING_LENGTH);
    memset(num_ucs2, 0, MMI_UCM_MAX_NUM_URI_LEN * ENCODING_LENGTH);
    
    num_len = strlen((S8*)g_ucm_p->mo_info.dial_num.num_uri);

    if (num_len > (MMI_UCM_MAX_NUM_URI_LEN - 1))
    {
        num_len = (MMI_UCM_MAX_NUM_URI_LEN - 1);
    }

    mmi_asc_n_to_ucs2((S8*)num_ucs2, (S8*)g_ucm_p->mo_info.dial_num.num_uri, num_len);
    
    mmi_ucm_app_make_call(g_ucm_p->mo_info.dial_type, (U8*) num_ucs2);

    OslMfree(num_ucs2);

    if (g_ucm_p->mo_info.callback != NULL)
    {
        g_ucm_p->mo_info.callback((void*)g_ucm_p->mo_info.callback_para);
    }    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_dial_option_make_call_sendkey
 * DESCRIPTION
 *  Funtion is called when make call from dial option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_dial_option_make_call_exec_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);
    DeleteScreenIfPresent(SCR_ID_UCM_DIAL_CALL_TYPE_MENU);

    switch (g_ucm_p->call_misc.entry_type)
    {
        case MMI_UCM_ENTRY_SEND_KEY:
        {
            mmi_ucm_exec_sendkey_hdlr();
        }
        break;
        
        case MMI_UCM_ENTRY_CENTER_KEY:
        {
            mmi_ucm_exec_centerkey_hdlr();
        }
        break;

        case MMI_UCM_ENTRY_MENU:
        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return;        
}


#ifdef __MMI_BG_SOUND_EFFECT__
/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_cancel_bgs_effect_select
 * DESCRIPTION
 *  Background sound effect selection screen exit function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_cancel_bgs_effect_select(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_bgsnd_common_mtmo_reset_state(MMI_FALSE);
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_entry_bgs_effect_select
 * DESCRIPTION
 *  Background sound effect selection screen entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_entry_bgs_effect_select(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer = NULL;
    S32 number_of_effect = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_UCM_BGS_EFFECT_SELECT, NULL, mmi_ucm_entry_bgs_effect_select, NULL);

    RegisterHighlightHandler(mmi_ucm_bgs_effect_highlight_hdlr);

    gui_buffer = GetCurrGuiBuffer(SCR_ID_UCM_BGS_EFFECT_SELECT);

    /* Fill effect list data */
    number_of_effect = (S32)mmi_bgsnd_common_mtmo_prepare_effect_list((PS8*)subMenuDataPtrs, MAX_SUB_MENUS, MAX_SUB_MENU_SIZE);

    ShowCategory89Screen(
        STR_ID_UCM_BACKGROUND_SOUND,
        0,
        STR_GLOBAL_SELECT,
        0,
        STR_GLOBAL_BACK,
        0,
        number_of_effect,
        subMenuDataPtrs,
        NULL,
        0,
        (S32)mmi_bgsnd_common_get_mtmo_bgs_curr_effect(),
        NULL);

    SetRightSoftkeyFunction(mmi_ucm_cancel_bgs_effect_select, KEY_EVENT_UP);
    SetKeyHandler(mmi_ucm_cancel_bgs_effect_select, KEY_LEFT_ARROW, KEY_EVENT_DOWN);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_bgs_effect_highlight_hdlr
 * DESCRIPTION
 *  This function is the highlight handler of sound effect list during call
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_bgs_effect_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION("\n[mmi_ucm_bgs_effect_highlight_hdlr] mmi_bgsnd_common_mtmo_set_highlight_index: %d\n", index);
    MMI_ASSERT(mmi_bgsnd_common_mtmo_set_highlight_index((U16)index));

    if (mmi_bgsnd_common_mtmo_check_ext_file_format() == BGSND_NO_EFFECT)
    {
        ChangeLeftSoftkey(0, 0);
        SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);    
        SetKeyHandler(NULL, KEY_SEND, KEY_EVENT_DOWN);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_SELECT, 0);
        SetLeftSoftkeyFunction(mmi_ucm_bgs_effect_select, KEY_EVENT_UP);    
        SetKeyHandler(mmi_ucm_bgs_effect_select, KEY_SEND, KEY_EVENT_DOWN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ucm_bgs_effect_highlight_hdlr
 * DESCRIPTION
 *  This function is the highlight handler of sound effect list during call
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ucm_bgs_effect_select(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 check_result = mmi_bgsnd_common_mtmo_check_ext_file_format();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (check_result == BGSND_AUDIO_SUCCESS)
    {
        mmi_bgsnd_common_mtmo_reset_state(MMI_TRUE);

        /* Incoming call option */
        if (mmi_ucm_get_incoming_group(MMI_UCM_CALL_TYPE_NO_DATA_CSD, g_ucm_p->call_misc.index_list))
        {
            mmi_ucm_incoming_call_sendkey();
        }
        /* Outgoing call */
        else
        {
            U8* ucs2_num = OslMalloc(MMI_UCM_MAX_NUM_URI_LEN * ENCODING_LENGTH);

            mmi_asc_n_to_ucs2((S8*)ucs2_num, (S8*)g_ucm_p->mo_info.dial_num.num_uri, MMI_UCM_MAX_NUM_URI_LEN);
            g_ucm_p->call_misc.is_bgs_selected = TRUE;
            mmi_ucm_app_make_call(g_ucm_p->mo_info.dial_type, ucs2_num);

            OslMfree(ucs2_num);
        }
    }
#ifdef __USB_IN_NORMAL_MODE__
    else if (check_result == BGSND_USB_NOT_ALLOWED)
    {
        mmi_usb_app_unavailable_popup(0);
    }
#endif /* __USB_IN_NORMAL_MODE__ */
    else
    {
        DisplayPopup(
            (PU8) GetString(mmi_bgsnd_common_get_uniform_popup_string_id(check_result)),
            IMG_GLOBAL_UNFINISHED,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            (U8) ERROR_TONE);
    }
}

#endif /* __MMI_BG_SOUND_EFFECT__ */

#endif /* __MMI_UCM__ */

