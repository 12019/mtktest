/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * UnifiedComposerMiscell.c
 *
 * Project:
 * --------
 * MAUI
 *
 * Description:
 * ------------
 * This file implements miscell utilities for Unified Composer application.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#include "MMI_include.h"
#ifndef _MMI_UNIFIED_COMPOSER_MISCELL_C
#define _MMI_UNIFIED_COMPOSER_MISCELL_C

#ifdef __MMI_UNIFIED_COMPOSER__

#include "FileManagerGProt.h"
#include "FileMgr.h"
#include "Fmt_struct.h"

#include "mdi_datatype.h"
#include "mdi_audio.h"
#if defined(__MMI_VIDEO_PLAYER__) || defined(__MMI_VIDEO_RECORDER__)
#include "mdi_video.h"
#endif 
/* micha1230 */
#include "custom_nvram_editor_data_item.h"
#include "custom_data_account.h"

#include "Conversions.h"


#include "CommonScreens.h"
#include "SettingProfile.h"
#include "PhoneBookGprot.h"

#include "wgui_status_icons.h"
#include "gpioInc.h"
#include "MessagesresourceData.h"
#include "MessagesMiscell.h"
#include "SmsGuiInterfaceProt.h"
#include "SmsGuiInterfaceType.h"
#include "SmsPsHandler.h"
#include "mmi_msg_context.h"
#include "xml_def.h"
#include "CallManagementGprot.h"

/* ASM */

#include "lcd_sw_rnd.h"

#include "USBDeviceGprot.h"
#include "app_base64.h"
#include "app_usedetails.h"
#include "SMSApi.h"
#include "SMSStruct.h"

#include "wapadp.h"
#include "mmsadp.h"
#include "wap_ps_struct.h"
#include "custom_wap_config.h"

#include "med_api.h"
#include "app_asyncfile.h"

#include "customer_ps_inc.h"

#include "UnifiedMessageGProt.h"
#include "custom_uc_config.h"
#include "UnifiedComposerResDef.h"
#include "UnifiedComposerGProt.h"
#include "UnifiedComposerProt.h"

/***************************************************************************** 
* Local Variable
*****************************************************************************/
const S8 g_uc_three_dot[] = { '.', '\0', '.', '\0', '.', '\0', '\0', '\0' };

/***************************************************************************** 
* Extern Function
*****************************************************************************/
extern EMSData *GetEMSDataForEdit(EMSData **p, U8 force);
extern int mmi_charset_utf8_to_ucs2_length_in_bytes(const kal_uint8 *raw);
extern int mmi_charset_ucs2_to_utf8_length_in_bytes(const kal_uint8 *raw);
extern kal_uint16 EMSUsableTextLen(kal_uint8   dcs);
extern EMSTATUS EMSCalculateSeg(kal_uint8   dcs,kal_uint16  num_byte, kal_uint8   *usedSegment);


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_init_context
 * DESCRIPTION
 *  Initialize Unified Composer context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_init_context(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(g_uc_p, 0 , sizeof(mmi_uc_context_struct));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_adm_mem
 * DESCRIPTION
 *  Create adm memory for UC
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_create_adm_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    g_uc_p->main.mem_pool_id = kal_adm_create(mmi_uc_adm_mem,
                                              MMI_UC_ADM_MEM_SIZE,
                                              NULL,
                                              KAL_FALSE);

    MMI_ASSERT(g_uc_p->main.mem_pool_id);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_add_address
 * DESCRIPTION
 *  add address function
 * PARAMETERS
 *  void
 * RETURNS
 *  TRUE means add successfully. Otherwise FALSE.
 *****************************************************************************/
BOOL mmi_uc_add_address(U8* ucs2_addr, mmi_uc_address_type_enum type, mmi_uc_address_group_type_enum group)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_addr_struct** addr_head = &(g_uc_p->msg.to_head);
    mmi_uc_addr_struct* addr_tail = NULL;
    mmi_uc_addr_struct* addr_new = NULL;
    U8 ascii_addr[MMI_UC_MAX_EMAIL_LEN + 1]; 
    U8 addr_num_calculated = 0;
    U8* addr_num = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (group)
    {
        case MMI_UC_ADDRESS_GROUP_TYPE_TO:
        {
            addr_tail = g_uc_p->msg.to_head;
            addr_head = &(g_uc_p->msg.to_head);
            addr_num = &(g_uc_p->msg.to_num);
        }
        break;
        
        case MMI_UC_ADDRESS_GROUP_TYPE_CC:
        {
            addr_tail = g_uc_p->msg.cc_head;
            addr_head = &(g_uc_p->msg.cc_head);
            addr_num = &(g_uc_p->msg.cc_num);
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_BCC:
        {
            addr_tail = g_uc_p->msg.bcc_head;
            addr_head = &(g_uc_p->msg.bcc_head);
            addr_num = &(g_uc_p->msg.bcc_num);
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_FROM:
        {
            addr_tail = g_uc_p->msg.from;
            addr_head = &(g_uc_p->msg.from);
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;        
    }
    
    if (type == MMI_UC_ADDRESS_TYPE_PHONE_NUMBER)
    {
        memset(ascii_addr, 0, sizeof(ascii_addr));
        mmi_ucs2_n_to_asc((S8*) ascii_addr, (S8*) ucs2_addr, MMI_UC_MAX_PHONE_NUMBER_LEN * ENCODING_LENGTH);
    }

    if (group != MMI_UC_ADDRESS_GROUP_TYPE_FROM)
    {
        if (addr_tail == NULL)
        {
            addr_num_calculated = 0;
        }
        else
        {
            addr_num_calculated = 1;
            
            for (; addr_tail->next != NULL ; addr_tail = addr_tail->next)
            {
                addr_num_calculated++;
            }
        }

        MMI_ASSERT((addr_num_calculated == (*addr_num)));
    }

    addr_new = kal_adm_alloc(g_uc_p->main.mem_pool_id, sizeof(mmi_uc_addr_struct));

    MMI_ASSERT(addr_new);

    addr_new->type = type;
    addr_new->group = group;    
    addr_new->next = NULL;

    if (addr_new->type == MMI_UC_ADDRESS_TYPE_PHONE_NUMBER)
    {
        U16 len = strlen((char*)ascii_addr);

        if (len > MMI_UC_MAX_PHONE_NUMBER_LEN)
        {
            kal_adm_free(g_uc_p->main.mem_pool_id, addr_new);
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMisc.c]mmi_uc_add_address, len(%d) > MMI_UC_MAX_ADDR_LEN*\n",len);
            return MMI_FALSE;
        }
        
        addr_new->addr = kal_adm_alloc(g_uc_p->main.mem_pool_id, len + 1);
        MMI_ASSERT(addr_new->addr);
        
        memset(addr_new->addr, 0, len + 1);
        memcpy(addr_new->addr, ascii_addr, len);        
    }
    else if (addr_new->type == MMI_UC_ADDRESS_TYPE_EMAIL)
    {    
        U16 len = mmi_ucs2strlen((S8*)ucs2_addr);

        if (len > MMI_UC_MAX_EMAIL_LEN)
        {
            kal_adm_free(g_uc_p->main.mem_pool_id, addr_new);
            return MMI_FALSE;
        }
        
        addr_new->addr = kal_adm_alloc(g_uc_p->main.mem_pool_id, ((len + 1) * ENCODING_LENGTH));
        MMI_ASSERT(addr_new->addr);

        memset(addr_new->addr, 0, ((len + 1) * ENCODING_LENGTH));        
        memcpy(addr_new->addr, ucs2_addr, (len * ENCODING_LENGTH));        
    }
    else
    {
        MMI_ASSERT(0);
    }

    /* First entry */
    if (addr_tail == NULL)
    {
        addr_new->previous = NULL;
        
        *addr_head = addr_new;
    }
    else
    {
        addr_new->previous = addr_tail;
        addr_tail->next = addr_new;
    }

    if (group != MMI_UC_ADDRESS_GROUP_TYPE_FROM)
    {
        (*addr_num) = (*addr_num) + 1;
    }

    return MMI_TRUE;
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_duplicate_address
 * DESCRIPTION
 *  Check duplicate address function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_addr_struct* mmi_uc_check_duplicate_address(U8* ucs2_addr, mmi_uc_address_type_enum type, mmi_uc_address_group_type_enum group)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_addr_struct* addr_tail = NULL;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (group)
    {
        case MMI_UC_ADDRESS_GROUP_TYPE_TO:
        {
            addr_tail = g_uc_p->msg.to_head;
        }
        break;
        
        case MMI_UC_ADDRESS_GROUP_TYPE_CC:
        {
            addr_tail = g_uc_p->msg.cc_head;
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_BCC:
        {
            addr_tail = g_uc_p->msg.bcc_head;
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_FROM:
        {
            addr_tail = g_uc_p->msg.from;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;        
    }
    
    if (type == MMI_UC_ADDRESS_TYPE_PHONE_NUMBER)
    {
        U8 addr[(MMI_UC_MAX_PHONE_NUMBER_LEN + 1) * ENCODING_LENGTH];
        
        memset(addr, 0, sizeof(addr));
        mmi_ucs2_n_to_asc((S8*) addr, (S8*) ucs2_addr, MMI_UC_MAX_PHONE_NUMBER_LEN * ENCODING_LENGTH);

        for (; addr_tail != NULL ; addr_tail = addr_tail->next)
        {
            if (addr_tail->type != MMI_UC_ADDRESS_TYPE_PHONE_NUMBER)
            {
                continue;
            }
            
            //if (strcmp((char*)addr, (char*)addr_tail->addr) == 0)
            if (ComparePhoneNum(addr, addr_tail->addr) == MMI_TRUE )
            {
                return addr_tail;
            }
        }
    }
    else if (type == MMI_UC_ADDRESS_TYPE_EMAIL)
    {
        for (; addr_tail != NULL ; addr_tail = addr_tail->next)
        {
            if (addr_tail->type != MMI_UC_ADDRESS_TYPE_EMAIL)
            {
                continue;
            }
        
            //if (mmi_ucs2cmp((S8*)ucs2_addr, (S8*)addr_tail->addr) == 0)
            if (mmi_uc_compare_string_ignore_case((U16*)ucs2_addr, (U16*)addr_tail->addr) == MMI_TRUE)
            {
                return addr_tail;
            }
        }        
    }
    else
    {
        MMI_ASSERT(0);
    }

    return NULL;
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_duplicate_address_with_start_addr
 * DESCRIPTION
 *  Check duplicate address function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_addr_struct* mmi_uc_check_duplicate_address_with_start_addr(U8* ucs2_addr, mmi_uc_address_type_enum type, mmi_uc_addr_struct* start_addr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_addr_struct* addr_tail = start_addr;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (addr_tail == NULL)
    {
        return NULL;
    }
    
    if (type == MMI_UC_ADDRESS_TYPE_PHONE_NUMBER)
    {
        U8 addr[(MMI_UC_MAX_PHONE_NUMBER_LEN + 1) * ENCODING_LENGTH];
        
        memset(addr, 0, sizeof(addr));
        mmi_ucs2_n_to_asc((S8*) addr, (S8*) ucs2_addr, MMI_UC_MAX_PHONE_NUMBER_LEN * ENCODING_LENGTH);

        for (; addr_tail != NULL ; addr_tail = addr_tail->next)
        {
            if (addr_tail->type != MMI_UC_ADDRESS_TYPE_PHONE_NUMBER)
            {
                continue;
            }
            
            if (ComparePhoneNum(addr, addr_tail->addr) == MMI_TRUE )
            {
                return addr_tail;
            }
        }
    }
    else if (type == MMI_UC_ADDRESS_TYPE_EMAIL)
    {
        for (; addr_tail != NULL ; addr_tail = addr_tail->next)
        {
            if (addr_tail->type != MMI_UC_ADDRESS_TYPE_EMAIL)
            {
                continue;
            }
        
            if (mmi_uc_compare_string_ignore_case((U16*)ucs2_addr, (U16*)addr_tail->addr) == MMI_TRUE)
            {
                return addr_tail;
            }
        }        
    }
    else
    {
        MMI_ASSERT(0);
    }

    return NULL;
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_change_msg_type_if_needed
 * DESCRIPTION
 *  Change msg type if needed.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_change_msg_type_if_needed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_msg_type_enum msg_type;
            

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*[UnifiedComposerMiscell.c] mmi_uc_change_msg_type_if_needed curr=%d spec=%d set=%d*\n",
                         g_uc_p->msg_type.curr_msg_type, 
                         g_uc_p->msg_type.caller_specific_msg_type,
                         g_uc_p->msg_type.setting_msg_type);

    msg_type = mmi_uc_determine_msg_type_by_content();

    switch (g_uc_p->msg_type.caller_specific_msg_type )
    {
        case MMI_UC_MSG_TYPE_SMS_ONLY:
        {
            MMI_ASSERT(g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER);
        }
        break;
        
        case MMI_UC_MSG_TYPE_MMS_ONLY:
        {
            MMI_ASSERT(g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER);
        }
        break;

        case MMI_UC_MSG_TYPE_DEFAULT:
        {                        
            if (g_uc_p->msg_type.setting_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
            {                
                if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
                {                    
                    if (msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
                    {
                        g_uc_p->msg_type.curr_msg_type = MMI_UC_MSG_TYPE_SMS_PREFER;
                        return TRUE;
                    }
                }
                else if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
                {
                    if (msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
                    {
                        g_uc_p->msg_type.curr_msg_type = MMI_UC_MSG_TYPE_MMS_PREFER;
                        return TRUE;
                    }
                }
                else
                {
                    MMI_ASSERT(0);
                }
            }
            else if (g_uc_p->msg_type.setting_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
            {
                if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
                {                    
                    /* Do nothing. */
                }
                else if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
                {
                    MMI_ASSERT(0);
                }
                else
                {
                    MMI_ASSERT(0);
                }
            }
            else
            {
                MMI_ASSERT(0);
            }
        }
        break;

        case MMI_UC_MSG_TYPE_SMS_PREFER:
        {
            if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
            {                    
                if (msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
                {
                    g_uc_p->msg_type.curr_msg_type = MMI_UC_MSG_TYPE_SMS_PREFER;
                    return TRUE;
                }
            }
            else if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
            {
                if (msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
                {
                    g_uc_p->msg_type.curr_msg_type = MMI_UC_MSG_TYPE_MMS_PREFER;
                    return TRUE;
                }
            }
            else
            {
                MMI_ASSERT(0);
            }
        }
        break;

        case MMI_UC_MSG_TYPE_MMS_PREFER:
        {
            if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
            {                    
                /* Do nothing. */
            }
            else if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
            {
                MMI_ASSERT(0);
            }
            else
            {
                MMI_ASSERT(0);
            }
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
    }       
    
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_determine_msg_type_by_content
 * DESCRIPTION
 *  Determine msg type according to current msg content
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_msg_type_enum mmi_uc_determine_msg_type_by_content(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_uc_p->msg.cc_num > 0)
    {        
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content cc=%d *\n",
                     g_uc_p->msg.cc_num);
        
        return MMI_UC_MSG_TYPE_MMS_PREFER;
    } 
    else if (g_uc_p->msg.bcc_num > 0)
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content bcc=%d *\n",
                     g_uc_p->msg.bcc_num);
        
        return MMI_UC_MSG_TYPE_MMS_PREFER;
    }    
    else if (mmi_ucs2strlen((S8*)g_uc_p->msg.subject))
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,"*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content subject *\n");
        
        return MMI_UC_MSG_TYPE_MMS_PREFER;
    }    
    else if (g_uc_p->msg.total_slide_num > 1)
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content slide=%d *\n",
                     g_uc_p->msg.total_slide_num);
        
        return MMI_UC_MSG_TYPE_MMS_PREFER;
    }
    else if (g_uc_p->msg.total_object_num > 1)
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content object=%d *\n",
                     g_uc_p->msg.total_object_num);
        
        return MMI_UC_MSG_TYPE_MMS_PREFER;
    }    
    else if ((g_uc_p->msg.total_object_num == 1) &&
             (g_uc_p->msg.object_head->type != MMI_UC_OBJECT_TYPE_TEXT))
    {    
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, 
                     "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content one object *\n");
        
        return MMI_UC_MSG_TYPE_MMS_PREFER;
    }    
    else
    {
        mmi_uc_addr_struct* addr = g_uc_p->msg.to_head;

        for (; addr != NULL; addr = addr->next)
        {
            if (addr->type == MMI_UC_ADDRESS_TYPE_EMAIL)
            {            
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, 
                         "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content email addr *\n");
                
                return MMI_UC_MSG_TYPE_MMS_PREFER;
            }
        }

        /* Add text object when the UC screen is exited */
        //MMI_ASSERT(g_uc_p->msg.current_slide->text.object);

        if (g_uc_p->msg.current_slide)
        {
            if (mmi_uc_get_sms_segment_number() > mmi_uc_custom_get_max_mo_sms_segment())
            {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, 
                         "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content segment exceed *\n");
                
                return MMI_UC_MSG_TYPE_MMS_PREFER;
            }
            
            if (g_uc_p->msg.current_slide->text.UCS2_count)
            {
                if (g_uc_p->msg.current_slide->text.char_count > g_uc_p->sms_info.max_ucs2_char_num)
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, 
                             "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content ucs2 text size exceed *\n");
                    
                    return MMI_UC_MSG_TYPE_MMS_PREFER;
                }
            }
            else if (g_uc_p->msg.current_slide->text.char_count)
            {
                if (g_uc_p->msg.current_slide->text.char_count + g_uc_p->msg.current_slide->text.extension_char_count > 
                    g_uc_p->sms_info.max_gsm7bit_char_num)
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, 
                             "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content ascii text size exceed *\n");
                    
                    return MMI_UC_MSG_TYPE_MMS_PREFER;
                }
            }
        }
    }
    
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, 
                             "*[UnifiedComposerMiscell.c] mmi_uc_determine_msg_type_by_content SMS *\n");

    return  MMI_UC_MSG_TYPE_SMS_PREFER;    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_update_msg_size
 * DESCRIPTION
 *  Update msg size
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_update_msg_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
            

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (g_uc_p->send_info.existed_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER &&
        (g_uc_p->main.state == MMI_UC_STATE_FORWARD || g_uc_p->main.state == MMI_UC_STATE_SEND))
    {
        g_uc_p->msg.msg_size = wap_mma_uc_calc_header_size(&g_uc_p->msg) + g_uc_p->msg.msg_body_size;
    }
    else
    {
        g_uc_p->msg.msg_size = wap_mma_uc_calc_msg_size(&g_uc_p->msg);            

    }
    
    if (g_uc_p->msg.current_slide)
    {
        g_uc_p->msg.msg_size_without_text_buffer = g_uc_p->msg.msg_size - g_uc_p->msg.current_slide->text.utf8_msg_len;
    }
    else
    {
        g_uc_p->msg.msg_size_without_text_buffer = g_uc_p->msg.msg_size;
    }

    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                 "*[UnifiedComposerMiscell.c] mmi_uc_update_msg_size msg_size=%d msg_size_wo_text=%d *\n",
                 g_uc_p->msg.msg_size,
                 g_uc_p->msg.msg_size_without_text_buffer);

    MMI_ASSERT(g_uc_p->msg.msg_size_without_text_buffer <= g_uc_p->msg.msg_size);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_addr_struct
 * DESCRIPTION
 *  get current highlighted address
 * PARAMETERS
 *  void
 * RETURNS
 *  current highlighted address
 *****************************************************************************/
mmi_uc_addr_struct* mmi_uc_get_highlighted_addr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_addr_struct* addr = NULL;
    U32 addr_num = 0;
    U32 i = 0;        

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    switch(g_uc_p->done.current_addr_type)
    {
        case MMI_UC_ADDRESS_GROUP_TYPE_TO:
        {
            addr = g_uc_p->msg.to_head;
            addr_num = g_uc_p->msg.to_num;
        }
        break;
        
        case MMI_UC_ADDRESS_GROUP_TYPE_CC:
        {
            addr = g_uc_p->msg.cc_head;
            addr_num = g_uc_p->msg.cc_num;            
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_BCC:
        {
            addr = g_uc_p->msg.bcc_head;
            addr_num = g_uc_p->msg.bcc_num;            
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    MMI_ASSERT(g_uc_p->done.current_addr_index < addr_num);

    for( ; i < g_uc_p->done.current_addr_index; addr = addr->next)
    {
        i++;
        MMI_ASSERT(addr->next);
    }

    return addr;    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_free_addr_memory
 * DESCRIPTION
 *  free address memory
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_free_addr_memory(mmi_uc_addr_struct* addr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  

    MMI_ASSERT(addr);

    if (addr->addr)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, addr->addr);
    }
    
    kal_adm_free(g_uc_p->main.mem_pool_id, addr);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_addr
 * DESCRIPTION
 *  Delete address
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_delete_addr(mmi_uc_addr_struct* address)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_addr_struct* addr = address;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (addr->group)
    {
        case MMI_UC_ADDRESS_GROUP_TYPE_TO:
        {
            if (g_uc_p->msg.to_num == 1)
            {
                g_uc_p->msg.to_num = 0;
                g_uc_p->msg.to_head = NULL;
            }
            else
            {
                g_uc_p->msg.to_num--;

                /* The first entry */
                if (addr == g_uc_p->msg.to_head)
                {
                    g_uc_p->msg.to_head = addr->next;
                    addr->next->previous = NULL;                    
                }
                /* The last entry */
                else if (addr->next == NULL)
                {
                    addr->previous->next = NULL;                    
                }
                else
                {
                    addr->next->previous = addr->previous;
                    addr->previous->next = addr->next;
                }
            }
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_CC:
        {
            if (g_uc_p->msg.cc_num == 1)
            {
                g_uc_p->msg.cc_num = 0;
                g_uc_p->msg.cc_head = NULL;
            }
            else
            {
                g_uc_p->msg.cc_num--;

                /* The first entry */
                if (addr == g_uc_p->msg.cc_head)
                {
                    g_uc_p->msg.cc_head = addr->next;
                    addr->next->previous = NULL;                    
                }
                /* The last entry */
                else if (addr->next == NULL)
                {
                    addr->previous->next = NULL;                    
                }
                else
                {
                    addr->next->previous = addr->previous;
                    addr->previous->next = addr->next;
                }                
            }
        }
        break;
        
        case MMI_UC_ADDRESS_GROUP_TYPE_BCC:
        {
            if (g_uc_p->msg.bcc_num == 1)
            {
                g_uc_p->msg.bcc_num = 0;
                g_uc_p->msg.bcc_head = NULL;
            }
            else
            {
                g_uc_p->msg.bcc_num--;

                /* The first entry */
                if (addr == g_uc_p->msg.bcc_head)
                {
                    g_uc_p->msg.bcc_head = addr->next;
                    addr->next->previous = NULL;                    
                }
                /* The last entry */
                else if (addr->next == NULL)
                {
                    addr->previous->next = NULL;                    
                }
                else
                {
                    addr->next->previous = addr->previous;
                    addr->previous->next = addr->next;
                }               
            }
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_FROM:
        {
            mmi_uc_free_addr_memory(addr);
            g_uc_p->msg.from = NULL;
            return;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;        
    } 
    mmi_uc_free_addr_memory(addr);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_all_addr
 * DESCRIPTION
 *  Delete group address address
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_delete_all_addr(mmi_uc_address_group_type_enum group)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_addr_struct* addr = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do
    {
        switch (group)
        {
            case MMI_UC_ADDRESS_GROUP_TYPE_TO:
            {
                addr = g_uc_p->msg.to_head;
            }
            break;
            
            case MMI_UC_ADDRESS_GROUP_TYPE_CC:
            {
                addr = g_uc_p->msg.cc_head;
            }
            break;

            case MMI_UC_ADDRESS_GROUP_TYPE_BCC:
            {
                addr = g_uc_p->msg.bcc_head;
            }
            break;

            default:
            {
                MMI_ASSERT(0);
            }
            break;        
        }

        if (addr != NULL)
        {
            mmi_uc_delete_addr(addr);
        }
        else
        {
            break;
        }
    }while(TRUE);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_copy_with_dot
 * DESCRIPTION
 *  Append three dots to the end of string
 * PARAMETERS
 *  source      [IN]            Source buffer.
 *  dest        [IN/OUT]        Destination buffer.
 *  max_len     [IN]            Max characters can be put in destination buffer
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_copy_with_dot(S8 *dest, S8 *source, S32 max_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ucs2strlen(source) <= max_len)
    {
        mmi_ucs2cpy((S8*) dest, (S8*) source);
    }
    else
    {
        /* do not clear end of string because mmi_ucs2ncpy will auto set NULL terminate */
        mmi_ucs2ncpy((S8*) dest, (S8*) source, max_len - 3);
        mmi_ucs2cat((S8*) dest, (S8*) g_uc_three_dot);
    }
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_VCARD__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_VCARD__ */ 
#ifdef __MMI_VCALENDAR__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_VCALENDAR__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if defined(__DRM_V02__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#ifdef __MMI_BARCODEREADER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if defined(__MMI_DOWNLOADABLE_THEMES_SUPPORT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /*if 0*/

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_to_mms_insert_type
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_convert_to_mms_insert_type(mmi_uc_object_type object_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (object_type)
    {
        case MMI_UC_OBJECT_TYPE_IMAGE:
        {
            return MMA_INSERT_IMAGE;
        }
        break;

        case MMI_UC_OBJECT_TYPE_AUDIO:
        {
            return MMA_INSERT_AUDIO;
        }
        break;

        case MMI_UC_OBJECT_TYPE_VIDEO:
        {
            return MMA_INSERT_VIDEO;
        }
        break;

        case MMI_UC_OBJECT_TYPE_ATTACHMENT:
        {
            return MMA_INSERT_ATTACHMENT;
        }
        break;

        case MMI_UC_OBJECT_TYPE_TEXT:
        {
            return MMA_INSERT_TEXT;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return MMA_INSERT_UNKNOWN;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_mms_insert_type_to_uc
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_object_type mmi_uc_convert_mms_insert_type_to_uc(U32 object_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (object_type)
    {
        case MMA_INSERT_IMAGE:
        {
            return  MMI_UC_OBJECT_TYPE_IMAGE;
        }
        break;

        case MMA_INSERT_AUDIO:
        {
            return  MMI_UC_OBJECT_TYPE_AUDIO;
        }
        break;

        case MMA_INSERT_VIDEO:
        {
            return  MMI_UC_OBJECT_TYPE_VIDEO;
        }
        break;

        case MMA_INSERT_ATTACHMENT:
        {
            return  MMI_UC_OBJECT_TYPE_ATTACHMENT;
        }
        break;

        case MMA_INSERT_TEXT:
        {
            return  MMI_UC_OBJECT_TYPE_TEXT;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return 0;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_to_editor_object_type
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_convert_to_editor_object_type(mmi_uc_object_type object_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (object_type)
    {
        case MMI_UC_OBJECT_TYPE_IMAGE:
        {
            return WGUI_UCE_OBJECT_TYPE_IMAGE;
        }
        break;

        case MMI_UC_OBJECT_TYPE_AUDIO:
        {
            return WGUI_UCE_OBJECT_TYPE_AUDIO;
        }
        break;

        case MMI_UC_OBJECT_TYPE_VIDEO:
        {
            return WGUI_UCE_OBJECT_TYPE_VIDEO;
        }
        break;

        case MMI_UC_OBJECT_TYPE_ATTACHMENT:
        {
            return WGUI_UCE_OBJECT_TYPE_ATTACHMENT;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_to_editor_msg_type
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_convert_to_editor_msg_type(mmi_uc_msg_type_enum msg_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (msg_type)
    {
        case MMI_UC_MSG_TYPE_SMS_PREFER:
        case MMI_UC_MSG_TYPE_SMS_ONLY:
        {
            return WGUI_UCE_MSG_TYPE_SMS;
        }
        break;

        case MMI_UC_MSG_TYPE_MMS_PREFER:
        case MMI_UC_MSG_TYPE_MMS_ONLY:
        {
            return WGUI_UCE_MSG_TYPE_MMS;
        }
        break;
        
        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_display_popup
 * DESCRIPTION
 *  Display result popup
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_display_popup(mmi_uc_result result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (result)
    {
        case MMI_UC_OK:
        {
            DisplayPopup(
                (PU8) GetString(STR_GLOBAL_OK),
                IMG_GLOBAL_ACTIVATED,
                1,
                MMI_UC_POPUP_TIME_OUT,
                (U8) SUCCESS_TONE);
        }
        break;

        case MMI_UC_SIZE_EXCEEDS:
        {
            
            DisplayPopup(
                    (PU8) GetString(STR_UC_MSG_SIZE_EXCEED_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMI_UC_SIZE_NOT_ENOUGH_FOR_REC_VIDEO:
        {
            
            DisplayPopup(
                    (PU8) GetString(STR_UC_SIZE_NOT_ENOUGH_FOR_REC_VIDEO_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMI_UC_PROHIBIT_BY_CREATION_MODE:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_PROHIBIT_BY_CREATION_MODE_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMI_UC_PROHIBIT_BY_DRM:
        {
            DisplayPopup(
                (PU8) GetString(STR_GLOBAL_DRM_PROHIBITED),
                IMG_GLOBAL_WARNING,
                1,
                MMI_UC_POPUP_TIME_OUT,
                (U8) WARNING_TONE);
        }
        break;

/*Because editor already play the error tone, therefore for no space case, app(UC) should not play tone again, fill tone ID =0*/
        case MMI_UC_NO_SPACE:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_NO_SPACE_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) 0);
        }
        break;

        case MMI_UC_STORAGE_FULL:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_STORAGE_FULL_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMI_UC_XML_ERROR:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_CONTENT_ERROR_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMI_UC_ERROR:
        {
            DisplayPopup(
                    (PU8) GetString(STR_GLOBAL_UNFINISHED),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMI_UC_NOT_SUPPORT:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_NOT_SUPPORT_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;
        case MMI_UC_FILE_CORRUPT:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_FILE_CORRUPT_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMI_UC_FILE_EMPTY:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_FILE_EMPTY_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;


        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_display_mma_result_popup
 * DESCRIPTION
 *  Display result popup
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_display_mma_result_popup(mma_result_enum result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (result)
    {
        case MMA_RESULT_OK:
        {
            DisplayPopup(
                (PU8) GetString(STR_GLOBAL_OK),
                IMG_GLOBAL_ACTIVATED,
                1,
                MMI_UC_POPUP_TIME_OUT,
                (U8) SUCCESS_TONE);
        }
        break;

        case MMA_RESULT_FAIL_UNSUPPORT_CONTENT:
        {
            
            DisplayPopup(
                    (PU8) GetString(STR_UC_UNSUPPORT_CONTENT_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_CREATION_MODE_MAX_MSG_SIZE_REACHED:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_CREATION_MODE_MAX_MSG_SIZE_REACHED_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_MAX_SLIDE_NUM_REACHED:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_MAX_SLIDE_NUM_REACHED_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_USERDEF_TEMPLATE_FULL:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_MAX_TEMPLATE_ALREADY_PRESENT_ID),
                    0,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_MAX_MSG_NUM_REACHED:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_TOO_MANY_MSG_ID),
                    0,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        
        case MMA_RESULT_FAIL_INSUFFICIENT_STORAGE:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_STORAGE_FULL_DELETE_FILE_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;
        case MMA_RESULT_FAIL_FILE_IO:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_STORAGE_FILE_IO_ERROR_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_NOT_READY:
        case MMA_RESULT_FAIL_BUSY:
        {
            DisplayPopup(
                    (PU8) GetString(mmi_um_get_not_available_string_id()),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        default:
        {
            DisplayPopup(
                    (PU8) GetString(STR_GLOBAL_UNFINISHED),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_display_mma_send_result_popup
 * DESCRIPTION
 *  Display result popup
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_display_mma_send_result_popup(mma_result_enum result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*[UnifiedComposerMiscell.c] mmi_uc_display_mma_send_result_popup fail_string result=%d*\n",
                         result);    

    if (g_uc_p->send_info.fail_cause != NULL && mmi_ucs2strlen((S8*)g_uc_p->send_info.fail_cause))
    {
        
        const S8 * pstr1;
        int msg_size;
        S8  *message = NULL;
        pstr1 = GetString(STR_UC_SERVER_ID);
        msg_size = ( mmi_ucs2strlen(pstr1) + mmi_ucs2strlen((S8*)g_uc_p->send_info.fail_cause) +1 ) * ENCODING_LENGTH; /* +1 for null terminate*/
        message = (S8 *)OslMalloc(msg_size);
        if (NULL == message)
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,"[UC]sendresult pop mem allocate fail"); 
            return;
        }
        
        mmi_ucs2cpy(message, pstr1);
        mmi_ucs2cat(message, (S8*)g_uc_p->send_info.fail_cause);
         
        DisplayPopup(
                (PU8) message,
                0,
                1,
                MMI_UC_POPUP_TIME_OUT,
                (U8) ERROR_TONE);

        OslMfree(message);

        return;
    }
    
    switch (result)
    {
        case MMA_RESULT_OK:
        {
            DisplayPopup(
                (PU8) GetString(STR_UC_SENT_ID),
                IMG_SEND_SUCCESS_PIC_MSG,
                1,
                MMI_UC_POPUP_TIME_OUT,
                (U8) SUCCESS_TONE);
        }
        break;

        case MMA_RESULT_FAIL_USER_CANCEL:
        {
            DisplayPopup(
                (PU8) GetString(STR_UC_ABORTED_ID),
                IMG_GLOBAL_ACTIVATED,
                1,
                MMI_UC_POPUP_TIME_OUT,
                (U8) SUCCESS_TONE);
        }
        break;

        case MMA_RESULT_FAIL_COMM_CONFIG_ERROR:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_CONFIG_ERROR_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_COMM_CONNECT_ERROR:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_SEND_FAIL_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_COMM_SERVER_TIMEOUT:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_SERVER_TIMEOUT_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_COMM_SERVER_ERROR:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_SERVER_ERROR_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_COMM_SERVICE_DENIED:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_SERVICE_DENIED_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_COMM_UNSUPPORT_CONTENT:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_UNSUPPORT_CONTENT_BY_SERVER_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_COMM_UNKNOWN_APN:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_UNKNOWN_APN_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_COMM_UNAUTHORIZED:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_UNAUTHORIZED_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMA_RESULT_FAIL_NOT_READY:
        case MMA_RESULT_FAIL_BUSY:
        {
            DisplayPopup(
                    (PU8) GetString(mmi_um_get_not_available_string_id()),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        default:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_SEND_FAIL_ID),
                    IMG_SEND_FAIL_PIC_MSG,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_uc_display_resize_result_popup
 * DESCRIPTION
 *  Display result popup
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_display_resize_result_popup(U16 result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (result)
    {
        case MMI_UC_RESIZING_SUCCEED:
        case MMI_UC_RESIZING_SUCCEED_WITH_UNCHANGED:
        {
            MMI_ASSERT(0);
        }
        break;

        case MMI_UC_RESIZING_FAILED_IN_GDI_ENCODER_ERR_DISK_FULL:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_STORAGE_FULL_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;

        case MMI_UC_RESIZING_FAILED_IN_INSUFFICIENT_DRAWING_BUF:
        case MMI_UC_RESIZING_FAILED_IN_NO_QUOTA:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_SYSTEM_RESOURCES_EXHAUSTED_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;        
        
        case MMI_UC_RESIZING_FAILED_IN_UNKNOWN_DIMENSION:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_FILE_CORRUPT_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;        

        case MMI_UC_RESIZING_FAILED_IN_GDI_FAILED:
        case MMI_UC_RESIZING_FAILED_IN_GDI_ENCODER_ERR_WRITE_PROTECTION:
        case MMI_UC_RESIZING_FAILED_IN_GDI_ENCODER_ERR_NO_DISK:
        default:
        {
            DisplayPopup(
                    (PU8) GetString(STR_UC_FAIL_TO_RESIZE_IMAGE_ID),
                    IMG_GLOBAL_UNFINISHED,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) ERROR_TONE);
        }
        break;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_if_scr_older
 * DESCRIPTION
 *  Check if the screen is older than the base screen in history
 * PARAMETERS
 *  U16 check_scr screen to be checked
 *  U16 base_scr base screen
 * RETURNS
 *  True means the check_scr is older than the base screen in history.
 *  False means the check_scr is newer, it is not in history, or base_scr is not in history
 *****************************************************************************/
MMI_BOOL mmi_uc_check_if_scr_older(U16 check_scr, U16 base_scr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 cur_scr = base_scr;
    U16 pre_scr = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!IsScreenPresent(check_scr))
    {
        return MMI_FALSE;
    }

    if (!IsScreenPresent(base_scr))
    {
        return MMI_FALSE;
    }

    while (GetPreviousScrnIdOf(cur_scr, &pre_scr))
    {
        if (pre_scr == check_scr)
        {
            return MMI_TRUE;
        }

        cur_scr = pre_scr;
        pre_scr = 0;
    }

    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_all_uc_screens
 * DESCRIPTION
 *  delete UC screens if present
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

void mmi_uc_delete_all_uc_screens(void)
{
    U16 startScrnId = 0;
    U16 endScrnId = 0;
    MMI_BOOL IsCurrentScrn = MMI_FALSE; 

    /*cases: 
        1. //no uc
        2. UC - call
        3. call - UC
        4. UC  
    */
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                 "*mmmi_uc_delete_all_uc_screens, g_uc_p->main.state=%d*\n",g_uc_p->main.state);  

    /*decide startScrnId*/
    if (g_uc_p->main.state == MMI_UC_STATE_FORWARD ||
        g_uc_p->main.state == MMI_UC_STATE_SEND)
    {
        startScrnId = SCR_ID_UC_OPT_DONE_OPT;
    }
    else
    {
        startScrnId= SCR_ID_UC_EDITOR;
    }                   

    if (IsScreenPresent(startScrnId))
    {
        IsCurrentScrn = MMI_FALSE;
    }
    else if (GetExitScrnID() == startScrnId)
    {
        IsCurrentScrn = MMI_TRUE;
    }
    else
    {
        /*case 1, no UC*/
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*mmmi_uc_delete_all_uc_screens, case1: no UC screens*\n");  
        return;
    }

    /*the endScrnId will differnt*/
    if (isInCall()) 
    {
        MMI_BOOL UC_is_older;
        GetPreviousScrnIdOf(GetCmMarkerScrnID(), &endScrnId);
        if (endScrnId)
        {
            UC_is_older = mmi_uc_check_if_scr_older(startScrnId,endScrnId); /*chk, base*/

            if (MMI_TRUE == UC_is_older)  /*case2: UC - call*/
            {   
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*mmmi_uc_delete_all_uc_screens, case2: UC - call, start=%d, end=%d*\n",
                         startScrnId,endScrnId);  
                /*UC must in history, IsCurrentScrn should be T*/
                DeleteBetweenScreen(startScrnId, endScrnId);
            }
            else /*case3: call - UC*/
            {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*mmmi_uc_delete_all_uc_screens, case3:call - UC, start=%d, end=%d, IsCurrentScrn=%d*\n",
                         startScrnId,endScrnId,IsCurrentScrn);  
                
                if (MMI_TRUE == IsCurrentScrn)  
                {
                    GoBackHistory();
                }
                else
                {
                    DeleteNScrId(startScrnId); /*delete screen up to start scrn and include start scrn*/
                }
            }
            
        }
        else
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*mmi_uc_delete_all_uc_screens can not get cm's prev screen, cm marker=%d *\n",
                         GetCmMarkerScrnID());    
            MMI_ASSERT(0);
        }
    }
    else  /*case 4, UC*/
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*mmmi_uc_delete_all_uc_screens, case4: UC , start=%d, IsCurrentScrn=%d*\n",
                         startScrnId,IsCurrentScrn); 
        
        if (MMI_TRUE == IsCurrentScrn)  
        {
            GoBackHistory();
        }
        else
        {
            DeleteNScrId(startScrnId); /*delete screen up to start scrn and include start scrn*/
        }
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_mms_check_result
 * DESCRIPTION
 *  Translate mms_uc_insert_check_struct to mmi_uc_result
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_result mmi_uc_convert_mms_check_result(mma_insert_check_struct* check_result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (check_result->result)
    {
        return MMI_UC_OK;
    }
    else
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                 "*mmi_uc_convert_mms_check_result, over=%d, mode=%d, drm=%d ---*\n",check_result->oversize,check_result->creation_mode_violate,check_result->drm_type);
        if ((check_result->oversize) || 
            (check_result->detail_result == MMA_RESULT_FAIL_MAX_MSG_SIZE_REACHED) ||
            (check_result->detail_result == MMA_RESULT_FAIL_CREATION_MODE_MAX_MSG_SIZE_REACHED) )
        {
            return MMI_UC_SIZE_EXCEEDS;
        }

        if (check_result->creation_mode_violate)
        {
            return MMI_UC_PROHIBIT_BY_CREATION_MODE;
        }

        if (check_result->drm_type == MMA_DRM_FL_CD ||
            check_result->drm_type == MMA_DRM_SD_NO_RIGHT)
        {
            return MMI_UC_PROHIBIT_BY_DRM;
        }
        if ( (check_result->detail_result == MMA_RESULT_FAIL_FILE_IO) || (check_result->detail_result == MMA_RESULT_FAIL_FILE_CORRUPTED))
        {
            return MMI_UC_FILE_CORRUPT;
        }

        if (check_result->detail_result == MMA_RESULT_FAIL_FILE_EMPTY)
        {
            return MMI_UC_FILE_EMPTY;
        }
    }
    
    return MMI_UC_NOT_SUPPORT;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_insert_slide
 * DESCRIPTION
 *  Insert empty slide next to cur_slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_slide_struct* mmi_uc_insert_slide(mmi_uc_slide_struct* cur_slide)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_slide_struct* new_slide;
    U32 slide_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    slide_size = sizeof(mmi_uc_slide_struct);
    new_slide = kal_adm_alloc(g_uc_p->main.mem_pool_id, slide_size);
    MMI_ASSERT(new_slide);
    memset(new_slide, 0, slide_size);
    new_slide->text.background_color = MMI_UC_DEFAULT_BG_COLOR;
    new_slide->text.foreground_color = MMI_UC_DEFAULT_FG_COLOR;

    g_uc_p->msg.total_slide_num++;
    new_slide->duration = g_uc_p->mms_info.sliding_time.value;

    MMI_ASSERT(g_uc_p->msg.total_slide_num <= MMI_UC_MAX_MMS_SLIDE_NUM);

    /* First slide */
    if (cur_slide == NULL)
    {
        //MMI_ASSERT( g_uc_p->msg.total_slide_num == 1 );
        new_slide->next = g_uc_p->msg.slide_head;
        new_slide->previous = NULL;

        if (g_uc_p->msg.slide_head)
        {
            g_uc_p->msg.slide_head->previous = new_slide;
        }
        
        g_uc_p->msg.slide_head = new_slide;        

        new_slide->slide_num = 1;

        if (new_slide->next)
        {
            mmi_uc_slide_struct* update_slide = mmi_uc_get_end_slide();            

            while (update_slide != new_slide)
            {
                update_slide->slide_num++;
                mmi_uc_update_text_object_path(update_slide);
                update_slide = update_slide->previous;
            }
        }       
    }
    else
    {
        new_slide->slide_num = cur_slide->slide_num + 1;
        
        new_slide->next = cur_slide->next;
        new_slide->previous = cur_slide;
        
        if (cur_slide->next)
        {
            mmi_uc_slide_struct* update_slide = mmi_uc_get_end_slide(); 
            
            cur_slide->next->previous = new_slide;

            while (update_slide != new_slide)
            {
                update_slide->slide_num++;
                mmi_uc_update_text_object_path(update_slide);
                update_slide = update_slide->previous;
            }
        }                
        cur_slide->next = new_slide;
    }

    return new_slide;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_duplicate_object
 * DESCRIPTION
 *  Check duplicate object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_object_struct* mmi_uc_check_duplicate_object(U16* filePath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_object_struct* obj = g_uc_p->msg.object_head;
    U32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_uc_p->msg.total_object_num == 0)
    {
        MMI_ASSERT(obj == NULL);
        return obj;
    }
    else
    {
        for (; i < g_uc_p->msg.total_object_num ; i++)
        {
            MMI_ASSERT(obj);
            
            if (mmi_ucs2cmp((S8*)obj->file_path, (S8*)filePath) == 0)
            {
                return obj;
            }
            else
            {
                obj = obj->next;
            }
        }            
    }    

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_duplicate_object_by_filename
 * DESCRIPTION
 *  Check duplicate object by file name
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_object_struct* mmi_uc_check_duplicate_object_by_filename(U16* file_name, mmi_uc_object_struct* start_obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_object_struct* obj = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (start_obj == NULL)
    {
        obj = g_uc_p->msg.object_head;
    }
    else
    {
        obj = start_obj;
    }

    for (; obj != NULL ; obj = obj->next)
    {
        MMI_ASSERT(obj);
        
        if (mmi_ucs2cmp((S8*)obj->file_name, (S8*)file_name) == 0)
        {
            return obj;
        }
    }            

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_if_exceed_MMS_size_limitation
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_check_if_exceed_MMS_size_limitation(U32 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMiscell.c] mmi_uc_check_if_exceed_MMS_size_limitation size=%d mms_max_size=%d *\n",
                     size,
                     g_uc_p->mms_info.max_mms_size);

    if (size <= g_uc_p->mms_info.max_mms_size)
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_insert_object_to_slide
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_insert_object_to_slide(mmi_uc_object_struct* object, mmi_uc_slide_struct* slide, mmi_uc_object_type object_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    switch (object_type)
    {
        case MMI_UC_OBJECT_TYPE_IMAGE:
        {
            slide->image.object = object;
            slide->image.begin = MMI_UC_INVALID_VALUE;
            slide->image.end = MMI_UC_INVALID_VALUE;
            object->reference_count++;
        }
        break;

        case MMI_UC_OBJECT_TYPE_AUDIO:
        {
            U32 file_duration = 0;
            slide->audio.object = object;
            /*1. check media file duration*/  
            if (g_uc_p->msg.best_page_duration)
            {
                if(mdi_audio_get_duration(slide->audio.object->file_path, &(file_duration)) != MDI_AUDIO_SUCCESS)
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UC]mdi_audio_get_duration fail");
                    file_duration = 0;
                }
                else
                {
                    file_duration = (file_duration / 1000);
                }

                /*2. update start, duration and end time*/
                slide->audio.begin = 0;
                if (slide->duration < file_duration) 
                {
                    slide->duration = slide->audio.begin + file_duration;
                    slide->audio.end = slide->duration;
                }
                else
                {
                    slide->audio.end = slide->duration;
                }
            }
            else  /*If best page is disable or edit existed msg*/
            {
                slide->audio.begin = MMI_UC_INVALID_VALUE;
                slide->audio.end = MMI_UC_INVALID_VALUE;
            }
            /*3. increase ref count*/
            object->reference_count++;
        }
        break;

        case MMI_UC_OBJECT_TYPE_VIDEO:
        {
#ifdef __MMI_VIDEO_PLAYER__
            mdi_video_info_struct vdo_info;
            MDI_RESULT result;
#endif       
            U32 file_duration = 0;
            slide->video.object = object;

            /*1. check media file duration*/  
            if (g_uc_p->msg.best_page_duration)
            {
#ifdef __MMI_VIDEO_PLAYER__            
                result = mdi_video_ply_open_clip_file((PS8)slide->video.object->file_path, &vdo_info);
                if (result < 0)
                {
                    file_duration = 0;
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UC]mdi_audio_get_duration fail");
                }
                else
                {
                    mdi_video_ply_close_clip_file();
                    file_duration = (vdo_info.total_time_duration / 1000);
                }
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UC]mdi_audio_get_duration =%d",file_duration);
#endif /*__MMI_VIDEO_PLAYER__*/                

                /*2. update start, duration and end time*/
                slide->video.begin = 0;
                if (slide->duration < file_duration) 
                {
                    slide->duration = slide->video.begin + file_duration;
                    slide->video.end = slide->duration;
                }
                else
                {
                    slide->video.end = slide->duration;
                }
            }
            else /*If best page is disable or edit existed msg*/
            {
                slide->video.begin = MMI_UC_INVALID_VALUE;
                slide->video.end = MMI_UC_INVALID_VALUE;
            }
            object->reference_count++;
        }
        break;

        case MMI_UC_OBJECT_TYPE_TEXT:
        {
            slide->text.object = object;
            slide->text.begin = MMI_UC_INVALID_VALUE;
            slide->text.end = MMI_UC_INVALID_VALUE;
            object->reference_count++;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_uc_initialize_editor
 * DESCRIPTION
 *  Initialize editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_editor_initialize()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_uce_initialize_editor(  g_uc_p->main.text_buffer,
                            	MMI_UC_TEXT_BUFFER_SIZE / ENCODING_LENGTH, 
                            	g_uc_p->msg.current_slide_num, 
                            	g_uc_p->msg.total_slide_num, 
                            	mmi_uc_get_message_size_callback, 
                            	mmi_uc_text_change_callback);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_to_editor_layout_type
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_convert_to_editor_layout_type(mmi_uc_layout_enum layout_type)

{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    switch (layout_type)
    {
        case MMI_UC_LAYOUT_DEFAULT:
        {
            return WGUI_UCE_LAYOUT_TYPE_THUMBNAIL_AT_TOP;
        }
        break;
        
        case MMI_UC_LAYOUT_THUMBNAIL_AT_TOP:
        {
            return WGUI_UCE_LAYOUT_TYPE_THUMBNAIL_AT_TOP;
        }
        break;

        case MMI_UC_LAYOUT_THUMBNAIL_AT_BOTTOM:
        {
            return WGUI_UCE_LAYOUT_TYPE_THUMBNAIL_AT_BOTTOM;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return WGUI_UCE_LAYOUT_TYPE_THUMBNAIL_AT_TOP;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_to_mms_layout_type
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_convert_to_mms_layout_type(mmi_uc_layout_enum layout_type)

{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    switch (layout_type)
    {
        case MMI_UC_LAYOUT_DEFAULT:
        {
            return MMA_LAYOUT_IMAGE_ON_TOP;
        }
        break;
        
        case MMI_UC_LAYOUT_THUMBNAIL_AT_TOP:
        {
            return MMA_LAYOUT_IMAGE_ON_TOP;
        }
        break;

        case MMI_UC_LAYOUT_THUMBNAIL_AT_BOTTOM:
        {
            return MMA_LAYOUT_TEXT_ON_TOP;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return MMA_LAYOUT_IMAGE_ON_TOP;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_mms_layout_type_to_uc
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_convert_mms_layout_type_to_uc(U8 layout_type)

{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    switch (layout_type)
    {
        case MMA_LAYOUT_NONE:
        {
            return MMI_UC_LAYOUT_DEFAULT;
        }
        break;
        
        case MMA_LAYOUT_IMAGE_ON_TOP:
        {
            return MMI_UC_LAYOUT_THUMBNAIL_AT_TOP;
        }
        break;

        case MMA_LAYOUT_TEXT_ON_TOP:
        {
            return MMI_UC_LAYOUT_THUMBNAIL_AT_BOTTOM;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return MMI_UC_LAYOUT_THUMBNAIL_AT_TOP;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_editor_add_object
 * DESCRIPTION
 *  Add object to editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_editor_add_object(mmi_uc_object_struct* object, mmi_uc_object_type object_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_uce_object_type_enum uce_object_type = mmi_uc_convert_to_editor_object_type(object_type);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (object_type == MMI_UC_OBJECT_TYPE_IMAGE ||
        object_type == MMI_UC_OBJECT_TYPE_VIDEO)
    {
        if (object->drm_type == MMA_DRM_NONE ||
            object->drm_type == MMA_DRM_SD)
        {
            if (object->is_virtual_file)
            {
                U8 virtual_file_name[(FS_GenVFN_SIZE + FMGR_MAX_EXT_LEN + 1) * ENCODING_LENGTH];
                S32 result;
                U16 virtual_file_name_len = sizeof(virtual_file_name);

                memset(virtual_file_name, 0, virtual_file_name_len);
                if (g_uc_p->main.file_handle > 0)
                {
                    FS_Close(g_uc_p->main.file_handle);
                    g_uc_p->main.file_handle = 0;
                }
                            
                g_uc_p->main.file_handle = FS_Open(object->file_path, FS_READ_ONLY | FS_OPEN_SHARED);
                
                if (g_uc_p->main.file_handle <= 0)
                {
                    MMI_ASSERT(0);
                }

            	result = FS_GenVirtualFileName( 
                                g_uc_p->main.file_handle, 
                                (U16*)virtual_file_name, 
                        		(unsigned int)FS_GenVFN_SIZE, 
                        		object->offset, 
                        		object->size);
                
                if (result < 0)
                {
                    MMI_ASSERT(0);
                }
                
                mmi_ucs2cat((PS8) virtual_file_name, (PS8) L".");
                MMI_ASSERT(mmi_uc_get_file_extension(object->file_name));
                mmi_ucs2ncat((PS8) virtual_file_name, (PS8) mmi_uc_get_file_extension(object->file_name), virtual_file_name_len / ENCODING_LENGTH);

                wgui_uce_add_object( uce_object_type, 
                                    (U16*)virtual_file_name, 
                                    0,
                                    mmi_uc_convert_to_editor_layout_type(g_uc_p->msg.layout));

            }
            else 
            {
                wgui_uce_add_object( uce_object_type, 
                                    object->file_path, 
                                    0,
                                    mmi_uc_convert_to_editor_layout_type(g_uc_p->msg.layout));
            }
            
        }
        else
        {
            wgui_uce_add_object( uce_object_type, 
                                NULL,
                                IMG_UC_DRM_THUMBNAIL_ID,
                                mmi_uc_convert_to_editor_layout_type(g_uc_p->msg.layout));
        }            
    }
    else
    {
        wgui_uce_add_object(uce_object_type, NULL, 0, 0);
    }
    
}



/*****************************************************************************
 * FUNCTION
 *  mmi_uc_insert_object
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_object_struct* mmi_uc_insert_object(S8* filePath, mmi_uc_object_type object_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_object_struct* new_object;
    U16* file_name;
    U32 object_size;
    U16 file_path_len = mmi_ucs2strlen(filePath);
    U16 file_name_len = 0;
     
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    object_size = sizeof(mmi_uc_object_struct);
    new_object = kal_adm_alloc(g_uc_p->main.mem_pool_id, object_size);
    MMI_ASSERT(new_object);
    memset(new_object, 0, object_size);

    /* file path */
    new_object->file_path = kal_adm_alloc(g_uc_p->main.mem_pool_id, (file_path_len + 1 ) * 2);
    MMI_ASSERT(new_object->file_path);
    memset(new_object->file_path, 0, (file_path_len + 1) * 2);
    mmi_ucs2ncpy((S8*)new_object->file_path, (S8*)filePath, file_path_len);

    /* file name */
    file_name = mmi_uc_get_file_name((U16*)filePath);
    file_name_len = mmi_ucs2strlen((S8*)file_name);
    new_object->file_name = kal_adm_alloc(g_uc_p->main.mem_pool_id, (file_name_len + 1 ) * 2);
    MMI_ASSERT(new_object->file_name);
    memset(new_object->file_name, 0, (file_name_len + 1) * 2);
    mmi_ucs2ncpy((S8*)new_object->file_name, (S8*)file_name, file_name_len);

    /* type */
    new_object->type = object_type;

    /* size */
    new_object->size = applib_get_file_size((kal_wchar*)filePath);       

    /* Default value! caller should update these value if necessary. */
    new_object->offset = 0;
    new_object->drm_type = MMA_DRM_NONE;
    new_object->is_virtual_file = MMI_FALSE;

    g_uc_p->msg.total_object_num++;

    /* First object */
    if (g_uc_p->msg.object_head == NULL)
    {
        g_uc_p->msg.object_head = new_object;
        new_object->next = NULL;
        new_object->previous = NULL;
    }
    else
    {
        /* Insert new object in the list head */    
        new_object->next = g_uc_p->msg.object_head;
        new_object->previous = NULL;

        g_uc_p->msg.object_head->previous = new_object;

        g_uc_p->msg.object_head = new_object;
    }

    return new_object; 
    
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_insert_attachment
 * DESCRIPTION
 *  Insert attachment 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_attachment_info_struct* mmi_uc_insert_attachment()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_attachment_info_struct* new_attach;
    U32 attach_size;
    U32 i = 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    attach_size = sizeof(mmi_uc_attachment_info_struct);
    new_attach = kal_adm_alloc(g_uc_p->main.mem_pool_id, attach_size);
    MMI_ASSERT(new_attach);
    memset(new_attach, 0, attach_size);

    if (g_uc_p->msg.total_attachment_num == 0)
    {
        MMI_ASSERT(g_uc_p->msg.attachment_head == NULL);
        g_uc_p->msg.attachment_head = new_attach;

        new_attach->next = NULL;
        new_attach->previous = NULL;        
    }
    else
    {
        mmi_uc_attachment_info_struct* cur_attach = g_uc_p->msg.attachment_head;
        MMI_ASSERT(cur_attach);
        
        for ( ; cur_attach->next != NULL; cur_attach = cur_attach->next)
        {
            i++;
        }

        MMI_ASSERT(i == g_uc_p->msg.total_attachment_num);

        cur_attach->next = new_attach;
        new_attach->next = NULL;
        new_attach->previous = cur_attach;
    }
    
    g_uc_p->msg.total_attachment_num++;

    return new_attach;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_insert_object_to_attachment
 * DESCRIPTION
 *  Insert object
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_insert_object_to_attachment(mmi_uc_object_struct*  object,mmi_uc_attachment_info_struct* attachment)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    attachment->object = object;
    object->reference_count++;

    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_file_name
 * DESCRIPTION
 *  Get file name
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16* mmi_uc_get_file_name(U16* filePath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 file_path_len = mmi_ucs2strlen((S8*)filePath);
    U16* cur_position;
    U16* pre_position;
    S32 i = file_path_len - 1;
    U8 pattern[3 * ENCODING_LENGTH];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(pattern, 0, sizeof(pattern));
    mmi_asc_n_to_ucs2((S8*)pattern, "\\", 1);
    
    for (; i >= 0 ; i--)
    {
        cur_position = &(filePath[i]);
        pre_position = cur_position - 1;
        if (mmi_ucs2ncmp((S8*)pre_position, (S8*)pattern, 1) == 0)
        {
            return cur_position;
        }
    }

    return filePath;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_file_extension
 * DESCRIPTION
 *  Get file name
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16* mmi_uc_get_file_extension(U16* filePath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 file_path_len = mmi_ucs2strlen((S8*)filePath);
    U16* cur_position;
    U16* pre_position;
    S32 i = file_path_len - 1;
    U8 pattern[3 * ENCODING_LENGTH];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(pattern, 0, sizeof(pattern));
    mmi_asc_n_to_ucs2((S8*)pattern, ".", 1);
    
    for (; i >= 0 ; i--)
    {
        cur_position = &(filePath[i]);
        pre_position = cur_position - 1;
        if (mmi_ucs2ncmp((S8*)pre_position, (S8*)pattern, 1) == 0)
        {
            return cur_position;
        }
    }

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_set_index
 * DESCRIPTION
 *  Set highlighted idnex
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_set_index(S32 hilited_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_uc_p->main.object_index = hilited_index;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_object_from_list
 * DESCRIPTION
 *  delete object from list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_delete_object_from_list(mmi_uc_object_struct* object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (object == g_uc_p->msg.object_head)
    {
        g_uc_p->msg.object_head = object->next;

        if (object->next)
        {
            object->next->previous = NULL;
        }        
    }
    else
    {
        object->previous->next = object->next;

        if (object->next)
        {
            object->next->previous = object->previous;
        }
    }    
    g_uc_p->msg.total_object_num--;

    if (object->file_name)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, object->file_name);
    }
    
    if (object->file_path)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, object->file_path);
    }    
    
    kal_adm_free(g_uc_p->main.mem_pool_id, object);
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_attachment_info_struct
 * DESCRIPTION
 *  get attachment by index
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_attachment_info_struct* mmi_uc_get_attachment_by_index(U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_attachment_info_struct* att = g_uc_p->msg.attachment_head;
    U16 i = 0;
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    MMI_ASSERT(g_uc_p->msg.attachment_head);
    
    for (; i < index ; i++)
    {
        MMI_ASSERT(att);
        att = att->next;
    }
    
    return att;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_attachment_from_list
 * DESCRIPTION
 *  delete attachment info from list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_delete_attachment_from_list(mmi_uc_attachment_info_struct* att)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (att == g_uc_p->msg.attachment_head)
    {
        g_uc_p->msg.attachment_head = att->next;

        if (att->next)
        {
            att->next->previous = NULL;
        }        
    }
    else
    {
        att->previous->next = att->next;

        if (att->next)
        {
            att->next->previous = att->previous;
        }
    }    
    g_uc_p->msg.total_attachment_num--;

    kal_adm_free(g_uc_p->main.mem_pool_id, att);
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_object_in_slide
 * DESCRIPTION
 *  Get object in slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_object_struct* mmi_uc_get_object_in_slide(mmi_uc_slide_struct* slide, mmi_uc_object_type object_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    switch (object_type)
    {
        case MMI_UC_OBJECT_TYPE_IMAGE:
        {
            return slide->image.object;
        }
        break;

        case MMI_UC_OBJECT_TYPE_AUDIO:
        {
            return slide->audio.object;
        }
        break;

        case MMI_UC_OBJECT_TYPE_VIDEO:
        {
            return slide->video.object;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return NULL;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_reset_text_buffer
 * DESCRIPTION
 *  Reset text buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_reset_text_buffer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(g_uc_p->main.text_buffer, 0, MMI_UC_TEXT_BUFFER_SIZE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_init_uc_folder
 * DESCRIPTION
 *  Create uc folder
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_init_uc_folder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle;
    S32 result;
    U8 mmi_uc_folder_path[MMI_UC_MAX_TEMP_FILE_LEN];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(mmi_uc_folder_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);
    MMI_UC_MAKE_FOLDER_PATH(mmi_uc_folder_path);
    
    /* if the dir exists, delete it */
    file_handle = FS_Open((WCHAR*)mmi_uc_folder_path, FS_OPEN_DIR | FS_READ_ONLY);
    if (file_handle >= 0)
    {            
        FS_Close(file_handle);

        FS_XDelete((WCHAR*)mmi_uc_folder_path, 
           FS_FILE_TYPE | FS_DIR_TYPE | FS_RECURSIVE_TYPE, 
           NULL, 
           0);
    }
    
    result = FS_CreateDir((WCHAR*)mmi_uc_folder_path);
    
    if (result < 0)
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                             "*[UnifiedComposerMiscell.c] mmi_uc_init_uc_folder Create DIR FAIL! *\n");
    }

    FS_SetAttributes((unsigned short*)mmi_uc_folder_path, FS_ATTR_DIR | FS_ATTR_HIDDEN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_uc_folder
 * DESCRIPTION
 *  Check if UC folder exists. If not, try to create it.
 * PARAMETERS
 *  void
 * RETURNS
 *  Positive or zero means UC folder exists or created. Negative means UC folder not exist.
 *****************************************************************************/
S32 mmi_uc_check_uc_folder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 mmi_uc_folder_path[MMI_UC_MAX_TEMP_FILE_LEN];
    FS_HANDLE file_handle;
    S32 result = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*---[UnifiedComposerMain.c] mmi_uc_check_uc_folder ---*\n");
    
    memset(mmi_uc_folder_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);
    MMI_UC_MAKE_FOLDER_PATH(mmi_uc_folder_path);
    
    file_handle = FS_Open((WCHAR*)mmi_uc_folder_path, FS_OPEN_DIR | FS_READ_ONLY);

    /* Check if the UC folder is created successfully. */
    if (file_handle >= 0)
    {            
        FS_Close(file_handle);        
    }
    else
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                             "*---[UnifiedComposerMain.c] mmi_uc_check_uc_folder Folder NOT exist---*\n");
        
        /* Try to create folder again besides mmi_uc_init_uc_folder. */
        result = FS_CreateDir((WCHAR*)mmi_uc_folder_path);

        /* Disallow to enter UC if UC folder cannot be created. */    
        if (result < 0)
        {            
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                             "*---[UnifiedComposerMain.c] mmi_uc_check_uc_folder Folder creation FAIL! = %d ---*\n",
                             result);            
        }
        else
        {
            FS_SetAttributes((unsigned short*)mmi_uc_folder_path, FS_ATTR_DIR | FS_ATTR_HIDDEN);    
        }
        
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_save_buffer_to_file
 * DESCRIPTION
 *  Save the content of text buffer to file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_save_buffer_to_file(U8* file_path, U8* buffer, U16 char_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle;
    S32 result = FS_NO_ERROR;
    U32 write_len = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Open the file to write, overwrite if already exists. */
    file_handle = FS_Open((U16*) file_path, FS_CREATE_ALWAYS | FS_READ_WRITE);
    if (file_handle > 0)
    {
        U32 utf8_buffer_size = (char_num * 3 + ENCODING_LENGTH);        
        U8* utf8_buffer = applib_mem_screen_alloc(utf8_buffer_size);
        U32 utf8_len = 0;
        
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
        "*mmi_uc_save_buffer_to_file char_num=%d ---*\n",char_num);
        MMI_ASSERT(utf8_buffer_size <= MMI_UC_UTF8_TEXT_BUFFER_SIZE);
        
        memset(utf8_buffer , 0, utf8_buffer_size);
        utf8_len = mmi_chset_ucs2_to_utf8_string(utf8_buffer, utf8_buffer_size, buffer);
        
        result = FS_Write(file_handle, 
                          utf8_buffer, 
                          utf8_len - 1, /* null terminator */
                          &write_len);
        
        applib_mem_screen_free(utf8_buffer);
        FS_Close(file_handle);
    }
    else
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                     "*---[UnifiedComposerMisc.c] mmi_uc_save_buffer_to_file fail! file_handle= %d ---*\n",
                                     file_handle);   
    }
    return result;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_switch_slide
 * DESCRIPTION
 *  Switch slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_switch_slide(mmi_uc_slide_struct* slide)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //wgui_uce_text_info_struct text_info;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //memset(&text_info, 0, sizeof(wgui_uce_text_info_struct));

    mmi_uc_reset_text_buffer();    
    mmi_uc_editor_initialize();
    mmi_uc_reset_history_guibuffer(SCR_ID_UC_EDITOR);
    
    if (slide != NULL && slide->text.object)
    {
        mmi_uc_read_file_to_text_buffer((U8*)slide->text.object->file_path, slide->text.object->encoding);
        //wgui_uce_get_text_info_for_buffer(&text_info, g_uc_p->main.text_buffer);
        //mmi_uc_set_text_info_to_slide(slide, &text_info);
    }    

    mmi_uc_set_editor_info(slide);
        
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_set_editor_info
 * DESCRIPTION
 *  Set editor info
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_set_editor_info(mmi_uc_slide_struct* slide)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_uce_text_info_struct text_info;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&text_info, 0, sizeof(wgui_uce_text_info_struct));

    if (slide != NULL)
    {    
        if (slide->text.object)
        {
            mmi_uc_set_text_info_from_slide(slide, &text_info);
            wgui_uce_insert_text(&text_info, g_uc_p->main.text_buffer);
        }

        if (slide->image.object)
        {
            mmi_uc_editor_add_object(slide->image.object, MMI_UC_OBJECT_TYPE_IMAGE);
        }

        if (slide->audio.object)
        {
            mmi_uc_editor_add_object(slide->audio.object, MMI_UC_OBJECT_TYPE_AUDIO);
        }
        
        if (slide->video.object)
        {
            mmi_uc_editor_add_object(slide->video.object, MMI_UC_OBJECT_TYPE_VIDEO);
        }
    }

    if (g_uc_p->msg.total_attachment_num)
    {
        mmi_uc_editor_add_object(NULL, MMI_UC_OBJECT_TYPE_ATTACHMENT);
    }
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_set_text_info_to_slide
 * DESCRIPTION
 *  Set text info to slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_set_text_info_to_slide(mmi_uc_slide_struct* slide, wgui_uce_text_info_struct* text_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    slide->text.char_count = text_info->char_count;
    slide->text.UCS2_count = text_info->UCS2_count;
    slide->text.utf8_msg_len = text_info->utf8_msg_len;
    slide->text.extension_char_count = text_info->extension_char_count;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_set_text_info_from_slide
 * DESCRIPTION
 *  Set text info from slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_set_text_info_from_slide(mmi_uc_slide_struct* slide, wgui_uce_text_info_struct* text_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    text_info->char_count = slide->text.char_count;
    text_info->UCS2_count = slide->text.UCS2_count;
    text_info->utf8_msg_len = slide->text.utf8_msg_len;
    text_info->extension_char_count = slide->text.extension_char_count;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_encoding_type_to_chset
 * DESCRIPTION
 *  convert encoding type (MSF_CHARSET_XXXX in mms module to MMI_CHSET_XXX in mmi module)
 * PARAMETERS
 *  U32
 * RETURNS
 *  U32
 *****************************************************************************/

mmi_chset_enum mmi_uc_convert_encoding_type_to_chset(U32 encoding)
{
    mma_charset_enum MMS_encoding = (mma_charset_enum)encoding;

    switch (MMS_encoding)
    {
        case MMA_CHARSET_ASCII:
            return MMI_CHSET_ASCII;
            
        case MMA_CHARSET_ISO_8859_1:    
            return MMI_CHSET_WESTERN_ISO;
            
         case MMA_CHARSET_UTF8:
            return MMI_CHSET_UTF8;           

        case MMA_CHARSET_UCS2:
            return MMI_CHSET_UCS2;

        case MMA_CHARSET_UTF16BE:
            return MMI_CHSET_UTF16BE;

        case MMA_CHARSET_UTF16LE:
            return MMI_CHSET_UTF16LE;
            
        case MMA_CHARSET_UTF16:
            return MMI_CHSET_UTF16LE;  /*MMS can not diff LE or BE, here we treat it as LE*/
        default:
            return MMI_CHSET_UTF8; 
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_read_file_to_text_buffer
 * DESCRIPTION
 *  Read the file to text buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_read_file_to_text_buffer(U8* file_path, U32 encoding)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle;
    U32 result;
    U32 read_len = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Open the file to write, overwrite if already exists. */

    mmi_chset_enum converted_encoding= mmi_uc_convert_encoding_type_to_chset(encoding);

    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "mmi_uc_read_file_to_text_buffer: encoding=%d, converted_encoding=%d *\n", encoding, converted_encoding); 

    file_handle = FS_Open((U16*) file_path, FS_READ_ONLY | FS_OPEN_SHARED );
    if (file_handle > 0)
    {            

        U8* temp_utf8_buffer = applib_mem_screen_alloc(MMI_UC_UTF8_TEXT_BUFFER_SIZE);

        memset(temp_utf8_buffer, 0, MMI_UC_UTF8_TEXT_BUFFER_SIZE);

        result = FS_Read(file_handle, 
                         temp_utf8_buffer, 
                         MMI_UC_UTF8_TEXT_BUFFER_SIZE,
                         &read_len);

        FS_Close(file_handle);
        mmi_uc_reset_text_buffer();   

        if (result == FS_NO_ERROR)
        {
            mmi_chset_convert(converted_encoding, MMI_CHSET_UCS2, (char*)temp_utf8_buffer, (char*)g_uc_p->main.text_buffer, MMI_UC_TEXT_BUFFER_SIZE);
            applib_mem_screen_free(temp_utf8_buffer);
            return;
        }
        else 
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "mmi_uc_read_file_to_text_buffer, FS_Read fail result=(%d) read_len=(%d)\n",result,read_len);
        }


        
        applib_mem_screen_free(temp_utf8_buffer);

    }                                
    else
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "mmi_uc_read_file_to_text_buffer, fopen fail (%d)*\n",file_handle);
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_slide
 * DESCRIPTION
 *  delete slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_delete_slide(mmi_uc_slide_struct* slide)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (slide == g_uc_p->msg.slide_head)
    {
        g_uc_p->msg.slide_head = slide->next;

        if (slide->next)
        {
            slide->next->previous = NULL;
        }        
    }
    else
    {
        slide->previous->next = slide->next;

        if (slide->next)
        {
            slide->next->previous = slide->previous;
        }
    }    
    g_uc_p->msg.total_slide_num--;

    if (slide->next)
    {
        mmi_uc_slide_struct* update_slide = slide->next;
        
        while (update_slide)
        {
            update_slide->slide_num--;
            mmi_uc_update_text_object_path(update_slide);
            update_slide = update_slide->next;
        }
    }      
    
    kal_adm_free(g_uc_p->main.mem_pool_id, slide);
    
}


/*****************************************************************************
* FUNCTION
*  mmi_uc_insert_signature_check
* DESCRIPTION
*  Check if it is needed to insert signature.
* PARAMETERS
*  void
* RETURNS
*  kal_bool 
*****************************************************************************/
void mmi_uc_insert_signature_check(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER &&
        g_uc_p->mms_info.signature.enable)
    {
        if (mmi_uc_insert_signature())
        {        
            /* Add signature successfully. Initialize editor. */
            //mmi_uc_switch_slide(g_uc_p->msg.current_slide);
            mmi_uc_editor_initialize();
            mmi_uc_set_editor_info(g_uc_p->msg.current_slide);
        }
    }
    else if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER &&
             g_uc_p->mms_info.signature.enable)
    {
        /* tricky! disallow to insert signature for forward and send case */
        if (g_uc_p->main.state != MMI_UC_STATE_FORWARD && 
            g_uc_p->main.state != MMI_UC_STATE_SEND)
        {
            g_uc_p->msg.signature_inserted = MMI_FALSE;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_insert_signature
 * DESCRIPTION
 *  insert signature
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_insert_signature()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_slide_struct* slide;
    mmi_uc_slide_struct* last_slide;
    U32 i = 1;
    U32 new_slide_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_uc_p->msg.signature_inserted)
    {
        g_uc_p->msg.fail_to_insert_signature = MMI_FALSE;
        return MMI_TRUE;
    }
    
    if (g_uc_p->msg.total_slide_num == MMI_UC_MAX_MMS_SLIDE_NUM)
    {
        g_uc_p->msg.fail_to_insert_signature = MMI_TRUE;
        return MMI_FALSE;
    }

    
    new_slide_size = wap_mma_uc_calc_slide_smil_size(g_uc_p->msg.slide_timing);

    if (mmi_uc_check_if_exceed_MMS_size_limitation(new_slide_size + g_uc_p->msg.msg_size))
    {    
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                       "*mmi_uc_insert_signature over size ---,new_slide_size=%d, g_uc_p->msg.msg_size=%d*\n",new_slide_size,g_uc_p->msg.msg_size);
        g_uc_p->msg.fail_to_insert_signature = MMI_TRUE;
        return MMI_FALSE;
    }
                
    for (last_slide = g_uc_p->msg.slide_head; last_slide->next != NULL ; last_slide = last_slide->next)
    {
        i++;
    }
    MMI_ASSERT( i == g_uc_p->msg.total_slide_num);
    
    slide = mmi_uc_insert_slide(last_slide);
    mmi_uc_update_msg_size();

    if (g_uc_p->mms_info.signature.img_file)
    {
    
        if (!mmi_uc_insert_signature_file(g_uc_p->mms_info.signature.img_file, 
                                          slide, 
                                          MMI_UC_OBJECT_TYPE_IMAGE))
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                      "*mmi_uc_insert_signature img fail ---*\n");
            mmi_uc_delete_slide_with_object(slide);
            g_uc_p->msg.fail_to_insert_signature = MMI_TRUE;
            return MMI_FALSE;
        }        
        mmi_uc_update_msg_size();
    }

    if (g_uc_p->mms_info.signature.audio_file)
    {
    
        if (!mmi_uc_insert_signature_file(g_uc_p->mms_info.signature.audio_file, 
                                          slide, 
                                          MMI_UC_OBJECT_TYPE_AUDIO))
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                      "*mmi_uc_insert_signature audio fail ---*\n");
            mmi_uc_delete_slide_with_object(slide);
            g_uc_p->msg.fail_to_insert_signature = MMI_TRUE;
            return MMI_FALSE;
        }        
        mmi_uc_update_msg_size();
    }
    
    if (g_uc_p->mms_info.signature.video_file)
    {
    
        if (!mmi_uc_insert_signature_file(g_uc_p->mms_info.signature.video_file,
                                          slide, 
                                          MMI_UC_OBJECT_TYPE_VIDEO))
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                      "*mmi_uc_insert_signature video_file fail ---*\n");
            mmi_uc_delete_slide_with_object(slide);
            g_uc_p->msg.fail_to_insert_signature = MMI_TRUE;
            return MMI_FALSE;
        }        
        mmi_uc_update_msg_size();
    }    

    if (g_uc_p->mms_info.signature.text_file)
    {
        if (!mmi_uc_insert_signature_file(g_uc_p->mms_info.signature.text_file, 
                                          slide, 
                                          MMI_UC_OBJECT_TYPE_TEXT))
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                      "*mmi_uc_insert_signature text fail ---*\n");
            mmi_uc_delete_slide_with_object(slide);
            g_uc_p->msg.fail_to_insert_signature = MMI_TRUE;
            return MMI_FALSE;
        }        
        mmi_uc_update_msg_size();
    }        

    g_uc_p->msg.fail_to_insert_signature = MMI_FALSE;    
    g_uc_p->msg.signature_inserted = MMI_TRUE;

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_slide_with_object
 * DESCRIPTION
 *  delete slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_delete_slide_with_object(mmi_uc_slide_struct* slide)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (slide->image.object)
     {
         slide->image.object->reference_count--;
    
         if (slide->image.object->reference_count == 0)
         {
             mmi_uc_delete_object_from_list(slide->image.object);
         }
     }
    
     if (slide->audio.object)
     {
         slide->audio.object->reference_count--;
    
         if (slide->audio.object->reference_count == 0)
         {
             mmi_uc_delete_object_from_list(slide->audio.object);
         }
     }
     
     if (slide->video.object)
     {
         slide->video.object->reference_count--;
    
         if (slide->video.object->reference_count == 0)
         {
             mmi_uc_delete_object_from_list(slide->video.object);
         }
     }
     
     if (slide->text.object)
     {        
        S32 result = FS_Delete((U16*)slide->text.object->file_path);
        
        if ( result != FS_NO_ERROR)
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                         "*[UnifiedComposerMiscell.c] mmi_uc_delete_slide_with_object Delete Text file FAIL! *\n");
        }
        
         mmi_uc_delete_object_from_list(slide->text.object);
     }
    
     mmi_uc_delete_slide(slide);

     mmi_uc_reset_layout_if_needed();
     
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_slide_with_object
 * DESCRIPTION
 *  delete slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_insert_signature_file(U16* file_path, mmi_uc_slide_struct* slide, mmi_uc_object_type type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_object_struct* object;
    mma_insert_type_enum mms_type = mmi_uc_convert_to_mms_insert_type(type);
    mma_insert_check_struct check_result;
    BOOL result = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    object = mmi_uc_check_duplicate_object(file_path);
    memset(&check_result, 0, sizeof(mma_insert_check_struct));
        
    if (object && object->type != MMI_UC_OBJECT_TYPE_ATTACHMENT)
    {        
        U32 obj_smil_size = wap_mma_uc_calc_object_smil_size(mms_type, file_path);
        
        if (mmi_uc_check_if_exceed_MMS_size_limitation(obj_smil_size + g_uc_p->msg.msg_size))
        {                
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                      "*mmi_uc_insert_signature_file exceed mms size limitation---type=%d*\n",object->type);
            result = MMI_FALSE;
        }
        else
        {
            mmi_uc_insert_object_to_slide(object, slide, type);
            result = MMI_TRUE;
        }
    }
    else
    {
    
        wap_mma_uc_insert_object_check(g_uc_p->mms_info.creation_mode,
                                       file_path, 
                                       mms_type, 
                                       g_uc_p->msg.msg_size, 
                                       g_uc_p->mms_info.max_mms_size,
                                       &check_result);        
        if (!(check_result.result))
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                      "*mmi_uc_insert_signature_file, wap_mma_uc_insert_object_check fail---size=%d*\n",g_uc_p->msg.msg_size);
            
            result = MMI_FALSE;
        }
        else
        {   
            if (type == MMI_UC_OBJECT_TYPE_TEXT)
            {            
                U8 mmi_uc_text_path[MMI_UC_MAX_TEMP_FILE_LEN];
                FS_HANDLE file_handle;
                U32 file_result = 0;
                U32 read_len = 0;
                U8* buffer = NULL;
                wgui_uce_text_info_struct text_info;
                U32 file_size = applib_get_file_size((kal_wchar*)file_path);
                U32 buffer_size = (file_size + 1);
                U32 write_len = 0;
                U32 ucs2_buffer_size = MMI_UC_UTF8_TEXT_BUFFER_SIZE;        
                U8* ucs2_buffer = 0;
                
                file_handle = FS_Open((U16*) file_path, FS_READ_ONLY );
                if (file_handle <= 0)
                {
                    return MMI_FALSE;
                }
                else
                {
                    buffer = kal_adm_alloc(g_uc_p->main.mem_pool_id, buffer_size);

                    if (buffer == NULL)
                    {
                        return MMI_FALSE;
                    }

                    memset(buffer, 0, buffer_size);
                    
                    file_result = FS_Read(
                                     file_handle, 
                                     buffer, 
                                     buffer_size - 1, /* file_size */
                                     &read_len);

                    FS_Close(file_handle);

                    if (file_result != FS_NO_ERROR)
                    {
                        kal_adm_free(g_uc_p->main.mem_pool_id, buffer);
                        return MMI_FALSE;                    
                    }
                }
                
                memset(mmi_uc_text_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);
                MMI_UC_MAKE_TEXT_FILE_PATH(mmi_uc_text_path, slide->slide_num);
                
                file_handle = FS_Open((U16*) mmi_uc_text_path, FS_CREATE_ALWAYS | FS_READ_WRITE);
                if (file_handle <= 0)
                {
                    kal_adm_free(g_uc_p->main.mem_pool_id, buffer);
                    return MMI_FALSE;
                }

                result = FS_Write(file_handle, 
                                  buffer, 
                                  buffer_size - 1, /* null terminator */
                                  &write_len);
                
                FS_Close(file_handle);

                if (result != FS_NO_ERROR)
                {
                    kal_adm_free(g_uc_p->main.mem_pool_id, buffer);
                    return MMI_FALSE;
                }

                ucs2_buffer = applib_mem_screen_alloc(ucs2_buffer_size);
                memset(ucs2_buffer,0,ucs2_buffer_size);
                mmi_chset_utf8_to_ucs2_string(ucs2_buffer, ucs2_buffer_size - ENCODING_LENGTH, buffer);

                mmi_uc_editor_initialize();
                memset(&text_info, 0, sizeof(wgui_uce_text_info_struct));
                wgui_uce_get_text_info_for_buffer(&text_info, ucs2_buffer);
                
                applib_mem_screen_free(ucs2_buffer);                                        
                 mmi_uc_set_text_info_to_slide(slide, &text_info);
                
                object = mmi_uc_insert_object((S8*)mmi_uc_text_path, MMI_UC_OBJECT_TYPE_TEXT);                
                mmi_uc_insert_object_to_slide(object, slide, MMI_UC_OBJECT_TYPE_TEXT);
                result = MMI_TRUE;
            }
            else
            {
                object = mmi_uc_insert_object((S8*) file_path, type);
                object->drm_type = check_result.drm_type;
            
                mmi_uc_insert_object_to_slide(object, slide, type);
                result = MMI_TRUE;
            }
        }
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_reset_mms_signature
 * DESCRIPTION
 *  Reset mms signature info in context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_reset_mms_signature(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_uc_p->mms_info.signature.text_file)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, g_uc_p->mms_info.signature.text_file);
        g_uc_p->mms_info.signature.text_file = NULL;
    }
    if (g_uc_p->mms_info.signature.img_file)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, g_uc_p->mms_info.signature.img_file);
        g_uc_p->mms_info.signature.img_file = NULL;
    }
    if (g_uc_p->mms_info.signature.audio_file)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, g_uc_p->mms_info.signature.audio_file);
        g_uc_p->mms_info.signature.audio_file = NULL;
    }
    if (g_uc_p->mms_info.signature.video_file)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, g_uc_p->mms_info.signature.video_file);
        g_uc_p->mms_info.signature.video_file = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_reset_msg
 * DESCRIPTION
 *  Reset msg info in context
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_reset_msg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (g_uc_p->msg.to_head)
    {
        mmi_uc_delete_addr(g_uc_p->msg.to_head);
    }
    
    while (g_uc_p->msg.cc_head)
    {
        mmi_uc_delete_addr(g_uc_p->msg.cc_head);
    }

    while (g_uc_p->msg.bcc_head)
    {
        mmi_uc_delete_addr(g_uc_p->msg.bcc_head);
    }    

    while (g_uc_p->msg.from)
    {
        mmi_uc_delete_addr(g_uc_p->msg.from);
    }    

    while (g_uc_p->msg.slide_head)
    {
        mmi_uc_delete_slide_with_object(g_uc_p->msg.slide_head);
    }

    while (g_uc_p->msg.attachment_head)
    {
        mmi_uc_delete_object_from_list(g_uc_p->msg.attachment_head->object);
        mmi_uc_delete_attachment_from_list(g_uc_p->msg.attachment_head);
    }

    while (g_uc_p->msg.object_head)
    {
        mmi_uc_delete_object_from_list(g_uc_p->msg.object_head);
    }

    memset(&(g_uc_p->msg), 0, sizeof(mmi_uc_msg_struct));

    if (g_uc_p->main.file_handle)
    {
        FS_Close(g_uc_p->main.file_handle);
        g_uc_p->main.file_handle = 0;
    }

    mmi_uc_init_uc_folder();

    if (g_uc_p->main.file_path)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, g_uc_p->main.file_path);
        g_uc_p->main.file_path = NULL;
    }

    if (g_uc_p->send_info.fail_cause)
    {
        kal_adm_free(g_uc_p->main.mem_pool_id, g_uc_p->send_info.fail_cause);
        g_uc_p->send_info.fail_cause = NULL;
    }   
    memset(&(g_uc_p->send_info),0,sizeof(g_uc_p->send_info));
    mmi_uc_reset_mms_signature();

    g_uc_p->main.image_no = 0;

    if (g_uc_p->main.callback != NULL)
    {
        g_uc_p->main.callback((void*)g_uc_p->main.callback_para);
        
        g_uc_p->main.callback = NULL;        
    }
    
    g_uc_p->main.callback_para = NULL;
    
    kal_adm_delete(g_uc_p->main.mem_pool_id);
    mmi_uc_create_adm_mem();
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_init_setting
 * DESCRIPTION
 *  Init msg setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_init_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 index = 0;
    S16 errorCode = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadValue(NVRAM_UC_PREFERRED_MSG_TYPE, &index, DS_BYTE, &errorCode);
    
    if (index >= 2)
    {
        index = 0;
        WriteValue(NVRAM_UC_PREFERRED_MSG_TYPE, &index, DS_BYTE, &errorCode);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_setting_msg_type
 * DESCRIPTION
 *  Get msg type
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_msg_type_enum mmi_uc_get_setting_msg_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 index = 0;
    S16 errorCode = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    ReadValue(NVRAM_UC_PREFERRED_MSG_TYPE, &index, DS_BYTE, &errorCode);

    if (index == 0)
    {
        return MMI_UC_MSG_TYPE_SMS_PREFER;
    }
    else if (index == 1)
    {
        return MMI_UC_MSG_TYPE_MMS_PREFER;
    }
    else
    {
        MMI_ASSERT(0);
        return MMI_UC_MSG_TYPE_SMS_PREFER;        
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_setting_msg_type
 * DESCRIPTION
 *  Get msg type
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_clear_msg_bearer(mmi_uc_msg_type_enum msg_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (msg_type == MMI_UC_MSG_TYPE_DEFAULT || msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
    {        
        ReleaseEMSEditBuffer();
    }

    if (msg_type == MMI_UC_MSG_TYPE_DEFAULT || msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
    {
        /* Delete MMS temp msg ID*/
        mmi_uc_delete_mms_req(g_uc_p->send_info.new_msg_id);
        g_uc_p->send_info.new_msg_id = 0; /* tricky! */
        
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_sms_frm_screen
 * DESCRIPTION
 *  Delete SMS framework screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_delete_sms_frm_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_sms_delete_screen_history();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_addr
 * DESCRIPTION
 *  Get addr by type and index
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_addr_struct* mmi_uc_get_addr(mmi_uc_address_group_type_enum addr_type, U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i = 0;
    mmi_uc_addr_struct* addr = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (addr_type)
    {
        case MMI_UC_ADDRESS_GROUP_TYPE_TO:
        {
            addr = g_uc_p->msg.to_head;
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_CC:
        {
            addr = g_uc_p->msg.cc_head;
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_BCC:
        {
            addr = g_uc_p->msg.bcc_head;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
            return NULL;
        }
    }
    
    for ( ; i < index ; i++)
    {
        MMI_ASSERT(addr->next);
        addr = addr->next;
    }

    return addr;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_save_sms_after_send
 * DESCRIPTION
 *  Save sms after send
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_save_sms_after_send(U8 status, void *number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_sms_send_struct *sendData = OslMalloc(sizeof(mmi_frm_sms_send_struct));
    EMSData *data = GetEMSDataForEdit(0, 0);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset((S8*) sendData, 0, sizeof(mmi_frm_sms_send_struct));
    sendData->dcs = data->dcs;
    sendData->status = status;
    strncpy((S8*) sendData->number, (S8*) number,MAX_DIGITS_SMS - 1);
        
    mmi_frm_sms_save_sms(mmi_uc_save_sms_rsp, MOD_MMI, sendData);
    OslMfree(sendData);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_mms_xml_description_file
 * DESCRIPTION
 *  Create the mms xml description file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_mms_xml_description_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 file_path[MMI_UC_MAX_TEMP_FILE_LEN];
    FS_HANDLE fh;
    S32 result = FS_NO_ERROR;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_uc_update_object_id();

    /* Make sure every object name is unique. */
    mmi_uc_replace_duplicate_object_file_name();
    
    memset(file_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);
    MMI_UC_MAKE_MMS_XML_FILE_PATH(file_path, 0);
    
    /* Open the file to write, overwrite if already exists. */
    fh = FS_Open((U16*) file_path, FS_CREATE_ALWAYS | FS_READ_WRITE);
    if (fh > 0)
    {
        /* <mms> */
        if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_MMS, NULL)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh))!= FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        /* <header> */
        if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_HEADER, NULL)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        /* To address */
        if (g_uc_p->msg.to_num)
        {
            if ((result = mmi_uc_create_xml_addr(fh, MMI_UC_ADDRESS_GROUP_TYPE_TO))
                != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }
        }
        
        /* Cc address */
        if (g_uc_p->msg.cc_num)
        {
            if ((result = mmi_uc_create_xml_addr(fh, MMI_UC_ADDRESS_GROUP_TYPE_CC))
                != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }
        }
        
        /* Bcc address */
        if (g_uc_p->msg.bcc_num)
        {
            if ((result = mmi_uc_create_xml_addr(fh, MMI_UC_ADDRESS_GROUP_TYPE_BCC))
                != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }
        }

        /* subject */
        if (mmi_ucs2strlen((S8*)g_uc_p->msg.subject))
        {
            if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_SUBJECT, NULL)) != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }
            if ((result = mmi_uc_create_xml_data_usc2_to_utf8_to_base64(fh, (U8*)g_uc_p->msg.subject)) != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }        
            if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_SUBJECT)) != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }
            if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }
        }

        /* Read Report */
        if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_READ_REPORT, NULL)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_data_numeric_to_char(fh, g_uc_p->msg.read_report)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }        
        if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_READ_REPORT)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        /* Delivery Report */
        if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_DELIVERY_REPORT, NULL)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_data_numeric_to_char(fh, g_uc_p->msg.delivery_report)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }        
        if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_DELIVERY_REPORT)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        /* Priority */
        if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_PRIORITY, NULL)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_data_numeric_to_char(fh, g_uc_p->msg.priority)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }        
        if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_PRIORITY)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        /* Expiry time */
        if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_EXPIRY, NULL)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_data_numeric_to_char(fh, mmi_uc_convert_to_mms_expiry_time(g_uc_p->msg.expiry_time))) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }        
        if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_EXPIRY)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        /* Delivery time */
        if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_DELIVERY_TIME, NULL)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_data_numeric_to_char(fh, mmi_uc_convert_to_mms_delivery_time(g_uc_p->msg.delivery_time))) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }        
        if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_DELIVERY_TIME)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        /* Sender visibility */
        if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_VISIBLE, NULL)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_data_numeric_to_char(fh, g_uc_p->msg.sender_visibility)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }        
        if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_VISIBLE)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        /* </header> */
        if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_HEADER)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }

        if ((g_uc_p->main.state != MMI_UC_STATE_FORWARD && g_uc_p->main.state != MMI_UC_STATE_SEND) ||
            ((g_uc_p->main.state == MMI_UC_STATE_FORWARD || g_uc_p->main.state == MMI_UC_STATE_SEND) && 
                (g_uc_p->send_info.existed_msg_type != MMI_UC_MSG_TYPE_MMS_PREFER)))
        {
            /* <body> */
            {
                U16 color_str_len = 10; /* size of bg_color and fg_color */
                U16 str_len = 5; /* size of slide_num, obj_num, and layout */
                U16 attr_num = 5; /* size of arrt_list would be attr_num * 2 + 1 */
                U8 bg_color[10];
                U8 fg_color[10];
                U8 slide_num[5];
                U8 obj_num[5];
                U8 layout[5];
                U8* attr_list[5 * 2 + 1];
                U8 i = 0;

                memset(bg_color, 0, color_str_len);
                sprintf((char*)bg_color, "0x%06x", g_uc_p->msg.background_color);
                attr_list[i++] = (U8*)MMI_UC_XML_ATTR_BGCOLOR;
                attr_list[i++] = bg_color;
                
                memset(fg_color, 0, color_str_len);
                sprintf((char*)fg_color, "0x%06x", g_uc_p->msg.foreground_color);
                attr_list[i++] = (U8*)MMI_UC_XML_ATTR_FGCOLOR;
                attr_list[i++] = fg_color;

                /* If only attachments and one slide without any content, do not send slide info.*/
                /* reference phone behavior */
                memset(slide_num, 0, str_len);            
                if (mmi_uc_check_only_attachment() && g_uc_p->send_info.action != MMI_UC_ACTION_PREVIEW)
                {
                    sprintf((char*)slide_num, "%d", 0);
                }
                else
                {
                    sprintf((char*)slide_num, "%d", g_uc_p->msg.total_slide_num);
                }
                attr_list[i++] = (U8*)MMI_UC_XML_ATTR_SLIDE_NUM;
                attr_list[i++] = slide_num;

                memset(obj_num, 0, str_len);
                sprintf((char*)obj_num, "%d", g_uc_p->msg.total_object_num);
                attr_list[i++] = (U8*)MMI_UC_XML_ATTR_OBJ_NUM;
                attr_list[i++] = obj_num;            

                memset(layout, 0, str_len);
                sprintf((char*)layout, "%d", mmi_uc_convert_to_mms_layout_type(g_uc_p->msg.layout));
                attr_list[i++] = (U8*)MMI_UC_XML_ATTR_LAYOUT;
                attr_list[i++] = layout;

                attr_list[i++] = NULL;

                MMI_ASSERT(i == (attr_num * 2 + 1));

                if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_BODY, attr_list)) != FS_NO_ERROR)
                {
                    FS_Close(fh);
                    return result;
                }
                if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
                {
                    FS_Close(fh);
                    return result;
                }            
            }

            /* Slide */
            if (mmi_uc_check_only_attachment() && g_uc_p->send_info.action != MMI_UC_ACTION_PREVIEW)
            {
                /* If only attachments and one slide without any content, do not send slide info.*/
                /* reference phone behavior */
            }
            else
            {
                if (g_uc_p->msg.total_slide_num)
                {
                    mmi_uc_slide_struct* slide = g_uc_p->msg.slide_head;
                    U16 i = 0;

                    while (i < g_uc_p->msg.total_slide_num)
                    {
                        MMI_ASSERT(slide);
                        if ((result = mmi_uc_create_xml_slide(fh, slide)) != FS_NO_ERROR)
                        {
                            FS_Close(fh);
                            return result;
                        }
                        slide = slide->next;
                        i++;
                    }            
                }
            }

            /* Object */
            if (g_uc_p->msg.total_object_num)
            {
                mmi_uc_object_struct* object = g_uc_p->msg.object_head;
                U16 i = 0;

                while (i < g_uc_p->msg.total_object_num)
                {
                    MMI_ASSERT(object);
                    if ((result = mmi_uc_create_xml_object(fh, object)) != FS_NO_ERROR)
                    {
                        FS_Close(fh);
                        return result;
                    }
                    object = object->next;
                    i++;
                }            
            }

            /* </body> */
            if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_BODY)) != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }
            if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
            {
                FS_Close(fh);
                return result;
            }
        }

        /* </mms> */
        if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_MMS)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            FS_Close(fh);
            return result;
        }            
        
        FS_Close(fh);
    }
    else
    {
        result = (S32)fh;
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                             "*[UnifiedComposerMiscell.c] mmi_uc_create_mms_xml_description_file Create xml file FAIL! res=%d *\n", result);
    }

    return result;
}




/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_element_start
 * DESCRIPTION
 *  Create the xml start element
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_element_start(FS_HANDLE fh, U8* element_name, U8** attr_list)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* temp_str = OslMalloc(MMI_UC_XML_TEMP_STR_LEN);
    S32 result = FS_NO_ERROR;
    U32 write_len = 0;
    U32 i = 0;
    U32 offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(temp_str,0,MMI_UC_XML_TEMP_STR_LEN);
    offset += sprintf((char*)temp_str, "%s%s", XML_TAG_ELEMENT_START, element_name);

    if (attr_list)
    {
        while (attr_list[i])
        {
            offset += sprintf((char*)temp_str + offset, " %s=\"%s\"", attr_list[i], attr_list[i + 1]);
            i = i + 2;
        }
    }

    offset += sprintf((char*)(temp_str + offset), "%s", XML_TAG_GENERAL_END);

    MMI_ASSERT(offset < MMI_UC_XML_TEMP_STR_LEN);

    result = FS_Write(fh, temp_str, offset, &write_len);

    OslMfree(temp_str);

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_element_end
 * DESCRIPTION
 *  Create the xml end element
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_element_end(FS_HANDLE fh, U8* element_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* temp_str = OslMalloc(MMI_UC_XML_TEMP_STR_LEN);
    S32 result = FS_NO_ERROR;
    U32 write_len = 0;
    U32 offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(temp_str,0,MMI_UC_XML_TEMP_STR_LEN);
    offset += sprintf((char*)temp_str, "%s%s%s", XML_TAG_ELEMENT_END, element_name,XML_TAG_GENERAL_END);

    MMI_ASSERT(offset < MMI_UC_XML_TEMP_STR_LEN);

    result = FS_Write(fh, temp_str, offset, &write_len);

    OslMfree(temp_str);

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_new_line
 * DESCRIPTION
 *  Insert new line
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_new_line(FS_HANDLE fh)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* temp_str = OslMalloc(MMI_UC_XML_TEMP_STR_LEN);
    S32 result = FS_NO_ERROR;
    U32 write_len = 0;
    U32 offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(temp_str,0,MMI_UC_XML_TEMP_STR_LEN);
    offset += sprintf((char*)temp_str, "\n");

    result = FS_Write(fh, temp_str, offset, &write_len);

    OslMfree(temp_str);

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_data
 * DESCRIPTION
 *  Add data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_data(FS_HANDLE fh, U8* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result = FS_NO_ERROR;
    U32 write_len = 0;
    U32 offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    offset = strlen((char*)data);

    result = FS_Write(fh, data, offset, &write_len);

    return result;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_data
 * DESCRIPTION
 *  Add data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_data_usc2_to_utf8(FS_HANDLE fh, U8* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* utf8_data;
    U32 utf8_data_len = mmi_ucs2strlen((S8*)data) * 3 + 1;
    S32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    utf8_data = OslMalloc(utf8_data_len);
    memset(utf8_data,0,utf8_data_len);
    
    mmi_chset_ucs2_to_utf8_string(
        (kal_uint8*) utf8_data,
        utf8_data_len,
        (kal_uint8*) data);

    result = mmi_uc_create_xml_data(fh, utf8_data);

    OslMfree(utf8_data);

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_data_usc2_to_utf8_to_base64
 * DESCRIPTION
 *  Add data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_data_usc2_to_utf8_to_base64(FS_HANDLE fh, U8* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* utf8_data;
    U32 utf8_data_len = mmi_ucs2strlen((S8*)data) * 3 + 1;
    S32 result;
    U32 utf8_data_actual_len = 0;
    U32 base64_data_len = 0;
    U8* base64_data = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    utf8_data = OslMalloc(utf8_data_len);
    memset(utf8_data,0,utf8_data_len);
    
    utf8_data_actual_len = mmi_chset_ucs2_to_utf8_string(
                                        (kal_uint8*) utf8_data,
                                        utf8_data_len,
                                        (kal_uint8*) data);
    
    base64_data_len = utf8_data_actual_len * 3;
    
    base64_data = OslMalloc(base64_data_len + 1);
    memset(base64_data,0,base64_data_len + 1);
    
    applib_base64_encode((S8*)utf8_data, utf8_data_actual_len, (S8*)base64_data, base64_data_len);

    result = mmi_uc_create_xml_data(fh, base64_data);

    OslMfree(base64_data);
    OslMfree(utf8_data);

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_data_numeric_to_char
 * DESCRIPTION
 *  Add numeric data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_data_numeric_to_char(FS_HANDLE fh, U32 value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* data;
    U32 data_len = 10;
    S32 result;
    U32 offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    data = OslMalloc(data_len);
    memset(data,0,data_len);
    
    offset += sprintf((char*)data, "%d", value);

    result = mmi_uc_create_xml_data(fh, data);

    OslMfree(data);

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_addr
 * DESCRIPTION
 *  Add data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_addr(FS_HANDLE fh, mmi_uc_address_group_type_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result;
    U32 i = 0;
    mmi_uc_addr_struct* addr = NULL;
    U8* attr_list[3];
    U8* xml_addr_type = NULL;
    U32 total = 0;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (type)
    {
        case MMI_UC_ADDRESS_GROUP_TYPE_TO:
        {
            addr = g_uc_p->msg.to_head;
            total = g_uc_p->msg.to_num;
            xml_addr_type = (U8*)MMI_UC_XML_ELEMENT_TO;
        }
        break;
            
        case MMI_UC_ADDRESS_GROUP_TYPE_CC:
        {
            addr = g_uc_p->msg.cc_head;
            total = g_uc_p->msg.cc_num;
            xml_addr_type = (U8*)MMI_UC_XML_ELEMENT_CC;
        }
        break;

        case MMI_UC_ADDRESS_GROUP_TYPE_BCC:
        {
            addr = g_uc_p->msg.bcc_head;
            total = g_uc_p->msg.bcc_num;
            xml_addr_type = (U8*)MMI_UC_XML_ELEMENT_BCC;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    attr_list[0] = (U8*)MMI_UC_XML_ATTR_TYPE;
    attr_list[2] = NULL;
    while (i < total)
    {
        MMI_ASSERT(addr);
        
        if (addr->type == MMI_UC_ADDRESS_TYPE_PHONE_NUMBER)
        {
            attr_list[1] = (U8*)MMI_UC_XML_ATTR_POHNE_NUMBER;
            if ((result = mmi_uc_create_xml_element_start(fh,xml_addr_type,attr_list)) 
                != FS_NO_ERROR)
            {
                return result;
            }

            if ((result = mmi_uc_create_xml_data(fh, addr->addr)) != FS_NO_ERROR)
            {
                return result;
            }                    
        }
        else if (addr->type == MMI_UC_ADDRESS_TYPE_EMAIL)
        {        
            attr_list[1] = (U8*)MMI_UC_XML_ATTR_EMAIL_ADDR;
            
            if ((result = mmi_uc_create_xml_element_start(fh,xml_addr_type,attr_list)) 
                != FS_NO_ERROR)
            {
                return result;
            }            
            if ((result = mmi_uc_create_xml_data_usc2_to_utf8(fh, addr->addr)) != FS_NO_ERROR)
            {
                return result;
            }                    
        }
        else
        {
            MMI_ASSERT(0);
        }

        if ((result = mmi_uc_create_xml_element_end(fh, xml_addr_type)) 
                != FS_NO_ERROR)
        {
            return result;
        }
        if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
        {
            return result;
        }

        addr = addr->next;
        i++;
    }
    return FS_NO_ERROR;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_slide
 * DESCRIPTION
 *  Add data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_slide(FS_HANDLE fh, mmi_uc_slide_struct* slide)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result;    
    U16 str_len = 5;  /* size of index and duration */
    U16 attr_num = 2; /* size of attr_list would be attr_num * 2 + 1 */
    U8 index[5];
    U8 duration[5];
    U8* attr_list[2 * 2 + 1];
    U8 j = 0;

    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(slide);

    memset(index, 0, str_len);
    sprintf((char*)index, "%d", (slide->slide_num));
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_INDEX;
    attr_list[j++] = index;

    memset(duration, 0, str_len);
    sprintf((char*)duration, "%d", slide->duration);
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_DURATION;
    attr_list[j++] = duration;

    attr_list[j++] = NULL;

    MMI_ASSERT(j == (attr_num * 2 + 1));

    if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_SLIDE, attr_list)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
    {
        return result;
    }
    /* text */
    if (slide->text.object)
    {
        if ((result = mmi_uc_create_xml_slide_object(fh, slide, MMI_UC_OBJECT_TYPE_TEXT)) != FS_NO_ERROR)
        {
            return result;
        }
    }
    /* image */
    if (slide->image.object)
    {
        if ((result = mmi_uc_create_xml_slide_object(fh, slide, MMI_UC_OBJECT_TYPE_IMAGE)) != FS_NO_ERROR)
        {
            return result;
        }
    }
    /* audio */
    if (slide->audio.object)
    {
        if ((result = mmi_uc_create_xml_slide_object(fh, slide, MMI_UC_OBJECT_TYPE_AUDIO)) != FS_NO_ERROR)
        {
            return result;
        }
    }
    /* video */
    if (slide->video.object)
    {
        if ((result = mmi_uc_create_xml_slide_object(fh, slide, MMI_UC_OBJECT_TYPE_VIDEO)) != FS_NO_ERROR)
        {
            return result;
        }
    }

    if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_SLIDE)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
    {
        return result;
    }

    return FS_NO_ERROR;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_slide_object
 * DESCRIPTION
 *  Add data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_slide_object(FS_HANDLE fh, mmi_uc_slide_struct* slide, mmi_uc_object_type obj_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result;
    U32 bg_color = 0;
    U32 fg_color = 0;
    U32 begin = 0;
    U32 end = 0;    
    U16 color_str_len = 10; /* size of bg_color_str and fg_color_str */
    U16 str_len = 5; /* size of id_str , start_str, and end_str */
    U16 attr_num = 5; /* size of attr_list would be attr_num * 2 + 1 */
    U32 id = 0;    
    U8 bg_color_str[10];
    U8 fg_color_str[10];
    U8 id_str[5];
    U8 start_str[5];
    U8 end_str[5];
    U8* attr_list[5 * 2 + 1];
    U8 i = 0;
    U8* obj_xml_type = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(slide);
    
    switch (obj_type)
    {
        case MMI_UC_OBJECT_TYPE_TEXT:
        {
            MMI_ASSERT(slide->text.object);
            /*Because currently, not support setting text bgcolor or fgcolor, therefore if glbal bgcolor exist, will use it*/
            if ((slide->text.foreground_color == MMI_UC_DEFAULT_FG_COLOR) && 
                (g_uc_p->msg.foreground_color != MMI_UC_DEFAULT_FG_COLOR))
            { 
                fg_color = g_uc_p->msg.foreground_color; 
            }
            else
            {
                fg_color = slide->text.foreground_color;
            } 
            if ((slide->text.background_color == MMI_UC_DEFAULT_BG_COLOR) &&
                (g_uc_p->msg.background_color != MMI_UC_DEFAULT_BG_COLOR))
            { 
                bg_color = g_uc_p->msg.background_color; 
            }
            else
            {
                bg_color = slide->text.background_color;
            } 
           
            id = slide->text.object->id;
            if ( (MMI_UC_INVALID_VALUE == slide->text.begin) || (MMI_UC_INVALID_VALUE == slide->text.end) )
            {
                begin = 0;
                end =  slide->duration;
            }
            else
            {
                begin = slide->text.begin;            
                end = slide->text.end;
            }
            obj_xml_type = (U8*)MMI_UC_XML_ELEMENT_TEXT;
        }
        break;

        case MMI_UC_OBJECT_TYPE_IMAGE:
        {
            MMI_ASSERT(slide->image.object);
            id = slide->image.object->id;
            if ( (MMI_UC_INVALID_VALUE == slide->image.begin) || (MMI_UC_INVALID_VALUE == slide->image.end) )
            {
                begin = 0;
                end =  slide->duration;
            }
            else
            {
                begin = slide->image.begin;            
                end = slide->image.end;
            }
            obj_xml_type = (U8*)MMI_UC_XML_ELEMENT_IMAGE;
        }
        break;
        
        case MMI_UC_OBJECT_TYPE_AUDIO:
        {
            MMI_ASSERT(slide->audio.object);
            id = slide->audio.object->id;
            if ( (MMI_UC_INVALID_VALUE == slide->audio.begin) || (MMI_UC_INVALID_VALUE == slide->audio.end) )
            {
                begin = 0;
                end =  slide->duration;
            }
            else
            {
                begin = slide->audio.begin;            
                end = slide->audio.end;
            }
            obj_xml_type = (U8*)MMI_UC_XML_ELEMENT_AUDIO;
        }
        break;
        
        case MMI_UC_OBJECT_TYPE_VIDEO:
        {
            MMI_ASSERT(slide->video.object);
            id = slide->video.object->id;
            if ( (MMI_UC_INVALID_VALUE == slide->video.begin) || (MMI_UC_INVALID_VALUE == slide->video.end) )
            {
                begin = 0;
                end =  slide->duration;
            }
            else
            {
                begin = slide->video.begin;            
                end = slide->video.end;
            }

            obj_xml_type = (U8*)MMI_UC_XML_ELEMENT_VIDEO;
        }
        break;        

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }


    if (obj_type == MMI_UC_OBJECT_TYPE_TEXT)
    {
        memset(bg_color_str, 0, color_str_len);
        sprintf((char*)bg_color_str, "0x%06x", bg_color);
        attr_list[i++] = (U8*)MMI_UC_XML_ATTR_BGCOLOR;
        attr_list[i++] = bg_color_str;
        
        memset(fg_color_str, 0, color_str_len);
        sprintf((char*)fg_color_str, "0x%06x", fg_color);
        attr_list[i++] = (U8*)MMI_UC_XML_ATTR_FGCOLOR;
        attr_list[i++] = fg_color_str;
    }

    memset(id_str, 0, str_len);
    sprintf((char*)id_str, "%d", id);
    attr_list[i++] = (U8*)MMI_UC_XML_ATTR_ID;
    attr_list[i++] = id_str;

    if (begin != MMI_UC_INVALID_VALUE &&
        end != MMI_UC_INVALID_VALUE)
    {
        memset(start_str, 0, str_len);
        sprintf((char*)start_str, "%d", begin);
        attr_list[i++] = (U8*)MMI_UC_XML_ATTR_BEGIN;
        attr_list[i++] = start_str;            

        memset(end_str, 0, str_len);
        sprintf((char*)end_str, "%d", end);
        attr_list[i++] = (U8*)MMI_UC_XML_ATTR_END;
        attr_list[i++] = end_str;
    }
    
    attr_list[i] = NULL;

    MMI_ASSERT(i <= (attr_num * 2 + 1));

    if ((result = mmi_uc_create_xml_element_single(fh, obj_xml_type, attr_list)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
    {
        return result;
    }

    return FS_NO_ERROR;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_element_single
 * DESCRIPTION
 *  Create the xml single element
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_element_single(FS_HANDLE fh, U8* element_name, U8** attr_list)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* temp_str = OslMalloc(MMI_UC_XML_TEMP_STR_LEN);
    S32 result = FS_NO_ERROR;
    U32 write_len = 0;
    U32 i = 0;
    U32 offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(temp_str,0,MMI_UC_XML_TEMP_STR_LEN);
    offset += sprintf((char*)temp_str, "%s%s", XML_TAG_ELEMENT_START, element_name);

    if (attr_list)
    {
        while (attr_list[i])
        {
            offset += sprintf((char*)(temp_str + offset), " %s=\"%s\"", attr_list[i], attr_list[i + 1]);
            i = i + 2;
        }
    }

    offset += sprintf((char*)(temp_str + offset), "%s", XML_TAG_SINGLE_END);

    MMI_ASSERT(offset < MMI_UC_XML_TEMP_STR_LEN);

    result = FS_Write(fh, temp_str, offset, &write_len);

    OslMfree(temp_str);

    return result;
}


    
/*****************************************************************************
 * FUNCTION
 *  mmi_uc_create_xml_object
 * DESCRIPTION
 *  Add data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_create_xml_object(FS_HANDLE fh, mmi_uc_object_struct* obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result;    
    U16 str_len = 5; /* size of id, attach, vf, and drm */
    U16 byte_len = 10; /* size of size and offset */
    U16 attr_num = 7;/* size of attr_list would be attr_num * 2 + 1 */ 
    U8 id[5];
    U8 attach[5];
    U8 vf[5];
    U8 drm[5];
    U8 size[10];
    U8 offset[10];
    U8 encoding[5];
    U8* attr_list[7 * 2 + 1]; /*7:id,attach, vf,drm,size,offset,encoding */
    U8 j = 0;

    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(obj);

    memset(id, 0, str_len);
    sprintf((char*)id, "%d", obj->id);
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_ID;
    attr_list[j++] = id;

    memset(attach, 0, str_len);
    if (obj->type == MMI_UC_OBJECT_TYPE_ATTACHMENT)
    {
        sprintf((char*)attach, "%d", 1);
    }
    else
    {
        sprintf((char*)attach, "%d", 0);
    }    
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_ATTACH;
    attr_list[j++] = attach;

    memset(vf, 0, str_len);
    sprintf((char*)vf, "%d", obj->is_virtual_file);
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_VIRTUAL_FILE;
    attr_list[j++] = vf;

    memset(drm, 0, str_len);
    sprintf((char*)drm, "%d", obj->drm_type);
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_DRM;
    attr_list[j++] = drm;

    memset(size, 0, byte_len);
    sprintf((char*)size, "%d", obj->size);
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_SIZE;
    attr_list[j++] = size;

    memset(offset, 0, byte_len);
    sprintf((char*)offset, "%d", obj->offset);
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_OFFSET;
    attr_list[j++] = offset;

    memset(encoding, 0, str_len);
    if (MMI_UC_OBJECT_TYPE_TEXT == obj->type)
    {
        sprintf((char*)encoding, "%d", MMA_CHARSET_UTF8);
    }
    else
    {
        sprintf((char*)encoding, "%d", obj->encoding);
    }
    attr_list[j++] = (U8*)MMI_UC_XML_ATTR_ENCODING;
    attr_list[j++] = encoding;


    attr_list[j++] = NULL;

    MMI_ASSERT(j == (attr_num * 2 + 1));

    /* <obj> */
    if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_OBJECT, attr_list)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
    {
        return result;
    }
    
    /* name */
    if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_NAME, NULL)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_data_usc2_to_utf8(fh, (U8*)obj->file_name)) != FS_NO_ERROR)
    {
        return result;
    }                    
    if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_NAME)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
    {
        return result;
    }
    
    /* file path */
    if ((result = mmi_uc_create_xml_element_start(fh, (U8*)MMI_UC_XML_ELEMENT_FILE_PATH, NULL)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_data_usc2_to_utf8(fh, (U8*)obj->file_path)) != FS_NO_ERROR)
    {
        return result;
    }                    
    if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_FILE_PATH)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
    {
        return result;
    }
   
    /* </obj> */
    if ((result = mmi_uc_create_xml_element_end(fh, (U8*)MMI_UC_XML_ELEMENT_OBJECT)) != FS_NO_ERROR)
    {
        return result;
    }
    if ((result = mmi_uc_create_xml_new_line(fh)) != FS_NO_ERROR)
    {
        return result;
    }

    return FS_NO_ERROR;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_update_object_id
 * DESCRIPTION
 *  Update object ID
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_update_object_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i = 1;
    mmi_uc_object_struct* object = g_uc_p->msg.object_head;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for(;i <= g_uc_p->msg.total_object_num; i++)
    {
        MMI_ASSERT(object);
        object->id = i;
        object = object->next;
    }
    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_parse_mms_xml_description_file
 * DESCRIPTION
 *  Pare mms xml description file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_uc_parse_mms_xml_description_file(U16* file_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_uc_p->xml.xml_parser = OslMalloc(sizeof(XML_PARSER_STRUCT));

    memset(g_uc_p->xml.xml_parser, 0, sizeof(XML_PARSER_STRUCT));

    result = xml_new_parser(g_uc_p->xml.xml_parser);

    if (result)
    {
        xml_close_parser(g_uc_p->xml.xml_parser);
        OslMfree(g_uc_p->xml.xml_parser);
        g_uc_p->xml.xml_parser = NULL;
        return MMI_UC_XML_ERROR;
    }

    xml_register_element_handler(g_uc_p->xml.xml_parser, mmi_uc_xml_start_element_hdlr, mmi_uc_xml_end_element_hdlr);

    xml_register_data_handler(g_uc_p->xml.xml_parser, mmi_uc_xml_data_hdlr);

    result = xml_parse(g_uc_p->xml.xml_parser, file_path);

    xml_close_parser(g_uc_p->xml.xml_parser);

    OslMfree(g_uc_p->xml.xml_parser);
    g_uc_p->xml.xml_parser = NULL;

    if (result)
    {
        return MMI_UC_XML_ERROR;
    }
    else
    {
        S32 match_obj_result = mmi_uc_match_object_id();
        
        if (FS_NO_ERROR == match_obj_result)
        {
            return MMI_UC_OK;
        }
        else if (FS_ERROR_RESERVED == match_obj_result) /*mean text obj is refered more than once*/
        {
            return MMI_UC_NOT_SUPPORT;
        }
        else
        {
            return MMI_UC_STORAGE_FULL;
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_mms_app_mode_to_uc_state
 * DESCRIPTION
 *  Convert mma_app_mode_enum to mmi_uc_state_enum
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_uc_convert_mms_app_mode_to_uc_state(U16 app_mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 uc_state = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (app_mode)
    {
        case MMA_MODE_SEND:
        {
            uc_state = MMI_UC_STATE_SEND;
        }
        break;
        case MMA_MODE_FORWARD:
        {
            uc_state = MMI_UC_STATE_FORWARD;
        }
        break;
        case MMA_MODE_REPLY:
        {
            uc_state = MMI_UC_STATE_REPLY;
        }
        break;
        case MMA_MODE_REPLY_ALL:
        {
            uc_state = MMI_UC_STATE_REPLY_ALL;
        }
        break;
        case MMA_MODE_EDIT:
        {
            uc_state = MMI_UC_STATE_EDIT_EXISTED_MSG;
        }
        break;
        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }
    
    return uc_state;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_uc_state_to_mms_app_mode
 * DESCRIPTION
 *  Convert mmi_uc_state_enum to mma_app_mode_enum
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_uc_convert_uc_state_to_mms_app_mode(U16 uc_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 app_mode = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (uc_state)
    {
        case MMI_UC_STATE_SEND:
        {
            app_mode =  MMA_MODE_SEND;
        }
        break;
        case MMI_UC_STATE_FORWARD:
        {
            app_mode =  MMA_MODE_FORWARD;
        }
        break;
        case MMI_UC_STATE_REPLY:
        {
            app_mode =  MMA_MODE_REPLY;
        }
        break;
        case MMI_UC_STATE_REPLY_ALL:
        {
            app_mode =  MMA_MODE_REPLY_ALL;
        }
        break;
        case MMI_UC_STATE_EDIT_EXISTED_MSG:
        {
            app_mode =  MMA_MODE_EDIT;
        }
        break;
        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }
    
    return app_mode;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_xml_start_element_hdlr
 * DESCRIPTION
 *  Start element handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_xml_start_element_hdlr(void *data, const char *el, const char **attr, S32 error)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((!strcmp(MMI_UC_XML_ELEMENT_TO, el)) || 
        (!strcmp(MMI_UC_XML_ELEMENT_CC, el)) ||
        (!strcmp(MMI_UC_XML_ELEMENT_BCC, el))||
        (!strcmp(MMI_UC_XML_ELEMENT_FROM, el)))
    {
        if (!strcmp(MMI_UC_XML_ATTR_TYPE, attr[0]))
        {
            if (!strcmp(MMI_UC_XML_ATTR_POHNE_NUMBER, attr[1]))
            {
                g_uc_p->xml.addr_type = MMI_UC_ADDRESS_TYPE_PHONE_NUMBER;
            }
            else if (!strcmp(MMI_UC_XML_ATTR_EMAIL_ADDR, attr[1]))
            {
                g_uc_p->xml.addr_type = MMI_UC_ADDRESS_TYPE_EMAIL;
            }
            else
            {                
                MMI_ASSERT(0);
                
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*[UnifiedComposerMain.c] mmi_uc_xml_start_element_hdlr addr type error*\n");
                
                g_uc_p->xml.addr_type = MMI_UC_ADDRESS_TYPE_PHONE_NUMBER;
            }
        }        
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_BODY , el))
    {
        for (i = 0; attr[i]; i = i + 2)
        {
            if (!strcmp(MMI_UC_XML_ATTR_BGCOLOR , attr[i]))
            {
                g_uc_p->msg.background_color = mmi_uc_convert_ascii_hex_to_dec((U8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_FGCOLOR , attr[i]))
            {
                g_uc_p->msg.foreground_color = mmi_uc_convert_ascii_hex_to_dec((U8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_SLIDE_NUM , attr[i]))
            {
                /* updated in mmi_uc_insert_slide_by_number*/
                //g_uc_p->msg.total_slide_num = atoi((S8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_OBJ_NUM , attr[i]))
            {
                /* updated in mmi_uc_insert_object_to_list_tail() */
                //g_uc_p->msg.total_object_num = atoi((S8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_LAYOUT , attr[i]))
            {
                g_uc_p->msg.layout = mmi_uc_convert_mms_layout_type_to_uc((U8)atoi((S8*) attr[i + 1]));
            }                
        }        
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_SLIDE  , el))
    {
        U8 slide_number = 0;
        U32 duration = g_uc_p->mms_info.sliding_time.value;

        for (i = 0; attr[i]; i = i + 2)
        {
            if (!strcmp(MMI_UC_XML_ATTR_INDEX, attr[i]))
            {
                slide_number = atoi((S8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_DURATION , attr[i]))
            {
                duration = atoi((S8*) attr[i + 1]);
            }
        }        

        if (slide_number)
        {
            g_uc_p->xml.slide = mmi_uc_insert_slide_by_number(slide_number);

            if (g_uc_p->xml.slide)
            {
                MMI_ASSERT(g_uc_p->xml.slide->slide_num == slide_number);

                /* Check slide duration boundary */
                if (duration > g_uc_p->mms_info.sliding_time.max)
                {
                    duration = g_uc_p->mms_info.sliding_time.max;
                }
                else if (duration < g_uc_p->mms_info.sliding_time.min)
                {
                    duration = g_uc_p->mms_info.sliding_time.min;
                }                
                g_uc_p->xml.slide->duration = duration;
            }                
            else
            {
                MMI_ASSERT(0);
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*[UnifiedComposerMain.c] mmi_uc_xml_start_element_hdlr slide error*\n");      
            }
        }
        else
        {
            MMI_ASSERT(0);
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMain.c] mmi_uc_xml_start_element_hdlr slide number error*\n");      
        }        
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_TEXT , el))
    {
        g_uc_p->xml.slide->text.background_color = MMI_UC_DEFAULT_BG_COLOR;
        g_uc_p->xml.slide->text.foreground_color = MMI_UC_DEFAULT_FG_COLOR;
            
        for (i = 0; attr[i]; i = i + 2)
        {
            if (!strcmp(MMI_UC_XML_ATTR_ID , attr[i]))
            {
                g_uc_p->xml.slide->text.id = (atoi((S8*) attr[i + 1]));
            }
            else if (!strcmp(MMI_UC_XML_ATTR_BEGIN , attr[i]))
            {
                g_uc_p->xml.slide->text.begin = atoi((S8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_END , attr[i]))
            {
                g_uc_p->xml.slide->text.end = atoi((S8*) attr[i + 1]);
            }            
            else if (!strcmp(MMI_UC_XML_ATTR_BGCOLOR , attr[i]))
            {
                g_uc_p->xml.slide->text.background_color = mmi_uc_convert_ascii_hex_to_dec((U8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_FGCOLOR , attr[i]))
            {
                g_uc_p->xml.slide->text.foreground_color = mmi_uc_convert_ascii_hex_to_dec((U8*) attr[i + 1]);
            }
        }        
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_IMAGE, el))
    {
        for (i = 0; attr[i]; i = i + 2)
        {
            if (!strcmp(MMI_UC_XML_ATTR_ID , attr[i]))
            {
                g_uc_p->xml.slide->image.id = (atoi((S8*) attr[i + 1]));
            }
            else if (!strcmp(MMI_UC_XML_ATTR_BEGIN , attr[i]))
            {
                g_uc_p->xml.slide->image.begin = atoi((S8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_END , attr[i]))
            {
                g_uc_p->xml.slide->image.end = atoi((S8*) attr[i + 1]);
            }            
        }        
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_AUDIO, el))
    {
        for (i = 0; attr[i]; i = i + 2)
        {
            if (!strcmp(MMI_UC_XML_ATTR_ID , attr[i]))
            {
                g_uc_p->xml.slide->audio.id = (atoi((S8*) attr[i + 1]));
            }
            else if (!strcmp(MMI_UC_XML_ATTR_BEGIN , attr[i]))
            {
                g_uc_p->xml.slide->audio.begin = atoi((S8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_END , attr[i]))
            {
                g_uc_p->xml.slide->audio.end = atoi((S8*) attr[i + 1]);
            }            
        }        
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_VIDEO, el))
    {
        for (i = 0; attr[i]; i = i + 2)
        {
            if (!strcmp(MMI_UC_XML_ATTR_ID , attr[i]))
            {
                g_uc_p->xml.slide->video.id = (atoi((S8*) attr[i + 1]));
            }
            else if (!strcmp(MMI_UC_XML_ATTR_BEGIN , attr[i]))
            {
                g_uc_p->xml.slide->video.begin = atoi((S8*) attr[i + 1]);
            }
            else if (!strcmp(MMI_UC_XML_ATTR_END , attr[i]))
            {
                g_uc_p->xml.slide->video.end = atoi((S8*) attr[i + 1]);
            }            
        }        
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_OBJECT, el))
    {
        g_uc_p->xml.object = mmi_uc_insert_object_to_list_tail();
        
        for (i = 0; attr[i]; i = i + 2)
        {
            if (!strcmp(MMI_UC_XML_ATTR_ID , attr[i]))
            {
                g_uc_p->xml.object->id = (atoi((S8*) attr[i + 1]));
            }
            else if (!strcmp(MMI_UC_XML_ATTR_ATTACH , attr[i]))
            {
                if (atoi((S8*) attr[i + 1]))
                {
                    g_uc_p->xml.object->type = MMI_UC_OBJECT_TYPE_ATTACHMENT;
                }
            }
            else if (!strcmp(MMI_UC_XML_ATTR_VIRTUAL_FILE , attr[i]))
            {
                if (atoi((S8*) attr[i + 1]))
                {
                    g_uc_p->xml.object->is_virtual_file = MMI_TRUE;
                }
                else
                {
                    g_uc_p->xml.object->is_virtual_file = MMI_FALSE;
                }
            }            
            else if (!strcmp(MMI_UC_XML_ATTR_DRM, attr[i]))
            {
                if (atoi((S8*) attr[i + 1]))
                {
                    g_uc_p->xml.object->drm_type = (atoi((S8*) attr[i + 1]));
                }
            }
            else if (!strcmp(MMI_UC_XML_ATTR_SIZE , attr[i]))
            {
                if (atoi((S8*) attr[i + 1]))
                {
                    g_uc_p->xml.object->size = (atoi((S8*) attr[i + 1]));
                }
            }
            else if (!strcmp(MMI_UC_XML_ATTR_OFFSET  , attr[i]))
            {
                if (atoi((S8*) attr[i + 1]))
                {
                    g_uc_p->xml.object->offset = (atoi((S8*) attr[i + 1]));
                }
            }            
            else if (!strcmp(MMI_UC_XML_ATTR_ENCODING  , attr[i]))
            {
                if (atoi((S8*) attr[i + 1]))
                {
                    g_uc_p->xml.object->encoding = (atoi((S8*) attr[i + 1]));
                }
            } 
        }        
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_xml_end_element_hdlr
 * DESCRIPTION
 *  end element handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_xml_end_element_hdlr(void *data, const char *el, S32 error)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!strcmp(MMI_UC_XML_ELEMENT_OBJECT, el))
    {   
        if (g_uc_p->xml.object->type == MMI_UC_OBJECT_TYPE_ATTACHMENT)
        {
            mmi_uc_attachment_info_struct* att;
            
            att = mmi_uc_insert_attachment();
            mmi_uc_insert_object_to_attachment(g_uc_p->xml.object, att);
        }
    }
    return;

}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_xml_start_element_hdlr
 * DESCRIPTION
 *  Start element handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_xml_data_hdlr(void *data, const char *el, const char *value, int len, S32 error)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!strcmp(MMI_UC_XML_ELEMENT_TO, el))
    {   
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY ||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Do nothing */
        }
        else
        {
            mmi_uc_xml_data_address_hdlr(
                    (U8*)value,
                    len,
                    g_uc_p->xml.addr_type, 
                    MMI_UC_ADDRESS_GROUP_TYPE_TO);
        }
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_CC, el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Do nothing */
        }
        else
        {
            mmi_uc_xml_data_address_hdlr(
                    (U8*)value,
                    len,
                    g_uc_p->xml.addr_type, 
                    MMI_UC_ADDRESS_GROUP_TYPE_CC);
        }
        
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_BCC, el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Do nothing */
        }
        else
        {
            mmi_uc_xml_data_address_hdlr(
                    (U8*)value,
                    len,
                    g_uc_p->xml.addr_type, 
                    MMI_UC_ADDRESS_GROUP_TYPE_BCC);
        }
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_FROM, el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY ||
            g_uc_p->main.state == MMI_UC_STATE_REPLY_ALL )
        {
            mmi_uc_xml_data_address_hdlr(
                    (U8*)value,
                    len,
                    g_uc_p->xml.addr_type, 
                    MMI_UC_ADDRESS_GROUP_TYPE_TO);
        }
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_SUBJECT, el))
    {
        U8 *utf8_data = NULL;
        U32 base64_len = strlen((S8*)value);
        U32 utf8_len = 0;
        
        memset(g_uc_p->msg.subject, 0 ,MMI_UC_MAX_SUBJECT_LEN * ENCODING_LENGTH);

        utf8_len = applib_base64_decode_len((S8*)value, base64_len);
        utf8_data = OslMalloc(utf8_len + 1);
        memset(utf8_data, 0 , utf8_len + 1);
        
        applib_base64_decode((S8*)value, base64_len, (S8*)utf8_data,utf8_len);

        mmi_chset_utf8_to_ucs2_string((kal_uint8*)g_uc_p->msg.subject, (MMI_UC_MAX_SUBJECT_LEN + 1) * ENCODING_LENGTH, (kal_uint8*)utf8_data);

        OslMfree(utf8_data);
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_READ_REPORT, el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY ||
            g_uc_p->main.state == MMI_UC_STATE_REPLY_ALL ||
            g_uc_p->main.state == MMI_UC_STATE_EDIT_EXISTED_MSG ||
            g_uc_p->main.state == MMI_UC_STATE_SEND ||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Use current setting value */
        }
        else
        {
            if (atoi((S8*) value))
            {
                g_uc_p->msg.read_report = MMI_TRUE;
            }
            else
            {
                g_uc_p->msg.read_report = MMI_FALSE;
            }
        }
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_DELIVERY_REPORT, el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY ||
            g_uc_p->main.state == MMI_UC_STATE_REPLY_ALL ||
            g_uc_p->main.state == MMI_UC_STATE_EDIT_EXISTED_MSG ||
            g_uc_p->main.state == MMI_UC_STATE_SEND ||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Use current setting value */
        }
        else
        {
            if (atoi((S8*) value))
            {
                g_uc_p->msg.delivery_report = MMI_TRUE;
            }
            else
            {
                g_uc_p->msg.delivery_report = MMI_FALSE;
            }
        }
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_PRIORITY , el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY ||
            g_uc_p->main.state == MMI_UC_STATE_REPLY_ALL ||
            g_uc_p->main.state == MMI_UC_STATE_EDIT_EXISTED_MSG ||
            g_uc_p->main.state == MMI_UC_STATE_SEND ||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Use current setting value */
        }
        else
        {
            g_uc_p->msg.priority = atoi((S8*) value);        
        }
    }
    else if (!strcmp(MMI_UC_XML_ELEMENT_EXPIRY , el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY ||
            g_uc_p->main.state == MMI_UC_STATE_REPLY_ALL ||
            g_uc_p->main.state == MMI_UC_STATE_EDIT_EXISTED_MSG ||
            g_uc_p->main.state == MMI_UC_STATE_SEND ||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Use current setting value */
        }
        else
        {
            g_uc_p->msg.expiry_time = mmi_uc_convert_mms_expiry_time_to_uc(atoi((S8*) value));        
        }
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_DELIVERY_TIME , el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY ||
            g_uc_p->main.state == MMI_UC_STATE_REPLY_ALL ||
            g_uc_p->main.state == MMI_UC_STATE_EDIT_EXISTED_MSG ||
            g_uc_p->main.state == MMI_UC_STATE_SEND ||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Use current setting value */
        }
        else
        {
            g_uc_p->msg.delivery_time = mmi_uc_convert_mms_delivery_time_to_uc(atoi((S8*) value));        
        }
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_VISIBLE , el))
    {
        if (g_uc_p->main.state == MMI_UC_STATE_REPLY ||
            g_uc_p->main.state == MMI_UC_STATE_REPLY_ALL ||
            g_uc_p->main.state == MMI_UC_STATE_EDIT_EXISTED_MSG ||
            g_uc_p->main.state == MMI_UC_STATE_SEND ||
            g_uc_p->main.state == MMI_UC_STATE_FORWARD)
        {
            /* Use current setting value */
        }
        else
        {
            if (atoi((S8*) value))
            {
                g_uc_p->msg.sender_visibility = MMI_TRUE;
            }
            else
            {
                g_uc_p->msg.sender_visibility = MMI_FALSE;
            }
        }
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_NAME , el))
    {
        U32 ucs2_len = (len + 1) * ENCODING_LENGTH;
        
        MMI_ASSERT(g_uc_p->xml.object);
        MMI_ASSERT(g_uc_p->xml.object->file_name == NULL);

        g_uc_p->xml.object->file_name = kal_adm_alloc(g_uc_p->main.mem_pool_id, ucs2_len);
        MMI_ASSERT(g_uc_p->xml.object->file_name);
        memset(g_uc_p->xml.object->file_name, 0, ucs2_len);
        mmi_chset_utf8_to_ucs2_string((kal_uint8*)g_uc_p->xml.object->file_name, ucs2_len, (kal_uint8*)value);
    }    
    else if (!strcmp(MMI_UC_XML_ELEMENT_FILE_PATH  , el))
    {
        U32 ucs2_len = (len + 1) * ENCODING_LENGTH;
        
        MMI_ASSERT(g_uc_p->xml.object);
        MMI_ASSERT(g_uc_p->xml.object->file_path == NULL);

        g_uc_p->xml.object->file_path = kal_adm_alloc(g_uc_p->main.mem_pool_id, ucs2_len);
        MMI_ASSERT(g_uc_p->xml.object->file_path);
        memset(g_uc_p->xml.object->file_path, 0, ucs2_len);
        mmi_chset_utf8_to_ucs2_string((kal_uint8*)g_uc_p->xml.object->file_path, ucs2_len, (kal_uint8*)value);
    }
        
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_xml_data_address_hdlr
 * DESCRIPTION
 *  Add address 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_xml_data_address_hdlr(U8* utf8_addr,
                                  S32 addr_len,
                                  mmi_uc_address_type_enum addr_type, 
                                  mmi_uc_address_group_type_enum addr_group_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *ucs2;
    U32 ucs2_len;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (addr_group_type == MMI_UC_ADDRESS_GROUP_TYPE_TO ||
        addr_group_type == MMI_UC_ADDRESS_GROUP_TYPE_CC ||
        addr_group_type == MMI_UC_ADDRESS_GROUP_TYPE_BCC)
    {
        if ((g_uc_p->msg.to_num + g_uc_p->msg.cc_num + g_uc_p->msg.bcc_num ) >= MMI_UC_MAX_ADDRESS_NUM)
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_xml_data_address_hdlr addr no. EXCEED!*\n");
            return;
        }
    }

    ucs2_len = (addr_len + 1) * ENCODING_LENGTH;        
    ucs2 = OslMalloc(ucs2_len);
    memset(ucs2, 0, ucs2_len);
        
    mmi_chset_utf8_to_ucs2_string(ucs2, ucs2_len, utf8_addr);

    if (mmi_uc_check_duplicate_address(ucs2, addr_type, addr_group_type) != NULL)
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_xml_data_address_hdlr duplicate addr *\n");
    }
    else
    {    
        if (addr_type == MMI_UC_ADDRESS_TYPE_PHONE_NUMBER || 
            addr_type == MMI_UC_ADDRESS_TYPE_EMAIL )
        {
            mmi_uc_add_address(ucs2, addr_type, addr_group_type);
        }
        else
        {
            MMI_ASSERT(0);
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMiscell.c] mmi_uc_xml_data_address_hdlr addr type error*\n");            
        }
    }
    
    OslMfree(ucs2);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_ascii_hex_to_dec
 * DESCRIPTION
 *  Converts Ascii value to Decimal value
 * PARAMETERS
 *  character       [IN]        
 *  S8 ascii values(?)
 * RETURNS
 *  U8 Decimal value.
 *****************************************************************************/
U32 mmi_uc_convert_ascii_hex_to_dec(U8* character)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i = 0;
    U32 value = 0;
    U8 c = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Skip prefix "0x" or "0X" */
    if (character[0] == '0' && (character[1] == 'x' || character[1] == 'X'))
    {
        i = 2;
    }
    
    while ((c = character[i]) != 0)
    {
        value = value * 16;
        
        if (c > 47 && c < 58)   /* Digits 0..9 */
        {
            value += (c - 48);
        }
        else if (c > 64 && c < 71)  /* Characters A..F */
        {
            value += (c - 55);
        }
        else if (c > 96 && c < 103) /* Characters a..f */
        {
            value += (c - 87);
        }
        i++;
    }
    return value;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_insert_slide_by_number
 * DESCRIPTION
 *  Insert slide by slide number
 * PARAMETERS
 *  character       [IN]        
 *  S8 ascii values(?)
 * RETURNS
 *  U8 Decimal value.
 *****************************************************************************/
mmi_uc_slide_struct* mmi_uc_insert_slide_by_number(U8 slide_number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_slide_struct* cur_slide = g_uc_p->msg.slide_head;
    mmi_uc_slide_struct* pre_slide = cur_slide;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (slide_number == 1)
    {
        return mmi_uc_insert_slide(NULL);        
    }
    else
    {
        while (cur_slide && (cur_slide->slide_num < slide_number))
        {
            pre_slide = cur_slide;
            cur_slide = cur_slide->next;
        }

        return mmi_uc_insert_slide(pre_slide);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_insert_object_to_list_tail
 * DESCRIPTION
 *  Insert object to object list tail
 * PARAMETERS
 *  character       [IN]        
 *  S8 ascii values(?)
 * RETURNS
 *  U8 Decimal value.
 *****************************************************************************/
mmi_uc_object_struct* mmi_uc_insert_object_to_list_tail(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_object_struct* new_object;
    U32 object_size;     
    U32 i = 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    object_size = sizeof(mmi_uc_object_struct);
    new_object = kal_adm_alloc(g_uc_p->main.mem_pool_id, object_size);
    MMI_ASSERT(new_object);
    memset(new_object, 0, object_size);

    /* First object */
    if (g_uc_p->msg.object_head == NULL)
    {
        g_uc_p->msg.object_head = new_object;
        new_object->next = NULL;
        new_object->previous = NULL;
    }
    else
    {
        mmi_uc_object_struct* cur_object = g_uc_p->msg.object_head;

        while (cur_object->next)
        {
            MMI_ASSERT( i < g_uc_p->msg.total_object_num);
            cur_object = cur_object->next;
            i++;
        }        

        cur_object->next = new_object;
        
        new_object->next = NULL;
        new_object->previous = cur_object;
    }

    g_uc_p->msg.total_object_num++;

    return new_object;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_match_object_id
 * DESCRIPTION
 *  Match object id after parsing xml file
 * PARAMETERS
 *  character       [IN]        
 *  S8 ascii values(?)
 * RETURNS
 *  U8 Decimal value.
 *****************************************************************************/
S32 mmi_uc_match_object_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_slide_struct* cur_slide = g_uc_p->msg.slide_head;
    U32 slide_num = 0;
    mmi_uc_object_struct* cur_object = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (; cur_slide != NULL; cur_slide = cur_slide->next, slide_num++)
    {
    
        if (cur_slide->text.id)
        {
            wgui_uce_text_info_struct text_info;
            U8 mmi_uc_text_path[MMI_UC_MAX_TEMP_FILE_LEN];
            U8 virtual_file_name[(FS_GenVFN_SIZE + 1) * ENCODING_LENGTH];
            S32 ori_file_handle;
            S32 result;
            U8* file_name;
        #ifdef __MMI_MMS_2__
            S32 start_time = cur_slide->text.begin;
            S32 end_time = cur_slide->text.end;
        #endif /* __MMI_MMS_2__ */
            U32 bg_color = cur_slide->text.background_color;
            U32 fg_color = cur_slide->text.foreground_color;
            U16 file_path_len = 0;
            U16 file_name_len = 0;
           
            memset(mmi_uc_text_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);
            MMI_UC_MAKE_TEXT_FILE_PATH(mmi_uc_text_path, cur_slide->slide_num);
        
            /*the object maybe reomoved because creation mode (reference and removed in previous slide)*/
            cur_object = mmi_uc_get_object_by_id(cur_slide->text.id);
            
            if ( cur_object == NULL) /*the object is removed from object list when handling previous page--creation mode*/         
            {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id is already removed,text *\n");
                memset(&(cur_slide->text), 0, sizeof(mmi_uc_object_info_struct));  
                return FS_ERROR_RESERVED; 
            }
            else if (cur_object->reference_count > 0) /*same text obj is refered more than once */
            {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id ref more than once,text *\n");
                memset(&(cur_slide->text), 0, sizeof(mmi_uc_object_info_struct));  
                return FS_ERROR_RESERVED; 
            }
            /*first handled and object exists*/
            else if (MMI_FALSE == mmi_uc_check_virtual_file_object_for_creation_mode(cur_object, MMI_UC_OBJECT_TYPE_TEXT))
            {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id remove text *\n");
                
                mmi_uc_delete_object_from_list(cur_object);
                memset(&(cur_slide->text), 0, sizeof(mmi_uc_object_info_struct));  
                
            }
            else /* already handled before and passed creation mode check*/
            {
                mmi_uc_insert_object_to_slide(cur_object, cur_slide, MMI_UC_OBJECT_TYPE_TEXT);
                cur_slide->text.object->type = MMI_UC_OBJECT_TYPE_TEXT;            

            #ifdef __MMI_MMS_2__
                if (start_time != 0 || end_time != 0)
                {
                    cur_slide->text.begin = start_time;
                    cur_slide->text.end = end_time;
                }
            #endif /* __MMI_MMS_2__ */

                cur_slide->text.background_color = bg_color;
                cur_slide->text.foreground_color = fg_color;

                MMI_ASSERT(cur_slide->text.object->file_path);

                if (cur_slide->text.object->is_virtual_file)
                {
                    ori_file_handle = FS_Open(cur_slide->text.object->file_path, FS_READ_ONLY | FS_OPEN_SHARED);

                    if (ori_file_handle <= 0)
                    {
                        MMI_ASSERT(0);
                        return ori_file_handle;
                    }

                	result = FS_GenVirtualFileName( 
                                        ori_file_handle, 
                                        (U16*)virtual_file_name, 
                                		(unsigned int)FS_GenVFN_SIZE, 
                                		cur_slide->text.object->offset, 
                                		cur_slide->text.object->size);
                    
                    if (result < 0)
                    {
                        MMI_ASSERT(0);
                        return result;
                    }

                    mmi_uc_read_file_to_text_buffer(virtual_file_name, cur_slide->text.object->encoding);

                    FS_Close(ori_file_handle);
                    
                }
                else
                {
                    mmi_uc_read_file_to_text_buffer((U8*)cur_slide->text.object->file_path, 0);
                }
                
                memset(&text_info, 0, sizeof(wgui_uce_text_info_struct));
                wgui_uce_get_text_info_for_buffer(&text_info, g_uc_p->main.text_buffer);                        

                mmi_uc_set_text_info_to_slide(cur_slide, &text_info);
            
                if ((result = mmi_uc_save_buffer_to_file(mmi_uc_text_path, g_uc_p->main.text_buffer, text_info.char_count)) != FS_NO_ERROR)
                {
                    return result;
                }

                /* file path */
                kal_adm_free(g_uc_p->main.mem_pool_id, cur_slide->text.object->file_path);
                file_path_len = mmi_ucs2strlen((S8*)mmi_uc_text_path);
                cur_slide->text.object->file_path = kal_adm_alloc(g_uc_p->main.mem_pool_id, (file_path_len + 1 ) * 2);
                MMI_ASSERT(cur_slide->text.object->file_path);
                memset(cur_slide->text.object->file_path, 0, (file_path_len + 1) * 2);
                mmi_ucs2ncpy((S8*)cur_slide->text.object->file_path, (S8*)mmi_uc_text_path, file_path_len);

                /* file name */
                if (cur_slide->text.object->file_name)
                {
                    kal_adm_free(g_uc_p->main.mem_pool_id, cur_slide->text.object->file_name);
                }
                file_name = (U8*)mmi_uc_get_file_name((U16*)mmi_uc_text_path);
                file_name_len = mmi_ucs2strlen((S8*)file_name);
                cur_slide->text.object->file_name = kal_adm_alloc(g_uc_p->main.mem_pool_id, (file_name_len + 1 ) * 2);
                MMI_ASSERT(cur_slide->text.object->file_name);
                memset(cur_slide->text.object->file_name, 0, (file_name_len + 1) * 2);
                mmi_ucs2ncpy((S8*)cur_slide->text.object->file_name, (S8*)file_name, file_name_len);

                cur_slide->text.object->offset = 0;
                cur_slide->text.object->size = applib_get_file_size((kal_wchar*)cur_slide->text.object->file_path);    
                cur_slide->text.object->drm_type = MMA_DRM_NONE;
                cur_slide->text.object->is_virtual_file = MMI_FALSE;
            }
        }        

        if (cur_slide->image.id)
        {
            cur_object = mmi_uc_get_object_by_id(cur_slide->image.id);

            if (cur_object != NULL)
            {
            #ifdef __MMI_MMS_2__
                if (MMI_FALSE == mmi_uc_check_virtual_file_object_for_creation_mode(cur_object, MMI_UC_OBJECT_TYPE_IMAGE))
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id remove IMAGE*\n");
                    
                    mmi_uc_delete_object_from_list(cur_object);
                    memset(&(cur_slide->image), 0, sizeof(mmi_uc_object_info_struct));  
                }
                else
            #endif /* __MMI_MMS_2__ */
                {
                #ifdef __MMI_MMS_2__
                    S32 start_time = cur_slide->image.begin;
                    S32 end_time = cur_slide->image.end;
                #endif /* __MMI_MMS_2__ */
                    
                    mmi_uc_insert_object_to_slide(cur_object, cur_slide, MMI_UC_OBJECT_TYPE_IMAGE);
                    cur_slide->image.object->type = MMI_UC_OBJECT_TYPE_IMAGE;    
                    
                #ifdef __MMI_MMS_2__
                    if (start_time != 0 || end_time != 0)
                    {
                        cur_slide->image.begin = start_time;
                        cur_slide->image.end = end_time;
                    }
                #endif /* __MMI_MMS_2__ */
                
                }
            }
            else  /*the object is removed from object list when handling previous page--creation mode*/
            {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id is removed before - IMAGE*\n");
                memset(&(cur_slide->image), 0, sizeof(mmi_uc_object_info_struct)); 
            }
        }
        if (cur_slide->audio.id)
        {
            cur_object = mmi_uc_get_object_by_id(cur_slide->audio.id);
            
            if (cur_object != NULL)
            {
            #ifdef __MMI_MMS_2__
                if (MMI_FALSE == mmi_uc_check_virtual_file_object_for_creation_mode(cur_object, MMI_UC_OBJECT_TYPE_AUDIO))
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id remove AUDIO*\n");
                    
                    mmi_uc_delete_object_from_list(cur_object);
                    memset(&(cur_slide->audio), 0, sizeof(mmi_uc_object_info_struct));  
                }
                else
            #endif /* __MMI_MMS_2__ */
                {
                #ifdef __MMI_MMS_2__
                    S32 start_time = cur_slide->audio.begin;
                    S32 end_time = cur_slide->audio.end;
                #endif /* __MMI_MMS_2__ */
                
                    mmi_uc_insert_object_to_slide(cur_object, cur_slide, MMI_UC_OBJECT_TYPE_AUDIO);
                    cur_slide->audio.object->type = MMI_UC_OBJECT_TYPE_AUDIO;    
                    
                #ifdef __MMI_MMS_2__
                    if (start_time != 0 || end_time != 0)
                    {
                        cur_slide->audio.begin = start_time;
                        cur_slide->audio.end = end_time;
                    }
                #endif /* __MMI_MMS_2__ */
                }
            }
            else /*the object is removed from object list when handling previous page--creation mode*/
            {
                
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id is removed before- AUDIO*\n");
                memset(&(cur_slide->audio), 0, sizeof(mmi_uc_object_info_struct)); 
            }
        }
        if (cur_slide->video.id)
        {
            cur_object = mmi_uc_get_object_by_id(cur_slide->video.id);
            
            if (cur_object != NULL)
            {
            #ifdef __MMI_MMS_2__
                if (MMI_FALSE == mmi_uc_check_virtual_file_object_for_creation_mode(cur_object, MMI_UC_OBJECT_TYPE_VIDEO))
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id remove VIDEO*\n");
                    
                    mmi_uc_delete_object_from_list(cur_object);
                    memset(&(cur_slide->video), 0, sizeof(mmi_uc_object_info_struct));  
                }
                else
            #endif /* __MMI_MMS_2__ */
                {                   
                #ifdef __MMI_MMS_2__
                    S32 start_time = cur_slide->video.begin;
                    S32 end_time = cur_slide->video.end;
                #endif /* __MMI_MMS_2__ */
                
                   mmi_uc_insert_object_to_slide(cur_object, cur_slide, MMI_UC_OBJECT_TYPE_VIDEO);
                   cur_slide->video.object->type = MMI_UC_OBJECT_TYPE_VIDEO;                     
                   
                #ifdef __MMI_MMS_2__
                    if (start_time != 0 || end_time != 0)
                    {
                        cur_slide->video.begin = start_time;
                        cur_slide->video.end = end_time;
                    }
                #endif /* __MMI_MMS_2__ */
                }
            }
            else
            {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id is removed before -  VIDEO*\n");
                memset(&(cur_slide->video), 0, sizeof(mmi_uc_object_info_struct));  
            }
        }     


        if (g_uc_p->msg.layout == MMI_UC_LAYOUT_DEFAULT)
        {
            if (cur_slide->image.object || cur_slide->video.object)
            {
                g_uc_p->msg.layout = MMI_UC_LAYOUT_THUMBNAIL_AT_TOP;
            }
        }
    }

    MMI_ASSERT( slide_num == g_uc_p->msg.total_slide_num);

#ifdef __MMI_MMS_2__
    {
        mmi_uc_attachment_info_struct* cur_attach = g_uc_p->msg.attachment_head;

        for (; cur_attach != NULL ; cur_attach = cur_attach->next)
        {
            cur_object =  cur_attach->object;
            if (MMI_FALSE == mmi_uc_check_virtual_file_object_for_creation_mode(cur_attach->object, MMI_UC_OBJECT_TYPE_ATTACHMENT))
            {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_match_object_id remove ATTACHMENT*\n");
                
                mmi_uc_delete_object_from_list(cur_object);
                mmi_uc_delete_attachment_from_list(cur_attach);  
            }            
        }
    }
#endif /* __MMI_MMS_2__ */    
    return FS_NO_ERROR;
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_object_by_id
 * DESCRIPTION
 *  Get object pointer by object id
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_object_struct* mmi_uc_get_object_by_id(U32 object_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_object_struct* cur_object = g_uc_p->msg.object_head;
    U32 object_num = 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (; cur_object != NULL; cur_object = cur_object->next, object_num++)
    {
        MMI_ASSERT( object_num <= g_uc_p->msg.total_object_num);
        
        if (cur_object->id == object_id)
        {
            return cur_object;
        }
    }

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_only_attachment
 * DESCRIPTION
 *  Only attachments and one empty slide.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_check_only_attachment (void)
{
#if (0)  
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* (0) */

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_resize_image
 * DESCRIPTION
 *  Resize image
 * PARAMETERS
 *  void
 * RETURNS
 *  1: resized. 0: no need to resize. negative: error!
 *****************************************************************************/
S32 mmi_uc_resize_image(U8 *file, U8 *dest_file, U32 resize_w, U32 resize_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_width = 0, img_height = 0;
    GDI_RESULT gdi_ret = GDI_FAILED;
    S32 ret = 0; 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(file != NULL);
    MMI_ASSERT(dest_file != NULL);

    /* Get the image dimension */
    gdi_image_get_dimension_file((PS8) file, &img_width, &img_height);

    if ((img_width != 0) && (img_height != 0))
    {
        /* calculate the dimension of the resize JPEG */
        if ((img_width > resize_w) || (img_height > resize_h))
        {
            S32 w = 0, h = 0, buf_size = 0;
            U8 *buf_ptr = NULL;

            /* need to resize */
            if ((img_width * resize_h) > (img_height * resize_w))
            {
                w = resize_w;
                h = img_height * resize_w / img_width;
                if (h == 0)
                {
                    h = 1;
                }
            }
            else
            {
                w = img_width * resize_h / img_height;
                h = resize_h;
                if (w == 0)
                {
                    w = 1;
                }
            }

            /* resize the image and encode to jpeg file */
            buf_size = (w * h * GDI_MAINLCD_BIT_PER_PIXEL) >> 3;
            buf_size = ((buf_size + 3) / 4) * 4;
            if (buf_size > 0)
            {
                media_get_ext_buffer(MOD_MMI, (void **)&buf_ptr, buf_size);
                if (buf_ptr != NULL)
                {
                    gdi_ret = gdi_image_encode_file_to_jpeg((PS8) file, (S8*)dest_file, w, h, buf_ptr, buf_size);
                    media_free_ext_buffer(MOD_MMI, (void **)&buf_ptr);
                }
                switch (gdi_ret)
                {
                    case GDI_SUCCEED:
                        ret = MMI_UC_RESIZING_SUCCEED;
                        break;
                    case GDI_IMAGE_ENCODER_ERR_DISK_FULL:
                        ret = MMI_UC_RESIZING_FAILED_IN_GDI_ENCODER_ERR_DISK_FULL;
                        break;
                    case GDI_IMAGE_ENCODER_ERR_WRITE_PROTECTION:
                        ret = MMI_UC_RESIZING_FAILED_IN_GDI_ENCODER_ERR_WRITE_PROTECTION;
                        break;
                    case GDI_IMAGE_ENCODER_ERR_NO_DISK:
                        ret = MMI_UC_RESIZING_FAILED_IN_GDI_ENCODER_ERR_NO_DISK;
                        break;
                    default:
                        ret = MMI_UC_RESIZING_FAILED_IN_GDI_FAILED;
                }
            }
            else
            {
                /* -12: can't allocate gdi_layer for drawing image */
                ret = MMI_UC_RESIZING_FAILED_IN_INSUFFICIENT_DRAWING_BUF;
            }
        }
        else
        {
            /* the dimension of the original image is smaller */
            ret = MMI_UC_RESIZING_SUCCEED_WITH_UNCHANGED; 
        }
    }
    else
    {
	     /* -11: can't get the image dimension */
         ret = MMI_UC_RESIZING_FAILED_IN_UNKNOWN_DIMENSION;   
    }

    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                     "*[UnifiedComposerMiscell.c] mmi_uc_resize_image(), ret=%d",
                                     ret);

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_entry_write_msg_with_content
 * DESCRIPTION
 *  Entry unified composer with content
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_entry_write_msg_with_content(mmi_uc_done_type_enum type, mmi_uc_entry_write_struct* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 addr_num = 0;
    mmi_uc_addr_struct* addr = data->addr;
    mmi_uc_object_struct* object;
    wgui_uce_text_info_struct text_info;
    U8 mmi_uc_text_path[MMI_UC_MAX_TEMP_FILE_LEN];
    S32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (!mmi_um_check_ready())
    {
        DisplayPopup(
            (PU8) GetString(mmi_um_get_not_available_string_id()),
            IMG_GLOBAL_ERROR,
            1,
            MMI_UC_POPUP_TIME_OUT,
            (U8) ERROR_TONE);

        if (data->callback != NULL)
        {
            data->callback((void*)data->callback_para);
        }
        
        return;
    }
    
#ifdef __USB_IN_NORMAL_MODE__
    if (mmi_usb_is_in_mass_storage_mode())
    {
        /* in mass storage mode */
        if (mmi_usb_check_path_exported((PS8) MMI_UC_FOLDER_DRV))
        {
            /* MMI public drive is exported, cannot use this app */
            mmi_usb_app_unavailable_popup(0);   /* pass 0 will show default string */

            if (data->callback != NULL)
            {
                data->callback((void*)data->callback_para);
            }
            
            return;
        }
    }
#endif /* __USB_IN_NORMAL_MODE__ */
    
    if (g_uc_p->send_info.action != MMI_UC_ACTION_IDLE ||
        IsScreenPresent(SCR_ID_UC_EDITOR))
    {
        DisplayPopup(
            (PU8) GetString(mmi_um_get_not_available_string_id()),
            IMG_GLOBAL_ERROR,
            1,
            MMI_UC_POPUP_TIME_OUT,
            (U8) ERROR_TONE);

        if (data->callback != NULL)
        {
            data->callback((void*)data->callback_para);
        }
        
        return;
    }
    
    mmi_uc_reset_msg();
    
    result = mmi_uc_check_uc_folder();

    if (result < 0)
    {    
        DisplayPopup(
            (PU8) GetString(GetFileSystemErrorString(result)),
            IMG_GLOBAL_UNFINISHED,
            1,
            MESSAGES_POPUP_TIME_OUT,
            (U8) ERROR_TONE);

        if (data->callback != NULL)
        {
            data->callback((void*)data->callback_para);
        }
        
        return;            
    }
    
    g_uc_p->main.state = type;

    if (type != MMI_UC_STATE_WRITE_NEW_MSG)
    {
        if (data->info_type == MMI_UC_INFO_TYPE_SMS)
        {
            U16* msg_id = data->info;
            
        #ifdef __UNIFIED_MESSAGE_ARCHIVE_SUPPORT__
            /* Treat edit archive box SMS msg as write new msg. */
            if ( (g_uc_p->main.state == MMI_UC_STATE_EDIT_EXISTED_MSG) && 
                 (UM_MSG_BOX_TYPE_ARCHIVE == mmi_um_get_current_msg_box_type()) ) 
            {
                g_uc_p->main.state = MMI_UC_STATE_WRITE_NEW_MSG;
            }        
            else
        #endif
            {
                g_uc_p->send_info.existed_msg_type = MMI_UC_MSG_TYPE_SMS_PREFER;
                g_uc_p->send_info.existed_msg_id = (U32)(*msg_id);
            }
        }
        else
        {
            MMI_ASSERT(0);
        }
    }
    
    for (; addr_num < data->addr_num; addr_num++)
    {
        MMI_ASSERT(addr);
        if (mmi_uc_check_duplicate_address(addr->addr, addr->type, addr->group) != NULL)
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_entry_write_msg_with_content duplicate addr *\n");
        }
    #ifndef __MMI_MMS_2__
        else if (addr->type == MMI_UC_ADDRESS_TYPE_PHONE_NUMBER &&
                 mmi_ucs2strlen((S8*)addr->addr) >= MAX_DIGITS_SMS)
        {
            DisplayPopup(
                (PU8) GetString(STR_UC_ADDR_LENGTH_EXCEED_ID),
                IMG_GLOBAL_UNFINISHED,
                1,
                MMI_UC_POPUP_TIME_OUT,
                (U8) ERROR_TONE);

            if (data->callback != NULL)
            {
                data->callback((void*)data->callback_para);
            }
            
            mmi_uc_reset_msg();
            return;
        }
    #endif /* __MMI_MMS_2__ */
        else
        {
            mmi_uc_add_address(addr->addr, addr->type, addr->group);        
        }
        addr = addr->next;
    }
    
    g_uc_p->msg.current_slide = mmi_uc_insert_slide(NULL);
    g_uc_p->msg.current_slide_num = g_uc_p->msg.current_slide->slide_num;     

    if (mmi_ucs2strlen((S8*)data->subject))
    {
        mmi_ucs2ncpy((S8*)g_uc_p->msg.subject, (S8*)data->subject, MMI_UC_MAX_SUBJECT_LEN);
    }

    /* text file */
    if (data->text_num)
    {
        U32 buffer_size = 0;        
        U8* buffer = NULL;
        U32 buffer_len = 0;

        /* Discard the exceeding part */
        if (data->text_num > MMI_UC_MAX_CHAR_NUM_IN_ONE_SLIDE)
        {
            data->text_num = MMI_UC_MAX_CHAR_NUM_IN_ONE_SLIDE;
        }

        buffer_size = (data->text_num + 1) * ENCODING_LENGTH;        
        buffer = applib_mem_screen_alloc(buffer_size);
        
        MMI_ASSERT(buffer_size <= MMI_UC_UTF8_TEXT_BUFFER_SIZE);
        
        memset(buffer , 0, buffer_size);
        mmi_frm_sms_remove_escape_symbol_for_extension_char((U16*)buffer, (U16*)data->text_buffer,(U16)data->text_num);
        buffer_len = mmi_ucs2strlen((S8*)buffer);
                    
        memset(mmi_uc_text_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);
        MMI_UC_MAKE_TEXT_FILE_PATH(mmi_uc_text_path, g_uc_p->msg.current_slide->slide_num);

        mmi_uc_reset_text_buffer();               
        if (buffer_len <= (MMI_UC_TEXT_BUFFER_SIZE / ENCODING_LENGTH) - 1)
        {
            mmi_ucs2ncpy((S8*)g_uc_p->main.text_buffer, (S8*)buffer, buffer_len);
        }
        else
        {
            mmi_ucs2ncpy(
                (S8*)g_uc_p->main.text_buffer, 
                (S8*)buffer, 
                (MMI_UC_TEXT_BUFFER_SIZE / ENCODING_LENGTH) - 1);
        }        

        applib_mem_screen_free(buffer);

        mmi_uc_editor_initialize();
        memset(&text_info, 0, sizeof(wgui_uce_text_info_struct));
        wgui_uce_get_text_info_for_buffer(&text_info, g_uc_p->main.text_buffer);                        

        result = mmi_uc_save_buffer_to_file(mmi_uc_text_path, g_uc_p->main.text_buffer, text_info.char_count);
        
        if (result == FS_NO_ERROR)
        {                        
            mmi_uc_set_text_info_to_slide(g_uc_p->msg.current_slide, &text_info);
            
            object = mmi_uc_insert_object((S8*)mmi_uc_text_path, MMI_UC_OBJECT_TYPE_TEXT);                
            mmi_uc_insert_object_to_slide(object, g_uc_p->msg.current_slide, MMI_UC_OBJECT_TYPE_TEXT);
        }
        else
        {
            mmi_uc_display_popup(MMI_UC_STORAGE_FULL);

            if (data->callback != NULL)
            {
                data->callback((void*)data->callback_para);
            }
            
            return;
        }            
    }

    mmi_uc_update_msg_size();

    if (data->info_type == MMI_UC_INFO_TYPE_SMS)
    {
        MMI_ASSERT(data->file_path == NULL);
    }

    if (data->file_path)
    {
        U32 flie_path_len = mmi_ucs2strlen((S8*)data->file_path);
            
        if (g_uc_p->main.file_path)
        {
            kal_adm_free(g_uc_p->main.mem_pool_id, g_uc_p->main.file_path);
        }

        g_uc_p->main.file_path = kal_adm_alloc(
                                    g_uc_p->main.mem_pool_id, 
                                    (flie_path_len + 1) * ENCODING_LENGTH);

        MMI_ASSERT(g_uc_p->main.file_path);

        mmi_ucs2ncpy((S8*)g_uc_p->main.file_path, (S8*)data->file_path, flie_path_len);
    }

    if (data->callback != NULL)
    {
        g_uc_p->main.callback = data->callback;
        g_uc_p->main.callback_para = data->callback_para;
    }
        
    g_uc_p->msg_type.setting_msg_type = mmi_uc_get_setting_msg_type();
    g_uc_p->msg_type.curr_msg_type = g_uc_p->msg_type.setting_msg_type;

    if (data->msg_type == MMI_UC_MSG_TYPE_SMS_ONLY)
    {
        g_uc_p->msg_type.curr_msg_type = MMI_UC_MSG_TYPE_SMS_PREFER;
    }
    else if (data->msg_type == MMI_UC_MSG_TYPE_MMS_ONLY)
    {
        g_uc_p->msg_type.curr_msg_type = MMI_UC_MSG_TYPE_MMS_PREFER;
    }
    
    g_uc_p->msg_type.caller_specific_msg_type = data->msg_type;
    g_uc_p->msg_type.backup_msg_type = MMI_UC_MSG_TYPE_DEFAULT;

    mmi_uc_process_entry_write_msg();
            
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_entry_done_option_with_content
 * DESCRIPTION
 *  Entry unified composer with content
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_entry_done_option_with_content(mmi_uc_done_type_enum type, mmi_uc_entry_write_struct* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_uc_entry_write_msg_with_content(type, data);            
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_calc_file_size_in_utf8
 * DESCRIPTION
 *  Read the file to text buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_calc_file_size_in_utf8 (U8* file_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle;
    U32 result;
    U32 read_len = 0;
    U32 length = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Open the file to read*/
    file_handle = FS_Open((U16*) file_path, FS_READ_ONLY | FS_OPEN_SHARED );
    if (file_handle > 0)
    {            
        U8* temp_buffer = applib_mem_screen_alloc(MMI_UC_UTF8_TEXT_BUFFER_SIZE);        
        memset(temp_buffer, 0, MMI_UC_UTF8_TEXT_BUFFER_SIZE);
        
        result = FS_Read(file_handle, 
                         temp_buffer, 
                         MMI_UC_UTF8_TEXT_BUFFER_SIZE - ENCODING_LENGTH,
                         &read_len);

        FS_Close(file_handle);

        if (result == FS_NO_ERROR)
        {
            length = mmi_charset_ucs2_to_utf8_length_in_bytes(temp_buffer);
        }
        applib_mem_screen_free(temp_buffer);
    }                                
    else
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                     "*---[UnifiedComposerMain.c] mmi_uc_calc_file_size_in_utf8 fail! file_handle= %d ---*\n",
                                     file_handle);   
    }
    
   return length;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_text_change_callback
 * DESCRIPTION
 *  Check if the text is allowed to be inserted
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
wgui_uce_text_change_result_enum mmi_uc_text_change_callback(wgui_uce_text_info_struct *new_text_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_BOOL Is_delete_char = MMI_FALSE;
    if (new_text_info->char_count > MMI_UC_MAX_CHAR_NUM_IN_ONE_SLIDE)
    {
        return WGUI_UCE_TEXT_CHANGE_NOT_ALLOWED;
    }
    else
    {
        if (g_uc_p->msg_type.caller_specific_msg_type == MMI_UC_MSG_TYPE_SMS_ONLY)
        {
            if (new_text_info->UCS2_count > 0)
            {
                if (new_text_info->char_count > g_uc_p->sms_info.max_ucs2_char_num)
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, 
                             "*[UnifiedComposerMiscell.c] mmi_uc_text_change_callback ucs2 text size exceed *\n");
                    
                    return WGUI_UCE_TEXT_CHANGE_NOT_ALLOWED;
                }
            }
            else
            {
                if (new_text_info->char_count + new_text_info->extension_char_count > g_uc_p->sms_info.max_gsm7bit_char_num)
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, 
                             "*[UnifiedComposerMiscell.c] mmi_uc_text_change_callback ascii text size exceed *\n");
                    
                    return WGUI_UCE_TEXT_CHANGE_NOT_ALLOWED;
                }
            }
        }
        
        if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)            
        {
            if (g_uc_p->msg.current_slide->text.char_count == 0)
            {
                U8 mmi_uc_text_path[MMI_UC_MAX_TEMP_FILE_LEN];
                U32 text_obj_size = 0;

                memset(mmi_uc_text_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);
                MMI_UC_MAKE_TEXT_FILE_PATH(mmi_uc_text_path, g_uc_p->msg.current_slide_num);
                text_obj_size = wap_mma_uc_calc_object_smil_size(MMA_INSERT_TEXT, (U16*)mmi_uc_text_path);
                text_obj_size += wap_mma_uc_calc_object_multipart_size((U16*)mmi_uc_text_path);

                if ((g_uc_p->msg.msg_size + text_obj_size + new_text_info->utf8_msg_len) > g_uc_p->mms_info.max_mms_size)
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*[UnifiedComposerMiscell.c] mmi_uc_text_change_callback(), MMS size exceed! msg=%d text_object=%d utf8_msg=%d",
                         g_uc_p->msg.msg_size,text_obj_size , new_text_info->utf8_msg_len);
                    
                    return WGUI_UCE_TEXT_CHANGE_NOT_ALLOWED;
                }
            }
            else
            {
                if (g_uc_p->msg.current_slide->text.char_count > new_text_info->char_count)
                {
                    /* Always allow to delete characters operation */
                }
                else if ((g_uc_p->msg.msg_size_without_text_buffer + new_text_info->utf8_msg_len) > g_uc_p->mms_info.max_mms_size)
                {
                    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                         "*[UnifiedComposerMiscell.c] mmi_uc_text_change_callback(), MMS size EXCEED! msg_wo_text_buffer=%d utf8_msg=%d",
                         g_uc_p->msg.msg_size_without_text_buffer, new_text_info->utf8_msg_len);

                    return WGUI_UCE_TEXT_CHANGE_NOT_ALLOWED;
                }
            }
        }
            
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
             "*[UnifiedComposerMiscell.c] mmi_uc_text_change_callback(), ORI char=%d utf8_len=%d exten=%d ucs2=%d",
             g_uc_p->msg.current_slide->text.char_count,g_uc_p->msg.current_slide->text.utf8_msg_len, 
             g_uc_p->msg.current_slide->text.extension_char_count, g_uc_p->msg.current_slide->text.UCS2_count );

        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
             "*[UnifiedComposerMiscell.c] mmi_uc_text_change_callback(), NEW char=%d utf8_len=%d exten=%d ucs2=%d",
             new_text_info->char_count,new_text_info->utf8_msg_len, 
             new_text_info->extension_char_count, new_text_info->UCS2_count );
        if (g_uc_p->msg.current_slide->text.char_count > new_text_info->char_count)
        {
            Is_delete_char = MMI_TRUE;
        }
        else
        {
            Is_delete_char = MMI_FALSE;
        }
        
        g_uc_p->msg.current_slide->text.char_count = new_text_info->char_count; 
        g_uc_p->msg.current_slide->text.utf8_msg_len = new_text_info->utf8_msg_len; 		
        g_uc_p->msg.current_slide->text.extension_char_count = new_text_info->extension_char_count;		
        g_uc_p->msg.current_slide->text.UCS2_count = new_text_info->UCS2_count;
        
        /* For better performance, only update text buffer to text object when char count is one or zero */
        /* That is, text object is existed or not. */
        if ((Is_delete_char == MMI_FALSE) && (new_text_info->char_count == 1) || 
            (Is_delete_char == MMI_TRUE) && (new_text_info->char_count == 0))
        {
            mmi_uc_exit_write_msg();
            /*Tricky: because before return WGUI_UCE_TEXT_CHANGE_ALLOWED, editor will not copy string to dst:g_uc_p->main.text_buffer
            so, when mmi_uc_save_buffer_to_file is called, no character will be saved to uc txt file, and obj size will not be updated.
            When wap call calculate api, use the obj->size, will use the wrong error --*/
            if (new_text_info->char_count == 1) /*only for add characters*/
            {
                if (g_uc_p->main.current_text_file_save_result == FS_NO_ERROR)
                {
                    g_uc_p->msg.current_slide->text.object->size = g_uc_p->msg.current_slide->text.utf8_msg_len;

                }
                else
                {
                    return WGUI_UCE_TEXT_CHANGE_NOT_ALLOWED;
                }
            }
            else
            {
                if (g_uc_p->main.current_text_file_save_result != FS_NO_ERROR)
                {
                    MMI_ASSERT(0); /*because should can save successfully for delete char case*/
                }
                
            }
            mmi_uc_update_msg_size();
        }        
        
        return WGUI_UCE_TEXT_CHANGE_ALLOWED;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_message_size_callback
 * DESCRIPTION
 *  Return msg size
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_get_message_size_callback (wgui_uce_text_info_struct *current_text_info, wgui_uce_msg_type_enum uce_msg_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 msg_size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (g_uc_p->msg.current_slide != NULL)
    {
        /* For better performance, only update text buffer to text object when char count is one or zero */
        /* That is, text object is existed or not. */
        if (g_uc_p->msg.current_slide->text.char_count == 1 || 
            g_uc_p->msg.current_slide->text.char_count == 0)
        {
            mmi_uc_exit_write_msg();
            mmi_uc_update_msg_size();
        }
    }        

    if (uce_msg_type == WGUI_UCE_MSG_TYPE_SMS)
    {   
        msg_size = current_text_info->char_count;
    }
    else if (uce_msg_type == WGUI_UCE_MSG_TYPE_MMS)
    {
        msg_size = current_text_info->utf8_msg_len + g_uc_p->msg.msg_size_without_text_buffer;
    }
    else
    {
        MMI_ASSERT(0);
    }
    
    if (mmi_uc_change_msg_type_if_needed())
    {
        StartTimer(UC_MSG_TYPE_CHECK_TIMER_ID, MMI_UC_MSG_TYPE_CHECK_TIME, mmi_uc_disply_msg_type_change);
    }

    return msg_size;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_message_size_callback
 * DESCRIPTION
 *  Return msg size
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_is_pending_content(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_uc_p->msg.total_slide_num > 0)
    {
        if (g_uc_p->msg.current_slide->text.char_count ||        
            g_uc_p->msg.total_slide_num > 1 ||
            g_uc_p->msg.object_head ||
            g_uc_p->msg.to_num + g_uc_p->msg.cc_num + g_uc_p->msg.bcc_num > 0 ||
            mmi_ucs2strlen((S8*)g_uc_p->msg.subject))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_sms_setting
 * DESCRIPTION
 *  Get SMS setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_get_sms_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_uc_p->sms_info.max_gsm7bit_char_num = EMSUsableTextLen(SMSAL_DEFAULT_DCS) / 2;
    g_uc_p->sms_info.max_ucs2_char_num = EMSUsableTextLen(SMSAL_UCS2_DCS) / 2;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_sms_segment_number
 * DESCRIPTION
 *  Get SMS segment
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_uc_get_sms_segment_number(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 segment = 0;
    mmi_uc_slide_struct* slide = g_uc_p->msg.current_slide;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (slide)
    {
        if (slide->text.UCS2_count)
        {
            if (EMSCalculateSeg(SMSAL_UCS2_DCS, (U16)(slide->text.char_count * 2), &segment) == EMS_OK)
            {
                return segment;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            if (EMSCalculateSeg(SMSAL_DEFAULT_DCS, (U16)((slide->text.char_count + slide->text.extension_char_count) * 2), &segment) == EMS_OK)
            {
                return segment;
            }
            else
            {
                return 0;
            }
        }
    }
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_sd_plug_out_hdlr
 * DESCRIPTION
 *  Handler when memory card is removed
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_sd_plug_out_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_slide_struct* slide = NULL;
    mmi_uc_object_struct* object = NULL;
    mmi_uc_attachment_info_struct* attachment = g_uc_p->msg.attachment_head;
    U16 shift_attachment_num = 0;    
    U8 cur_slide_num = 0;
    U8 cur_attachment_num = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* There is a popup when memory card is removed! */
    if (IsScreenPresent(SCR_ID_UC_EDITOR) && 
        (g_uc_p->send_info.action == MMI_UC_ACTION_IDLE || g_uc_p->send_info.action == MMI_UC_ACTION_PREVIEW))
    {
        for (slide = g_uc_p->msg.slide_head; cur_slide_num < g_uc_p->msg.total_slide_num; cur_slide_num++)
        {
            MMI_ASSERT(slide);
            if (slide->image.object)
            {
                object = slide->image.object;

                if (!(object->is_virtual_file))
                {
                    if (FS_GetAttributes(object->file_path) < 0)
                    {
                        if (object->reference_count > 1)
                        {
                            object->reference_count--;
                        }
                        else
                        {
                            mmi_uc_delete_object_from_list(object);
                        }
                        memset(&slide->image, 0, sizeof(mmi_uc_object_info_struct));
                    }
                }
            }

            if (slide->audio.object)
            {
                object = slide->audio.object;

                if (!(object->is_virtual_file))
                {
                    if (FS_GetAttributes(object->file_path) < 0)
                    {
                        if (object->reference_count > 1)
                        {
                            object->reference_count--;
                        }
                        else
                        {
                            mmi_uc_delete_object_from_list(object);
                        }
                        memset(&slide->audio, 0, sizeof(mmi_uc_object_info_struct));
                    }
                }
            }

            if (slide->video.object)
            {
                object = slide->video.object;

                if (!(object->is_virtual_file))
                {
                    if (FS_GetAttributes(object->file_path) < 0)
                    {
                        if (object->reference_count > 1)
                        {
                            object->reference_count--;
                        }
                        else
                        {
                            mmi_uc_delete_object_from_list(object);
                        }
                        memset(&slide->video, 0, sizeof(mmi_uc_object_info_struct));
                    }
                }
            }
            
            slide = slide->next;
            
        }

        while (attachment != NULL)
        {
            object = attachment->object;

            if (!(object->is_virtual_file))
            {
                if (FS_GetAttributes(object->file_path) < 0)
                {
                    mmi_uc_attachment_info_struct* att_temp = attachment->next;
                    
                    MMI_ASSERT(object->reference_count == 1);
                    mmi_uc_delete_object_from_list(object);

                    /* Replace attachment handling */
                    if (IsScreenPresent(SCR_ID_UC_OPT_REPLACE) &&
                        IsScreenPresent(SCR_ID_UC_OPT_ATTACHMENT_LIST))
                    {
                        if (g_uc_p->main.object_index == cur_attachment_num)
                        {
                            shift_attachment_num = MMI_UC_INVALID_INDEX;
                        }

                        if (shift_attachment_num != MMI_UC_INVALID_INDEX &&
                            g_uc_p->main.object_index > cur_attachment_num )
                        {
                            shift_attachment_num++;
                        }
                    }
                    
                    mmi_uc_delete_attachment_from_list(attachment);
                    attachment = att_temp;
                    cur_attachment_num++;

                    continue;
                }                            
            }            
            
            cur_attachment_num++;
            attachment = attachment->next;            
        }

        /* Replace attachment handling */
        if (shift_attachment_num > 0)
        {
            if (shift_attachment_num == MMI_UC_INVALID_INDEX)
            {
                g_uc_p->main.object_index = MMI_UC_INVALID_INDEX;
            }
            else
            {
                MMI_ASSERT(g_uc_p->main.object_index >= shift_attachment_num);
                g_uc_p->main.object_index -= shift_attachment_num;
            }
        }

        mmi_uc_reset_layout_if_needed();                
        
        if (mmi_uc_change_msg_type_if_needed())
        {
            mmi_uc_insert_signature_check();
        }
        mmi_uc_update_msg_size();                            
        //mmi_uc_switch_slide(g_uc_p->msg.current_slide);
        mmi_uc_editor_initialize();
        mmi_uc_set_editor_info(g_uc_p->msg.current_slide);
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_uc_sd_plug_out_hdlr
 * DESCRIPTION
 *  Handler when memory card is removed
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_reset_layout_if_needed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_object_struct* object = NULL;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (object = g_uc_p->msg.object_head ; object != NULL ; object = object->next)
    {
        if (object->type == MMI_UC_OBJECT_TYPE_IMAGE ||
            object->type == MMI_UC_OBJECT_TYPE_VIDEO )
        {
            break;
        }
    }
    
    if (object == NULL)
    {
        g_uc_p->msg.layout = MMI_UC_LAYOUT_DEFAULT;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_reset_editor_history_guibuffer
 * DESCRIPTION
 *  reset editor history gui buffer
 * PARAMETERS
 *  screen_id           [IN]        
 * RETURNS
 *  kal_bool 
 *****************************************************************************/
BOOL mmi_uc_reset_history_guibuffer(U16 screen_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    historyNode* history = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GetHistoryPointer(screen_id, &history);

    if (history != NULL)
    {    
        if (history->guiBuffer != NULL)
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                 "*[UnifiedComposerMiscell.c] mmi_uc_reset_history_guibuffer(), screen_id=%d",
                                 screen_id);

            OslMfree(history->guiBuffer);
            history->guiBuffer = NULL;
        }
        return KAL_TRUE;
    }
    else
    {
        return KAL_FALSE;
    }        
}



/*****************************************************************************
 * FUNCTION
 *  mmi_uc_is_uc_screen_in_history
 * DESCRIPTION
 *  Return if unified composer screen is in the history
 * PARAMETERS
 *  screen_id           [IN]        
 * RETURNS
 *  kal_bool 
 *****************************************************************************/
kal_bool mmi_uc_is_uc_screen_in_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    return (kal_bool)IsScreenPresent(SCR_ID_UC_EDITOR);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_is_email_addr_valid
 * DESCRIPTION
 *  Return if email address valid
 * PARAMETERS
 *  screen_id           [IN]        
 * RETURNS
 *  kal_bool 
 *****************************************************************************/
BOOL mmi_uc_is_email_addr_valid(U8* addr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 email_addr_len = mmi_ucs2strlen((S8*)addr);
    U16 i = 0;
    U16* email_addr = (U16*)addr;
    U16 j = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    for ( ; i< email_addr_len ; i++ )
    {
        if (mmi_ucs2ncmp((S8*)&email_addr[i], (S8*)L"@", 1) == 0)
        {
            if (i == 0 || i == (email_addr_len - 1))
            {
                return FALSE;
            }
            else
            {
                U8* ascii_addr = NULL;

                for ( ; j < email_addr_len ; j++ )
                {
                    U16 ucs2_char = email_addr[j];

                    /* non-ascii char */
                    if ((ucs2_char & 0xFF00) > 0)
                    {
                        return FALSE;
                    }
                }
                
                ascii_addr = OslMalloc(email_addr_len + 1);
                memset(ascii_addr, 0, (email_addr_len + 1));
                
                mmi_ucs2_n_to_asc((S8*)ascii_addr, (S8*)addr, email_addr_len * ENCODING_LENGTH);

                if (applib_is_valid_email_local_part((char*)ascii_addr, i) &&
                    applib_is_valid_email_domain_name((char*)(ascii_addr + i + 1)))
                {
                    OslMfree(ascii_addr);
                    return TRUE;
                }
                
                OslMfree(ascii_addr);
                
                return FALSE;
            }
        }
    }

    return FALSE;
        
}


/*****************************************************************************
* FUNCTION
*  mmi_uc_handle_msg_type_check
* DESCRIPTION
*  Handler for checking if msg type changes
* PARAMETERS
*  screen_id           [IN]        
* RETURNS
*  kal_bool 
*****************************************************************************/
void mmi_uc_handle_msg_type_check(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_handle_msg_type_check *\n");
    
    if (mmi_uc_change_msg_type_if_needed())
    {
        mmi_uc_insert_signature_check();
    }

    if (GetExitScrnID() == SCR_ID_UC_OPT_DONE)
    {
        if (g_uc_p->done.pre_msg_type != g_uc_p->msg_type.curr_msg_type)
        {
            g_uc_p->done.pre_msg_type = g_uc_p->msg_type.curr_msg_type;

            if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
            {
                DisplayPopup(
                    (PU8) GetString(STR_UC_CHANGED_TO_TEXT_MSG_ID),
                    0,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) WARNING_TONE);
            }
            else if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
            {
                DisplayPopup(
                    (PU8) GetString(STR_UC_CHANGED_TO_MULTIMEDIA_MSG_ID),
                    0,
                    1,
                    MMI_UC_POPUP_TIME_OUT,
                    (U8) WARNING_TONE);

            }
            else
            {
                MMI_ASSERT(0);
            }
        }
    }
    else
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_handle_msg_type_check IGNORE! *\n");
    }
}


/*****************************************************************************
* FUNCTION
*  mmi_uc_disply_msg_type_change
* DESCRIPTION
*  display msg type is changed
* PARAMETERS
*  screen_id           [IN]        
* RETURNS
*  kal_bool 
*****************************************************************************/
void mmi_uc_disply_msg_type_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_disply_msg_type_change *\n");
    
    if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_SMS_PREFER)
    {
        DisplayPopup(
            (PU8) GetString(STR_UC_CHANGED_TO_TEXT_MSG_ID),
            0,
            1,
            MMI_UC_POPUP_TIME_OUT,
            (U8) WARNING_TONE);
    }
    else if (g_uc_p->msg_type.curr_msg_type == MMI_UC_MSG_TYPE_MMS_PREFER)
    {
        DisplayPopup(
            (PU8) GetString(STR_UC_CHANGED_TO_MULTIMEDIA_MSG_ID),
            0,
            1,
            MMI_UC_POPUP_TIME_OUT,
            (U8) WARNING_TONE);

    }
    else
    {
        MMI_ASSERT(0);
    }

    mmi_uc_insert_signature_check();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_replace_duplicate_object_file_name
 * DESCRIPTION
 *  Replace duplicate object file name
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_replace_duplicate_object_file_name(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_object_struct* obj = g_uc_p->msg.object_head;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    while (obj != NULL)
    {
        mmi_uc_object_struct* handle_obj = obj->next;
        U8 i = 1;

        while (handle_obj != NULL)
        {
            handle_obj = mmi_uc_check_duplicate_object_by_filename(obj->file_name, handle_obj);

            if (handle_obj != NULL)
            {
                /* replace file name */
                U16 file_name_len = mmi_ucs2strlen((S8*)handle_obj->file_name);
                U16* new_file_name = kal_adm_alloc(g_uc_p->main.mem_pool_id, (file_name_len + 3 ) * ENCODING_LENGTH);
                U16 file_suffix[5];
                U16* file_extension = mmi_uc_get_file_extension(handle_obj->file_name);
                U16 file_extension_len = 0;

                if (file_extension != NULL)
                {
                    file_extension_len = mmi_ucs2strlen((S8*)file_extension);
                    mmi_ucs2ncpy((S8*)new_file_name, (S8*)handle_obj->file_name, (file_name_len - file_extension_len - 1));
                }
                else
                {
                    mmi_ucs2ncpy((S8*)new_file_name, (S8*)handle_obj->file_name, file_name_len);
                }
                
                memset(file_suffix, 0x00, sizeof(file_suffix));
                kal_wsprintf( (kal_uint16 *)file_suffix, "%02d", i);                                 
                mmi_ucs2cat((PS8) new_file_name, (PS8) file_suffix);

                if (file_extension != NULL)
                {
                    mmi_ucs2cat((PS8) new_file_name, (PS8) L".");
                    mmi_ucs2cat((PS8) new_file_name, (PS8) file_extension);
                }

                kal_adm_free(g_uc_p->main.mem_pool_id, handle_obj->file_name);
                handle_obj->file_name = new_file_name;
                i++;
                
                handle_obj = handle_obj->next;                
            }
        }

        obj = obj->next;
    }    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_compare_string_ignore_case
 * DESCRIPTION
 *  Compare string by ignoring case.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_compare_string_ignore_case(U16* addr_1, U16* addr_2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 addr_index = 0;
    U16 char_A = 0x0041;
    U16 char_Z = 0x005A;
    U16 char_a = 0x0061;
    U16 addr_1_len = mmi_ucs2strlen((S8*)addr_1);
    U16 addr_2_len = mmi_ucs2strlen((S8*)addr_2);
    U16 addr_1_char = 0;
    U16 addr_2_char = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (addr_1_len != addr_2_len)
    {
        return MMI_FALSE;
    }
    
    while (addr_index < addr_1_len)
    {
        if (addr_1[addr_index] >= char_A && addr_1[addr_index] <= char_Z)
        {
            addr_1_char = char_a + addr_1[addr_index] - char_A;
        }
        else
        {
            addr_1_char = addr_1[addr_index];            
        }

        
        if (addr_2[addr_index] >= char_A && addr_2[addr_index] <= char_Z)
        {
            addr_2_char = char_a + addr_2[addr_index] - char_A;
        }
        else
        {
            addr_2_char = addr_2[addr_index];
        }

        if (addr_1_char != addr_2_char)
        {
            return MMI_FALSE;
        }

        addr_index++;
    }
    
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_existed_mms
 * DESCRIPTION
 *  Delete existed MMS msg
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_delete_existed_mms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_uc_p->main.file_handle > 0)
    {
        FS_Close(g_uc_p->main.file_handle);
        g_uc_p->main.file_handle = 0;
    }
    
    mmi_uc_delete_mms_req(g_uc_p->send_info.existed_msg_id);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_update_text_object_path
 * DESCRIPTION
 *  Update text object file path
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_uc_update_text_object_path(mmi_uc_slide_struct* slide)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 mmi_uc_text_path[MMI_UC_MAX_TEMP_FILE_LEN];
    mmi_uc_object_struct* object = NULL;
    U16* file_name;
    U16 file_path_len = 0;
    U16 file_name_len = 0;
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(slide != NULL);
    memset(mmi_uc_text_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);
    MMI_UC_MAKE_TEXT_FILE_PATH(mmi_uc_text_path, slide->slide_num);
    file_path_len = mmi_ucs2strlen((S8*)mmi_uc_text_path);
    
    if ((object = slide->text.object) != NULL)
    {
        if (FS_Rename((U16*)object->file_path, (U16*)mmi_uc_text_path) != FS_NO_ERROR)
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS, "*[UnifiedComposerMiscell.c] mmi_uc_update_text_object_path FAIL *\n");
            return;
        }
        
        /* file path */
        if (object->file_path != NULL)
        {
            kal_adm_free(g_uc_p->main.mem_pool_id, object->file_path);
            object->file_path = NULL;
        }
        object->file_path = kal_adm_alloc(g_uc_p->main.mem_pool_id, (file_path_len + 1 ) * 2);
        MMI_ASSERT(object->file_path);
        memset(object->file_path, 0, (file_path_len + 1) * 2);
        mmi_ucs2ncpy((S8*)object->file_path, (S8*)mmi_uc_text_path, file_path_len);

        /* file name */
        if (object->file_name != NULL)
        {
            kal_adm_free(g_uc_p->main.mem_pool_id, object->file_name);
            object->file_name = NULL;
        }
        file_name = mmi_uc_get_file_name((U16*)mmi_uc_text_path);
        file_name_len = mmi_ucs2strlen((S8*)file_name);
        object->file_name = kal_adm_alloc(g_uc_p->main.mem_pool_id, (file_name_len + 1 ) * 2);
        MMI_ASSERT(object->file_name);
        memset(object->file_name, 0, (file_name_len + 1) * 2);
        mmi_ucs2ncpy((S8*)object->file_name, (S8*)file_name, file_name_len);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_get_end_slide
 * DESCRIPTION
 *  get the last slide
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_slide_struct* mmi_uc_get_end_slide(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_slide_struct* slide = g_uc_p->msg.slide_head;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(slide == NULL)
    {
        return NULL;
    }
    
    while (slide->next != NULL)
    {
        slide = slide->next;
    }

    return slide;
    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_delete_between_screens
 * DESCRIPTION
 *  Delete screens including start_sreen and end_screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_delete_between_screens(U16 start_screen_id, U16 end_screen_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                 "*[UnifiedComposerMiscell.c] mmi_uc_delete_between_screens(), start_scr=%d, end_scr=%d",
                                 start_screen_id, end_screen_id);
        
    if (!IsScreenPresent(start_screen_id))
    {        
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                     "*[UnifiedComposerMiscell.c] mmi_uc_delete_between_screens(), start_scr=%d NOT present",
                                     start_screen_id);
        return MMI_FALSE;        
    }

    if (!IsScreenPresent(end_screen_id))
    {
        
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                     "*[UnifiedComposerMiscell.c] mmi_uc_delete_between_screens(), end_scr=%d NOT present",
                                     end_screen_id);
        return MMI_FALSE;        
    }
    
    return DeleteBetweenScreen(start_screen_id, end_screen_id);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_is_pending_action
 * DESCRIPTION
 *  Check if uc has pending action
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool mmi_uc_is_pending_action(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                 "*[UnifiedComposerMiscell.c] mmi_uc_is_pending_action(), send_info.action=%d",
                                 g_uc_p->send_info.action);
        
    if (g_uc_p->send_info.action != MMI_UC_ACTION_IDLE)
    {
        return KAL_TRUE;
    }
    else
    {
        return KAL_FALSE;
    }        
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_number_length_for_sms
 * DESCRIPTION
 *  Check if number length exceeds SMS limitation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_uc_check_number_length_for_sms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_uc_addr_struct* addr_tail = NULL;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    addr_tail = g_uc_p->msg.to_head;
            
    for (; addr_tail != NULL ; addr_tail = addr_tail->next)
    {
        if (addr_tail->type != MMI_UC_ADDRESS_TYPE_PHONE_NUMBER)
        {
            continue;
        }
        
        if (strlen((S8*)addr_tail->addr) > (MAX_DIGITS_SMS - 1))
        {
            return (U8)MMI_FALSE;
        }
    }
    
    return (U8)MMI_TRUE;
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_check_virtual_file_object_for_creation_mode
 * DESCRIPTION
 *  Check if the virtual file can be inserted into existed msg
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
BOOL mmi_uc_check_virtual_file_object_for_creation_mode(mmi_uc_object_struct *obj, mmi_uc_object_type type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    mma_insert_check_struct check_result;
    mmi_uc_object_struct* object = obj;
    S32 file_handle = 0;
    mma_insert_type_enum mms_type = mmi_uc_convert_to_mms_insert_type(type);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&check_result, 0, sizeof(mma_insert_check_struct));
    
    if (object->is_virtual_file)
    {
        U8 virtual_file_name[(FS_GenVFN_SIZE + FMGR_MAX_EXT_LEN + 1) * ENCODING_LENGTH];
        S32 result;
        U16 virtual_file_name_len = sizeof(virtual_file_name);

        memset(virtual_file_name, 0, virtual_file_name_len);
                    
        file_handle = FS_Open(object->file_path, FS_READ_ONLY | FS_OPEN_SHARED);
        
        if (file_handle <= 0)
        {
            MMI_ASSERT(0);
        }

    	result = FS_GenVirtualFileName( 
                        file_handle, 
                        (U16*)virtual_file_name, 
                		(unsigned int)FS_GenVFN_SIZE, 
                		object->offset, 
                		object->size);
        
        if (result < 0)
        {
            MMI_ASSERT(0);
        }
        
        mmi_ucs2cat((PS8) virtual_file_name, (PS8) L".");
        /*MMI_ASSERT(mmi_uc_get_file_extension(object->file_name));*/
        if (mmi_uc_get_file_extension(object->file_name))
        {
            mmi_ucs2ncat((PS8) virtual_file_name, (PS8) mmi_uc_get_file_extension(object->file_name), virtual_file_name_len / ENCODING_LENGTH);  
        }
        else
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMiscell.c] mmi_uc_check_virtual_file_object_for_creation_mode() NO  ext name");
        }
        wap_mma_uc_insert_object_check(g_uc_p->mms_info.creation_mode,
                                       (U16*)virtual_file_name, 
                                       mms_type, 
                                       0, 
                                       g_uc_p->mms_info.max_mms_size,
                                       &check_result);   
        FS_Close(file_handle);

        if (check_result.result == MMI_FALSE && check_result.creation_mode_violate == MMI_TRUE)
        {
            return MMI_FALSE;
        }
    }
    else
    {
        MMI_ASSERT(0);
    }
        
    return MMI_TRUE;    
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_is_resized_image
 * DESCRIPTION
 *  Check if the image is the resize image which created by UC 
 * PARAMETERS
 *  void
 * RETURNS
 *  TRUE means the image is the resize image which created by UC.
 *****************************************************************************/
BOOL mmi_uc_is_resized_image(U16* file_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 mmi_uc_image_path[MMI_UC_MAX_TEMP_FILE_LEN];
    U32 i = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    for (; i <= g_uc_p->main.image_no ; i++)
    {
        memset(mmi_uc_image_path, 0, MMI_UC_MAX_TEMP_FILE_LEN);    
        MMI_UC_MAKE_IMAGE_FILE_PATH(mmi_uc_image_path, i);

        if (mmi_ucs2cmp((S8*) mmi_uc_image_path, (S8 *) file_path) == 0)
        {
                PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                 "*[UnifiedComposerMiscell.c] mmi_uc_is_resized_image() YES ");

                return MMI_TRUE;
        }
    }        
    
    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                     "*[UnifiedComposerMiscell.c] mmi_uc_is_resized_image() NO ");

    return MMI_FALSE;    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_is_valid_image
 * DESCRIPTION
 *  Check if the image is the valid
 * PARAMETERS
 *  void
 * RETURNS
 *  TRUE means the image is the valid
 *****************************************************************************/
BOOL mmi_uc_is_valid_image(U16* file_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT gdi_ret = GDI_FAILED;
    S32 width = 0, height = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    

    /* Check image resolution */
    gdi_ret = gdi_image_get_dimension_file((PS8) file_path, (S32*) &width, (S32*) &height);
    
    if (gdi_ret < 0 || 
        width <= 0 || 
        height <= 0 ||
        width > MMI_UC_MAX_IMAGE_WIDTH || 
        height > MMI_UC_MAX_IMAGE_HEIGHT)
    {
        PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                 "*[UnifiedComposerMiscell.c] mmi_uc_is_valid_image() NO, gdi_ret=%d ",gdi_ret);
        
        return MMI_FALSE;
    }

    PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                             "*[UnifiedComposerMiscell.c] mmi_uc_is_valid_image() YES ");
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_to_mms_expiry_time
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_convert_to_mms_expiry_time(mmi_uc_expiry_time_enum uc_expiry_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (uc_expiry_time)
    {
        case MMI_UC_EXPIRY_NOT_SET:
        {
            return MMA_EXPIRY_NOT_SET;
        }
        break;

        case MMI_UC_EXPIRY_1_HOUR:
        {
            return MMA_EXPIRY_1_HOUR;
        }
        break;

        case MMI_UC_EXPIRY_6_HOURS:
        {
            return MMA_EXPIRY_6_HOURS;
        }
        break;

        case MMI_UC_EXPIRY_12_HOURS:
        {
            return MMA_EXPIRY_12_HOURS;
        }
        break;

        case MMI_UC_EXPIRY_1_DAY:
        {
            return MMA_EXPIRY_1_DAY;
        }
        break;

        case MMI_UC_EXPIRY_1_WEEK:
        {
            return MMA_EXPIRY_1_WEEK;
        }
        break;

        case MMI_UC_EXPIRY_MAX:
        {
            return MMA_EXPIRY_MAX;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return MMA_EXPIRY_NOT_SET;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_mms_expiry_time_to_uc
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_expiry_time_enum mmi_uc_convert_mms_expiry_time_to_uc(U32 mms_expiry_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (mms_expiry_time)
    {
        case MMA_EXPIRY_1_HOUR:
        {
            return MMI_UC_EXPIRY_1_HOUR;
        }
        break;

        case MMA_EXPIRY_6_HOURS:
        {
            return MMI_UC_EXPIRY_6_HOURS;
        }
        break;
        

        case MMA_EXPIRY_12_HOURS:
        {
            return MMI_UC_EXPIRY_12_HOURS;
        }
        break;

        case MMA_EXPIRY_1_DAY:
        {
            return MMI_UC_EXPIRY_1_DAY;
        }
        break;

        case MMA_EXPIRY_1_WEEK:
        {
            return MMI_UC_EXPIRY_1_WEEK;
        }
        break;

        case MMA_EXPIRY_MAX:
        {
            return MMI_UC_EXPIRY_MAX;
        }
        break;

        default:
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                 "*[UnifiedComposerMiscell.c] mmi_uc_convert_mms_expiry_time_to_uc, mms_expiry_time=%d",
                                 mms_expiry_time);
            
            return MMI_UC_EXPIRY_NOT_SET;
        }
        break;
    }

    return MMI_UC_EXPIRY_NOT_SET;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_to_mms_delivery_time
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_uc_convert_to_mms_delivery_time(mmi_uc_delivery_time_enum uc_delivery_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (uc_delivery_time)
    {
        case MMI_UC_DELIVERY_NOT_SET:
        {
            return MMA_DELIVERY_NOT_SET;
        }
        break;

        case MMI_UC_DELIVERY_IMMEDIATE:
        {
            return MMA_DELIVERY_IMMEDIATE;
        }
        break;

        case MMI_UC_DELIVERY_1_HOUR:
        {
            return MMA_DELIVERY_1_HOUR;
        }
        break;

        case MMI_UC_DELIVERY_12_HOURS:
        {
            return MMA_DELIVERY_12_HOURS;
        }
        break;

        case MMI_UC_DELIVERY_24_HOURS:
        {
            return MMA_DELIVERY_24_HOURS;
        }
        break;

        default:
        {
            MMI_ASSERT(0);
        }
        break;
    }

    return MMA_DELIVERY_NOT_SET;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_uc_convert_mms_delivery_time_to_uc
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_uc_delivery_time_enum mmi_uc_convert_mms_delivery_time_to_uc(U32 mms_delivery_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    switch (mms_delivery_time)
    {
        case MMA_DELIVERY_IMMEDIATE:
        {
            return MMI_UC_DELIVERY_IMMEDIATE;
        }
        break;

        case MMA_DELIVERY_1_HOUR:
        {
            return MMI_UC_DELIVERY_1_HOUR;
        }
        break;

        case MMA_DELIVERY_12_HOURS:
        {
            return MMI_UC_DELIVERY_12_HOURS;
        }
        break;

        case MMA_DELIVERY_24_HOURS:
        {
            return MMI_UC_DELIVERY_24_HOURS;
        }
        break;

        default:
        {
            PRINT_INFORMATION_2(MMI_TRACE_G6_SMS,
                                 "*[UnifiedComposerMiscell.c] mmi_uc_convert_mms_delivery_time_to_uc, mms_delivery_time=%d",
                                 mms_delivery_time);
            
            return MMI_UC_DELIVERY_NOT_SET;
        }
        break;
    }

    return MMI_UC_DELIVERY_NOT_SET;
}


#endif /* __MMI_UNIFIED_COMPOSER__ */ 
#endif /* _MMI_UNIFIED_COMPOSER_MISCELL_C */ 

