/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * EngineerModeSrc.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is for Engineering mode
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/*****************************************************************/
/*************************  Header Files *************************/
/*****************************************************************/

#if !defined(__MTK_TARGET__)
#include <windows.h>
#endif 
#include "MMI_include.h"

#include "MMI_features.h"

#ifdef __MMI_ENGINEER_MODE__    

#ifdef FIRST_PASS
#include "BuildCfg.h"
#endif 

#include "ProtocolEvents.h"
#include "HardwareEvents.h"
#include "Thrdosinterface.h"
#include "OSThreadInterfaceGprot.h"

#include "device.h"
#include "uart_sw.h"
#include "custom_em.h"
#include "nvram_data_items.h"
#include "nvram_user_defs.h"
#include "nvram_default_audio.h"
#include "custom_nvram_editor_data_item.h"
#include "init.h"
#include "DateTimeType.h"
#include "DateTimeGprot.h"
#include "swdbg_sw.h"
#include "Sysconf_statistics.h"

#include "MainMenuDef.h"
#if defined(__VOIP__)
#include "VoIPResDef.h"
#include "VoIPGProt.h"
#include "VoIPProt.h"
#endif  /*  __VOIP__ */
#include "EngineerModeDef.h"
#include "EngineerModeType.h"
#include "EngineerModeTracer.h"
#include "EngineerModeProt.h"
#include "EngineerModeDeviceInc.h"
#include "EngineerModeSocketApp.h"
#include "CustomCfg.h"
#include "audioInc.h"
#include "IdleAppDef.h"
#include "gpioInc.h"
#include "mdi_datatype.h"
#include "mdi_audio.h"
#include "FactoryModeDef.h"
#include "sst_export.h"
#include "ex_item.h"
#include "CommonScreens.h"
#include "NetworkSetupDefs.h"

/* BEGIN OF IPERF */
#include "gui.h"
#include "soc_api.h"
#include "iperf_mmi_enums.h"
#include "iperf2mmi_struct.h"
#include "..\..\..\..\ps\Iperf\Include\Iperf_main.h"
#include "DataAccountDef.h"
#include "DataAccountGprot.h"
/* END OF IPERF */

#ifdef __MMI_USB_SUPPORT__
#include "USBDeviceGprot.h"
#include "USBDeviceDefs.h"
#endif /* __MMI_USB_SUPPORT__ */ 

#if defined(WAP_SUPPORT)
#include "wapadp.h"
#endif 

#ifdef __MMI_TVOUT__
#include "mdi_datatype.h"
#include "mdi_tv.h"

#include "med_api.h"
#endif /* __MMI_TVOUT__ */ 

#if defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT)
#include "med_api.h"
#endif 

#include "datetimetype.h"
#include "app_datetime.h"

#if defined(__VOIP__)
#include "voip_custom_api.h"
#include "SettingDefs.h"                /* ST_NOTIFYDURATION define */
#include "FileMgr.h"
#include "FileManagerGProt.h"
#include "fmt_struct.h"
#include "mmi2voip_enums.h"
#include "mmi2voip_struct.h"
#include "Asciiprot.h"
#endif

#if defined (__MMI_CSB_BROWSER__)
#include "CatScreenBrowserDefs.h"
#include "CatScreenBrowserProts.h"
#endif

#include "SoundRecorderProt.h"

#ifdef __MTK_TARGET__
#include "l1audio.h"
#endif 

#include "custom_data_account.h"

#if defined(__MMI_INTERACTIVE_PROFILNG__) || defined(__MMI_UI_BENCHMARK__)
#include "ProfilingEngine.h"
#endif 

#ifdef __MMI_CSB_BROWSER__
#include "CatScreenBrowserProts.h"
#endif

#if defined(MT6223P)
#include "msdc_def.h"
#endif 

#include "nvram_enums.h"
#include "Nvram_interface.h"

/*****************************************************************/
/****************  Structure / Variables Declaration *************/
/*****************************************************************/

#ifndef __PS_SERVICE__
#define GotoEmGprsMenu EntryEmGprsMenuNotSupport
#else 
#define GotoEmGprsMenu EntryEmGprsMenu
#endif 

/* ======= TV Out ======== */
#define MMI_EM_TVOUT_GROUP_NAME_LEN          (20)       /* group name length */
#define MMI_EM_TVOUT_GROUP_NAME_BUF_LEN      ((MMI_EM_TVOUT_GROUP_NAME_LEN-1)*ENCODING_LENGTH)
#define MMI_EM_TVOUT_MAX_ITEM_PER_GROUP      (15)
#define MMI_EM_TVOUT_ITEM_NAME_LEN           (40)
#define MMI_EM_TVOUT_ITEM_NAME_BUF_LEN       ((MMI_EM_TVOUT_ITEM_NAME_LEN-1)*ENCODING_LENGTH)
#define MMI_EM_TVOUT_ITEM_DIG_LEN            (15)
#define MMI_EM_TVOUT_ITEM_DIG_BUF_LEN        ((MMI_EM_TVOUT_ITEM_DIG_LEN-1)*ENCODING_LENGTH)

typedef struct
{
    S32 value;
    S32 min_value;
    S32 max_value;
    BOOL is_read_only;
    BOOL is_true_false;
    BOOL is_need_restart;
    S8 name_buf[MMI_EM_TVOUT_ITEM_NAME_BUF_LEN];
    S8 digit_buf[MMI_EM_TVOUT_ITEM_DIG_BUF_LEN];
} mmi_em_tvout_item_struct;

typedef struct
{
    S32 item_count;
    S32 item_idx;
    S8 name_buf[MMI_EM_TVOUT_GROUP_NAME_BUF_LEN];
    mmi_em_tvout_item_struct items[MMI_EM_TVOUT_MAX_ITEM_PER_GROUP];
} mmi_em_tvout_group_data_struct;

typedef struct
{
    S32 group_idx;
    S32 group_count;
    S32 hilight_idx;
    BOOL is_tvout_enable;
    PU8 tvout_buf_p;
    mmi_em_tvout_group_data_struct group_data;
    UI_string_type true_false_str[2];
} mmi_em_tvout_cntx_struct;

mmi_em_tvout_cntx_struct g_em_tvout_cntx;

/* ======= UI ======== */
U8 currentHighlightIndex;
EM_APP_UART_SETTING EmPortSetting;

/* ======= Audio ======== */
static U16 currentVolume = 0;
static EmVolumeTypeEnum currentVolumeType;
static EmVolumeModeEnum currentVolumeMode;
U16 gNoOfRing = 0;
U16 gNoOfImy = 0;
U16 gNoOfMidi = 0;
U16 gNoOfSound = 0;
U8 gFixedImyBegin;
U8 gFixedImyEnd;
U8 gFixedMidiBegin;
U8 gFixedMidiEnd;
U8 gFixedSoundBegin;
U8 gFixedSoundEnd;
EmAudioProfileStruct gAudioProfile;
EmAudioProfileStruct gAudioProfileOrg;
U8 activeRingToneIndex;
S32 currentKeyShift = 0;
BOOL isPopup;
EmAudioParamStruct AudioParameter;

/* =======  Audio -- 16-Level Volume & Auto VM ====== */
typedef struct {
    U8    MaxAnalogGain[8];
    U8    Step[8];
} em_audio_16_level_vol_struct;

em_audio_16_level_vol_struct g_aud_16_level_cntx={0};

typedef enum
{
    EM_AUD_AUTO_VM_CONFIG_VMSUPPORT = 0,
    EM_AUD_AUTO_VM_CONFIG_AUTOVM
} EM_AUD_AUTO_VM_CONFIG_ENUM;

/* =======  Device ====== */
U8 gIsBackLightOn = 0;

#ifdef __MMI_TVOUT__
BOOL gIsTVOut = FALSE;
U16 gTVOutIdx;
#endif /* __MMI_TVOUT__ */ 

#if defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT)
U16 gVideoHiBitrateIdx;
#endif 

const U8 AUTO_RESET_WARNING[] = { 'D', 0, 'o', 0, 'n', 0, '\'', 0, 't', 0, ' ', 0,
    's', 0, 'u', 0, 'b', 0, 'm', 0, 'i', 0, 't', 0, ' ', 0,
    'a', 0, 's', 0, ' ', 0, 'a', 0, ' ', 0, 'b', 0, 'u', 0, 'g', 0, '!', 0, 0, 0
};

/* =======  UART ====== */
static U8 *EmUartPortText[EM_UART_MAX_PORT_NUM];
static U8 *EmUartBaudText[EM_BAUD_NUM];
U32 EmUartPortTSTHighlight, EmUartBaudTSTHighlight;
U32 EmUartPortPSHighlight, EmUartBaudPSHighlight;
U32 EmUartPortTSTL1Highlight, EmUartBaudTSTL1Highlight;

U32 EmUartPortCTIHighlight, EmUartBaudCTIHighlight;
U8 EmAppPortArray[EM_APP_MAX_NUM];
U8 EmAppBaudArray[EM_APP_MAX_NUM];
#if defined(__MA_L1__)
/* under construction !*/
#endif

U8 g_em_set_uart_req_type = 0;

/* ======= DCM ====== */
kal_uint16 g_dcm_enable = 0;

/* ======= GPRS ====== */
S8 EmGprsSendDataSizeBuffer[10];
S16 EmSendDataScreenDigitKeyCode = -1;

EM_GPRS_ACT_PDP_TYPE_ENUM EmGprsActivatePDPType=0; 

/* ======= Backlight ======= */
static U8 backlight_mode = BACKLIGHT_NORMAL;

/* ======= Auto Testing Settings ====== */
S16 gAutoTestListSize = 0;
AutoTestItemArray nvramTestItemArray;
AutoTestResultArray nvramTestResultArray;
rtc_format_struct myclocktime;
S32 gPriorityValue = 0;
U16 gHiliteAutoTestCurrSelIdx = 0;
U16 gHiliteAllTestListIdx = 0;
U16 newPriority = 0;
PU8 AutoTestSelectedItems[MAX_AUTO_TEST_ITEMS];

/* ======= Power Down Control ======= */
#define  PWRDOWNSTRLEN 10
U8 Buf_PDN_CON0[PWRDOWNSTRLEN * 2];
U8 Buf_PDN_CON1[PWRDOWNSTRLEN * 2];
U8 Buf_PDN_CON2[PWRDOWNSTRLEN * 2];
U8 Buf_PDN_CON3[PWRDOWNSTRLEN * 2];

/* ======= SW Patch ======= */
U8 DSPpatch;

#if defined(__FS_TRACE_SUPPORT__)
/* ======= FS Trace Info ======= */
typedef struct {

    U8      *pEMFSTraceSetting[3];
    S32     currFsTraceSetting;

} em_fs_trace_struct;

em_fs_trace_struct g_em_fs_trace_cntx={0};

#endif /* defined(__FS_TRACE_SUPPORT__) */ 

static BOOL PWROFF_SAVING_STATS = FALSE;

#if defined(__AMR_SUPPORT__)
/* ======= AMR Info ======= */
static BOOL AMR_ON = FALSE;

U8 mscap[NVRAM_EF_MSCAP_SIZE];
#endif /* defined(__AMR_SUPPORT__) */ 

#if defined(__FLIGHT_MODE_SUPPORT__) || defined(__WIFI_SUPPORT__)
typedef enum {

   EM_SLEEPMODE_STATE_ENABLE = 0 ,
   EM_SLEEPMODE_STATE_DISABLE
   
}  EM_SLEEPMODE_STATE_ENUM;

U8 g_rf_tool_sleep_mode_state = EM_SLEEPMODE_STATE_ENABLE;
#endif 

#if defined(__MMI_EM_FIXED_GAIN_FOR_HELIOS2__)
/* ======= Fixed Gain for Helios2 ======= */
U8 FixedGain_On;
#endif /* __MMI_EM_FIXED_GAIN_FOR_HELIOS2__ */

#ifdef __FLIGHT_MODE_SUPPORT__
/* ===================================== */
/* ======= RF Test Tool -- GSM ========= */
/* ===================================== */

typedef enum {

   EM_RF_GSM_BAND_GSM850 = 0 ,
   EM_RF_GSM_BAND_GSM900,
   EM_RF_GSM_BAND_DCS1800,
   EM_RF_GSM_BAND_PCS1900
   
}  EM_RF_GSM_BAND_ENUM;

typedef enum {

   EM_RF_GSM_POWERSCAN_NONE = 0 ,
   EM_RF_GSM_POWERSCAN_BACK,
   EM_RF_GSM_POWERSCAN_ABORT
   
}  EM_RF_GSM_POWERSCAN_STATE;

U8 rf_gsm_band[4] = { 0x80, 0x02, 0x08, 0x10 };

#define EM_RF_TOOL_GSM_POWERSCAN_DURATION         3000   /* 3 s*/
#define EM_RF_TOOL_GSM_RX_BURST_DURATION          9500   /* 9.5 s*/

typedef struct {

    S32     currRFGsmBand;
    S32     currTxBurstType;     
    S32     currRxBurstType;         
    U16     int_arfcn;         /* atoi value */
    S16     int_afc;           /* atoi value */
    S16     int_gain;          /* atoi value */
    S8      int_tsc;           /* atoi value */
    S8      int_pcl;           /* atoi value */
    U8      req_type;
    U8      arfcn[10];
    U8      tsc[10];
    U8      pcl[10];    
    U8      afc[10];    
    U8      gain[10];
    U8      *pEMRFGsmBand[4];
    U8      *pEMRFGsmBurstType[7];
    MMI_BOOL     request_processing;    
    EM_RF_GSM_POWERSCAN_STATE      power_scan_flag;
        
} em_rf_test_gsm_struct;

em_rf_test_gsm_struct g_rf_test_gsm_cntx={0};

#endif /* #ifdef __FLIGHT_MODE_SUPPORT__ */

#if defined(__WIFI_SUPPORT__)
/* ===================================== */
/* ======= RF Test Tool -- WiFi ======== */
/* ===================================== */

typedef struct {

    S32       currRFWifiDomain;
    S32       currRFWifiChFreq;     
    S32       currRFWifiTxRate;         
    S32       currRFWifiTxPattern;
    S32       currRFWifiTxShortPeramble;
    S32       currRFWifiPowerSave;
    S32       currRFWifiRegisterType;
    S32       currRFWifiRegisterAccess;
    U8         int_ant;                /* atoi value */
    U8         int_gain;              /* atoi value */
    U32       int_pktcount;       /* atoi value */
    U32       int_pktinterval;   /* atoi value */
    U32       int_pktlength;      /* atoi value */    
    U32       int_address;        /* atoi value */
    U32       int_index;            /* atoi value */
    U32       int_data;             /* atoi value */
    U8         hex_mac_header[24];    /* Hex */
    U8        ant[4];
    U8        gain[6];
    U8        pktCount[22];
    U8        pktInterval[10];
    U8        pktLength[10];
    U8        macHeader[98];
    U8        address[8];
    U8        index[6];
    U8        data[18];
    U8        *pEMRFWifiDomain[2];
    U8        *pEMRFWifiChFreq[14];
    U8        *pEMRFWifiTxRate[12];
    U8        *pEMRFWifiTxPattern[4];
    U8        *pEMRFWifiTxShortPeramble[2];
    U8        *pEMRFWifiPowerSave[3];
    U8        *pEMRFWifiRegisterType[2];
    U8        *pEMRFWifiRegisterAccess[2];
    U8         req_type;
    MMI_BOOL     request_processing;    
    
} em_rf_test_wifi_struct;

em_rf_test_wifi_struct g_rf_test_wifi_cntx={0};


U32 rf_wifi_tx_ch_freq[14]=
{
    2412000, 2417000, 2422000, 2427000, 2432000, 2437000, 2442000, 
    2447000, 2452000, 2457000, 2462000, 2467000, 2472000, 2484000
};

typedef enum {

   EM_RF_WIFI_DOMAIN_US = 0,
   EM_RF_WIFI_DOMAIN_JP
   
}  EM_RF_WIFI_DOMAIN_ENUM;

typedef enum {

   EM_RF_WIFI_REGISTER_TYPE_32 = 0,
   EM_RF_WIFI_REGISTER_TYPE_16   
   
}  EM_RF_WIFI_REGISTER_TYPE_ENUM;

typedef enum {

   EM_RF_WIFI_REGISTER_ACCESS_READ = 0,
   EM_RF_WIFI_REGISTER_ACCESS_WRITE
   
}  EM_RF_WIFI_REGISTER_ACCESS_ENUM;

/* local function */
static void EMRFTestWiFiFillTxCommonReqContext(mmi_eq_rf_test_wifi_req_struct* msg);

#endif   /* #if defined(__WIFI_SUPPORT__) */


/* ======= Socket Test ======= */
#ifdef __TCPIP__

S8 EmSocketInputBuff[(EM_SOCKET_MAX_INPUT_LEN + 1) * ENCODING_LENGTH];
static mmi_soc_demo_app_enum currentSocketAppType;
U8 EmSocketIsCallbackFuncCalled;
U8 EmSocketIP1[EM_SOCKET_IP_LEN * ENCODING_LENGTH];
U8 EmSocketIP2[EM_SOCKET_IP_LEN * ENCODING_LENGTH];
U8 EmSocketIP3[EM_SOCKET_IP_LEN * ENCODING_LENGTH];
U8 EmSocketIP4[EM_SOCKET_IP_LEN * ENCODING_LENGTH];
kal_uint8 EmServerIPAddress[4];
mmi_soc_demo_app_result EmSocketResult;
PS8 EmSocketResultBuffer;
S32 EmSocketResultBufferSize;

#endif /* __TCPIP__ */ 

/* BEGIN OF IPERF */
#ifdef __IPERF__
static unsigned int iperf_cur_job_id;
#endif /* __IPERF__ */


#define IPERF_MEMSET(local_para_ptr)    do {                            \
    memset((kal_uint8*)(local_para_ptr) + sizeof(local_para_struct), 0, \
           (local_para_ptr)->msg_len - sizeof(local_para_struct));      \
} while(0)

typedef struct
{
    kal_uint8           *client_server_list[2];     /* Inline selection list for "Client" and "Server" */
    kal_uint8           *rw_file_list[2];     /* Inline selection list for "Client" and "Server" */
    kal_uint8           *tos_list[4];               /* Inline selection list for "tos type" */
    kal_uint8           *dualtest[2];               /* Inline selection list for "dual test type" */
    iperf_prot          prot;                       /* udp or tcp */
} em_iperf_misc_struct;

typedef struct
{
    kal_uint8            report_buff[MAX_REPORT_BUFF];           /* report buffer for ascii*/
    UI_character_type    report_UI_buffer[MAX_REPORT_BUFF*2];    /* report buffer for unicode*/
} em_iperf_report_struct;

typedef struct
{
    kal_uint16          dt_acct_name[(MAX_DATA_ACCOUNT_NAME_LEN+1)]; /* Name of current selected data account */
    kal_uint8           account_id;	/* Network account ID */    
    kal_int32           client_server;	/* client/server mode */
    kal_int32           dualtest;	/* dualtest mode */
    UI_character_type   faddr_ip[4][4];     /* faddr */
    UI_character_type   len[IPERF_LEN];	/* length of send buf, recv buf */
    UI_character_type   port[IPERF_PORT];	/* server port */
    UI_character_type   window[IPERF_WINDOW];	/* TCP window size (socket buffer size) */
    UI_character_type   mss[IPERF_MSS];	/* tcp mss */
    UI_character_type   bandwidth[IPERF_BANDWIDTH];	/* udp bandwidth (bits/sec), UDP only*/
    UI_character_type   num[IPERF_NUM];	/* number of bytes to transmit */
    UI_character_type   time[IPERF_TIME];	/* time in seconds to transmit for, default=10 */
    kal_int32           tos;	/* type-of-service */
    kal_int32           rw_file;	/* read/wirte from/to file(flash) */
} em_iperf_edit_struct;

typedef struct
{
    em_iperf_misc_struct    *iperf_misc;  /* misc data for editing setting */
    em_iperf_edit_struct    *iperf_edit_tcp;  /* temp data for editing tcp setting */
    em_iperf_edit_struct    *iperf_edit_udp;  /* temp data for editing udp setting */
    em_iperf_report_struct  *iperf_report; /* data for iperf reporting */   
} em_iperf_context_struct;

extern byte wgui_inline_list_menu_changed;
em_iperf_context_struct *iperf_p;
em_iperf_context_struct iperf_context;
em_iperf_context_struct *iperf_p = &iperf_context;

const U16 g_iperf_inline_icons [24] = 
{
    IMG_GLOBAL_L1, 0,
    IMG_GLOBAL_L2, 0,
    IMG_GLOBAL_L3, 0,
    IMG_GLOBAL_L4, 0,
    IMG_GLOBAL_L5, 0,
    IMG_GLOBAL_L6, 0,
    IMG_GLOBAL_L7, 0,
    IMG_GLOBAL_L8, 0,
    IMG_GLOBAL_L9, 0,
    IMG_GLOBAL_L10, 0,
    IMG_GLOBAL_L11, 0,
    IMG_GLOBAL_L12, 0
};
/* END OF IPERF */

/* Speech Enhancement */
typedef enum
{
    EM_AUD_SPH_ENH_COMMON,
    EM_AUD_SPH_ENH_NORMAL_MODE,
    EM_AUD_SPH_ENH_HEADSET_MODE,
    EM_AUD_SPH_ENH_LOUDSPK_MODE,
    EM_AUD_SPH_ENH_BT_EARPHONE_MODE,
    EM_AUD_SPH_ENH_BT_CORDLESS_MODE,
    EM_AUD_SPH_ENH_AUX1_MODE,
    EM_AUD_SPH_ENH_AUX2_MODE,
    EM_AUD_SPH_ENH_AUX3_MODE,
    EM_AUD_MAX_SWING,
    EM_AUD_DEBUG_INFO
    
} mmi_em_para_enum;
mmi_em_para_enum mmi_em_para_type;
U8 mmi_em_sph_enh_para_index;

/* ======= Profiling Info ======= */
#ifdef __MMI_INTERACTIVE_PROFILNG__

#define MMI_EM_MAX_PROFILING_LEN            (4)
#define MMI_EM_PROFILING_BUFFER_SIZE        ((MMI_EM_MAX_PROFILING_LEN + 1) * ENCODING_LENGTH)

//MMI_BOOL frm_profiling_flag;
typedef struct
{
    U8  *on_off_list[2];
    S32 on_off_index;
    U8  *gdi_on_off_list[2];
    S32 gdi_on_off_index;
    U8  screen_delay[MMI_EM_PROFILING_BUFFER_SIZE];
    U8  matrix_delay[MMI_EM_PROFILING_BUFFER_SIZE];
    U8  list_delay[MMI_EM_PROFILING_BUFFER_SIZE];
    U8  delay_offset[MMI_EM_PROFILING_BUFFER_SIZE];
} mmi_em_profiling_struct;

mmi_em_profiling_struct g_em_profiling_cntx;

#endif /* __MMI_INTERACTIVE_PROFILNG__ */

#ifdef __MMI_UI_BENCHMARK__
const U8 *g_ui_benchmark_buffer_p;
#endif 

/* Cell Reselection */
typedef enum
{
    CELL_RESELECT_SUSPEND_IN_ALL,
    CELL_RESELECT_SUSPEND_IN_TRANSFER
} CELL_RESELECT_SUSPEND_ENUM;

U8 g_cell_reselection_item = 0;

#if defined(__MMI_EM_MT6223_DEBUG_MODE__)
U8 g_MT6223_Debug_mode_type = 0;
#endif

#if defined(__VOIP__)

typedef struct {

    S32     currP2Pcall;
    S32     currUASRefresher;
    S32     currUACRefresher;
    S32     currRPortSupport;
    U8      reregister_timer[12];
    U8      call_refresh_timer[12];
    U8      refer_sub_timer[12];
    U8      mwi_sub_timer[12];
    U8      mwi_retry_time[6];
    U8      *pEMVOIPP2PCall[2];
    U8      *pEMVOIPUASRefresher[2];
    U8      *pEMVOIPRportSupport[2];
    U8      EMVOIPLocalAddr[42];
    UI_character_type input_buf[VOIP_CUST_STR_LEN*2];     
} em_voip_struct;

em_voip_struct g_em_voip_cntx={0};

typedef struct 
{
    S32     call_id;
    S32     dialog_id;
    S32     status;
    S8      filename[FMGR_PATH_BUFFER_SIZE];
} em_voip_log_call_status_struct;

typedef struct 
{
    S32     curr_log_activate;
    S32     curr_log_storage;
    S32     curr_log_del_time;
    S32     hili_log_activate;
    S32     hili_log_storage;
    S32     hili_log_del_time;
    S32     delete_all;
    S32     interrupt;
    em_voip_log_call_status_struct call_status[EM_VOIP_LOG_MAX_CALL];
    U8      *em_voip_log_activate[EM_VOIP_LOG_ACTIVATE_TOTAL];
    S8      filepath[FMGR_PATH_BUFFER_SIZE];
    U8      *em_voip_log_delete[EM_VOIP_LOG_AUTO_DELETE_TOTAL];
    U8      dirpath[EM_VOIP_LOG_MAX_DIR_PATH];
} em_voip_log_struct;

em_voip_log_struct g_em_voip_log_cntx={0};

extern int isInCall(void);
extern S8 nPrintableStr[];
extern pBOOL IsBackHistory;
#endif /*  __VOIP__ */



/*****************************************************************/
/******************  External functions / variables **************/
/*****************************************************************/
extern UART_PORT TST_PORT;
extern UART_baudrate TST_BAUDRATE;

#ifndef L4_NOT_PRESENT
extern UART_PORT PS_UART_PORT;
extern UART_baudrate PS_BAUDRATE;
#endif /* L4_NOT_PRESENT */ 

/* ======= Display Buffer for Engineering Mode and Factory Mode ======== */
extern S8 EMFMUnicodeDisplayBuf[MAX_TEST_STRING_BUF * 2];
extern U8 EMFMAsciiDisplayBuf[MAX_TEST_STRING_BUF];

/* ======= UI ======== */
extern PU8 subMenuDataPtrs[MAX_SUB_MENUS];
extern U8 subMenuData[MAX_SUB_MENUS][MAX_SUB_MENU_SIZE];
extern U8 gCurrentMode;
extern PROFILE gprofiles[];
extern PROFILE gcurrentprofile;
extern U8 gprofileId;
extern U8 gactivatedprofile;
extern U16 gstartMidiId;
extern U16 gstartGeneralToneId;
extern U8 glastactivatedprofile;
extern U8 gprofilenvram;
extern U8 glastColorID;
extern U8 gcurrentColorId;
extern S32 gcurrHiliteIndexOne; /* Current hilite index value */
extern U16 g_profiles_melody_list_index;
extern S32 gcommonvolumehandler;
extern U16 gcurrentaudioId;
extern U16 glastaudioId;
extern U16 gstartRingId;
extern U16 gtotalRingId;
extern U16 gstartMidiId;
extern U16 gtotalMidiId;

extern UI_character_type InputBuf[8];

extern const testlet Tests[MAX_AUTO_TEST_ITEMS];

/* =======  MMI Memory Dump ====== */
extern kal_uint32 INT_MemoryDumpFlag;

extern kal_bool UART_setting;

/* ======= UART POWER ON ====== */
extern kal_uint8 UART_POWER_SETTING;
extern kal_uint8 SWDBG_Profile;
extern kal_bool High_Speed_SIM;

#ifdef __MOD_TCM__
extern U8 g_gprs_pdp_idx;
extern kal_bool g_gprs_set_minqos_required;
#endif /* __MOD_TCM__ */ 

/* ======= Profile ======= */
extern U8 gprofileId;
extern U8 gactivatedprofile;
extern U8 glastactivatedprofile;

/* ======= WAP ======= */
#if defined(WAP_SUPPORT)
extern kal_bool wap_enable_debug_assert;
extern kal_bool global_offline_page;
extern U8 global_wap_user_agent;
extern U8 global_wap_accept_header;
extern U8 global_mms_version;
#endif 

extern wgui_inline_item wgui_inline_items[];

/* ======= Power On Duration Info ======= */
extern MYTIME StartUpTime, LastDuration;


/*****************************************************************/
/************************  Extern functions **********************/
/*****************************************************************/

/* Todo: Shall provide an primitive base interface for MMI to set echo suppression */
extern void L1SP_SetEchoSuppressionParameter(U16 timeConst, U16 volConst);
extern void SetBacklightModeExe(U8 mode);
extern void ShowCategory63Screen(U8 *message, U16 message_icon, U8 *history_buffer);
extern void DisplayPopup(U8 *string, U16 imageId, U8 imageOnBottom, U32 popupDuration, U8 toneId);
extern void ShowCategory16Screen(
                U16 left_softkey,
                U16 left_softkey_icon,
                U16 right_softkey,
                U16 right_softkey_icon,
                U8 *Buffer,
                U32 BufferLength,
                U8 *history_buffer);
extern void SetCategory16RightSoftkeyFunction(void (*f) (void), MMI_key_event_type k);
extern kal_bool SST_AdvRAMTest(void);

/* extern void ShowCategory164Screen(U16 left_softkey,U16 left_softkey_icon,U16 right_softkey,U16 right_softkey_icon,U16 message,U16 message_icon,U8* history_buffer); */
extern void playRequestedTone(ALL_TONE_ENUM playtone);
extern void ShowCategory64Screen(U16 message, U16 message_icon, U8 *history_buffer);
extern void Category53ChangeItemDescription(S32 index, U8 *text);

#ifdef __TCPIP__
extern void stopRequestedTone(ALL_TONE_ENUM playtone);
extern void ReturnThreeDigitString(PU8 StringVal, U8 DigitVal);
extern void PreparedIPAddressString(U8 *string_buffer, U8 *IP1, U8 *IP2, U8 *IP3, U8 *IP4);
extern void soc_init_win32(void);
#endif /* __TCPIP__ */ 

#ifdef __MMI_TVOUT__
extern void mmi_phnset_tvout_event_hdlr(MDI_RESULT result);
#endif 

extern void L1sim_Enable_Enhanced_Speed(kal_bool enable);

#ifndef __DYNAMIC_UART_PORT_SWITCHING__
extern void ShutdownSystemOperation(void);
#endif 

void DisplayConfirm(
        U16 LSK_str,
        U16 LSK_img,
        U16 RSK_str,
        U16 RSK_img,
        UI_string_type message,
        MMI_ID_TYPE message_image,
        U8 toneId);


/*****************************************************************/
/************************  Static functions **********************/
/*****************************************************************/
#ifdef __MMI_TVOUT__
static void mmi_em_tvout_hint_switch(U16 index);
static void mmi_em_tvout_init(void);
static void mmi_em_tvout_entry_setting_scr(void);
static void mmi_em_tvout_highlight_setting(void);
static void mmi_em_tvout_highlight_switch(void);
static void mmi_em_tvout_switch_on_off(void);
static void mmi_em_tvout_highlight_tunning(void);
static void mmi_em_tvout_entry_tunning_scr(void);
static void mmi_em_tvout_exit_tunning_scr(void);
static void mmi_em_tvout_tunning_set_value(void);
static void mmi_em_tvout_tunning_highlight_hdlr(S32 index);
static void mmi_em_tvout_tunning_toggle_group(void);
static void mmi_em_tvout_get_group_info(S32 group_index);
#endif /* __MMI_TVOUT__ */ 

static void mmi_em_audio_debug_info_init(void);
extern void HighlightEmTracert(void);

/*****************************************************************/
/***************************  Code Body **************************/
/*****************************************************************/

/*****************************************************************************
 * FUNCTION
 *  InitEngineerMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitEngineerMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*******************************************************************/
    /******************* Hilite handler of Menu item *******************/
    /*******************************************************************/
    
    /******************* Network *********************/
#ifdef __EM_MODE__
    SetHiliteHandler(EM_NETWORK_SETTING_MENUID, HighlightEmNetworkSetting);
    SetHiliteHandler(EM_NETWORK_INFO_MENUID, HighlightEmNetworkInfo);    
    SetHiliteHandler(EM_BAND_SEL_MENUID, HighlightNETSETBandSelection);
    
#if defined(__GSM_RAT__) && defined(__WCDMA_RAT__)    
/* under construction !*/
#endif /* #if defined(__GSM_RAT__) && defined(__WCDMA_RAT__) */

    SetHiliteHandler(EM_NETWORK_CELL_LOCK_MENUID, HighlightEmNWCellLock);

    SetHiliteHandler(EM_NETWORK_NETWORK_EVENT_MENUID, HighlightEmNWNetworkEvents);
    SetHiliteHandler(EM_NETWORK_NW_EVENT_START_MENUID, HighlightEmNWStart);
    SetHiliteHandler(EM_NETWORK_NW_EVENT_FILTER_MENUID, HighlightEmNWFilter);
    SetHiliteHandler(EM_NETWORK_NW_EVENT_SETTING_MENUID, HighlightEmNWSetting);    
#endif /* #ifdef __EM_MODE__ */    

    /******************* Device **********************/
    /* LCD */
    SetHiliteHandler(EM_DEVICE_MENUID, HighlightEmDevice);
    SetHiliteHandler(EM_DEV_LCD_MENU_ID, HighlightEmLCD);
    SetHiliteHandler(EM_DEV_LCD_MAIN_MENU_ID, HighlightEmLCDMain);
    SetHiliteHandler(EM_DEV_LCD_SUB_MENU_ID, HighlightEmLCDSub);
    SetHiliteHandler(EM_DEV_LCD_SET_CONSTRAST_MENU_ID, HighlightEmLCDSetContrast);
    SetHiliteHandler(EM_DEV_LCD_SET_BIAS_MENU_ID, HighlightEmLCDSetBias);
    SetHiliteHandler(EM_DEV_LCD_SET_LINERATE_MENU_ID, HighlightEmLCDSetLineRate);
    SetHiliteHandler(EM_DEV_LCD_SET_TEMPERATURE_MENU_ID, HighlightEmLCDSetTemperature);
    SetHiliteHandler(EM_DEV_LCD_SET_COLOR_MENU_ID, HighlightEmLCDSetColor);
    SetHiliteHandler(EM_DEV_LCD_DISPLAY_DEMO_PIC_MENU_ID, HighlightEmLCDDiplayDemoPic);    

    /* GPIO */
    SetHiliteHandler(EM_DEV_GPIO_MENU_ID, HighlightEmGPIO);
    SetHiliteHandler(EM_DEV_GPIO_LIST_MENU_ID, HighlightEmGPIOList);
    SetHiliteHandler(EM_DEV_GPIO_SET_MENU_ID, HighlightEmGPIOSet);
    SetHiliteHandler(EM_DEV_GPO_SET_MENU_ID, HighlightEmGPOSet);
    /* PWM */
    SetHiliteHandler(EM_DEV_PWM_MENU_ID, HighlightEmPWM);
    /* EINT */   
    SetHiliteHandler(EM_DEV_EINT_MENU_ID, HighlightEmEINT);
    /* ADC */
    SetHiliteHandler(EM_DEV_ADC_MENU_ID, HighlightEmADC);
    /* Clam */
    SetHiliteHandler(EM_DEV_CLAM_MENUID, HighlightEmClam);
    /* Set Default Level */
    SetHiliteHandler(EM_DEV_HW_LEVEL_MENUID, HighlightEmHWLevel);
    /* Set UART */
    SetHiliteHandler(EM_DEV_SET_UART_MENUID, HighlightEmSetUart);
    SetHiliteHandler(EM_DEV_UART_SETTING_MENUID, HighlightEmUartSetting);
    SetHiliteHandler(EM_DEV_UART_POWER_ONOFF_MENUID, HighlightEmUartPowerOnOff);    
    /* Sleep Mode */
    SetHiliteHandler(EM_DEV_SLEEPMODE_MENUID, HighlightEmSetSleepMode);

#if defined(DCM_ENABLE)
    /* DCM Mode */
    SetHiliteHandler(EM_DEV_DCMMODE_MENUID, HighlightEmDCMMODE);
#endif 

#if (defined(MT6229) || defined(MT6227) || defined(MT6228) || defined(MT6225) || defined(MT6268T) || defined(MT6230) || defined(MT6227D) || defined(MT6223) || defined(MT6226D) || defined(MT6223P)) 
    /* SWDBG */
    SetHiliteHandler(EM_SWDBG_MENUID, HighlightEMSWDBG);
#endif 

#if defined(NAND_SUPPORT)       /* && defined(MMI_ON_HARDWARE_P) */
    /* NAND Format */
    SetHiliteHandler(EM_NAND_FORMAT_MENUID, HighlightEmNANDFormat);
#endif 

#if defined(MT6318)
    /* PMIC 6318 */
    SetHiliteHandler(EM_DEV_PMIC_6318_MENU_ID, HighlightEmPMIC6318);
    SetHiliteHandler(EM_DEV_PMIC_6318_REGISTER_EDITOR_MENU_ID, HighlightEmPMICRegisterEditor);
    SetHiliteHandler(EM_DEV_PMIC_6318_CHARGER_STATUS_MENU_ID, HighlightEmPMICChargerStatus);
    /* Set Charger */
    SetHiliteHandler(EM_DEV_PMIC_6318_SET_CHARGER_MENU_ID, HighlightEmPMICSetCharger);
    SetHiliteHandler(EM_DEV_PMIC_6318_SET_CHARGER_CHREN_MENU_ID, HighlightEmPMICSetChargerChrEn);
    SetHiliteHandler(EM_DEV_PMIC_6318_SET_CHARGER_AC_CURRENT_MENU_ID, HighlightEmPMICSetChargerACCurrent);
    SetHiliteHandler(EM_DEV_PMIC_6318_SET_CHARGER_USB_CHREN_MENU_ID, HighlightEmPMICSetChargerUSBChren);
    SetHiliteHandler(EM_DEV_PMIC_6318_SET_CHARGER_USB_CURRENT_MENU_ID, HighlightEmPMICSetChargerUSBCurrent);
    /* RGB LED */
    SetHiliteHandler(EM_DEV_PMIC_6318_RGB_MENU_ID, HighlightEmPMICRGB);
    SetHiliteHandler(EM_DEV_PMIC_6318_RGB_R_MENU_ID, HighlightEmPMICRLEDEnable);
    SetHiliteHandler(EM_DEV_PMIC_6318_RGB_R_CURRENT_MENU_ID, HighlightEmPMICRCurrent);
    SetHiliteHandler(EM_DEV_PMIC_6318_RGB_G_MENU_ID, HighlightEmPMICGLEDEnable);
    SetHiliteHandler(EM_DEV_PMIC_6318_RGB_G_CURRENT_MENU_ID, HighlightEmPMICGCurrent);
    SetHiliteHandler(EM_DEV_PMIC_6318_RGB_B_MENU_ID, HighlightEmPMICBLEDEnable);
    SetHiliteHandler(EM_DEV_PMIC_6318_RGB_B_CURRENT_MENU_ID, HighlightEmPMICBCurrent);
    /* KB LED */
    SetHiliteHandler(EM_DEV_PMIC_6318_KP_LED_MENU_ID, HighlightEmPMICKPLED);
    SetHiliteHandler(EM_DEV_PMIC_6318_KP_ENABLE_MENU_ID, HighlightEmPMICKPEnable);
    SetHiliteHandler(EM_DEV_PMIC_6318_KP_DUTY_OPTION_MENU_ID, HighlightEmPMICKPDutyOption);
    SetHiliteHandler(EM_DEV_PMIC_6318_KP_DIM_CLOCK_MENU_ID, HighlightEmPMICKPDimClk);
    SetHiliteHandler(EM_DEV_PMIC_6318_KP_CHR_PUMP_EN_MENU_ID, HighlightEmPMICKPChrPumpEnable);
    SetHiliteHandler(EM_DEV_PMIC_6318_KP_CHR_PUMP_CURRENT_MENU_ID, HighlightEmPMICKPChrPumpCurrent);
    /* BL LED */
    SetHiliteHandler(EM_DEV_PMIC_6318_BL_LED_MENU_ID, HighlightEmPMICBLLED);
    SetHiliteHandler(EM_DEV_PMIC_6318_BL_ENABLE_MENU_ID, HighlightEmPMICBLEnable);
    SetHiliteHandler(EM_DEV_PMIC_6318_BL_DUTY_OPTION_MENU_ID, HighlightEmPMICBLDutyOption);
    SetHiliteHandler(EM_DEV_PMIC_6318_BL_DIM_CLOCK_MENU_ID, HighlightEmPMICBLDimClock);
    SetHiliteHandler(EM_DEV_PMIC_6318_BL_DIM_BYPASS_MENU_ID, HighlightEmPMICBLDimBypassEnable);
    /* Audio */
    SetHiliteHandler(EM_DEV_PMIC_6318_AUDIO_MENU_ID, HighlightEmPMICAudio);
    SetHiliteHandler(EM_DEV_PMIC_6318_AUDIO_SPEAKER_ENABLE_MENU_ID, HighlightEmPMICAudioSpkEnable);
    SetHiliteHandler(EM_DEV_PMIC_6318_AUDIO_SPEAKER_GAIN_MENU_ID, HighlightEmPMICAudioSpkGain);
    /* Misc. */
    SetHiliteHandler(EM_DEV_PMIC_6318_MISC_MENU_ID, HighlightEmPMICMisc);
    SetHiliteHandler(EM_DEV_PMIC_6318_LCM_BL_SETTING_MENU_ID, HighlightEmPMICLCMBLSetting);

#endif /* defined(MT6318) */ 

#ifdef __MMI_TVOUT__
    /* TVOUT setting */
    SetHiliteHandler(EM_DEV_TVOUT_SETTING_MENUID, mmi_em_tvout_highlight_setting);
    SetHiliteHandler(EM_DEV_TVOUT_SETTING_SWITCH_MENUID, mmi_em_tvout_highlight_switch);
    SetHiliteHandler(EM_DEV_TVOUT_SETTING_TUNNING_MENUID, mmi_em_tvout_highlight_tunning);
    SetHintHandler(EM_DEV_TVOUT_SETTING_SWITCH_MENUID, mmi_em_tvout_hint_switch);
#endif /* __MMI_TVOUT__ */ 

#ifdef __OTG_ENABLE__
    /* USB */
    SetHiliteHandler(EM_DEVICE_USB_MENNUID, HighlightEmDevUSB);
    SetHiliteHandler(EM_DEVICE_USB_OTG_SRP_MENNUID, HighlightEmDevUSBOTGSRP);
#endif /* __OTG_ENABLE__ */ 

#ifdef __MMI_FM_RADIO__
    /* FM Radio */
    SetHiliteHandler(EM_DEVICE_FM_RADIO_MENU_ID,	HighlightEmDevFMRadio);
    SetHiliteHandler(EM_DEVICE_FM_RADIO_MONO_MENU_ID,	HighlightEmDevFMRadioMono);
    SetHiliteHandler(EM_DEVICE_FM_RADIO_STEREO_MENU_ID,	HighlightEmDevFMRadioStereo);
    SetHiliteHandler(EM_DEVICE_FM_RADIO_RSSI_MENU_ID,	HighlightEmDevFMRadioRSSI);
    SetHiliteHandler(EM_DEVICE_FM_RADIO_IF_COUNT_DELTA_MENU_ID,	HighlightEmDevFMRadioIFCountDelta);    
    SetHiliteHandler(EM_DEVICE_FM_RADIO_RSSI_INFO_MENU_ID,	HighlightEmDevFMRadioRSSIInfo);        
#endif /* #ifdef __MMI_FM_RADIO__ */

    SetHiliteHandler(EM_DEVICE_RTC_XOSC_MENU_ID, HighlightEmDevRTCXOSC);        


    /******************** Audio **********************/   
    
    SetHiliteHandler(EM_AUDIO_MENUID, HighlightEmAudio);
    /* Set Mode */
    SetHiliteHandler(EM_AUD_SET_MODE_MENUID, HighlightEmSetMode);
    /* Normal/LoudSp/Headset Mode */
    SetHiliteHandler(EM_AUD_NORMAL_MODE_MENUID, HighlightEmNormalMode);
    SetHiliteHandler(EM_AUD_LOUDSP_MODE_MENUID, HighlightEmLoudSpMode);
    SetHiliteHandler(EM_AUD_HEADSET_MODE_MENUID, HighlightEmHeadsetMode);
    SetHiliteHandler(EM_AUD_FIR_MENUID, HighlightEmFIR);
    SetHiliteHandler(EM_AUD_SPEECH_MENUID, HighlightEmSpeech);
    SetHiliteHandler(EM_AUD_KEY_TONE_MENUID, HighlightEmKeyTone);
    SetHiliteHandler(EM_AUD_MELODY_MENUID, HighlightEmMelody);
    SetHiliteHandler(EM_AUD_SOUND_MENUID, HighlightEmSound); /* FM */
    SetHiliteHandler(EM_AUD_MICROPHONE_MENUID, HighlightEmMicrophone);
    SetHiliteHandler(EM_AUD_SIDE_TONE_MENUID, HighlightEmSideTone);
// unused    SetHiliteHandler(EM_AUD_CALL_TONE_MENUID, HighlightEmCallTone);
    /* Ring Tone */
    SetHiliteHandler(EM_AUD_RING_TONE_MENUID, HighlightEmRingTone);
    /* Speech Enhancement */
    SetHiliteHandler(EM_AUD_SPEECH_ENHANCEMENT_MENUID, mmi_em_sph_enh_main_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_COMMON_PARA_MENUID, mmi_em_sph_enh_common_para_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_NORMAL_MODE_MENUID, mmi_em_sph_enh_normal_mode_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_HEADSET_MODE_MENUID, mmi_em_sph_enh_headset_mode_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_LOUDSPK_MODE_MENUID, mmi_em_sph_enh_loudspk_mode_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_BT_EARPHONE_MODE_MENUID, mmi_em_sph_enh_bt_earphone_mode_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_BT_CORDLESS_MODE_MENUID, mmi_em_sph_enh_bt_cordless_mode_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_AUX1_MODE_MENUID, mmi_em_sph_enh_aux1_mode_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_AUX2_MODE_MENUID, mmi_em_sph_enh_aux2_mode_highlight_hdlr);
    SetHiliteHandler(EM_AUD_SPH_ENH_AUX3_MODE_MENUID, mmi_em_sph_enh_aux3_mode_highlight_hdlr);
    /* Max Swing */
    SetHiliteHandler(EM_AUD_SET_MAX_SWING_MENUID, HighlightEmAudSetMaxSwing);

#if defined(TV_OUT_SUPPORT)
    /* TV Out */
    SetHiliteHandler(EM_AUD_TV_OUT_MENUID, HighlightEmAudTVOUT);
#endif    
    /* Debug Info */
    SetHiliteHandler(EM_AUD_DEBUG_INFO_MENUID, HighlightEmAudVMDebugInfo); 
    /* Auto VM Setting */
    SetHiliteHandler(EM_AUD_AUTO_VM_SETTING_MENUID, HighlightEmAudAutoVMSetting); 

    /********************* GPRS ACT *********************/
    
    SetHiliteHandler(EM_GPRS_ACT_MENUID, HighlightEmGprs);
    /* Attach */
    SetHiliteHandler(EM_GPRS_AUTO_ATTACH_MENUID, HighlightEmAutoAttach);
    /* 1st PDP */
    SetHiliteHandler(EM_GPRS_1stPDP_MENUID, HighlightEm1stPDP);
    /* 2st PDP */
    SetHiliteHandler(EM_GPRS_2ndPDP_MENUID, HighlightEm2ndPDP);
    /* Activate 1st PDP */
    SetHiliteHandler(EM_GPRS_ACTIVATE_PDP_MENUID, HighlightEmActivatePDP);
    /* Deactivate PDP */
    SetHiliteHandler(EM_GPRS_DEACTIVATE_PDP_MENUID, HighlightEmDeactivatePDP);
    /* Send Data */
    SetHiliteHandler(EM_GPRS_SEND_DATA_MENUID, HighlightEmSendDataMenu);
    SetHiliteHandler(EM_GPRS_SEND_DATA_HDR_MENUID, HighlightEmSendData);
    SetHiliteHandler(EM_GPRS_SEND_DATA_NORM_MENUID, HighlightEmSendData);
    /* Activate 2nd PDP */
    SetHiliteHandler(EM_GPRS_ACTIVATE_2ND_PDP_MENUID, HighlightEmActivate2ndPDP);
    /* Activate 2nd PDP -- Primary */
    SetHiliteHandler(EM_GPRS_ACTIVATE_2ND_PDP_PRIMARY_MENUID, HighlightEmActivate2ndPDPPrimary);
    /* Activate 2nd PDP -- Secondary */
    SetHiliteHandler(EM_GPRS_ACTIVATE_2ND_PDP_SENCOND_MENUID, HighlightEmActivate2ndPDPSecondary);

    /********************** Misc. ***********************/
    
    SetHiliteHandler(EM_MISC_MENUID, HighlightEmMisc);
    SetHiliteHandler(EM_AUTO_ANSWER_MENUID, HighlightEmAutoAnswer);
    SetHiliteHandler(EM_HIGHSPEED_SIM_MENUID, HighlightEmHighSpeedSIM);
    SetHiliteHandler(EM_POWER_ON_DURATION_MENUID, HighlightEMPowerOnDuration);
    SetHiliteHandler(EM_BACKLIGHT_MENUID, HighlightEmMiscBacklight);
    SetHiliteHandler(EM_SERIAL_PORT_EN_MENUID, HighlightEmSerialPortEnable);
    SetHiliteHandler(EM_AUTO_RESET_MENUID, HighlightEmAutoReset);
    SetHiliteHandler(EM_RAM_TEST_MENUID, HightlightEMRAMTestHdlr);
    SetHiliteHandler(EM_MEMORY_DUMP_MENUID, HighlightEmMemoryDump);
    SetHiliteHandler(EM_MMI_DEBUG_MENUID, HighlightEmMMIDebug);
    /* WAP */
    SetHiliteHandler(EM_WAP_MENUID, HighlightEMWAP);
    SetHiliteHandler(EM_WAP_ENABLE_DEBUG_MENUID, HighlightEmWAPEnableDebug);
    SetHiliteHandler(EM_WAP_OFFLINE_PAGE_MENUID, HighlightEmWAPOfflinePage);
    SetHiliteHandler(EM_WAP_USER_AGENT_MENUID, HighlightEMUserAgent);
    SetHiliteHandler(EM_WAP_ACCEPT_HEADER_MENUID, HighlightEMAcceptHeader);
    SetHiliteHandler(EM_WAP_MMS_VERSION_MENUID, HighlightEMMMSVersion);

#if defined(__AMR_SUPPORT__)
    /* AMR */
    SetHiliteHandler(EM_AMR_MENUID, HighlightEmAMR);
#endif 

#ifdef __J2ME__
    /* J2ME */
    SetHiliteHandler(EM_J2ME_TCK_MENUID, HighlightEmMiscJ2meTck);
#endif 

#if defined(__MMI_TOUCH_SCREEN__)
    /* Touch Panel */
    SetHiliteHandler(EM_TOUCHSCREEN_MENUID, HighlightEmPen);
    SetHiliteHandler(EM_TOUCHSCREEN_TEST_STATISTICS_MENUID, HighlightEmPenStatistics);
    SetHiliteHandler(EM_TOUCHSCREEN_TEST_EXIT_MENUID, HighlightEmPenExit);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

#if defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT)
    /* Video High birate */
    SetHiliteHandler(EM_VIDEO_HI_BITRATE_MENUID, HighlightVideoHiBitrate);
#endif 

#ifdef __MMI_INTERACTIVE_PROFILNG__
    /* Profiling */
    SetHiliteHandler(EM_FRM_PROFILING_MENUID, HighlightEmFRMProfiling);
#endif 

#ifdef __MMI_UI_BENCHMARK__
    /* UI Bench Mark */
    SetHiliteHandler(EM_UI_BENCHMARK_MENUID, HighlightEmUIBenchmark);
#endif

    /* Cell Reselection */
    SetHiliteHandler(EM_MISC_CELL_RESELECTION_MENUID, HightlightEMCellReselect);

#if defined(__MMI_EM_FIXED_GAIN_FOR_HELIOS2__)
    /* Fixed Gain mechanism for Helios2 */
    SetHiliteHandler(EM_MISC_FIXED_GAIN_FOR_HELIOS2_MENUID, HightlightEMFixedGainForHelios2);
#endif /* __MMI_EM_FIXED_GAIN_FOR_HELIOS2__ */

#if defined(__MMI_EM_MT6223_DEBUG_MODE__)
    /* MT6223 Debug Mode */
    SetHiliteHandler(EM_MISC_MT_6223_DEBUG_MODE_MENU_ID, HightlightEMMT6223DebugMode);
#endif 

#if defined(MT6223P)
    /* LSD Slower */
    SetHiliteHandler(EM_MISC_LSD_SLOWER_MENU_ID, HightlightEMLSDSlowerMode);
#endif

    /***************** Auto Test List *******************/
    
    SetHiliteHandler(EM_AUTO_TEST_SETTING_MENUID, HighlightAutoTestSetting);

    /***************** PWR Down Control *****************/
    
    SetHiliteHandler(EM_PWR_DOWN_CONTROL_MENUID, HighlightEmPWRDownCtrl);

    /***************** SW Patch Select ******************/
    
    SetHiliteHandler(EM_SW_PATCH_MENUID, HighlightEmSWPatch);

    /******************** Debug Info ********************/
    
    SetHiliteHandler(EM_DEBUG_INFO_MENUID, HighlightEMDebugInfo);
#if defined(__FS_TRACE_SUPPORT__)
    SetHiliteHandler(EM_FS_TRACE_MENUID, HighlightEMFsTrace);
#endif 
    SetHiliteHandler(EM_LAST_EXCEPTION_MENUID, HighlightEMLastException);
    SetHiliteHandler(EM_SYS_STATS_MENUID, HighlightEMSysStat);
    SetHiliteHandler(EM_WRITE_SYS_STATS_MENUID, HighlightEMWriteSysStats);
// unused   SetHiliteHandler(EM_SAVING_STAT_PWROFF_MENUID, HighlightEMSavingStatPWROFF);

    /******************** Socket Test *******************/
#ifdef __TCPIP__
    SetHiliteHandler(EM_SOCKET_MENUID, HighlightEmSocket);
    SetHiliteHandler(EM_SOCKET_DNS_MENUID, HighlightEmDNSQuery);
    SetHiliteHandler(EM_SOCKET_HTTP_MENUID, HighlightEmHTTPGet);
    SetHiliteHandler(EM_SOCKET_ECHO_MENUID, HighlightEmEcho);
    SetHiliteHandler(EM_SOCKET_DATE_MENUID, HighlightEmDate);
    SetHiliteHandler(EM_SOCKET_TRACERT_MENUID, HighlightEmTracert);

    /* BEGIN OF IPERF */
    SetHiliteHandler(EM_SOCKET_IPERF_MENUID ,HighlightEmIperf);
#ifdef __IPERF__
    SetHiliteHandler(EM_SOCKET_IPERF_TCP_MENUID ,HighlightEmIperfTcp);
    SetHiliteHandler(EM_SOCKET_IPERF_UDP_MENUID ,HighlightEmIperfUdp);
#endif /* __IPERF__ */
    /* END OF IPERF */

    SetHiliteHandler(EM_SOCKET_DNS_DONE_MENUID, HighlightEmDNSQueryDone);
    SetHiliteHandler(EM_SOCKET_DNS_INPUT_METHOD_MENUID, HighlightEmDNSQueryInputMethod);
    SetHiliteHandler(EM_SOCKET_HTTP_DONE_MENUID, HighlightEmHTTPGetDone);
    SetHiliteHandler(EM_SOCKET_HTTP_INPUT_METHOD_MENUID, HighlightEmHTTPGetInputMethod);
#endif /* __TCPIP__ */ 

    /*********************** RF Tool ********************/
    
#if defined(__FLIGHT_MODE_SUPPORT__) || defined(__WIFI_SUPPORT__)
    /* RF Test Tool */
    SetHiliteHandler(EM_RF_TEST_TOOL_MENUID, HighlightRFTestTool);
#endif    

#ifdef __FLIGHT_MODE_SUPPORT__
    /* RF Test Tool -- GSM */
    SetHiliteHandler(EM_RF_TEST_GSM_MENUID,  HighlightRFTestGSM);
    SetHiliteHandler(EM_RF_GSM_TX_TEST_MENUID,  HighlightRFTestGSMTxTest);
    SetHiliteHandler(EM_RF_GSM_RX_TEST_MENUID,  HighlightRFTestGSMRxTest);
    SetHiliteHandler(EM_RF_GSM_POWER_SCAN_MENUID,  HighlightRFTestGSMPowerScan);
#endif    

#if defined(__WIFI_SUPPORT__)    
    /* RF Test Tool -- WiFi */
    SetHiliteHandler(EM_RF_TEST_WIFI_MENUID,  HighlightRFTestWiFi);
    SetHiliteHandler(EM_RF_WIFI_TX_TESTS_MENUID,  HighlightRFTestWiFiTxTest);
    SetHiliteHandler(EM_RF_WIFI_CONT_PKT_RX_MENUID,  HighlightRFTestWiFiContPKTRx);
    SetHiliteHandler(EM_RF_WIFI_POWER_SAVE_MENUID,  HighlightRFTestWiFiPowerSave);
    SetHiliteHandler(EM_RF_WIFI_REGISTER_ACCESS_MENUID,  HighlightRFTestWiFiRegisterAccess);
    /* RF Test Tool -- WiFi -- TX */
    SetHiliteHandler(EM_RF_WIFI_TX_DAC_OFFSET_MENUID,  HighlightRFTestWiFiTXDACOffset);
    SetHiliteHandler(EM_RF_WIFI_TX_OUTPUT_POWER_MENUID,  HighlightRFTestWiFiTXOutputPower);
    SetHiliteHandler(EM_RF_WIFI_TX_CARRIER_SUPP_MENUID,  HighlightRFTestWiFiTXCarrierSupp);
    SetHiliteHandler(EM_RF_WIFI_TX_LOCAL_FREQUENCY_MENUID,  HighlightRFTestWiFiTXLocalFreq);
    SetHiliteHandler(EM_RF_WIFI_TX_CONT_PKT_TX_MENUID,  HighlightRFTestWiFiTXContPKT);
    /* RF Test Tool -- WiFi -- Register */
    SetHiliteHandler(EM_RF_WIFI_REGISTER_MCR_MENUID,  HighlightRFTestWiFiRegisterMCR);
    SetHiliteHandler(EM_RF_WIFI_REGISTER_BBCR_MENUID,  HighlightRFTestWiFiRegisterBBCR);
    SetHiliteHandler(EM_RF_WIFI_REGISTER_EEPROM_MENUID,  HighlightRFTestWiFiRegisterEEPROM);
#endif


#if defined(__VOIP__)  
    SetHiliteHandler(EM_VOIP_MENNUID, HighlightEmVOIP);
    SetHiliteHandler(EM_VOIP_SETTINGS_MENU_ID, HighlightEmVOIPSetting);
    SetHiliteHandler(EM_VOIP_SIP_SUPPORTED_MENU_ID, HighlightEmVOIPSIPSupported);
    SetHiliteHandler(EM_VOIP_SIP_REQUIRE_MENU_ID, HighlightEmVOIPSIPRequire);    

    SetHiliteHandler(EM_VOIP_LOG_MENU_ID, HighlightEmVOIPLog);
    SetHiliteHandler(EM_VOIP_LOG_VIEW_MENU_ID, HighlightEmVOIPLogView);
    SetHiliteHandler(EM_VOIP_LOG_SETTINGS_MENU_ID, HighlightEmVOIPLogSetting);
    
    SetHiliteHandler(EM_VOIP_LOG_OPTION_VIEW_MENU_ID, HighlightEmVOIPLogOptionView);
    SetHiliteHandler(EM_VOIP_LOG_OPTION_DELETE_MENU_ID, HighlightEmVOIPLogOptionDelete);
    SetHiliteHandler(EM_VOIP_LOG_OPTION_DELETE_ALL_MENU_ID, HighlightEmVOIPLogOptionDeleteAll);
#endif /*  __VOIP__ */

#if defined (__MMI_CSB_BROWSER__)
	SetHiliteHandler(CSB_MENUID, HighlightCSB);
	SetHiliteHandler(CSB_VIEW_MENUID, HighlightCSBView);
	SetHiliteHandler(CSB_START_VIEW_MENUID, HighlightCSBStartView);
	SetHiliteHandler(CSB_START_VIEW_X_MENUID, HighlightCSBStartViewX);
	SetHiliteHandler(CSB_VIEW_OPTIONS_MENUID, HighlightCSBViewOptions);
	SetHiliteHandler(CSB_VIEW_OPTIONS_VIEW_MODE_MENUID, HighlightCSBOptionsViewMode);
	SetHiliteHandler(CSB_VIEW_OPTIONS_MODE_SETTINGS_MENUID, HighlightCSBOptionsModeSettings);
	SetHiliteHandler(CSB_OPTIONS_SETTING_AUTO_MODE_TIME_MENUID, HighlightCSBOptionsAutoModeTime);
	SetHiliteHandler(CSB_OPTIONS_SETTING_MANUAL_MODE_MENUID, HighlightCSBOptionsManualMode);
	SetHiliteHandler(CSB_SEARCH_MENUID, HighlightCSBSearch);
	SetHiliteHandler(CSB_SEARCH_CONTROL_MENUID,HighlightCSBSearchByControl);
	SetHiliteHandler(CSB_SEARCH_APP_MENUID,HighlightCSBSearchByApp);
	SetHiliteHandler(CSB_SEARCH_SCREENID_MENUID,HighlightCSBSearchByScrID);
	SetHiliteHandler(CSB_TESTOOL_MENUID, HighlightCSBTestTool);
	SetHiliteHandler(CSB_TESTOOL_RUN_MENUID, HighlightCSBTestToolRun);
	SetHiliteHandler(CSB_TESTOOL_SET_LOC_MENUID, HighlightCSBTestToolSetLoc);
	SetHiliteHandler(CSB_TESTOOL_VIEW_IMAGES_MENUID, HighlightCSBTestToolViewImages);
#endif

    /* Cascade Menu */
#if defined(__MMI_CASCADE_MENU__)    
    SetHiliteHandler(EM_MISC_CASCADE_MENU_MENU_ID, HighlightCascadeMenuTest);
#endif /* defined(__MMI_CASCADE_MENU__) */

    /*******************************************************************/
    /***********   Protocol Event handler & Init Functions  ************/
    /*******************************************************************/

    /********************* Network **********************/
#ifdef __EM_MODE__
    SetProtocolEventHandler(EngineerModeStartRes, MSG_ID_EM_START_RSP);
    SetProtocolEventHandler(EngineerModeStatusInd, MSG_ID_EM_STATUS_IND);
    SetProtocolEventHandler(EmNWEventStartStopRsp, MSG_ID_MMI_EM_NW_EVENT_NOTIFY_RSP);
    SetProtocolEventHandler(EngineerModeNWEventNotifyInd, MSG_ID_MMI_EM_NW_EVENT_NOTIFY_IND);
#endif /* #ifdef __EM_MODE__ */    
    
    /********************** Device **********************/    
    /* Set UART */
    SetProtocolEventHandler(EngineerModeSetUartRes, MSG_ID_EM_SET_UART_RSP);
    SetProtocolEventHandler(EngineerModeAttachUartRes, MSG_ID_MMI_ATTACH_UART_PORT_RSP);
    SetProtocolEventHandler(EngineerModeDetachUartRes, MSG_ID_MMI_DETACH_UART_PORT_RSP);
    /* Set Default Level */
    SetProtocolEventHandler(SendSetHWLevelInfoRsp, MSG_ID_MMI_EQ_SET_HW_LEVEL_RSP);
    /* Sleep mode */
    SetProtocolEventHandler(EngineerModeSetSleepModeRes, MSG_ID_MMI_EQ_SET_SLEEP_MODE_RSP);
    
#if defined(MT6318)
    /* PMIC 6318 */
    SetProtocolEventHandler(EMPMICRegisterRes, MSG_ID_MMI_EQ_PMIC_CONFIG_RSP);
#endif 

#ifdef __MMI_FM_RADIO__
    /* FM Radio */
    SetProtocolEventHandler (EMFMRadioSendRes, MSG_ID_MMI_EQ_FM_RADIO_CONFIG_RSP);
#endif	

#ifdef __MMI_TVOUT__
    /* TV-Out Setting */
    mmi_em_tvout_init();
#endif 

    /*********************** Audio **********************/  
//    SetProtocolEventHandler(EngineerModeGetAudioProfileRes, MSG_ID_MMI_EQ_GET_AUDIO_PROFILE_RSP);
//    SetProtocolEventHandler(EngineerModeSetAudioProfileRes, MSG_ID_MMI_EQ_SET_AUDIO_PROFILE_RSP);
//    SetProtocolEventHandler(EngineerModeGetAudioParamRes, MSG_ID_MMI_EQ_GET_AUDIO_PARAM_RSP);
//    SetProtocolEventHandler(EngineerModeSetAudioParamRes, MSG_ID_MMI_EQ_SET_AUDIO_PARAM_RSP);

    /* Audio Debug Info Init */
    mmi_em_audio_debug_info_init();

    /*********************** RF Tool *********************/ 
#ifdef __FLIGHT_MODE_SUPPORT__
    SetProtocolEventHandler(EMRFTestGsmSendRes ,  MSG_ID_MMI_EQ_RF_TEST_GSM_RSP);
    /* RF Test Tool GSM Init Context */
    EMRFTestGSMInitContext();
#endif    

#if defined(__WIFI_SUPPORT__)
    SetProtocolEventHandler(EMRFTestWifiSendRes ,  MSG_ID_MMI_EQ_RF_TEST_WIFI_RSP);
    /* RF Test Tool Wifi Init Context */
    EMRFTestWiFiInitContext();
#endif   


    /************************ GPRS ***********************/ 
#ifdef __MOD_TCM__
    SetProtocolEventHandler(EngineerModeGprsDeactivatePDPRes, MSG_ID_MMI_PS_ACT_TEST_RSP);
    SetProtocolEventHandler(EngineerModeGprsSendDataRes, MSG_ID_MMI_PS_SEND_DATA_RSP);
    SetProtocolEventHandler(EngineerModeGprsSetDefinitionRes, MSG_ID_MMI_PS_SET_DEFINITION_RSP);
    SetProtocolEventHandler(EngineerModeGprsSetDefinitionRes, MSG_ID_MMI_PS_SET_SEC_DEFINITION_RSP);
#ifdef __R99__
    SetProtocolEventHandler(EngineerModeGprsSetEQosRes, MSG_ID_MMI_PS_SET_EQOS_RSP);
#endif 
    SetProtocolEventHandler(EngineerModeGprsSetQosRes, MSG_ID_MMI_PS_SET_QOS_RSP);
    SetProtocolEventHandler(EngineerModeGprsActTestRes, MSG_ID_MMI_PS_ACT_TEST_RSP);
#endif /* __MOD_TCM__ */ 

#ifdef __MMI_DUAL_SIM_SINGLE_CALL__
    mmi_frm_set_slave_protocol_event_handler(EngineerModeGprsDeactivatePDPRes, MSG_ID_MMI_PS_ACT_TEST_RSP);
    mmi_frm_set_slave_protocol_event_handler(EngineerModeGprsSendDataRes, MSG_ID_MMI_PS_SEND_DATA_RSP);
    mmi_frm_set_slave_protocol_event_handler(EngineerModeGprsSetDefinitionRes, MSG_ID_MMI_PS_SET_DEFINITION_RSP);
    mmi_frm_set_slave_protocol_event_handler(EngineerModeGprsSetDefinitionRes, MSG_ID_MMI_PS_SET_SEC_DEFINITION_RSP);
#ifdef __R99__    
    mmi_frm_set_slave_protocol_event_handler(EngineerModeGprsSetEQosRes, MSG_ID_MMI_PS_SET_EQOS_RSP);
#endif
    mmi_frm_set_slave_protocol_event_handler(EngineerModeGprsSetQosRes, MSG_ID_MMI_PS_SET_QOS_RSP);
    mmi_frm_set_slave_protocol_event_handler(EngineerModeGprsActTestRes, MSG_ID_MMI_PS_ACT_TEST_RSP);    
#endif /* __MMI_DUAL_SIM_SINGLE_CALL__ */

    /************************ GPRS ***********************/ 
    
#if (defined(__MMI_ENGINEER_MODE__) && defined(__MMI_GPRS_PING_APP__) && defined(__TCPIP__) && defined(__PS_SERVICE__))
    /* GPRS Act / PING */
    InitEngineerModeSocketApp();
#endif 

    /********************** Bluetooth *******************/

#if defined(__MMI_BT_SUPPORT__)
    InitEngineerModeBT();
#endif 

    /********************** Profiling *******************/
    mmi_em_init_profiling();

    /***********************CSB**************************/
#if defined(__MMI_CSB_BROWSER__)
	InitCSB();	
#endif
}


/*****************************************************************************
 * FUNCTION
 *  InitEngineerModeSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitEngineerModeSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gCurrentMode = ENGINEERING_MODE;
    mdi_audio_suspend_background_play();
    StopLEDPatternBackGround();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEngineerModeMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEngineerModeMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_MAIN_MENU_SCR, NULL, EntryEngineerModeMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_MAIN_MENU_SCR);

    nItems = GetNumOfChild(ENGINEER_MODE_MENUID);
    GetSequenceStringIds(ENGINEER_MODE_MENUID, ItemList);
    SetParentHandler(ENGINEER_MODE_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);
    }

    ShowCategory52Screen(
        ENGINEER_MODE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    InitEngineerModeSetting();

}


/*****************************************************************************
 * FUNCTION
 *  SendSetAudioProfileReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendSetAudioProfileReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EngineerModeSetAudioProfileReq(&gAudioProfile);
}


/*****************************************************************************
 * FUNCTION
 *  SendSetVolumeReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendSetVolumeReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EngineerModeSetVolumeReq((U8) currentVolumeType, (U8) currentVolume);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmAudioMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAudioMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUDIO_MENU_SCR, ExitEmAudioMenu, NULL, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUDIO_MENU_SCR);
    nItems = GetNumOfChild(EM_AUDIO_MENUID);
    GetSequenceStringIds(EM_AUDIO_MENUID, ItemList);
    SetParentHandler(EM_AUDIO_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    ShowCategory52Screen(
        EM_AUDIO_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmAudioMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmAudioMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currHistory.scrnID = EM_AUDIO_MENU_SCR;
    /* currHistory.entryFuncPtr = EntryEmAudioMenu; */
    currHistory.entryFuncPtr = SendGetAudioParamReq;
    mmi_ucs2cpy((S8*) currHistory.inputBuffer, (S8*) L"");
    GetCategoryHistory(currHistory.guiBuffer);
    AddHistory(currHistory);
}


/*****************************************************************************
 * FUNCTION
 *  EngineerModeRingTonePlay
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EngineerModeRingTonePlay(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StopTimer(EM_RINGTONE_HIGHLIGHT_TIMER);
    if (activeRingToneIndex >= (gNoOfImy + gNoOfMidi))
    {
        EngineerModePlayAudioReq((U8) (activeRingToneIndex - (gNoOfImy + gNoOfMidi)), AUD_SOUND);
    }
    else if (activeRingToneIndex >= gNoOfImy)
    {
        EngineerModePlayAudioReq((U8) (activeRingToneIndex - gNoOfImy), AUD_MIDI);
    }
    else
    {
        EngineerModePlayAudioReq(activeRingToneIndex, AUD_IMELODY);
    }
}


/*****************************************************************************
 * FUNCTION
 *  HighlightRingToneIndex
 * DESCRIPTION
 *  
 * PARAMETERS
 *  nIndex      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightRingToneIndex(S32 nIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!isPopup)
    {
        if (activeRingToneIndex >= (gNoOfImy + gNoOfMidi))
        {
            EngineerModeStopAudioReq((U8) (activeRingToneIndex - (gNoOfImy + gNoOfMidi)), AUD_SOUND);
        }
        else if (activeRingToneIndex >= gNoOfImy)
        {
            EngineerModeStopAudioReq((U8) (activeRingToneIndex - gNoOfImy), AUD_MIDI);
        }
        else
        {
            EngineerModeStopAudioReq((U8) activeRingToneIndex, AUD_IMELODY);
        }

        activeRingToneIndex = (U8) nIndex;
        StartTimer(EM_RINGTONE_HIGHLIGHT_TIMER, EM_HIGHTLIGHT_DURATION, EngineerModeRingTonePlay);
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmPrepareRingToneList
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmPrepareRingToneList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i;
    S8 buffer[20];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    custom_get_fixed_imelody_range(&gFixedImyBegin, &gFixedImyEnd);
    custom_get_fixed_midi_range(&gFixedMidiBegin, &gFixedMidiEnd);
    custom_get_fixed_sound_range(&gFixedSoundBegin, &gFixedSoundEnd);

    gNoOfImy = (gFixedImyEnd - gFixedImyBegin + 1);
    gNoOfMidi = (gFixedMidiEnd - gFixedMidiBegin + 1);
    gNoOfSound = (gFixedSoundEnd - gFixedSoundBegin + 1);

    for (i = 0; i < gNoOfImy && i < MAX_SUB_MENUS; i++)
    {
        sprintf(buffer, "IMY %d", i);
        mmi_asc_to_ucs2((PS8) subMenuData[i], buffer);
        subMenuDataPtrs[i] = subMenuData[i];
    }

    for (i = gNoOfImy; i < gNoOfImy + gNoOfMidi && i < MAX_SUB_MENUS; i++)
    {
        sprintf(buffer, "MIDI %d", i - gNoOfImy);
        mmi_asc_to_ucs2((PS8) subMenuData[i], buffer);
        subMenuDataPtrs[i] = subMenuData[i];
    }

    for (i = gNoOfImy + gNoOfMidi; i < gNoOfImy + gNoOfMidi + gNoOfSound && i < MAX_SUB_MENUS; i++)
    {
        sprintf(buffer, "SOUND %d", i - (gNoOfImy + gNoOfMidi));
        mmi_asc_to_ucs2((PS8) subMenuData[i], buffer);
        subMenuDataPtrs[i] = subMenuData[i];
    }

    gNoOfRing = gNoOfImy + gNoOfMidi + gNoOfSound;

}


/*****************************************************************************
 * FUNCTION
 *  EmPopupFinishHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmPopupFinishHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StopTimer(EM_NOTIFYDURATION_TIMER);
    GoBackHistory();
    isPopup = FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  EmAudioKeyUp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmAudioKeyUp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 temp[30];
    U8 MessageString[30];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentKeyShift += 1;
    if (currentKeyShift > MAX_KEY_SHIFT)
    {
        currentKeyShift = MAX_KEY_SHIFT;
    }
    /* currentKeyShift = MIN(currentKeyShift, MAX_KEY_SHIFT); */
    if (!custom_em_melody_key_shift(currentKeyShift))
    {
        return;
    }

    isPopup = TRUE;

    EntryNewScreen(EM_AUD_RING_TONE_MENU_SCR, NULL, NULL, NULL);

    memset(MessageString, 0, 30);

    if (currentKeyShift > 0)
    {
        sprintf(temp, "%d halftone Up!", currentKeyShift);
    }
    else if (currentKeyShift < 0)
    {
        sprintf(temp, "%d halftone Down!", -currentKeyShift);
    }
    else
    {
        sprintf(temp, "Key not changed!");
    }

    mmi_asc_to_ucs2((PS8) MessageString, temp);

    ShowCategory63Screen(MessageString, EM_NETWORK_ICON, NULL);

    SetLeftSoftkeyFunction(EmPopupFinishHandler, KEY_EVENT_UP);

    StartTimer(EM_NOTIFYDURATION_TIMER, EM_NOTIFY_DURATION, EmPopupFinishHandler);
}


/*****************************************************************************
 * FUNCTION
 *  EmAudioKeyDown
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmAudioKeyDown(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 temp[30];
    U8 MessageString[30];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentKeyShift -= 1;
    if (currentKeyShift < (-MAX_KEY_SHIFT))
    {
        currentKeyShift = -MAX_KEY_SHIFT;
    }
    /* currentKeyShift = MAX(currentKeyShift, (-MAX_KEY_SHIFT)); */
    if (!custom_em_melody_key_shift(currentKeyShift))
    {
        return;
    }

    isPopup = TRUE;

    EntryNewScreen(EM_AUD_RING_TONE_MENU_SCR, NULL, NULL, NULL);

    memset(MessageString, 0, 30);

    if (currentKeyShift > 0)
    {
        sprintf(temp, "%d halftone Up!", currentKeyShift);
    }
    else if (currentKeyShift < 0)
    {
        sprintf(temp, "%d halftone Down!", -currentKeyShift);
    }
    else
    {
        sprintf(temp, "Key not changed!");
    }

    mmi_asc_to_ucs2((PS8) MessageString, temp);

    ShowCategory63Screen(MessageString, EM_NETWORK_ICON, NULL);
    SetLeftSoftkeyFunction(EmPopupFinishHandler, KEY_EVENT_UP);
    StartTimer(EM_NOTIFYDURATION_TIMER, EM_NOTIFY_DURATION, EmPopupFinishHandler);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmRingToneMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmRingToneMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_RING_TONE_MENU_SCR, ExitEmRingToneMenu, NULL, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_RING_TONE_MENU_SCR);

    RegisterHighlightHandler(HighlightRingToneIndex);
    EmPrepareRingToneList();

    if (gNoOfRing < 1)
    {
        ShowCategory6Screen(
            EM_AUD_RING_TONE_TEXT,
            0,
            STR_GLOBAL_OK,
            0,
            STR_GLOBAL_BACK,
            0,
            gNoOfRing + 1,
            (PU8*) subMenuDataPtrs,
            NULL,
            0,
            guiBuffer);
        SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
        SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    }
    else
    {
        ShowCategory6Screen(
            EM_AUD_RING_TONE_TEXT,
            0,
            STR_GLOBAL_OK,
            0,
            STR_GLOBAL_BACK,
            0,
            gNoOfRing,
            (PU8*) subMenuDataPtrs,
            NULL,
            0,
            guiBuffer);
        SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
        SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
        SetKeyHandler(EmAudioKeyUp, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(EmAudioKeyDown, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmRingToneMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmRingToneMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!isPopup)
    {
        /* stop timer */
        StopTimer(EM_RINGTONE_HIGHLIGHT_TIMER);
        /* stop ring tone */
        if (activeRingToneIndex >= (gNoOfImy + gNoOfMidi))
        {
            EngineerModeStopAudioReq((U8) (activeRingToneIndex - (gNoOfImy + gNoOfMidi)), AUD_SOUND);
        }
        else if (activeRingToneIndex >= gNoOfImy)
        {
            EngineerModeStopAudioReq((U8) (activeRingToneIndex - gNoOfImy), AUD_MIDI);
        }
        else
        {
            EngineerModeStopAudioReq(activeRingToneIndex, AUD_IMELODY);
        }
    }

    currHistory.scrnID = EM_AUD_RING_TONE_MENU_SCR;
    currHistory.entryFuncPtr = EntryEmRingToneMenu;
    mmi_ucs2cpy((S8*) currHistory.inputBuffer, (S8*) L"");
    GetCategoryHistory(currHistory.guiBuffer);
    AddHistory(currHistory);
}


/*****************************************************************************
 * FUNCTION
 *  IsAudioProfileChanged
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
BOOL IsAudioProfileChanged(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MAX_EM_VOLUME_LEVEL; i++)
    {
        if (gAudioProfile.melody[i] != gAudioProfileOrg.melody[i] ||
            gAudioProfile.sound[i] != gAudioProfileOrg.sound[i] ||
            gAudioProfile.keytone[i] != gAudioProfileOrg.keytone[i] ||
            gAudioProfile.speech[i] != gAudioProfileOrg.speech[i] || gAudioProfile.mic[i] != gAudioProfileOrg.mic[i] ||
            gAudioProfile.tvout[i] != gAudioProfileOrg.tvout[i] )
        {
            return TRUE;
        }
    }

    if (gAudioProfile.sidetone != gAudioProfileOrg.sidetone)
    {
        return TRUE;
    }

    if (gAudioProfile.vol_16_level_max_gain!= gAudioProfileOrg.vol_16_level_max_gain)
    {
        return TRUE;
    }

    if (gAudioProfile.vol_16_level_step!= gAudioProfileOrg.vol_16_level_step)
    {
        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  CheckAudioProfile
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void CheckAudioProfile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (IsAudioProfileChanged())
    {
        ShowCategory2Screen(EM_UPDATE_TITLE_TEXT, 0, STR_GLOBAL_YES, 0, STR_GLOBAL_NO, 0, EM_UPDATE_QUERY_TEXT, NULL);
        SetLeftSoftkeyFunction(SendSetAudioProfileReq, KEY_EVENT_UP);
        SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
        ReplaceNewScreenHandler(EM_UPDATE_TITLE_TEXT, NULL, NULL);
    }
    else
    {
        GoBackHistory();
    }
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSetMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSetMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 ItemList[] = 
    {
        EM_AUD_NORMAL_MODE_TEXT,
        EM_AUD_LOUDSP_MODE_TEXT,
        EM_AUD_HEADSET_MODE_TEXT
    };
    U8 modeList[] = 
    {
        AUD_MODE_NORMAL,
        AUD_MODE_LOUDSPK,
        AUD_MODE_HEADSET
    };
    U8 audio_mode = mdi_audio_get_audio_mode();
    U16 i, audio_mode_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = audio_mode_index = 0; i < 3; i++)
    {
        if (modeList[i] == (U16) audio_mode)
        {
            audio_mode_index = i;
            break;
        }
    }

    EntryNewScreen(EM_AUD_SET_MODE_MENU_SCR, NULL, EntryEmSetMode, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_SET_MODE_MENU_SCR);
    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_AUD_SET_MODE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        3,
        ItemList,
        audio_mode_index,
        guiBuffer);

    SetLeftSoftkeyFunction(EmSetMode, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EmSetMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSetMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[] = 
    {
        EM_AUD_NORMAL_MODE_TEXT,
        EM_AUD_LOUDSP_MODE_TEXT,
        EM_AUD_HEADSET_MODE_TEXT
    };
    U8 modeList[] = 
    {
        AUD_MODE_NORMAL,
        AUD_MODE_LOUDSPK,
        AUD_MODE_HEADSET
    };

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_audio_set_audio_mode(modeList[currentHighlightIndex]);
    DisplayPopup((PU8) GetString(ItemList[currentHighlightIndex]), IMG_GLOBAL_OK, 1, 1000, (U8) SUCCESS_TONE);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSetMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSetMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSetMode, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmNormalModeMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmNormalModeMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_NORMAL_MODE_MENU_SCR, NULL, EntryEmNormalModeMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_NORMAL_MODE_MENU_SCR);

    nItems = GetNumOfChild(EM_AUD_NORMAL_MODE_MENUID);
    GetSequenceStringIds(EM_AUD_NORMAL_MODE_MENUID, ItemList);
    SetParentHandler(EM_AUD_NORMAL_MODE_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    ShowCategory52Screen(
        EM_AUD_NORMAL_MODE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(CheckAudioProfile, KEY_EVENT_UP);

    /* reset current highlight index */
    SetHighlightIndex(0);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmLoudSpModeMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmLoudSpModeMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_LOUDSP_MODE_MENU_SCR, NULL, EntryEmLoudSpModeMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_LOUDSP_MODE_MENU_SCR);

    nItems = GetNumOfChild(EM_AUD_LOUDSP_MODE_MENUID);
    GetSequenceStringIds(EM_AUD_LOUDSP_MODE_MENUID, ItemList);
    SetParentHandler(EM_AUD_LOUDSP_MODE_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    ShowCategory52Screen(
        EM_AUD_LOUDSP_MODE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(CheckAudioProfile, KEY_EVENT_UP);

    /* reset current highlight index */
    SetHighlightIndex(0);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmHeadsetModeMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmHeadsetModeMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_HEADSET_MODE_MENU_SCR, NULL, EntryEmHeadsetModeMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_HEADSET_MODE_MENU_SCR);

    nItems = GetNumOfChild(EM_AUD_HEADSET_MODE_MENUID);
    GetSequenceStringIds(EM_AUD_HEADSET_MODE_MENUID, ItemList);
    SetParentHandler(EM_AUD_HEADSET_MODE_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    ShowCategory52Screen(
        EM_AUD_HEADSET_MODE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(CheckAudioProfile, KEY_EVENT_UP);

    /* reset current highlight index */
    SetHighlightIndex(0);
}


/*****************************************************************************
 * FUNCTION
 *  EmAudioVolumeUp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmAudioVolumeUp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (currentVolume < MAX_VOLUME - VOLUME_STEP)
    {
        currentVolume += VOLUME_STEP;
    }
    else
    {
        currentVolume = MAX_VOLUME;
    }

    ShowCategory204Screen(EM_SET_LSK_TEXT, 0, STR_GLOBAL_BACK, 0, EM_AUD_SET_VOLUME_TEXT, currentVolume, 0, 0);
    SetLeftSoftkeyFunction(EmSetVolume, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeUp, KEY_UP_ARROW, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeDown, KEY_DOWN_ARROW, KEY_EVENT_UP);
#ifdef __MMI_FOURWAYS_KEY_DISABLE__
    SetKeyHandler(EmAudioVolumeUp, KEY_VOL_UP, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeDown, KEY_VOL_DOWN, KEY_EVENT_UP);
#endif /* __MMI_FOURWAYS_KEY_DISABLE__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  EmAudioVolumeDown
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmAudioVolumeDown(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (currentVolume > MIN_VOLUME + VOLUME_STEP)
    {
        currentVolume -= VOLUME_STEP;
    }
    else
    {
        currentVolume = MIN_VOLUME;
    }

    ShowCategory204Screen(EM_SET_LSK_TEXT, 0, STR_GLOBAL_BACK, 0, EM_AUD_SET_VOLUME_TEXT, currentVolume, 0, 0);
    SetLeftSoftkeyFunction(EmSetVolume, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeUp, KEY_UP_ARROW, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeDown, KEY_DOWN_ARROW, KEY_EVENT_UP);

#ifdef __MMI_FOURWAYS_KEY_DISABLE__
    SetKeyHandler(EmAudioVolumeUp, KEY_VOL_UP, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeDown, KEY_VOL_DOWN, KEY_EVENT_UP);
#endif /* __MMI_FOURWAYS_KEY_DISABLE__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  EmGetCurrentVolume
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
U8 EmGetCurrentVolume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (currentVolumeType)
    {
        case EM_VOL_TYPE_SPH:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                return gAudioProfile.speech[currentHighlightIndex];
            }
            else
            {
                return gAudioProfile.sp_gain;
            }
            break;
        case EM_VOL_TYPE_KEY:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                return gAudioProfile.keytone[currentHighlightIndex];
            }
            else
            {
                return gAudioProfile.kt_gain;
            }
            break;
        case EM_VOL_TYPE_MIC:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                return gAudioProfile.mic[currentHighlightIndex];
            }
            else
            {
                return gAudioProfile.mic_gain;
            }
            break;
        case EM_VOL_TYPE_SID:
            return gAudioProfile.sidetone;
            break;
        case EM_VOL_TYPE_MEDIA:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                return gAudioProfile.melody[currentHighlightIndex];
            }
            else
            {
                return gAudioProfile.mel_gain;
            }
            break;
        case EM_VOL_TYPE_SND:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                return gAudioProfile.sound[currentHighlightIndex];
            }
            else
            {
                return gAudioProfile.snd_gain;
            }
            break;
        case EM_VOL_TYPE_TVOUT:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                return gAudioProfile.tvout[currentHighlightIndex];
            }
            else
            {
                return gAudioProfile.tvout_gain;
            }
            break;
        default:
            return 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmSetVolume
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSetVolume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (currentVolumeType)
    {
        case EM_VOL_TYPE_SPH:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                gAudioProfile.speech[currentHighlightIndex] = (U8) currentVolume;
            }
            else
            {
                SendSetVolumeReq();
                gAudioProfile.sp_gain = (U8) currentVolume;
            }
            break;
        case EM_VOL_TYPE_KEY:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                gAudioProfile.keytone[currentHighlightIndex] = (U8) currentVolume;
            }
            else
            {
                SendSetVolumeReq();
                gAudioProfile.kt_gain = (U8) currentVolume;
            }
            break;
        case EM_VOL_TYPE_MIC:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                gAudioProfile.mic[currentHighlightIndex] = (U8) currentVolume;
            }
            else
            {
                SendSetVolumeReq();
                gAudioProfile.mic_gain = (U8) currentVolume;
            }
            break;
        case EM_VOL_TYPE_SID:
            gAudioProfile.sidetone = (U8) currentVolume;
            break;
        case EM_VOL_TYPE_MEDIA:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                gAudioProfile.melody[currentHighlightIndex] = (U8) currentVolume;
            }
            else
            {
                SendSetVolumeReq();
                gAudioProfile.mel_gain = (U8) currentVolume;
            }
            break;
        case EM_VOL_TYPE_SND:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                gAudioProfile.sound[currentHighlightIndex] = (U8) currentVolume;
            }
            else
            {
                SendSetVolumeReq();
                gAudioProfile.snd_gain = (U8) currentVolume;
            }
            break;
        case EM_VOL_TYPE_TVOUT:
            if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
            {
                gAudioProfile.tvout[currentHighlightIndex] = (U8) currentVolume;
            }
            else
            {
                SendSetVolumeReq();
                gAudioProfile.tvout_gain = (U8) currentVolume;
            }
            break;
    }

    GoBackHistory();

}


/*****************************************************************************
 * FUNCTION
 *  ExitEmSet16LevelVolume
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmSet16LevelVolume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSetVolume
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSetVolume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* guiBuffer;
    U16 ImageList[4];
    S8  buffer[20];
    U8  gain = 0;
    U8  step = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (currentHighlightIndex < MAX_EM_VOLUME_LEVEL)
    {
        EntryNewScreen(EM_AUD_SET_VOLUME_MENU_SCR, NULL, NULL, NULL);

        currentVolume = EmGetCurrentVolume();
        ShowCategory204Screen(EM_SET_LSK_TEXT, 0, STR_GLOBAL_BACK, 0, EM_AUD_SET_VOLUME_TEXT, currentVolume, 0, 0);
        SetLeftSoftkeyFunction(EmSetVolume, KEY_EVENT_UP);
        SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
        SetKeyHandler(EmAudioVolumeUp, KEY_UP_ARROW, KEY_EVENT_UP);
        SetKeyHandler(EmAudioVolumeDown, KEY_DOWN_ARROW, KEY_EVENT_UP);

    #ifdef __MMI_FOURWAYS_KEY_DISABLE__
        SetKeyHandler(EmAudioVolumeUp, KEY_VOL_UP, KEY_EVENT_UP);
        SetKeyHandler(EmAudioVolumeDown, KEY_VOL_DOWN, KEY_EVENT_UP);
    #endif /* __MMI_FOURWAYS_KEY_DISABLE__ */ 
    }
    else if (currentHighlightIndex == MAX_EM_VOLUME_LEVEL)  /* 16 Level */
    {
        EmGetCurrent16LevelInfo(&gain, &step);

        sprintf(buffer,"%d", gain);
        mmi_asc_to_ucs2((PS8)g_aud_16_level_cntx.MaxAnalogGain, buffer);

        sprintf(buffer,"%d", step);
        mmi_asc_to_ucs2((PS8)g_aud_16_level_cntx.Step, buffer);
        
        EntryNewScreen(EM_AUD_16_LEVEL_VOLUME_SCR, ExitEmSet16LevelVolume, NULL, NULL); 
        InitializeCategory57Screen();
        guiBuffer = GetCurrGuiBuffer(EM_AUD_16_LEVEL_VOLUME_SCR);        

        /* Max Analog Gain */
        SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_AUD_16_LELVEL_MAX_GAIN_TEXT));
        ImageList[0] = IMG_STATUS;
       
        SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemTextEdit(&wgui_inline_items[1], (PU8)g_aud_16_level_cntx.MaxAnalogGain, 4, INPUT_TYPE_NUMERIC);
        ImageList[1] = 0;

        /* Step */
        SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_AUD_16_LELVEL_STEP_TEXT));
        ImageList[2] = IMG_STATUS;
       
        SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemTextEdit(&wgui_inline_items[3], (PU8)g_aud_16_level_cntx.Step, 4, INPUT_TYPE_NUMERIC);
        ImageList[3] = 0;

        ShowCategory57Screen(EM_AUD_16_LELVEL_VOLUME_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    4, ImageList, wgui_inline_items, 0, guiBuffer);	
      
        SetCategory57RightSoftkeyFunctions( EmSet16LevelVolume, GoBackHistory );

        SetLeftSoftkeyFunction(EmSet16LevelVolume, KEY_EVENT_UP);
        
    }
    else
        ASSERT(0);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmFIR
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmFIR(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 ItemList[] = 
    {
        EM_AUD_FIR_0_TEXT,
        EM_AUD_FIR_1_TEXT,
        EM_AUD_FIR_2_TEXT,
        EM_AUD_FIR_3_TEXT,
        EM_AUD_FIR_4_TEXT,
        EM_AUD_FIR_5_TEXT
    };

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_FIR_MENU_SCR, NULL, EntryEmFIR, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_FIR_MENU_SCR);

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_AUD_FIR_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        6,
        ItemList,
        AudioParameter.selected_FIR_output_index,
        guiBuffer);

    SetLeftSoftkeyFunction(EmSetFIR, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EmSetFIR
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSetFIR(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*
     * U16 ItemList[]=
     * {  
     * EM_AUD_FIR_0_TEXT,
     * EM_AUD_FIR_1_TEXT,
     * EM_AUD_FIR_2_TEXT,
     * EM_AUD_FIR_3_TEXT,
     * EM_AUD_FIR_4_TEXT,
     * EM_AUD_FIR_5_TEXT
     * };
     */
    AudioParameter.selected_FIR_output_index = currentHighlightIndex;
    EngineerModeSetAudioParamReq(&AudioParameter);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmFIR
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmFIR(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmFIR, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSpeech
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSpeech(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[] = 
    {
        EM_AUD_VOLUME_0_TEXT,
        EM_AUD_VOLUME_1_TEXT,
        EM_AUD_VOLUME_2_TEXT,
        EM_AUD_VOLUME_3_TEXT,
        EM_AUD_VOLUME_4_TEXT,
        EM_AUD_VOLUME_5_TEXT,
        EM_AUD_VOLUME_6_TEXT,
        EM_AUD_16_LELVEL_VOLUME_TEXT,
        EM_AUD_DIRECT_APPLY_TEXT
    };
    U16 ItemIcons[32];
    U16 nItems = 8 ;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_SPEECH_MENU_SCR, NULL, EntryEmSpeech, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_SPEECH_MENU_SCR);

    SetParentHandler(EM_AUD_SPEECH_MENUID);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    currentVolumeType = EM_VOL_TYPE_SPH;

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory52Screen(
        EM_AUD_SPEECH_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(EntryEmSetVolume, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmKeyTone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmKeyTone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[] = 
    {
        EM_AUD_VOLUME_0_TEXT,
        EM_AUD_VOLUME_1_TEXT,
        EM_AUD_VOLUME_2_TEXT,
        EM_AUD_VOLUME_3_TEXT,
        EM_AUD_VOLUME_4_TEXT,
        EM_AUD_VOLUME_5_TEXT,
        EM_AUD_VOLUME_6_TEXT,
        EM_AUD_16_LELVEL_VOLUME_TEXT,
        EM_AUD_DIRECT_APPLY_TEXT
    };
    U16 ItemIcons[32];
    U16 nItems = 8 ;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_KEY_TONE_MENU_SCR, NULL, EntryEmKeyTone, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_KEY_TONE_MENU_SCR);

    SetParentHandler(EM_AUD_KEY_TONE_MENUID);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    currentVolumeType = EM_VOL_TYPE_KEY;

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory52Screen(
        EM_AUD_KEY_TONE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(EntryEmSetVolume, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmMelody
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmMelody(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[] = 
    {
        EM_AUD_VOLUME_0_TEXT,
        EM_AUD_VOLUME_1_TEXT,
        EM_AUD_VOLUME_2_TEXT,
        EM_AUD_VOLUME_3_TEXT,
        EM_AUD_VOLUME_4_TEXT,
        EM_AUD_VOLUME_5_TEXT,
        EM_AUD_VOLUME_6_TEXT,
        EM_AUD_16_LELVEL_VOLUME_TEXT,
        EM_AUD_DIRECT_APPLY_TEXT
    };
    U16 ItemIcons[32];
    U16 nItems = 8 ;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_MELODY_MENU_SCR, NULL, EntryEmMelody, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_MELODY_MENU_SCR);

    SetParentHandler(EM_AUD_MELODY_MENUID);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    currentVolumeType = EM_VOL_TYPE_MEDIA;

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory52Screen(
        EM_AUD_MELODY_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(EntryEmSetVolume, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSideTone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSideTone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_SIDE_TONE_MENU_SCR, NULL, NULL, NULL);

    currentVolumeType = EM_VOL_TYPE_SID;
    currentVolume = EmGetCurrentVolume();
    ShowCategory204Screen(EM_SET_LSK_TEXT, 0, STR_GLOBAL_BACK, 0, EM_AUD_SET_VOLUME_TEXT, currentVolume, 0, 0);
    SetLeftSoftkeyFunction(EmSetVolume, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeUp, KEY_UP_ARROW, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeDown, KEY_DOWN_ARROW, KEY_EVENT_UP);

#ifdef __MMI_FOURWAYS_KEY_DISABLE__
    SetKeyHandler(EmAudioVolumeUp, KEY_VOL_UP, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeDown, KEY_VOL_DOWN, KEY_EVENT_UP);
#endif /* __MMI_FOURWAYS_KEY_DISABLE__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmCallTone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmCallTone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_CALL_TONE_MENU_SCR, NULL, NULL, NULL);

    currentVolumeType = EM_VOL_TYPE_CTN;
    currentVolume = INIT_VOLUME;
    ShowCategory204Screen(EM_SET_LSK_TEXT, 0, STR_GLOBAL_BACK, 0, EM_AUD_SET_VOLUME_TEXT, currentVolume, 0, 0);
    SetLeftSoftkeyFunction(EmSetVolume, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeUp, KEY_UP_ARROW, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeDown, KEY_DOWN_ARROW, KEY_EVENT_UP);

#ifdef __MMI_FOURWAYS_KEY_DISABLE__
    SetKeyHandler(EmAudioVolumeUp, KEY_VOL_UP, KEY_EVENT_UP);
    SetKeyHandler(EmAudioVolumeDown, KEY_VOL_DOWN, KEY_EVENT_UP);
#endif /* __MMI_FOURWAYS_KEY_DISABLE__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSound
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSound(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[] = 
    {
        EM_AUD_VOLUME_0_TEXT,
        EM_AUD_VOLUME_1_TEXT,
        EM_AUD_VOLUME_2_TEXT,
        EM_AUD_VOLUME_3_TEXT,
        EM_AUD_VOLUME_4_TEXT,
        EM_AUD_VOLUME_5_TEXT,
        EM_AUD_VOLUME_6_TEXT,
        EM_AUD_16_LELVEL_VOLUME_TEXT,
        EM_AUD_DIRECT_APPLY_TEXT
    };
    U16 ItemIcons[32];
    U16 nItems = 8 ;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_SOUND_MENU_SCR, NULL, EntryEmSound, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_SOUND_MENU_SCR);

    SetParentHandler(EM_AUD_SOUND_MENUID);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    currentVolumeType = EM_VOL_TYPE_SND;

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory52Screen(
        EM_AUD_SOUND_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(EntryEmSetVolume, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmMicrophone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmMicrophone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[] = 
    {
        EM_AUD_VOLUME_0_TEXT,
        EM_AUD_VOLUME_1_TEXT,
        EM_AUD_VOLUME_2_TEXT,
        EM_AUD_VOLUME_3_TEXT,
        EM_AUD_VOLUME_4_TEXT,
        EM_AUD_VOLUME_5_TEXT,
        EM_AUD_VOLUME_6_TEXT,
        EM_AUD_16_LELVEL_VOLUME_TEXT,
        EM_AUD_DIRECT_APPLY_TEXT
    };
    U16 ItemIcons[32];
    U16 nItems = 8 ;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_MICROPHONE_MENU_SCR, NULL, EntryEmMicrophone, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_MICROPHONE_MENU_SCR);

    SetParentHandler(EM_AUD_MICROPHONE_MENUID);
    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);
    }

    currentVolumeType = EM_VOL_TYPE_MIC;
    RegisterHighlightHandler(SetHighlightIndex);
    ShowCategory52Screen(
        EM_AUD_MICROPHONE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(EntryEmSetVolume, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmAudSetParamEdit
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAudSetParamEdit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *history_buffer;
    U16 text_id = 0;
    S32 level = 0;
    S8 ScrBuf[16];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_PARAM_EDITOR_SCR, NULL, EntryEmAudSetParamEdit, NULL);
    history_buffer = GetCurrGuiBuffer(EM_AUD_PARAM_EDITOR_SCR);

    memset(InputBuf, 0, sizeof(InputBuf));
    text_id = (U16) (EM_AUD_PARAMETER_0_TEXT + mmi_em_sph_enh_para_index);
    switch (mmi_em_para_type)
    {
        case EM_AUD_SPH_ENH_COMMON:
            level = (S32) AudioParameter.speech_common_para[mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_SPH_ENH_NORMAL_MODE:
            level = (S32) AudioParameter.speech_mode_para[0][mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_SPH_ENH_HEADSET_MODE:
            level = (S32) AudioParameter.speech_mode_para[1][mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_SPH_ENH_LOUDSPK_MODE:
            level = (S32) AudioParameter.speech_mode_para[2][mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_SPH_ENH_BT_EARPHONE_MODE:
            level = (S32) AudioParameter.speech_mode_para[3][mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_SPH_ENH_BT_CORDLESS_MODE:
            level = (S32) AudioParameter.speech_mode_para[4][mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_SPH_ENH_AUX1_MODE:
            level = (S32) AudioParameter.speech_mode_para[5][mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_SPH_ENH_AUX2_MODE:
            level = (S32) AudioParameter.speech_mode_para[6][mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_SPH_ENH_AUX3_MODE:
            level = (S32) AudioParameter.speech_mode_para[7][mmi_em_sph_enh_para_index];
            break;
        case EM_AUD_MAX_SWING:
            text_id = EM_AUD_SET_MAX_SWING_TEXT;
            level = (S32) AudioParameter.max_swing;
            break;
        case EM_AUD_DEBUG_INFO:
            level = (S32) AudioParameter.debug_info[mmi_em_sph_enh_para_index];
            break;
        default:
            ASSERT(0);
    }

    sprintf(ScrBuf, "%d", level);
    mmi_asc_to_ucs2((PS8) InputBuf, ScrBuf);
    ShowCategory5Screen(
        text_id,
        (U16) NULL,
        STR_GLOBAL_OK,
        (U16) NULL,
        STR_GLOBAL_BACK,
        (U16) NULL,
        INPUT_TYPE_NUMERIC,
        (U8*) InputBuf,
        8,
        history_buffer);

    SetLeftSoftkeyFunction(EmAudSetParam, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_END, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmAudSetMaxSwing
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAudSetMaxSwing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_MAX_SWING;
    EntryEmAudSetParamEdit();
}


/*****************************************************************************
 * FUNCTION
 *  EmAudSetParam
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmAudSetParam(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 U8StrBuf[8];
    U16 value;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2_to_asc((S8*) U8StrBuf, (S8*) InputBuf);
    value = (U16) atoi((S8*) U8StrBuf);

    switch (mmi_em_para_type)
    {
        case EM_AUD_SPH_ENH_COMMON:
            AudioParameter.speech_common_para[mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_SPH_ENH_NORMAL_MODE:
            AudioParameter.speech_mode_para[0][mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_SPH_ENH_HEADSET_MODE:
            AudioParameter.speech_mode_para[1][mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_SPH_ENH_LOUDSPK_MODE:
            AudioParameter.speech_mode_para[2][mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_SPH_ENH_BT_EARPHONE_MODE:
            AudioParameter.speech_mode_para[3][mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_SPH_ENH_BT_CORDLESS_MODE:
            AudioParameter.speech_mode_para[4][mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_SPH_ENH_AUX1_MODE:
            AudioParameter.speech_mode_para[5][mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_SPH_ENH_AUX2_MODE:
            AudioParameter.speech_mode_para[6][mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_SPH_ENH_AUX3_MODE:
            AudioParameter.speech_mode_para[7][mmi_em_sph_enh_para_index] = value;
            break;
        case EM_AUD_MAX_SWING:
            AudioParameter.max_swing = value;
            break;
        case EM_AUD_DEBUG_INFO:
            AudioParameter.debug_info[mmi_em_sph_enh_para_index] = value;
            break;
        default:
            ASSERT(0);
    }

    EngineerModeSetAudioParamReq(&AudioParameter);
}


/*****************************************************************************
 * FUNCTION
 *  SendGetAudioParamReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendGetAudioParamReq()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EngineerModeGetAudioParamReq();
}


/*****************************************************************************
 * FUNCTION
 *  EmUpdateAudioParam
 * DESCRIPTION
 *  
 * PARAMETERS
 *  audp        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EmUpdateAudioParam(U8 *audp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    audio_param_struct *p = (audio_param_struct*) audp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    AudioParameter.selected_FIR_output_index = p->selected_FIR_output_index;
    memcpy(AudioParameter.speech_common_para, p->speech_common_para, sizeof(p->speech_common_para));
    memcpy(AudioParameter.speech_mode_para, p->speech_mode_para, sizeof(p->speech_mode_para));
    AudioParameter.max_swing = p->max_swing;
/* marked and wait for W06.25 check-in */
//    memcpy(AudioParameter.debug_info, p->debug_info, sizeof(p->debug_info));
    EntryEmAudioMenu();

}


/*****************************************************************************
 * FUNCTION
 *  SendGetAudioProfileReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendGetAudioProfileReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EngineerModeGetAudioProfileReq((U8) currentVolumeMode);
}


/*****************************************************************************
 * FUNCTION
 *  EmUpdateAudioProfile
 * DESCRIPTION
 *  
 * PARAMETERS
 *  speech          [?]         
 *  keytone         [?]         
 *  melody          [?]         
 *  sound           [?]         
 *  mic             [?]         
 *  sidetone        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EmUpdateAudioProfile(U8 *speech, U8 *keytone, U8 *melody, U8 *sound, U8 *mic, U8 sidetone, U8 *tvout, U8 max_gain, U8 step)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gAudioProfile.mode = currentVolumeMode;

    memcpy(gAudioProfile.speech, speech, MAX_EM_VOLUME_LEVEL);
    memcpy(gAudioProfile.keytone, keytone, MAX_EM_VOLUME_LEVEL);
    memcpy(gAudioProfile.melody, melody, MAX_EM_VOLUME_LEVEL);
    memcpy(gAudioProfile.sound, sound, MAX_EM_VOLUME_LEVEL);
    memcpy(gAudioProfile.mic, mic, MAX_EM_VOLUME_LEVEL);
    gAudioProfile.sidetone = sidetone;

    memcpy(gAudioProfile.tvout, tvout, MAX_EM_VOLUME_LEVEL);
    gAudioProfile.vol_16_level_max_gain = max_gain;
    gAudioProfile.vol_16_level_step = step;

    memcpy(&gAudioProfileOrg, &gAudioProfile, sizeof(gAudioProfile));

    switch (currentVolumeMode)
    {
        case EM_NORMAL_MODE:
            EntryEmNormalModeMenu();
            break;
        case EM_HEADSET_MODE:
            EntryEmHeadsetModeMenu();
            break;
        case EM_LOUDSP_MODE:
            EntryEmLoudSpModeMenu();
            break;
#if defined(TV_OUT_SUPPORT)            
        case EM_TV_OUT_MODE:
            EntryEmAudTVOUT();
            break;
#endif            
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_entry_main
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_entry_main(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 item_texts[32];
    U16 item_icons[32];
    U16 item_num;
    U8 *gui_buffer;
    U8 *item_hints[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_SPH_ENH_MAIN_SCR, NULL, mmi_em_sph_enh_entry_main, NULL);
    gui_buffer = GetCurrGuiBuffer(EM_AUD_SPH_ENH_MAIN_SCR);

    item_num = GetNumOfChild(EM_AUD_SPEECH_ENHANCEMENT_MENUID);
    GetSequenceStringIds(EM_AUD_SPEECH_ENHANCEMENT_MENUID, item_texts);
    SetParentHandler(EM_AUD_SPEECH_ENHANCEMENT_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < item_num; i++)
    {
        item_hints[i] = NULL;
        item_icons[i] = (U16) (IMG_GLOBAL_L1 + i);
    }

    ShowCategory52Screen(
        EM_AUD_SPEECH_ENHANCEMENT_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        item_num,
        item_texts,
        item_icons,
        (U8 **) item_hints,
        0,
        0,
        gui_buffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_entry_para_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_entry_para_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 item_texts[32];
    U16 item_icons[32];
    U16 item_num;
    U16 title_id = 0, menu_id = 0;
    U8 *gui_buffer;
    U8 *item_hints[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_SPH_ENH_PARA_LIST_SCR, NULL, mmi_em_sph_enh_entry_para_list, NULL);
    gui_buffer = GetCurrGuiBuffer(EM_AUD_SPH_ENH_PARA_LIST_SCR);

    item_num = 8;
    switch (mmi_em_para_type)
    {
        case EM_AUD_SPH_ENH_COMMON:
            title_id = EM_AUD_COMMON_PARAMETERS_TEXT;
            menu_id = EM_AUD_SPH_ENH_COMMON_PARA_MENUID;
            item_num = 12;
            break;
        case EM_AUD_SPH_ENH_NORMAL_MODE:
            title_id = EM_AUD_NORMAL_MODE_TEXT;
            menu_id = EM_AUD_SPH_ENH_NORMAL_MODE_MENUID;
            break;
        case EM_AUD_SPH_ENH_HEADSET_MODE:
            title_id = EM_AUD_HEADSET_MODE_TEXT;
            menu_id = EM_AUD_SPH_ENH_HEADSET_MODE_MENUID;
            break;
        case EM_AUD_SPH_ENH_LOUDSPK_MODE:
            title_id = EM_AUD_LOUDSP_MODE_TEXT;
            menu_id = EM_AUD_SPH_ENH_LOUDSPK_MODE_MENUID;
            break;
        case EM_AUD_SPH_ENH_BT_EARPHONE_MODE:
            title_id = EM_AUD_BT_EARPHONE_MODE_TEXT;
            menu_id = EM_AUD_SPH_ENH_BT_EARPHONE_MODE_MENUID;
            break;
        case EM_AUD_SPH_ENH_BT_CORDLESS_MODE:
            title_id = EM_AUD_BT_CORDLESS_MODE_TEXT;
            menu_id = EM_AUD_SPH_ENH_BT_CORDLESS_MODE_MENUID;
            break;
        case EM_AUD_SPH_ENH_AUX1_MODE:
            title_id = EM_AUD_AUX1_MODE_TEXT;
            menu_id = EM_AUD_SPH_ENH_AUX1_MODE_MENUID;
            break;
        case EM_AUD_SPH_ENH_AUX2_MODE:
            title_id = EM_AUD_AUX2_MODE_TEXT;
            menu_id = EM_AUD_SPH_ENH_AUX2_MODE_MENUID;
            break;
        case EM_AUD_SPH_ENH_AUX3_MODE:
            title_id = EM_AUD_AUX3_MODE_TEXT;
            menu_id = EM_AUD_SPH_ENH_AUX3_MODE_MENUID;
            break;
        case EM_AUD_DEBUG_INFO:
            title_id = EM_AUD_DEBUG_INFO_TEXT;
            menu_id = EM_AUD_DEBUG_INFO_MENUID;        
            break;
        default:
            ASSERT(0);
    }

    SetParentHandler(menu_id);
    RegisterHighlightHandler(mmi_em_sph_enh_para_list_highlight_hdlr);

    for (i = 0; i < item_num; i++)
    {
        item_hints[i] = NULL;
        item_icons[i] = (U16) (IMG_GLOBAL_L1 + i);
        item_texts[i] = (U16) (EM_AUD_PARAMETER_0_TEXT + i);
    }

    ShowCategory52Screen(
        title_id,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        item_num,
        item_texts,
        item_icons,
        (U8 **) item_hints,
        0,
        0,
        gui_buffer);

    SetLeftSoftkeyFunction(EntryEmAudSetParamEdit, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_main_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_main_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_main, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_common_para_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_common_para_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_COMMON;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_normal_mode_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_normal_mode_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_NORMAL_MODE;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_headset_mode_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_headset_mode_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_HEADSET_MODE;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_loudspk_mode_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_loudspk_mode_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_LOUDSPK_MODE;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_bt_earphone_mode_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_bt_earphone_mode_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_BT_EARPHONE_MODE;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_bt_cordless_mode_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_bt_cordless_mode_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_BT_CORDLESS_MODE;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_aux1_mode_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_aux1_mode_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_AUX1_MODE;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_aux2_mode_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_aux2_mode_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_AUX2_MODE;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_aux3_mode_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_aux3_mode_highlight_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_SPH_ENH_AUX3_MODE;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_sph_enh_para_list_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_sph_enh_para_list_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_sph_enh_para_index = index;
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmAudio
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAudio(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(SendGetAudioParamReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmRingTone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmRingTone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRingToneMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmNormalMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmNormalMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentVolumeMode = EM_NORMAL_MODE;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(SendGetAudioProfileReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmLoudSpMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmLoudSpMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentVolumeMode = EM_LOUDSP_MODE;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(SendGetAudioProfileReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmHeadsetMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmHeadsetMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentVolumeMode = EM_HEADSET_MODE;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(SendGetAudioProfileReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSetVolume
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSetVolume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSetVolume, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSpeech
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSpeech(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSpeech, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSideTone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSideTone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSideTone, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmKeyTone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmKeyTone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmKeyTone, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmCallTone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmCallTone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmCallTone, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmMelody
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmMelody(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmMelody, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSound
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSound(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSound, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmMicrophone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmMicrophone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmMicrophone, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmAudSetMaxSwing
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAudSetMaxSwing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmAudSetMaxSwing, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


#if defined(TV_OUT_SUPPORT)
/*****************************************************************************
 * FUNCTION
 *  HighlightEmAudTVOUT
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAudTVOUT(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentVolumeMode = EM_TV_OUT_MODE;
    
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(SendGetAudioProfileReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}
#endif /* defined(TV_OUT_SUPPORT) */


/*****************************************************************************
 * FUNCTION
 *  HighlightEmAudVMDebugInfo
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAudVMDebugInfo(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_em_para_type = EM_AUD_DEBUG_INFO;
    SetLeftSoftkeyFunction(mmi_em_sph_enh_entry_para_list, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmAudVM1
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAudAutoVMSetting(void)
{
    SetLeftSoftkeyFunction(EntryAudioAutoVMSetting, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryAudioAutoVMSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryAudioAutoVMSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[] = 
    {
        EM_AUD_VM_SUPPORT_TEXT,
        EM_AUD_AUTO_VM_TEXT
    };
    U16 ItemIcons[3];
    U16 nItems = 2;
    U8 *guiBuffer;
    U8 *PopUpList[3];
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_AUTO_VM_SETTING_SCR, NULL, EntryAudioAutoVMSetting, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_AUTO_VM_SETTING_SCR);

    SetParentHandler(EM_AUD_AUTO_VM_SETTING_MENUID);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   
    }

    RegisterHighlightHandler(EmAudAutoVMSettingHighlightIndex);

    ShowCategory52Screen(
        EM_AUD_AUTO_VM_SETTING_TEXT,
        0,
        0,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(EmAudAutoVMSetting, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
}

/*****************************************************************************
 * FUNCTION
 *  EmAudAutoVMSettingHighlightIndex
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmAudAutoVMSettingHighlightIndex(S32 nIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 ret_value;
    S16 error;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentHighlightIndex = nIndex;
    
    if (currentHighlightIndex == EM_AUD_AUTO_VM_CONFIG_VMSUPPORT)
    {
        ReadValue(NVRAM_AUTO_VM_SETTING_VM_SUPPORT, &ret_value, DS_BYTE, &error);
    }
    else if (currentHighlightIndex == EM_AUD_AUTO_VM_CONFIG_AUTOVM)
    {
        ReadValue(NVRAM_AUTO_VM_SETTING_AUTO_VM, &ret_value, DS_BYTE, &error);
    }
    else
        ASSERT(0);
    
    if (ret_value)
    {
        Category52ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_ON));
        change_left_softkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        Category52ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_OFF));
        change_left_softkey(STR_GLOBAL_ON, 0);
    }

    RedrawCategoryFunction();
}


/*****************************************************************************
 * FUNCTION
 *  EmAudAutoVMSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmAudAutoVMSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 ret_value=0;
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (currentHighlightIndex == EM_AUD_AUTO_VM_CONFIG_VMSUPPORT)
    {
        ReadValue(NVRAM_AUTO_VM_SETTING_VM_SUPPORT, &ret_value, DS_BYTE, &error);
        if (ret_value)
        {
            ret_value = 0;
            WriteValue(NVRAM_AUTO_VM_SETTING_VM_SUPPORT, &ret_value, DS_BYTE, &error);
        #ifdef __MMI_SOUND_RECORDER__
            mmi_sndrec_auto_record_change_setting(0, -1);
        #endif
        }
        else
        {
            ret_value = 1;
            WriteValue(NVRAM_AUTO_VM_SETTING_VM_SUPPORT, &ret_value, DS_BYTE, &error);
        #ifdef __MMI_SOUND_RECORDER__
            mmi_sndrec_auto_record_change_setting(1, -1);
        #endif
        }
    }
    else if (currentHighlightIndex == EM_AUD_AUTO_VM_CONFIG_AUTOVM)
    {
        ReadValue(NVRAM_AUTO_VM_SETTING_AUTO_VM, &ret_value, DS_BYTE, &error);

        if (ret_value)
        {
            ret_value = 0;
            WriteValue(NVRAM_AUTO_VM_SETTING_AUTO_VM, &ret_value, DS_BYTE, &error);
        #ifdef __MMI_SOUND_RECORDER__
            mmi_sndrec_auto_record_change_setting(-1, 0);
        #endif
        }
        else
        {
            ret_value = 1;
            WriteValue(NVRAM_AUTO_VM_SETTING_AUTO_VM, &ret_value, DS_BYTE, &error);
        #ifdef __MMI_SOUND_RECORDER__
            mmi_sndrec_auto_record_change_setting(-1, 1);
        #endif
        }
    }
    else
        ASSERT(0);
    
    if (ret_value)
    {
        Category52ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_ON));
        change_left_softkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        Category52ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_OFF));
        change_left_softkey(STR_GLOBAL_ON, 0);
    }

    RedrawCategoryFunction();

}


#if defined(TV_OUT_SUPPORT)
/*****************************************************************************
 * FUNCTION
 *  EntryEmAudTVOUT
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAudTVOUT(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[] = 
    {
        EM_AUD_VOLUME_0_TEXT,
        EM_AUD_VOLUME_1_TEXT,
        EM_AUD_VOLUME_2_TEXT,
        EM_AUD_VOLUME_3_TEXT,
        EM_AUD_VOLUME_4_TEXT,
        EM_AUD_VOLUME_5_TEXT,
        EM_AUD_VOLUME_6_TEXT,
        EM_AUD_16_LELVEL_VOLUME_TEXT,
        EM_AUD_DIRECT_APPLY_TEXT
    };
    U16 ItemIcons[32];
    U16 nItems = 8 /*7*/;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUD_TV_OUT_SCR, NULL, EntryEmAudTVOUT, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUD_TV_OUT_SCR);

    SetParentHandler(EM_AUD_TV_OUT_MENUID);

    currentVolumeType = EM_VOL_TYPE_TVOUT;
    
    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory52Screen(
        EM_AUD_TV_OUT_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(EntryEmSetVolume, KEY_EVENT_UP);

    SetRightSoftkeyFunction(CheckAudioProfile, KEY_EVENT_UP);
    
}
#endif /* defined(TV_OUT_SUPPORT) */


/*****************************************************************************
 * FUNCTION
 *  EmSet16LevelVolume
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSet16LevelVolume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 textbuf[20];
    U16 int_gain;
    U16 int_step;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_aud_16_level_cntx.MaxAnalogGain);
    int_gain = atoi((const char *) textbuf);
    
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_aud_16_level_cntx.Step);
    int_step = atoi((const char *) textbuf);

    if (int_gain > 255)
        int_gain = 255;

    if (int_step > 255)
        int_step = 255;
        
    gAudioProfile.vol_16_level_max_gain = (U8)int_gain;
    gAudioProfile.vol_16_level_step = (U8)int_step;

    GoBackHistory();

}


/*****************************************************************************
 * FUNCTION
 *  EmGetCurrent16LevelInfo
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
void EmGetCurrent16LevelInfo(U8 *gain, U8 *step)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *gain = gAudioProfile.vol_16_level_max_gain;
    *step = gAudioProfile.vol_16_level_step;
}


/* ========  Device ======== */


/*****************************************************************************
 * FUNCTION
 *  EntryEmDeviceMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmDeviceMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_DEVICE_MENU_SCR, NULL, EntryEmDeviceMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_DEVICE_MENU_SCR);

    nItems = GetNumOfChild(EM_DEVICE_MENUID);
    GetSequenceStringIds(EM_DEVICE_MENUID, ItemList);
    SetParentHandler(EM_DEVICE_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    ShowCategory52Screen(
        EM_DEVICE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EmIsPortAllow
 * DESCRIPTION
 *  
 * PARAMETERS
 *  port_num        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
BOOL EmIsPortAllow(U8 port_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef BT_UART_PORT
    if (BT_UART_PORT == port_num)
    {
        return MMI_FALSE;
    }
#endif /* BT_UART_PORT */ 

#ifndef L4_NOT_PRESENT
    if ((PS_UART_PORT == TST_PORT) && (PS_UART_PORT!=uart_port_null))
    {
        return MMI_FALSE;
    }
#endif /* L4_NOT_PRESENT */ 

#if defined(__MMI_IRDA_SUPPORT__)
    {
    #ifndef L4_NOT_PRESENT
        if (PS_UART_PORT == uart_port_irda)
        {
            return MMI_FALSE;
        }
    #endif /* L4_NOT_PRESENT */ 
    }
#endif /* defined(__MMI_IRDA_SUPPORT__) */ 

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  SendSetUartReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendSetUartReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);

    /* Check TST Port Setting & PS Port Setting */
    if (EmIsPortAllow((U8) EmUartPortTSTHighlight) == MMI_FALSE ||
        EmIsPortAllow((U8) EmUartPortPSHighlight) == MMI_FALSE  ||
        EmIsPortAllow((U8) EmUartPortTSTL1Highlight) == MMI_FALSE  
        #if defined(__MA_L1__)
/* under construction !*/
        #endif
        )
    {
        mmi_eq_set_uart_rsp_struct st_rsp;

        st_rsp.result = MMI_FALSE;
        EngineerModeSetUartRes(&st_rsp);
        return;
    }


    /* Check TST & PS & CTI conflict */
    if (   ( (EmUartPortTSTHighlight == EmUartPortPSHighlight) && (EmUartPortTSTHighlight!= EM_UART_PORT_NULL)) 
        || ( (EmUartPortTSTL1Highlight == EmUartPortPSHighlight) && (EmUartPortTSTL1Highlight != EM_UART_PORT_NULL)) 
#if defined(__MA_L1__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
        )
    {
        mmi_eq_set_uart_rsp_struct st_rsp;

        st_rsp.result = MMI_FALSE;
        EngineerModeSetUartRes(&st_rsp);
        return;
    }
    
#if defined(__MMI_ONLY_ONE_UART_AVAILABLE__)
    if (EmUartPortTSTHighlight==EM_UART_PORT_2 || EmUartPortPSHighlight==EM_UART_PORT_2
        || EmUartPortTSTL1Highlight==EM_UART_PORT_2)
    {
        mmi_eq_set_uart_rsp_struct st_rsp;

        st_rsp.result = MMI_FALSE;
        EngineerModeSetUartRes(&st_rsp);
        return;
    }
#endif /* __MMI_ONLY_ONE_UART_AVAILABLE__ */


   /**************************/
   /* TST-PS UART & Baudrate */
   /**************************/
#ifdef __MMI_USB_SUPPORT__   
    if (EmUartPortTSTHighlight == EM_USB_PORT)
    {
        EmAppPortArray[EM_APP_TST_PS] = (U8) uart_port_usb;
    }
    else
#endif    
    if (EmUartPortTSTHighlight == EM_UART_PORT_NULL)
    {
        EmAppPortArray[EM_APP_TST_PS] = (U8) uart_port_null;
    }
    else
    {
        EmAppPortArray[EM_APP_TST_PS] = (U8) EmUartPortTSTHighlight;
    }
    EmAppBaudArray[EM_APP_TST_PS] = (U8) EmUartBaudTSTHighlight;


    /**************************/
    /*** PS UART & Baudrate ***/
    /**************************/
#ifdef __MMI_USB_SUPPORT__    
    if (EmUartPortPSHighlight == EM_USB_PORT)
    {
        EmAppPortArray[EM_APP_PS] = (U8) uart_port_usb;
    }
    else
#endif    
    if (EmUartPortPSHighlight == EM_UART_PORT_NULL)
    {
        EmAppPortArray[EM_APP_PS] = (U8) uart_port_null;
    }
    else
    {
        EmAppPortArray[EM_APP_PS] = (U8) EmUartPortPSHighlight;
    }
    EmAppBaudArray[EM_APP_PS] = (U8) EmUartBaudPSHighlight;


   /**************************/
   /* TST-L1 UART & Baudrate */
   /**************************/
#ifdef __MMI_USB_SUPPORT__   
    if (EmUartPortTSTL1Highlight == EM_USB_PORT)
    {
        EmAppPortArray[EM_APP_TST_L1] = (U8) uart_port_usb;
    }
    else
#endif    
    if (EmUartPortTSTL1Highlight == EM_UART_PORT_NULL)
    {
        EmAppPortArray[EM_APP_TST_L1] = (U8) uart_port_null;
    }
    else
    {
        EmAppPortArray[EM_APP_TST_L1] = (U8) EmUartPortTSTL1Highlight;
    }
    EmAppBaudArray[EM_APP_TST_L1] = (U8) EmUartBaudTSTL1Highlight;


   /**************************/
   /*** CTI UART & Baudrate **/
   /**************************/
#ifdef __MMI_USB_SUPPORT__   
    if (EmUartPortCTIHighlight == EM_USB_PORT)
    {
        EmAppPortArray[EM_APP_CTI] = (U8) uart_port_usb;
    }
    else
#endif    
    if (EmUartPortCTIHighlight == EM_UART_PORT_NULL)
    {
        EmAppPortArray[EM_APP_CTI] = (U8) uart_port_null;
    }
    else
    {
        EmAppPortArray[EM_APP_CTI] = (U8) EmUartPortCTIHighlight;
    }
    EmAppBaudArray[EM_APP_CTI] = (U8) EmUartBaudCTIHighlight;


     UART_setting = TRUE;
    EngineerModeSetUartReq();

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSetUartMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSetUartMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[5];
    U16 ItemIcons[5];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[5];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_DEV_SET_UART_MENU_SCR, NULL, EntryEmSetUartMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_DEV_SET_UART_MENU_SCR);

    nItems = GetNumOfChild(EM_DEV_SET_UART_MENUID);
    GetSequenceStringIds(EM_DEV_SET_UART_MENUID, ItemList);
    SetParentHandler(EM_DEV_SET_UART_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);  
    }

    ShowCategory52Screen(
        EM_DEV_SET_UART_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmUartSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmUartSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_em_set_uart_req_type = EM_SET_UART_UART_SETTING;
            
    /* Register function for left soft key */    
    SetLeftSoftkeyFunction(EngineerModeGetUartReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmUartPowerOnOff
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmUartPowerOnOff(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_em_set_uart_req_type = EM_SET_UART_POWER_SETTING;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EngineerModeGetUartReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EmSetUartFillInlineStruct
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSetUartFillInlineStruct()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /********************/
    /*** TST-PS Config **/
    /********************/
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_DEV_SET_UART_TST_PS_TEXT));

    EmUartPortText[EM_UART_PORT_1] = (PU8) GetString(EM_DEV_UART_1_TEXT);
    EmUartPortText[EM_UART_PORT_2] = (PU8) GetString(EM_DEV_UART_2_TEXT);
#ifdef __UART3_SUPPORT__
    EmUartPortText[EM_UATR_PORT_3] = (PU8) GetString(EM_DEV_UART_3_TEXT);
#endif     
#ifdef __MMI_USB_SUPPORT__
    EmUartPortText[EM_USB_PORT] = (PU8) GetString(EM_DEV_USB_PORT_TEXT);
#endif
    EmUartPortText[EM_UART_PORT_NULL] = (PU8) GetString(STR_GLOBAL_NONE);

    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], EM_UART_MAX_PORT_NUM, EmUartPortText, (PS32) & EmUartPortTSTHighlight);

    EmUartBaudText[0] = (PU8) GetString(EM_DEV_BAUD_AUTO_TEXT);
    EmUartBaudText[1] = (PU8) GetString(EM_DEV_BAUD_75_TEXT);
    EmUartBaudText[2] = (PU8) GetString(EM_DEV_BAUD_150_TEXT);
    EmUartBaudText[3] = (PU8) GetString(EM_DEV_BAUD_300_TEXT);
    EmUartBaudText[4] = (PU8) GetString(EM_DEV_BAUD_600_TEXT);
    EmUartBaudText[5] = (PU8) GetString(EM_DEV_BAUD_1200_TEXT);
    EmUartBaudText[6] = (PU8) GetString(EM_DEV_BAUD_2400_TEXT);
    EmUartBaudText[7] = (PU8) GetString(EM_DEV_BAUD_4800_TEXT);
    EmUartBaudText[8] = (PU8) GetString(EM_DEV_BAUD_7200_TEXT);
    EmUartBaudText[9] = (PU8) GetString(EM_DEV_BAUD_9600_TEXT);
    EmUartBaudText[10] = (PU8) GetString(EM_DEV_BAUD_14400_TEXT);
    EmUartBaudText[11] = (PU8) GetString(EM_DEV_BAUD_19200_TEXT);
    EmUartBaudText[12] = (PU8) GetString(EM_DEV_BAUD_28800_TEXT);
    EmUartBaudText[13] = (PU8) GetString(EM_DEV_BAUD_33900_TEXT);
    EmUartBaudText[14] = (PU8) GetString(EM_DEV_BAUD_38400_TEXT);
    EmUartBaudText[15] = (PU8) GetString(EM_DEV_BAUD_57600_TEXT);
    EmUartBaudText[16] = (PU8) GetString(EM_DEV_BAUD_115200_TEXT);
    EmUartBaudText[17] = (PU8) GetString(EM_DEV_BAUD_230400_TEXT);
    EmUartBaudText[18] = (PU8) GetString(EM_DEV_BAUD_460800_TEXT);

#if !defined(DCM_ENABLE) || defined(MT6227D) || defined(MT6223) || defined(MT6223P)
    EmUartBaudText[19] = (PU8) GetString(EM_DEV_BAUD_921600_TEXT);
#endif 
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[2], EM_BAUD_NUM, EmUartBaudText, (PS32) & EmUartBaudTSTHighlight);


    /********************/
    /**** PS Config *****/
    /********************/
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[3], (U8*)GetString(EM_DEV_SET_UART_PS_TEXT));

    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[4], EM_UART_MAX_PORT_NUM, EmUartPortText, (PS32) & EmUartPortPSHighlight);

    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[5], EM_BAUD_NUM, EmUartBaudText, (PS32) & EmUartBaudPSHighlight);


    /********************/
    /** TST-L1 Config ***/
    /********************/
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_DEV_SET_UART_TST_L1_TEXT));

    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[7], EM_UART_MAX_PORT_NUM, EmUartPortText, (PS32) & EmUartPortTSTL1Highlight);

    SetInlineItemActivation(&wgui_inline_items[8], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[8], EM_BAUD_NUM, EmUartBaudText, (PS32) & EmUartBaudTSTL1Highlight);


#if defined(__MA_L1__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* #if defined(__MA_L1__) */

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmUartSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmUartSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *inputBuffer;    /* added for inline edit history */
    U8 *guiBuffer;      /* Buffer holding history data */
    U16 inputBufferSize;
    U16 ImageList[20];  
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_DEV_INLINE_CONFIG_UART_MENU_SCR, ExitEmUartSetting, NULL, NULL);

    InitializeCategory57Screen();

    EmSetUartFillInlineStruct();

    for (i=0; i<EM_INLINE_STRUCT_MAX_NUM; i+=3)
    {
        ImageList[i] = IMG_STATUS;   /* Config String */
        ImageList[i+1] = 0;          /* Port Selection */
        ImageList[i+2] = 0;          /* Baud Rate Selection */
    }
    
    SetParentHandler(0);
    guiBuffer = GetCurrGuiBuffer(EM_DEV_INLINE_CONFIG_UART_MENU_SCR);
    inputBuffer = GetCurrNInputBuffer(EM_DEV_INLINE_CONFIG_UART_MENU_SCR, &inputBufferSize);    /* added for inline edit history */

    RegisterHighlightHandler(HighlightHdlrUartSettingsInline);

    DisableCategory57ScreenDone(); 

    ShowCategory57Screen(
        EM_DEV_UART_SETTING_TEXT,
        EM_DEV_SET_UART_ICON,
        STR_GLOBAL_OK,
        ENGINEER_MODE_LSK_ICON,
        STR_GLOBAL_BACK,
        ENGINEER_MODE_RSK_ICON,
        EM_INLINE_STRUCT_MAX_NUM,
        ImageList,
        wgui_inline_items, //EmInlineEditorStruct,
        0,
        guiBuffer);

    SetCategory57RightSoftkeyFunctions(GoBackHistory, GoBackHistory);

}


/**************************************************************

	FUNCTION NAME		: HighlightHdlrUartSettingsInline()

  	PURPOSE				: Uart Settings inline highlight handler

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void HighlightHdlrUartSettingsInline(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(SendSetUartReq, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmUartSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmUartSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;
    U16 inputBufferSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    h.scrnID = EM_DEV_INLINE_CONFIG_UART_MENU_SCR;
    h.entryFuncPtr = EntryEmUartSetting;
    GetCategoryHistory(h.guiBuffer);
    inputBufferSize = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) h.inputBuffer);
    AddNHistory(h, inputBufferSize);
}


/*****************************************************************************
 * FUNCTION
 *  SendSetSleepModeReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendSetSleepModeReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EngineerModeSetSleepModeReq(currentHighlightIndex);
}


/*****************************************************************************
 * FUNCTION
 *  SendGetSleepModeReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendGetSleepModeReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryEmSetSleepMode(0);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSetSleepMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSetSleepMode(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U16 nStrItemList[] = {EM_DEV_SLEEPMODE_ON_TEXT,
        EM_DEV_SLEEPMODE_OFF_TEXT
    };
    U8 nNumofItem = 2;
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentHighlightIndex = index;

    EntryNewScreen(EM_DEV_SLEEPMODE_MENU_SCR, ExitEmSetSleepMode, NULL, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_DEV_SLEEPMODE_MENU_SCR);

    RegisterHighlightHandler(SetHighlightIndex);
    ShowCategory11Screen(
        EM_DEV_SLEEPMODE_TEXT,
        EM_DEV_SLEEPMODE_ICON,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nNumofItem,
        nStrItemList,
        currentHighlightIndex,
        guiBuffer);

    SetLeftSoftkeyFunction(SendSetSleepModeReq, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}

#if defined(DCM_ENABLE)


/*****************************************************************************
 * FUNCTION
 *  HighlightEmDCMMODE
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmDCMMODE(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 1 Register function for left soft key */
    SetLeftSoftkeyFunction(EmEntryDCMModeMenu, KEY_EVENT_UP);

    /* 2 Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EmEntryDCMModeMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmEntryDCMModeMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nStrItemList[] = {EM_DEV_DCMMODE_OFF_TEXT,
        EM_DEV_DCMMODE_ON_TEXT
    };
    U8 nNumofItem = 2;
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_DEV_DCMMODE_MENU_SCR, NULL, EmEntryDCMModeMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_DEV_DCMMODE_MENU_SCR);

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_DEV_DCMMODE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nNumofItem,
        nStrItemList,
        g_dcm_enable,
        guiBuffer);

    SetLeftSoftkeyFunction(SendSetDCMModeReq, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  SendSetDCMModeReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendSetDCMModeReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_dcm_enable = currentHighlightIndex;

    EngineerModeSetDCMModeReq(g_dcm_enable);
}
#endif /* defined(DCM_ENABLE) */ 


/*****************************************************************************
 * FUNCTION
 *  EntrySetUartPowerONOFFScr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntrySetUartPowerONOFFScr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U8 i;
    U16 ItemIcons[EM_MENU_SERIAL_PORT_EN_MAX];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_DEV_UART_POWER_ONOFF_MENU_SCR, NULL, EntrySetUartPowerONOFFScr, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_DEV_UART_POWER_ONOFF_MENU_SCR);

    RegisterHighlightHandler(SetUartPowerOnHighlightIndex);

    subMenuDataPtrs[0] = (PU8) GetString(EM_DEV_UART_1_TEXT);
    subMenuDataPtrs[1] = (PU8) GetString(EM_DEV_UART_2_TEXT);
    subMenuDataPtrs[2] = (PU8) GetString(EM_DEV_UART_3_TEXT);

    for (i = 0; i < EM_MENU_SERIAL_PORT_EN_MAX; i++)
    {
        ItemIcons[i] = IMG_GLOBAL_L1 + i;
        hintDataPtrs[i] = NULL;
    }

    ShowCategory53Screen(
        EM_DEV_UART_POWER_ONOFF_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        EM_MENU_SERIAL_PORT_EN_MAX,
        (PU8*) subMenuDataPtrs,
        (U16*) ItemIcons,
        0,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(SetUARTPowerOnOffHdlr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  SetUartPowerOnHighlightIndex
 * DESCRIPTION
 *  
 * PARAMETERS
 *  nIndex      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetUartPowerOnHighlightIndex(S32 nIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentHighlightIndex = nIndex;

    if (EM_IS_SET(UART_POWER_SETTING, currentHighlightIndex))
    {
        Category52ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_ON));
        change_left_softkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        Category52ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_OFF));
        change_left_softkey(STR_GLOBAL_ON, 0);
    }

    RedrawCategoryFunction();
}


/*****************************************************************************
 * FUNCTION
 *  SetUARTPowerOnOffHdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetUARTPowerOnOffHdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    mmi_eq_set_uart_req_struct *msg_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#if defined(__MMI_ONLY_ONE_UART_AVAILABLE__)
    if (currentHighlightIndex==EM_UART_PORT_2)
    {
        DisplayPopup((PU8) GetString(EM_DEV_SET_UART_ERROR_TEXT), IMG_GLOBAL_WARNING, 0, EM_NOTIFY_DURATION, 0);
        return;
    }
#endif /* #if defined(__MMI_ONLY_ONE_UART_AVAILABLE__) */
    
    EM_STATE_TOGGLE(UART_POWER_SETTING, currentHighlightIndex);

    msg_p = OslConstructDataPtr(sizeof(mmi_eq_set_uart_req_struct));
    msg_p->func_id = UART_NVRAM_LID_FUNC_UART_POWER;

    msg_p->ps_port = EmAppPortArray[EM_APP_PS];
    msg_p->tst_port_ps = EmAppPortArray[EM_APP_TST_PS];
    msg_p->tst_port_l1 = EmAppPortArray[EM_APP_TST_L1];
    msg_p->cti_uart_port = EmAppPortArray[EM_APP_CTI];

    msg_p->ps_baud_rate = EM_GetBaudRateByIdx(EmAppBaudArray[EM_APP_PS]);
    msg_p->tst_baud_rate_ps = EM_GetBaudRateByIdx(EmAppBaudArray[EM_APP_TST_PS]);
    msg_p->tst_baud_rate_l1 = EM_GetBaudRateByIdx(EmAppBaudArray[EM_APP_TST_L1]);
    msg_p->cti_baud_rate = EM_GetBaudRateByIdx(EmAppBaudArray[EM_APP_CTI]);

//    msg_p->ps_port = EmAppPortArray[EM_APP_PS];
//    msg_p->tst_port = EmAppPortArray[EM_APP_TST];    

//    msg_p->ps_baud_rate = PS_BAUDRATE;
//    msg_p->tst_baud_rate = TST_BAUDRATE;

    msg_p->High_Speed_SIM_Enabled = High_Speed_SIM;
    msg_p->swdbg = SWDBG_Profile;
    msg_p->uart_power_setting = UART_POWER_SETTING;


    if (EM_IS_SET(UART_POWER_SETTING, currentHighlightIndex))
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
        Category53ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
        Category53ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_OFF));
    }

    RedrawCategoryFunction();

    EngineerModeSendMsg(MSG_ID_MMI_EQ_SET_UART_REQ, msg_p, NULL);

}


/*****************************************************************************
 * FUNCTION
 *  ExitEmSetSleepMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmSetSleepMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;
    S16 nHistory = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currHistory.scrnID = EM_DEV_SLEEPMODE_MENU_SCR;
    currHistory.entryFuncPtr = SendGetSleepModeReq;
    mmi_ucs2cpy((S8*) currHistory.inputBuffer, (S8*) & nHistory);
    GetCategoryHistory(currHistory.guiBuffer);
    AddHistory(currHistory);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmDevice
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmDevice(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmDeviceMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSetUart
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSetUart(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 1 Change text for left soft key */
    change_left_softkey(STR_GLOBAL_OK, 0);

    /* 2 Redraw left soft key */
    redraw_left_softkey();

    /* 3 Register function for left soft key */
    /* SetLeftSoftkeyFunction(SendGetUartReq,KEY_EVENT_UP); */
    SetLeftSoftkeyFunction(EntryEmSetUartMenu, KEY_EVENT_UP);

    /* 4 Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSetSleepMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSetSleepMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 1 Change text for left soft key */
    change_left_softkey(STR_GLOBAL_OK, 0);

    /* 2 Redraw left soft key */
    redraw_left_softkey();

    /* 3 Register function for left soft key */
    SetLeftSoftkeyFunction(SendGetSleepModeReq, KEY_EVENT_UP);

    /* 4 Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}

/* ======== GPRS ACT ======== */


/*****************************************************************************
 * FUNCTION
 *  EntryEmGprsMenuNotSupport
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmGprsMenuNotSupport(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 StrBuf[40];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);

    memset(StrBuf, 0, sizeof(StrBuf));
    mmi_asc_to_ucs2((PS8) StrBuf, "Not Support!");
    EngineerModeNoticeText(StrBuf, IMG_GLOBAL_ERROR);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmGprsMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmGprsMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_GPRS_ACT_MENU_SCR, NULL, EntryEmGprsMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_GPRS_ACT_MENU_SCR);

    nItems = GetNumOfChild(EM_GPRS_ACT_MENUID);
    GetSequenceStringIds(EM_GPRS_ACT_MENUID, ItemList);
    SetParentHandler(EM_GPRS_ACT_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    ShowCategory52Screen(
        EM_GPRS_ACT_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmAutoAttach
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAutoAttach(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 1 Call Exit Handler */
    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);

    SendGprsAttachReq();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEm1stPDPMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEm1stPDPMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_GPRS_1ST_PDP_MENU_SCR, NULL, EntryEm1stPDPMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_GPRS_1ST_PDP_MENU_SCR);

    nItems = GetNumOfChild(EM_GPRS_1stPDP_MENUID);
    GetSequenceStringIds(EM_GPRS_1stPDP_MENUID, ItemList);
    SetParentHandler(EM_GPRS_1stPDP_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   
    }

    ShowCategory52Screen(
        EM_GPRS_1st_PDP_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEm2ndPDPMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEm2ndPDPMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_GPRS_2ND_PDP_MENU_SCR, NULL, EntryEm2ndPDPMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_GPRS_2ND_PDP_MENU_SCR);

    nItems = GetNumOfChild(EM_GPRS_2ndPDP_MENUID);
    GetSequenceStringIds(EM_GPRS_2ndPDP_MENUID, ItemList);
    SetParentHandler(EM_GPRS_2ndPDP_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   
    }

    ShowCategory52Screen(
        EM_GPRS_2nd_PDP_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmActivatePDPMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmActivatePDPMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 ItemIcons[32];
    U8 *PopUpList[32];
    S32 i;
    
    U16 ItemList[EM_GPRS_PDP_CONTEXT_MAX_NUM] = 
    {
        EM_GPRS_PDP_CONTEXT_1_TEXT,
        EM_GPRS_PDP_CONTEXT_2_TEXT,
        EM_GPRS_PDP_CONTEXT_3_TEXT,
        EM_GPRS_PDP_CONTEXT_4_TEXT,
        EM_GPRS_PDP_CONTEXT_5_TEXT,
        EM_GPRS_PDP_CONTEXT_6_TEXT,
        EM_GPRS_PDP_CONTEXT_7_TEXT,
        EM_GPRS_PDP_CONTEXT_8_TEXT,
        EM_GPRS_PDP_CONTEXT_9_TEXT,
        EM_GPRS_PDP_CONTEXT_10_TEXT,
        EM_GPRS_PDP_CONTEXT_11_TEXT,
        EM_GPRS_PDP_CONTEXT_12_TEXT,
        EM_GPRS_PDP_CONTEXT_13_TEXT,
        EM_GPRS_PDP_CONTEXT_14_TEXT,
        EM_GPRS_PDP_CONTEXT_15_TEXT
#ifdef __R99__	   
        ,EM_GPRS_PDP_CONTEXT_30_TEXT
        ,EM_GPRS_PDP_CONTEXT_31_TEXT

#if defined(__GSM_RAT__) && defined(__WCDMA_RAT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif 
        
#endif
    };

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_GPRS_ACTIVATE_PDP_MENU_SCR, NULL, NULL, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_GPRS_ACTIVATE_PDP_MENU_SCR);
    
    RegisterHighlightHandler(SetHighlightIndex);

    for (i = 0; i < EM_GPRS_PDP_CONTEXT_MAX_NUM; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   
    }

    ShowCategory52Screen(
        EM_GPRS_ACTIVATE_PDP_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        EM_GPRS_PDP_CONTEXT_MAX_NUM,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetLeftSoftkeyFunction(EMGPRSActivatePDPReq, KEY_EVENT_UP);    

}


/*****************************************************************************
 * FUNCTION
 *  EMGPRSActivatePDPReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMGPRSActivatePDPReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);

    SendGprsActivatePDPContext((U8)(currentHighlightIndex+1));
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmActivate2ndPDPMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmActivate2ndPDPMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_GPRS_ACTIVATE_2ND_PDP_MENU_SCR, NULL, EntryEmActivate2ndPDPMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_GPRS_ACTIVATE_2ND_PDP_MENU_SCR);

    nItems = GetNumOfChild(EM_GPRS_ACTIVATE_2ND_PDP_MENUID);
    GetSequenceStringIds(EM_GPRS_ACTIVATE_2ND_PDP_MENUID, ItemList);
    SetParentHandler(EM_GPRS_ACTIVATE_2ND_PDP_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   
    }

    ShowCategory52Screen(
        EM_GPRS_ACTIVATE_PDP_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSendDataMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSendDataMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_GPRS_SEND_DATA_MENU_SCR, NULL, EntryEmSendDataMenu, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_GPRS_SEND_DATA_MENU_SCR);

    nItems = GetNumOfChild(EM_GPRS_SEND_DATA_MENUID);
    GetSequenceStringIds(EM_GPRS_SEND_DATA_MENUID, ItemList);
    SetParentHandler(EM_GPRS_SEND_DATA_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    ShowCategory52Screen(
        EM_GPRS_SEND_DATA_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSendData
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSendData(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //U8 *history_buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentHighlightIndex = (U8) GetHighlightedItem();

    EntryNewScreen(EM_GPRS_SEND_DATA_EDITOR_SCR, NULL, EntryEmSendData, NULL);
    //history_buffer = GetCurrGuiBuffer(EM_GPRS_SEND_DATA_EDITOR_SCR);

    memset(InputBuf, 0, sizeof(InputBuf));
    ShowCategory16Screen(STR_GLOBAL_OK, (U16) NULL, STR_GLOBAL_BACK, (U16) NULL, (U8*) InputBuf, 8, NULL);//history_buffer);

    SetLeftSoftkeyFunction(EmSendDataScreenLSKHandler, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_END, KEY_EVENT_UP);
    /* SetKeyHandler(DialPadCall,KEY_SEND,KEY_EVENT_UP); */
    SetCategory16RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    /* SetKeyHandler(SSCStringParsing,KEY_POUND,KEY_EVENT_UP); */
}


/*****************************************************************************
 * FUNCTION
 *  EmSendDataScreenLSKHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSendDataScreenLSKHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);

    mmi_ucs2_to_asc((S8*) EmGprsSendDataSizeBuffer, (S8*) InputBuf);
    size = (kal_uint32) atoi(EmGprsSendDataSizeBuffer);
    if (currentHighlightIndex == 0)
    {
        SendGprsSendDataReq(size);
    }
    else
    {
        SendGprsSendDataReq((U32) (size - EM_TCM_PDU_HDR));
    }

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmDeactivatePDP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmDeactivatePDP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);

    SendGprsDeactivatePDPReq();
}


/*****************************************************************************
 * FUNCTION
 *  SendGprsAttachReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendGprsAttachReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EngineerModeGprsAttachReq();
}


/*****************************************************************************
 * FUNCTION
 *  SendGprsDeactivatePDPReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendGprsDeactivatePDPReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EngineerModeGprsDeactivatePDPReq();
}


/*****************************************************************************
 * FUNCTION
 *  SendGprsSendDataReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  size        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SendGprsSendDataReq(kal_uint32 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EngineerModeGprsSendDataReq(size);
}


/*****************************************************************************
 * FUNCTION
 *  SendGprsActivatePDPContext
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pdp_idx     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SendGprsActivatePDPContext(U8 pdp_idx)
{
#ifdef __MOD_TCM__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_gprs_pdp_idx = pdp_idx;
    g_gprs_set_minqos_required = KAL_FALSE;
#endif /* __MOD_TCM__ */ 

    EngineerModeGprsActivatePDPContext(pdp_idx);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmGprs
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmGprs(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(GotoEmGprsMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmAutoAttach
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAutoAttach(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmAutoAttach, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEm1stPDP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEm1stPDP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmGprsActivatePDPType = EM_GPRS_ACT_PDP_TYPE_1ST;
   
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEm1stPDPMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEm2ndPDP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEm2ndPDP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmGprsActivatePDPType = EM_GPRS_ACT_PDP_TYPE_2ND_PRIMARY;
    
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEm2ndPDPMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmActivate2ndPDP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmActivate2ndPDP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmActivate2ndPDPMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmActivate2ndPDPPrimary
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmActivate2ndPDPPrimary(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmGprsActivatePDPType = EM_GPRS_ACT_PDP_TYPE_2ND_PRIMARY;
    
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmActivatePDPMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmActivate2ndPDPSecondary
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmActivate2ndPDPSecondary(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmGprsActivatePDPType = EM_GPRS_ACT_PDP_TYPE_2ND_SECONDARY;
    
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmActivatePDPMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmActivatePDP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmActivatePDP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmGprsActivatePDPType = EM_GPRS_ACT_PDP_TYPE_1ST;
    
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmActivatePDPMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmDeactivatePDP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmDeactivatePDP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmDeactivatePDP, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSendDataMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSendDataMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSendDataMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSendData
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSendData(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSendData, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  SetHighlightIndex
 * DESCRIPTION
 *  
 * PARAMETERS
 *  nIndex      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void SetHighlightIndex(S32 nIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentHighlightIndex = (U8) nIndex;
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmMisc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmMisc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;
    S32 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_MISC_MENU_SCR, NULL, EntryEmMisc, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_MISC_MENU_SCR);

    nItems = GetNumOfChild(EM_MISC_MENUID);
    GetSequenceStringIds(EM_MISC_MENUID, ItemList);
    SetParentHandler(EM_MISC_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);
    }

    index = 0;

    /* EM_AUTO_ANSWER_MENUID */
    if (gprofiles[0].answeringMode.automatic == 1)
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_ON);
    }
    else
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_OFF);
    }
    index++; /* auto answer */

    /* EM_HIGHSPEED_SIM_MENUID */
    if (High_Speed_SIM)
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_ON);
    }
    else
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_OFF);
    }
    index++; /* high speed sim */

    /* EM_POWER_ON_DURATION_MENUID */
    index++;

    /* EM_BACKLIGHT_MENUID */
    if (backlight_mode == BACKLIGHT_NORMAL)
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_OFF);
    }
    else
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_ON);
    }
    index++;

    /* EM_SERIAL_PORT_EN_MENUID */
    index++;

    /* EM_AUTO_RESET_MENUID */
    PopUpList[index] = (U8*) AUTO_RESET_WARNING;
    index++;

    /* EM_RAM_TEST_MENUID */
    index++;

    /* EM_MEMORY_DUMP_MENUID */
    if (INT_MemoryDumpFlag == EX_FORCEMEMORYDUMP)
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_ON);
    }
    else
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_OFF);
    }
    index++;

    /* EM_MMI_DEBUG_MENUID */
#ifdef DEBUG_ASSERT
    if (g_mmi_frm_enable_debug_assert)
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_ON);
    }
    else
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_OFF);
    }
#endif /* DEBUG_ASSERT */ 
    index++;

    /* EM_AMR_MENUID */
#if defined(__AMR_SUPPORT__)
    {
        S16 ret, error_code;

        memset(mscap, 0, NVRAM_EF_MSCAP_SIZE);
        ret = ReadRecord(NVRAM_EF_MSCAP_LID, 1, &mscap, NVRAM_EF_MSCAP_SIZE, &error_code);
        if (!(error_code == NVRAM_READ_SUCCESS && ret == NVRAM_EF_MSCAP_SIZE))
        {
            ASSERT(0);
        }

        if (mscap[0] == 0x1f)
        {
            AMR_ON = TRUE;
        }
        else
        {
            AMR_ON = FALSE;
        }
    }
    if (AMR_ON)
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_ON);
    }
    else
    {
        PopUpList[index] = (U8*) get_string(STR_GLOBAL_OFF);
    }
    index++;
#endif /* defined(__AMR_SUPPORT__) */ 

    /* EM_WAP_MENUID */
#if defined(WAP_SUPPORT)
    index++;
#endif 

    /* EM_J2ME_TCK_MENUID */
#ifdef __J2ME__
    index++;
#endif 

    /* EM_TOUCHSCREEN_MENUID */
#if defined(__MMI_TOUCH_SCREEN__)
    index++;
#endif 

    /* EM_VIDEO_HI_BITRATE_MENUID */
#if defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT)
    {
        U8 mode;

        mode = media_vid_get_em_mode();

        if (mode == VID_EM_MODE_DISABLED)
        {
            PopUpList[index] = (U8*) get_string(STR_GLOBAL_OFF);
        }
        else if (mode == VID_EM_MODE_ULTRA_HIGH_BITRATE)
        {
            PopUpList[index] = (U8*) get_string(STR_GLOBAL_ON);
        }
        else
        {
            ASSERT(0);
        }

        gVideoHiBitrateIdx = index;
    }
    index++;
#endif /* defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT) */ 

#ifdef __MMI_INTERACTIVE_PROFILNG__
    /* EM_FRM_PROFILING_MENUID */
    index++;
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    /* EM_MISC_CELL_RESELECTION_MENUID */
    index++;

#if defined(__MMI_EM_FIXED_GAIN_FOR_HELIOS2__)
    {
        S16 ret, error_code;
        U8 DSPdata[8];
        
        ret = ReadRecord(NVRAM_EF_SYS_CACHE_OCTET_LID,
                         NVRAM_SYS_FIXED_GAIN_MECH_FOR_HELIOS2,
                         DSPdata,
                         NVRAM_EF_SYS_CACHE_OCTET_SIZE,
                         &error_code);
    
        FixedGain_On = DSPdata[0];
    
        if (FixedGain_On)
        {
            PopUpList[index] = (U8*) get_string(STR_GLOBAL_ON);
        }
        else
        {
            PopUpList[index] = (U8*) get_string(STR_GLOBAL_OFF);
        }
    
        index++;
    }
#endif /* __MMI_EM_FIXED_GAIN_FOR_HELIOS2__ */

    ShowCategory52Screen(
        EM_MISC_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmMisc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmMisc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmMisc, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


#if defined(__FLIGHT_MODE_SUPPORT__) || defined(__WIFI_SUPPORT__)
/**************************************************************
 ***************** GSM  RF Test *******************************
 **************************************************************/
/**************************************************************
**	FUNCTION NAME		: HighlightRFTestTool
**
**  PURPOSE				: Highlight function for RF Test Tool menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestTool(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EmRFTestDisableSleepMode, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EmRFTestDisableSleepMode
**
**  PURPOSE				: RF Test Disable Sleep Mode
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EmRFTestDisableSleepMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* re-register protocol event handler of MSG_ID_MMI_EQ_SET_SLEEP_MODE_RSP */
    SetProtocolEventHandler (EmRFTestToolSleepModeHdlr, MSG_ID_MMI_EQ_SET_SLEEP_MODE_RSP);    

    g_rf_tool_sleep_mode_state = EM_SLEEPMODE_STATE_DISABLE;    
    EngineerModeSetSleepModeReq(EM_SLEEPMODE_STATE_DISABLE);    
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestTool
**
** 	PURPOSE				: Enrty function for RF Test Tool menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestTool(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16		ItemList[8];
    U16		ItemIcons[8];
    U16		nItems;
    U8*		guiBuffer;
    U8*		PopUpList[8];
    S32		i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_RF_TEST_TOOL_SCR, NULL, EntryEmRFTestTool, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_TOOL_SCR);
    nItems = GetNumOfChild(EM_RF_TEST_TOOL_MENUID);
    GetSequenceStringIds(EM_RF_TEST_TOOL_MENUID, ItemList);
    SetParentHandler(EM_RF_TEST_TOOL_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for(i=0 ; i<nItems ; i++)
    {
        PopUpList[i] =NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1+i);
    }

    ShowCategory52Screen(EM_RF_TEST_TOOL_TEXT,0,
							STR_GLOBAL_OK,0,
							STR_GLOBAL_BACK,0,
							nItems, ItemList, ItemIcons, (U8**) PopUpList, 0, 0, guiBuffer);

    SetRightSoftkeyFunction(EmRFTestEnableSleepMode,KEY_EVENT_UP);
   
    /* Register END key handler */
    SetKeyHandler(EmRFTestEnableSleepMode,KEY_END,KEY_EVENT_DOWN);
   
}


/**************************************************************
**	FUNCTION NAME		: EmRFTestEnableSleepMode
**
**  PURPOSE				: RF Test Tool Enable Sleep Mode
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EmRFTestEnableSleepMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   /* re-register protocol event handler of MSG_ID_MMI_EQ_SET_SLEEP_MODE_RSP */
    SetProtocolEventHandler (EmRFTestToolSleepModeHdlr, MSG_ID_MMI_EQ_SET_SLEEP_MODE_RSP);    

    g_rf_tool_sleep_mode_state = EM_SLEEPMODE_STATE_ENABLE;    
    EngineerModeSetSleepModeReq(EM_SLEEPMODE_STATE_ENABLE); 

}
    

/**************************************************************
**	FUNCTION NAME		: EmRFTestToolSleepModeHdlr
**
**  PURPOSE				: RF Test Tool Sleep Mode Handler
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void  EmRFTestToolSleepModeHdlr(void* inMsg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (g_rf_tool_sleep_mode_state)
    {
        case EM_SLEEPMODE_STATE_ENABLE: /* enable measn that exit RF Test Screen */
        {
            /* recover the protocol event handler of MSG_ID_MMI_EQ_SET_SLEEP_MODE_RSP */
            SetProtocolEventHandler (EngineerModeSetSleepModeRes, MSG_ID_MMI_EQ_SET_SLEEP_MODE_RSP);           
            
            /* resume MMI sleep mode */
            TurnOnBacklight(1);
            
            GoBackHistory();
            break;
        }
        case EM_SLEEPMODE_STATE_DISABLE: /* disable means that enter RF Test Screen*/
        {
            /* stop MMI sleep mode */
            TurnOnBacklight(0);
            
            /* Enter RF Test Tool Screen */
            EntryEmRFTestTool();
            break;
         }
    }
}


/**************************************************************

	FUNCTION NAME		: ExitEmRFTestInlineSelectScreen()

  	PURPOSE				: Exit Em RF Test inline select screen

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void ExitEmRFTestInlineSelectScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
}
#endif /* #ifdef __FLIGHT_MODE_SUPPORT__ || defined(__WIFI_SUPPORT__) */

#ifdef __FLIGHT_MODE_SUPPORT__
/**************************************************************
**	FUNCTION NAME		: EMRFTestGSMInitContext
**
**  PURPOSE				:  
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTestGSMInitContext(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 buffer[20];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_rf_test_gsm_cntx.currRFGsmBand = 1;  /* default hilte GSM900 */

    sprintf(buffer,"20");
    mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.arfcn, buffer);

    /* tsc default value */        
    sprintf(buffer,"5");
    mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.tsc, buffer);
            
    /* pcl default value */        
    sprintf(buffer,"5");
    mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.pcl, buffer);
    
    /* afc default value */        
    sprintf(buffer,"4100");
    mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.afc, buffer);
    
    /* burst type default value */        
    g_rf_test_gsm_cntx.currTxBurstType = 0;  /* NB */
    
    /* rx gain default value */        
    sprintf(buffer,"40");
    mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.gain, buffer);
        
    g_rf_test_gsm_cntx.power_scan_flag = EM_RF_GSM_POWERSCAN_NONE;
}


/**************************************************************
**	FUNCTION NAME		: EMRFTestGsmSendReq
**
** 	PURPOSE				: RF Test GSM send request function. 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTestGsmSendReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_rf_test_gsm_req_struct *msg_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_p = OslConstructDataPtr(sizeof(mmi_eq_rf_test_gsm_req_struct));

    msg_p->request_type = g_rf_test_gsm_cntx.req_type;

    switch(g_rf_test_gsm_cntx.req_type)
    {
        case RF_TEST_GSM_STOP:
        {
            StopTimer(EM_RINGTONE_HIGHLIGHT_TIMER);    
            break;
        }
        case RF_TEST_GSM_TX_TEST:
        {
            msg_p->request.gsm_tx_test.band = rf_gsm_band[g_rf_test_gsm_cntx.currRFGsmBand];           
            msg_p->request.gsm_tx_test.arfcn = g_rf_test_gsm_cntx.int_arfcn;
            msg_p->request.gsm_tx_test.tsc = g_rf_test_gsm_cntx.int_tsc;
            msg_p->request.gsm_tx_test.pcl = g_rf_test_gsm_cntx.int_pcl;
            msg_p->request.gsm_tx_test.afc = g_rf_test_gsm_cntx.int_afc;
            msg_p->request.gsm_tx_test.pattern = g_rf_test_gsm_cntx.currTxBurstType;
            break;
        }
        case RF_TEST_GSM_RX_TEST:
        {
            msg_p->request.gsm_rx_test.band = rf_gsm_band[g_rf_test_gsm_cntx.currRFGsmBand];                       
            msg_p->request.gsm_rx_test.arfcn = g_rf_test_gsm_cntx.int_arfcn;
            msg_p->request.gsm_rx_test.gain = g_rf_test_gsm_cntx.int_gain;
            msg_p->request.gsm_rx_test.pattern = g_rf_test_gsm_cntx.currRxBurstType;
            break;       	
        }
        case RF_TEST_GSM_POWER_SCAN:
        {
            msg_p->request.gsm_power_scan.band = rf_gsm_band[g_rf_test_gsm_cntx.currRFGsmBand];                       
            msg_p->request.gsm_power_scan.arfcn_in = g_rf_test_gsm_cntx.int_arfcn;
            break;       	
        }
  	 default:
	     ASSERT(0);
            break;
    }

    EngineerModeSendMsg(MSG_ID_MMI_EQ_RF_TEST_GSM_REQ, msg_p, NULL);

}


/**************************************************************
**	FUNCTION NAME		: EMRFTestGsmSendRes
**
** 	PURPOSE				: RF Test GSM send request response function. 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTestGsmSendRes(void* inMsg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_rf_test_gsm_rsp_struct *rsp_p = inMsg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(rsp_p->request_type)
    {
        case RF_TEST_GSM_STOP:
        {
            /* if go back from power scan screen, to avoid assert in layer1, 
               should receive confirm then go back history.
               Remark: Layer1 will assert if receives a new request when last request doesn't finish */
            if (g_rf_test_gsm_cntx.power_scan_flag == EM_RF_GSM_POWERSCAN_BACK)
            {
                g_rf_test_gsm_cntx.power_scan_flag = EM_RF_GSM_POWERSCAN_NONE;
                GoBackHistory();
            }
            else if (g_rf_test_gsm_cntx.power_scan_flag == EM_RF_GSM_POWERSCAN_ABORT)
            {
                g_rf_test_gsm_cntx.power_scan_flag = EM_RF_GSM_POWERSCAN_NONE;
                EntryEmRFTestGSMPowerScan();
            }
            break;
        }
        case RF_TEST_GSM_TX_TEST:
        {
            break;
        }
        case RF_TEST_GSM_RX_TEST:
        {
            break;
        }
        case RF_TEST_GSM_POWER_SCAN:
        {
            EntryEMRFGSMPowerScanRsp(rsp_p->request.gsm_power_scan.arfcn_out, rsp_p->request.gsm_power_scan.power);
            break;
        }
        default:
            ASSERT(0);
            break;
    }

}


/**************************************************************

	FUNCTION NAME		: EmStopRFTestGsm()

  	PURPOSE				: Stop Em RF Test GSM Request

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EmStopRFTestGsm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_rf_test_gsm_cntx.request_processing == MMI_TRUE)
    {
        g_rf_test_gsm_cntx.req_type = RF_TEST_GSM_STOP;
        g_rf_test_gsm_cntx.request_processing = MMI_FALSE;
        EMRFTestGsmSendReq();        
    }
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestGSM
**
**  PURPOSE				: Highlight function for RF Test GSM menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestGSM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryRFTestGSMEnterCondirm, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryRFTestGSMEnterCondirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryRFTestGSMEnterCondirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayConfirm(
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        get_string(EM_RF_TEST_GSM_CONFIRM_NOTIFY_TEST) ,
        IMG_GLOBAL_INFO,
        WARNING_TONE);

    SetLeftSoftkeyFunction(EmRFTestGSMEnterFlightMode, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EmRFTestGSMEnterFlightMode
**
**  PURPOSE				: RF Test GSM menu Enter Flight Mode
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EmRFTestGSMEnterFlightMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    extern void mmi_em_enter_flight_mode(FuncPtr callback);
    
    mmi_em_enter_flight_mode((FuncPtr)EntryEmRFTestGSM);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestGSM
**
**  PURPOSE				: Enrty function for RF Test GSM menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestGSM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16	ItemList[8];
    U16	ItemIcons[8];
    U16	nItems;
    U8*	guiBuffer;
    U8*	PopUpList[8];
    S32	i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestGsm();

    EntryNewScreen(EM_RF_TEST_GSM_SCR, NULL, EntryEmRFTestGSM, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_GSM_SCR);
	
    nItems = GetNumOfChild(EM_RF_TEST_GSM_MENUID);
    GetSequenceStringIds(EM_RF_TEST_GSM_MENUID, ItemList);
    SetParentHandler(EM_RF_TEST_GSM_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for(i=0;i<nItems;i++)
    {
        PopUpList[i]=NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1+i);
    }

    ShowCategory52Screen(EM_RF_TEST_GSM_TEST,0,
							STR_GLOBAL_OK,0,
							STR_GLOBAL_BACK,0,
							nItems, ItemList, ItemIcons, (U8**) PopUpList, 0, 0, guiBuffer);

    SetRightSoftkeyFunction(EmRFTestGSMExitFlightMode,KEY_EVENT_UP);

    /* Register END key handler */
    SetKeyHandler(EmRFTestGSMExitFlightMode,KEY_END,KEY_EVENT_DOWN);
	
}


/**************************************************************
**	FUNCTION NAME		: EmRFTestGSMExitFlightMode
**
**  PURPOSE				: RF Test GSM menu Exit Flight Mode
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EmRFTestGSMExitFlightMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    extern void mmi_em_exit_flight_mode(void);
    extern void QuitSystemOperation(void);
    
    mmi_em_exit_flight_mode();

    QuitSystemOperation();
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestGSMTxTest
**
**  PURPOSE				: Highlight function for RF Test GSM Tx Test menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestGSMTxTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestGSMTxTest, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestGSMTxTest
**
**  PURPOSE				: Enrty function for RF Test GSM Tx Test menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestGSMTxTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* guiBuffer;
    U16 ImageList[12];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestGsm();

    /* set request type = GSM TX Test */    
    g_rf_test_gsm_cntx.req_type = RF_TEST_GSM_TX_TEST;

    EntryNewScreen(EM_RF_TEST_GSM_TX_TEST_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_GSM_TX_TEST_SCR);

    RegisterHighlightHandler(HighlightHandlerRFGSMTxInline);
    
    /* Band */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_GSM_TX_BAND_TEXT));
    ImageList[0] = IMG_STATUS;

    g_rf_test_gsm_cntx.pEMRFGsmBand[0] = (U8*)GetString(EM_RF_GSM_TX_BAND_GSM850_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[1] = (U8*)GetString(EM_RF_GSM_TX_BAND_GSM900_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[2] = (U8*)GetString(EM_RF_GSM_TX_BAND_DCS1800_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[3] = (U8*)GetString(EM_RF_GSM_TX_BAND_PCS1900_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 4, (U8**)g_rf_test_gsm_cntx.pEMRFGsmBand, &g_rf_test_gsm_cntx.currRFGsmBand);
    RegisterInlineSelectHighlightHandler(&wgui_inline_items[1],HighlightHandlerRFGSMBandInline);
    ImageList[1] = 0;

    /* ARFCN */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_GSM_TX_ARFCN_TEXT));
    ImageList[2] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[3], (PU8)g_rf_test_gsm_cntx.arfcn, 5, INPUT_TYPE_NUMERIC);
    ImageList[3] = 0;

    /* TSC */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_GSM_TX_TSC_TEXT));
    ImageList[4] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[5], (PU8)g_rf_test_gsm_cntx.tsc, 5, INPUT_TYPE_NUMERIC);
    ImageList[5] = 0;

    /* PCL */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_RF_GSM_TX_PCL_TEXT));
    ImageList[6] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[7], (PU8)g_rf_test_gsm_cntx.pcl, 5, INPUT_TYPE_NUMERIC);
    ImageList[7] = 0;

    /* AFC */
    SetInlineItemActivation(&wgui_inline_items[8], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[8], (U8*)GetString(EM_RF_GSM_TX_AFC_TEXT));
    ImageList[8] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[9], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[9], (PU8)g_rf_test_gsm_cntx.afc, 5, INPUT_TYPE_NUMERIC);
    ImageList[9] = 0;

    /* Burst Type */
    SetInlineItemActivation(&wgui_inline_items[10], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[10], (U8*)GetString(EM_RF_GSM_TX_BURST_TYPE_TEXT));
    ImageList[10] = IMG_STATUS;

    g_rf_test_gsm_cntx.pEMRFGsmBurstType[0] = (U8*)GetString(EM_RF_GSM_TX_BURST_NB_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBurstType[1] = (U8*)GetString(EM_RF_GSM_TX_BURST_NBALL_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBurstType[2] = (U8*)GetString(EM_RF_GSM_TX_BURST_AB_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBurstType[3] = (U8*)GetString(EM_RF_GSM_TX_BURST_CONTTX00_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBurstType[4] = (U8*)GetString(EM_RF_GSM_TX_BURST_CONTTX11_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBurstType[5] = (U8*)GetString(EM_RF_GSM_TX_BURST_CONTTX01_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBurstType[6] = (U8*)GetString(EM_RF_GSM_TX_BURST_CONTTX_RANDOM_TEXT);
    SetInlineItemActivation(&wgui_inline_items[11], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[11], 7, (U8**)(g_rf_test_gsm_cntx.pEMRFGsmBurstType), &g_rf_test_gsm_cntx.currTxBurstType);
    ImageList[11] = 0;       

    DisableCategory57ScreenDone();
     	
    ShowCategory57Screen(EM_RF_GSM_TX_TEST_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    12, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);

}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFGSMTxInline
**
**  PURPOSE				: Highlight handler of Tx inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFGSMTxInline(S32 index) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ( g_rf_test_gsm_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFGSMTXTestCheckAndSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestGSMTxTest, KEY_EVENT_UP);
    }

    /* Register END key handler, for inline editor might register END key */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFGSMBandInline
**
**  PURPOSE				: Highlight handler of GSM Band Inline highlight handler.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFGSMBandInline(S32 index) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 buffer[32];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* arfcn default value */
    switch(g_rf_test_gsm_cntx.currRFGsmBand)
    {
        case RF_TEST_GSM_TX_BAND_900:
        {
            sprintf(buffer,"20");
            mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.arfcn, buffer);
            break;
        }
        case RF_TEST_GSM_TX_BAND_850:
        {
            sprintf(buffer,"128");
            mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.arfcn, buffer);
            break;
        }
        case RF_TEST_GSM_TX_BAND_1800:
        {
            sprintf(buffer,"512");
            mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.arfcn, buffer);
            break;
        }
        case RF_TEST_GSM_TX_BAND_1900:
        {
            sprintf(buffer,"512");
            mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.arfcn, buffer);
            break;
        }
        default:
            ASSERT(0);
    }
     redraw_fixed_list();
}


/**************************************************************

	FUNCTION NAME		: EMRFGSMTXTestCheckAndSendReq

  	PURPOSE				: Check RF GSM TX Test parameter

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EMRFGSMTXTestCheckAndSendReq(void) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8  textbuf[20];
    MMI_BOOL result = MMI_TRUE;
    U16  tsc , pcl, afc;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
    
    /* To check if ARFCN is valid */
    result = check_gsm_arfcn_valid();
     
    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_rf_test_gsm_cntx.arfcn)
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_gsm_cntx.tsc)
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_gsm_cntx.pcl)
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_gsm_cntx.afc ))
        result = MMI_FALSE;

    /* To check if TSC is valid */    
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_gsm_cntx.tsc);
    tsc = atoi((const char *) textbuf);
    if (tsc > 7)
        result = MMI_FALSE;

    /* To check if PCL is valid */
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_gsm_cntx.pcl);
    pcl = atoi((const char *) textbuf);
    if (pcl > 31)
        result = MMI_FALSE;

    /* To check if AFC is valid */
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_gsm_cntx.afc);
    afc = atoi((const char *) textbuf);
    if ( afc>8191)
        result = MMI_FALSE;
   
    /* If one of the parameters is invalid, then pop-up error and return */
    if (result == MMI_FALSE)
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
 	 DeleteScreenIfPresent(EM_RF_TEST_GSM_TX_TEST_SCR);
 	 return;
    }

    /* set the atoi result to global context */
    g_rf_test_gsm_cntx.int_tsc = (S8)tsc;
    g_rf_test_gsm_cntx.int_pcl = (S8)pcl;
    g_rf_test_gsm_cntx.int_afc= afc;

    /* Send request to RF , now req_type = RF_TEST_GSM_TX_TEST */
    g_rf_test_gsm_cntx.request_processing = MMI_TRUE;
    EMRFTestGsmSendReq();

    /* show RF Test GSM TX Test Done screen */
    EntryEMRFTESTGsmTXTestDone();    
}


/**************************************************************
**	FUNCTION NAME		: EntryEMRFTESTGsmTXTestDone
**
**  PURPOSE				: Enrty function for RF Test GSM Tx Test Done
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEMRFTESTGsmTXTestDone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* guiBuffer;
    U16 ImageList[12];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_RF_TEST_GSM_TX_TEST_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_GSM_TX_TEST_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFGSMTxInline);
    
    /* Band */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_GSM_TX_BAND_TEXT));
    ImageList[0] = IMG_STATUS;

    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[1], (U8*)g_rf_test_gsm_cntx.pEMRFGsmBand[g_rf_test_gsm_cntx.currRFGsmBand]);
    ImageList[1] = 0;

    /* ARFCN */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_GSM_TX_ARFCN_TEXT));
    ImageList[2] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[3], (PU8)g_rf_test_gsm_cntx.arfcn);
    ImageList[3] = 0;

    /* TSC */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_GSM_TX_TSC_TEXT));
    ImageList[4] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[5], (PU8)g_rf_test_gsm_cntx.tsc);
    ImageList[5] = 0;
       
    /* PCL */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_RF_GSM_TX_PCL_TEXT));
    ImageList[6] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[7], (PU8)g_rf_test_gsm_cntx.pcl);
    ImageList[7] = 0;

    /* AFC */
    SetInlineItemActivation(&wgui_inline_items[8], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[8], (U8*)GetString(EM_RF_GSM_TX_AFC_TEXT));
    ImageList[8] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[9], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[9], (PU8)g_rf_test_gsm_cntx.afc);        
    ImageList[9] = 0;

    /* Burst Type */
    SetInlineItemActivation(&wgui_inline_items[10], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[10], (U8*)GetString(EM_RF_GSM_TX_BURST_TYPE_TEXT));
    ImageList[10] = IMG_STATUS;

    SetInlineItemActivation(&wgui_inline_items[11], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[11], (PU8)g_rf_test_gsm_cntx.pEMRFGsmBurstType[g_rf_test_gsm_cntx.currTxBurstType]);                
    ImageList[11] = 0;            

    ShowCategory57Screen(EM_RF_GSM_TX_TEST_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    12, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);

}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestGSMRxTest
**
**  	PURPOSE				: Highlight function for RF Test GSM Rx Test menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestGSMRxTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestGSMRxTest, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestGSMRxTest
**
**  	PURPOSE				: Enrty function for RF Test GSM Rx Test menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestGSMRxTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* guiBuffer;
    U16 ImageList[8];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestGsm();

    /* set request type = GSM RX Test */    
    g_rf_test_gsm_cntx.req_type = RF_TEST_GSM_RX_TEST;
    
    EntryNewScreen(EM_RF_TEST_GSM_RX_TEST_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_GSM_RX_TEST_SCR);

    RegisterHighlightHandler(HighlightHandlerRFGSMRxInline);

    /* Band */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_GSM_TX_BAND_TEXT));
    ImageList[0] = IMG_STATUS;

    g_rf_test_gsm_cntx.pEMRFGsmBand[0] = (U8*)GetString(EM_RF_GSM_TX_BAND_GSM850_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[1] = (U8*)GetString(EM_RF_GSM_TX_BAND_GSM900_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[2] = (U8*)GetString(EM_RF_GSM_TX_BAND_DCS1800_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[3] = (U8*)GetString(EM_RF_GSM_TX_BAND_PCS1900_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 4, (U8**)g_rf_test_gsm_cntx.pEMRFGsmBand, &g_rf_test_gsm_cntx.currRFGsmBand);    
    RegisterInlineSelectHighlightHandler(&wgui_inline_items[1],HighlightHandlerRFGSMBandInline);    
    ImageList[1] = 0;

    /* ARFCN */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_GSM_TX_ARFCN_TEXT));
    ImageList[2] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[3], (PU8)g_rf_test_gsm_cntx.arfcn, 5, INPUT_TYPE_NUMERIC);
    ImageList[3] = 0;

    /* Gain */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_GSM_TX_GAIN_TEXT));
    ImageList[4] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[5], (PU8)g_rf_test_gsm_cntx.gain, 5, INPUT_TYPE_DECIMAL_NUMERIC);
    ImageList[5] = 0;

    /* Burst Type */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_RF_GSM_TX_BURST_TYPE_TEXT));
    ImageList[6] = IMG_STATUS;

    g_rf_test_gsm_cntx.pEMRFGsmBurstType[0] = (U8*)GetString(EM_RF_GSM_RX_BURST_CONT_RX_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBurstType[1] = (U8*)GetString(EM_RF_GSM_RX_BURST_BURST_RX_TEXT);
    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[7], 2, (U8**)g_rf_test_gsm_cntx.pEMRFGsmBurstType, &g_rf_test_gsm_cntx.currRxBurstType);
    ImageList[7] = 0;       

    DisableCategory57ScreenDone();
     	
    ShowCategory57Screen(EM_RF_GSM_RX_TEST_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    8, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFGSMRxInline
**
**  PURPOSE				: Highlight handler of Rx inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFGSMRxInline(S32 index) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ( g_rf_test_gsm_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFGSMRXTestCheckAndSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestGSMRxTest, KEY_EVENT_UP);
    }

    /* Register END key handler, for inline editor might register END key */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
}


/**************************************************************

	FUNCTION NAME		: EMRFGSMRXTestCheckAndSendReq

  	PURPOSE				: Check RF GSM RX Test parameter

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EMRFGSMRXTestCheckAndSendReq(void) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8  textbuf[20];
    DOUBLE gain;
    MMI_BOOL result = MMI_TRUE;
    U8 i, len;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    /* To check if ARFCN is valid */
    result = check_gsm_arfcn_valid();

    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_rf_test_gsm_cntx.arfcn) 
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_gsm_cntx.gain))
        result = MMI_FALSE;

    /* To check if Gain is valid */
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_gsm_cntx.gain);
    len = strlen((S8*)textbuf);
    for (i = 0; i< len ; i++)
        if (textbuf[i] == '.')
            break;

    /* check if there is a dot and the dot is not located at the last 2 position.
         because only accept one digit after dot. */
    if ( (i != (len-2)) && (i != len))
        result = MMI_FALSE;
              
    /* If one of the parameters is invalid, then pop-up error and return */
    if (result == MMI_FALSE)
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
 	 DeleteScreenIfPresent(EM_RF_TEST_GSM_RX_TEST_SCR);
 	 return;
    }

    /* set the atoi result to global context */
    gain = atof((const char *) textbuf);    
    g_rf_test_gsm_cntx.int_gain = (S16)(gain * 8);        

    /* Send request to RF,  now req_type = RF_TEST_GSM_RX_TEST */
    g_rf_test_gsm_cntx.request_processing = MMI_TRUE;
    EMRFTestGsmSendReq();

    /* start a timer to send RX test request */
    StartTimer(EM_RINGTONE_HIGHLIGHT_TIMER, EM_RF_TOOL_GSM_RX_BURST_DURATION, EMRFTestGsmRXTestTimeoutHdlr);    

    /* show RF Test GSM RX Test Done screen */
    EntryEMRFTESTGsmRXTestDone();

}


/**************************************************************
**	FUNCTION NAME		: EMRFTestGsmRXTestTimeoutHdlr
**
**  PURPOSE				: Enrty function for RF Test GSM Rx Test timeout hdlr
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTestGsmRXTestTimeoutHdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* at first, to stop last request */
    g_rf_test_gsm_cntx.req_type = RF_TEST_GSM_STOP;    
    EMRFTestGsmSendReq();   
    
    /* then send the next request */
    g_rf_test_gsm_cntx.req_type = RF_TEST_GSM_RX_TEST;
    EMRFTestGsmSendReq();
    
    /* re-start the timer */
    StartTimer(EM_RINGTONE_HIGHLIGHT_TIMER, EM_RF_TOOL_GSM_RX_BURST_DURATION, EMRFTestGsmRXTestTimeoutHdlr);    
}


/**************************************************************
**	FUNCTION NAME		: EntryEMRFTESTGsmRXTestDone
**
**  PURPOSE				: Enrty function for RF Test GSM Rx Test Done
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEMRFTESTGsmRXTestDone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U8* guiBuffer;
    U16 ImageList[12];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_RF_TEST_GSM_RX_TEST_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();

    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_GSM_RX_TEST_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFGSMRxInline);

    /* Band */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_GSM_TX_BAND_TEXT));
    ImageList[0] = IMG_STATUS;

    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[1], (U8*)g_rf_test_gsm_cntx.pEMRFGsmBand[g_rf_test_gsm_cntx.currRFGsmBand]);
    ImageList[1] = 0;

    /* ARFCN */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_GSM_TX_ARFCN_TEXT));
    ImageList[2] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[3], (PU8)g_rf_test_gsm_cntx.arfcn);
    ImageList[3] = 0;

    /* Gain */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_GSM_TX_GAIN_TEXT));
    ImageList[4] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[5], (PU8)g_rf_test_gsm_cntx.gain);
    ImageList[5] = 0;

    /* Burst Type */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_RF_GSM_TX_BURST_TYPE_TEXT));
    ImageList[6] = IMG_STATUS;

    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[7],(U8*)g_rf_test_gsm_cntx.pEMRFGsmBurstType[g_rf_test_gsm_cntx.currRxBurstType] );
    ImageList[7] = 0;     

    ShowCategory57Screen(EM_RF_GSM_RX_TEST_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    8, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);

}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestGSMPowerScan
**
**  PURPOSE				: Highlight function for RF Test GSM Power Scan menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestGSMPowerScan(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestGSMPowerScan, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestGSMPowerScan
**
**  PURPOSE				: Enrty function for RF Test GSM Power Scan menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestGSMPowerScan(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* guiBuffer;
    U16 ImageList[4];
    S8 buffer[20];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestGsm();

    /* set request type = GSM Power Scan */    
    g_rf_test_gsm_cntx.req_type = RF_TEST_GSM_POWER_SCAN;

    EntryNewScreen(EM_RF_TEST_GSM_POWER_SCAN_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_GSM_POWER_SCAN_SCR);

    RegisterHighlightHandler(HighlightHandlerRFGSMPowerScanInline);

    /* Band */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_GSM_TX_BAND_TEXT));
    ImageList[0] = IMG_STATUS;

    g_rf_test_gsm_cntx.pEMRFGsmBand[0] = (U8*)GetString(EM_RF_GSM_TX_BAND_GSM850_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[1] = (U8*)GetString(EM_RF_GSM_TX_BAND_GSM900_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[2] = (U8*)GetString(EM_RF_GSM_TX_BAND_DCS1800_TEXT);
    g_rf_test_gsm_cntx.pEMRFGsmBand[3] = (U8*)GetString(EM_RF_GSM_TX_BAND_PCS1900_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 4, (U8**)g_rf_test_gsm_cntx.pEMRFGsmBand, &g_rf_test_gsm_cntx.currRFGsmBand);
    ImageList[1] = 0;

    /* ARFCN */
    /* set Power Scan -- ARFCN default value */
    sprintf(buffer,"9999");
    mmi_asc_to_ucs2((PS8)g_rf_test_gsm_cntx.arfcn, buffer);

    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_GSM_TX_ARFCN_TEXT));
    ImageList[2] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[3], (PU8)g_rf_test_gsm_cntx.arfcn, 5, INPUT_TYPE_NUMERIC);
    ImageList[3] = 0;

    DisableCategory57ScreenDone();
     	
    ShowCategory57Screen(EM_RF_GSM_POWER_SCAN_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    4, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFGSMPowerScanInline
**
**  PURPOSE				: Highlight handler of Power Scan inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFGSMPowerScanInline(S32 index) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(EMRFGSMPowerScanFunc, KEY_EVENT_UP);

    /* Register END key handler, for inline editor might register END key */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
}


/**************************************************************

	FUNCTION NAME		: EMRFGSMPowerScanFunc

  	PURPOSE				: Set RF GSM Power Scan

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EMRFGSMPowerScanFunc(void) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
    
    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_rf_test_gsm_cntx.arfcn))
        result = MMI_FALSE;

    /* To check if ARFCN is valid */
    if (result == MMI_TRUE)
        result = check_gsm_arfcn_valid();

    /* If one of the parameters is invalid, then pop-up error and return */
    if (result == MMI_FALSE)
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
 	 DeleteScreenIfPresent(EM_RF_TEST_GSM_POWER_SCAN_SCR);
 	 return;
    }

    /* Send request to RF , now req_type = RF_TEST_GSM_POWER_SCAN */
    g_rf_test_gsm_cntx.request_processing = MMI_TRUE;
    EMRFTestGsmSendReq();
    
    ClearInputEventHandler(MMI_DEVICE_ALL);
}


/**************************************************************

	FUNCTION NAME		: EntryEMRFGSMPowerScanRsp

  	PURPOSE				: RF GSM Power Scan Response 

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EntryEMRFGSMPowerScanRsp(PS16 arfcn, PS16 power) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* guiBuffer;
    S8 buffer[32];
    U8 nItems = 0;
    U16 val_arfnc;        

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* start the timer to send power scan request */
    StartTimer(EM_RINGTONE_HIGHLIGHT_TIMER, EM_RF_TOOL_GSM_POWERSCAN_DURATION, EMRFTestGsmSendReq);            
    
    EntryNewScreen(EM_RF_TEST_GSM_POWER_SCAN_RESULT_SCR, NULL, NULL, NULL);
    guiBuffer = GetCurrGuiBuffer (EM_RF_TEST_GSM_POWER_SCAN_RESULT_SCR);
    
    RegisterHighlightHandler (SetHighlightIndex);		 

    mmi_ucs2_to_asc((PS8)buffer,  (PS8)g_rf_test_gsm_cntx.arfcn);
    val_arfnc = atoi((const char *) buffer);

    if (val_arfnc == 9999)
    {
        for(nItems=0; nItems<20; nItems++)
        {
            sprintf(buffer,"CH%d: %.1f", arfcn[nItems] , (DOUBLE)power[nItems]/4);
            mmi_asc_to_ucs2((PS8)subMenuData[nItems], buffer);
            subMenuDataPtrs[nItems] = subMenuData[nItems];
        }
    }
    else
    {
        sprintf(buffer,"CH%d: %.1f", arfcn[nItems] , (DOUBLE)power[nItems]/4);
        mmi_asc_to_ucs2((PS8)subMenuData[nItems], buffer);
        subMenuDataPtrs[nItems] = subMenuData[nItems];
        nItems ++;
    }

    ShowCategory6Screen (EM_RF_GSM_POWER_SCAN_TEXT, 0,
						  STR_GLOBAL_ABORT, 0,
						  STR_GLOBAL_BACK, 0,
						  nItems, (PU8*)subMenuDataPtrs,NULL, currentHighlightIndex,
						  guiBuffer); 
						  
    SetLeftSoftkeyFunction (EmRFTestGSMPowerScanAbort, KEY_EVENT_UP);
    SetRightSoftkeyFunction (EmRFTestGSMPowerScanBack, KEY_EVENT_UP);

    /* Register END key handler */
    SetKeyHandler(EmRFTestGSMPowerScanBack, KEY_END,KEY_EVENT_DOWN);
    
}


/**************************************************************

	FUNCTION NAME		: EmRFTestGSMPowerScanBack()

  	PURPOSE				: Em RF Test GSM Power Scan GoBack function

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EmRFTestGSMPowerScanBack(void)
{
    g_rf_test_gsm_cntx.power_scan_flag = EM_RF_GSM_POWERSCAN_BACK;
    
    if (g_rf_test_gsm_cntx.request_processing == MMI_TRUE)
    {
        g_rf_test_gsm_cntx.req_type = RF_TEST_GSM_STOP;
        g_rf_test_gsm_cntx.request_processing = MMI_FALSE;
        EMRFTestGsmSendReq();        
    }
    else
        ASSERT(0);
}


/**************************************************************
	FUNCTION NAME		: EmRFTestGSMPowerScanAbort()

  	PURPOSE				: Em RF Test GSM Power Scan Abort function

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EmRFTestGSMPowerScanAbort(void)
{
    g_rf_test_gsm_cntx.power_scan_flag = EM_RF_GSM_POWERSCAN_ABORT;
    
    if (g_rf_test_gsm_cntx.request_processing == MMI_TRUE)
    {
        g_rf_test_gsm_cntx.req_type = RF_TEST_GSM_STOP;
        g_rf_test_gsm_cntx.request_processing = MMI_FALSE;
        EMRFTestGsmSendReq();        
    }
    else
        ASSERT(0);
}


/**************************************************************
**	FUNCTION NAME		: check_rf_test_gsm_parameter_valid
**
**  PURPOSE				: Check if ARFCN parameter is valid.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
MMI_BOOL check_gsm_arfcn_valid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8  textbuf[20];
    MMI_BOOL result = MMI_TRUE;
    U16 arfcn;

    /*----------------------------------------------------------------*/
    /* Code Body                                                */
    /*----------------------------------------------------------------*/
    /* To check if ARFCN is valid */
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_gsm_cntx.arfcn);
    arfcn = atoi((const char *) textbuf);
         
    if (g_rf_test_gsm_cntx.currRFGsmBand == EM_RF_GSM_BAND_GSM900)
    {
         if ( (arfcn>124 && arfcn < 975) || (arfcn >1024))
             result = MMI_FALSE;         
    }
    else if (g_rf_test_gsm_cntx.currRFGsmBand == EM_RF_GSM_BAND_GSM850)
    {
         if ( (arfcn < 128) ||  (arfcn > 251))
             result = MMI_FALSE;     
    }
    else if (g_rf_test_gsm_cntx.currRFGsmBand == EM_RF_GSM_BAND_DCS1800)
    {
         if ( (arfcn < 512) ||  (arfcn > 885))
             result = MMI_FALSE;     
    }
    else if (g_rf_test_gsm_cntx.currRFGsmBand == EM_RF_GSM_BAND_PCS1900)
    {
         if ( (arfcn < 512) ||  (arfcn > 810))
             result = MMI_FALSE;     
    }
    else
        ASSERT(0);

    if (g_rf_test_gsm_cntx.req_type == RF_TEST_GSM_POWER_SCAN)
        if (arfcn == 9999)
            result = MMI_TRUE;

    /* set the atoi result to global context */
    g_rf_test_gsm_cntx.int_arfcn = arfcn;
    
    return result;
}
#endif /* #ifdef __FLIGHT_MODE_SUPPORT__ */

#if defined(__WIFI_SUPPORT__) 
/**************************************************************
  ***************** WiFi  RF Test *********************************
  **************************************************************/
/**************************************************************
**	FUNCTION NAME		: EMRFTestWiFiASCII2Hex
**
**  PURPOSE				:  
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
MMI_BOOL EMRFTestWiFiASCII2Hex(S8 *buf , U8 len)
{
    U8 i;

    for(i=0;i<len;i++)
    {
        if( buf[i] >='0' && buf[i] <='9' )           /* 0 ~ 9 */
            buf[i] = buf[i] - '0';
        else if (buf[i] >= 'A' && buf[i] <= 'F')     /* A ~ F */
            buf[i] = buf[i] - 'A' + 10; 
        else if (buf[i] >= 'a' && buf[i] <= 'f')     /* a ~ f */
            buf[i] = buf[i] - 'a' + 10;        
        else 
            return MMI_FALSE; 
    }
    return MMI_TRUE;    
}


/**************************************************************
**	FUNCTION NAME		: EMRFTestWiFiInitContext
**
**  PURPOSE				:  
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTestWiFiInitContext(void)
{
    S8 buffer[50];

    sprintf(buffer,"0");
    mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.ant, buffer);
    mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.gain, buffer);
    mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.pktCount, buffer);
    mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.address, buffer);    
    mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.index, buffer);        

    sprintf(buffer,"100");
    mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.pktInterval, buffer);

    sprintf(buffer,"128");
    mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.pktLength, buffer);

    sprintf(buffer,"08020000FFFFFFFFFFFF000822000001FFFFFFFFFFFF1000");
    mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.macHeader, buffer);
    
}


/**************************************************************
**	FUNCTION NAME		: EMRFTestWiFiFillTxCommonReqContext
**
**  PURPOSE				:  
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTestWiFiFillTxCommonReqContext(mmi_eq_rf_test_wifi_req_struct* msg)
{

    if(g_rf_test_wifi_cntx.currRFWifiDomain == EM_RF_WIFI_DOMAIN_US)         /* index = 0 */
    {
        msg->request.wifi_tx_common.contry_code[0]='U';
        msg->request.wifi_tx_common.contry_code[1]='S';
    }
    else if (g_rf_test_wifi_cntx.currRFWifiDomain == EM_RF_WIFI_DOMAIN_JP)  /* index = 1 */
    {
        msg->request.wifi_tx_common.contry_code[0]='J';
        msg->request.wifi_tx_common.contry_code[1]='P';
    }
    else
        ASSERT(0);
    
    msg->request.wifi_tx_common.ch_freq = rf_wifi_tx_ch_freq[g_rf_test_wifi_cntx.currRFWifiChFreq];
    msg->request.wifi_tx_common.tx_rate = (U8)g_rf_test_wifi_cntx.currRFWifiTxRate;
    msg->request.wifi_tx_common.tx_ant = g_rf_test_wifi_cntx.int_ant;
    msg->request.wifi_tx_common.gain = g_rf_test_wifi_cntx.int_gain;
}


/**************************************************************
**	FUNCTION NAME		: EMRFTestWiFiSendReq
**
**  PURPOSE				:  
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTestWiFiSendReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_rf_test_wifi_req_struct *msg_p;
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_p = OslConstructDataPtr(sizeof(mmi_eq_rf_test_wifi_req_struct));

    msg_p->request_type = g_rf_test_wifi_cntx.req_type;
       
    switch(g_rf_test_wifi_cntx.req_type)
    {
        case RF_TEST_WIFI_STOP:
        {
            break;
        }
        case RF_TEST_WIFI_TEST_MODE:
        {
            break;
        }
        case RF_TEST_WIFI_NORMAL_MODE:
        {
            break;       	
        }
        case RF_TEST_WIFI_TX_GET_DAC_OFFSET:
        {
            break;       	
        }
        case RF_TEST_WIFI_TX_OUTPUT_POWER:
        {
            EMRFTestWiFiFillTxCommonReqContext(msg_p);
            break;       	
        }
        case RF_TEST_WIFI_TX_CARRIER_SUPP:
        {
            EMRFTestWiFiFillTxCommonReqContext(msg_p);        
            break;       	
        }
        case RF_TEST_WIFI_TX_LOCAL_FREQ:
        {
            EMRFTestWiFiFillTxCommonReqContext(msg_p);        
            break;       	
        }
        case RF_TEST_WIFI_TX_CONT_PKT:
        {
            if(g_rf_test_wifi_cntx.currRFWifiDomain == EM_RF_WIFI_DOMAIN_US)         /* index = 0 */
            {
                msg_p->request.wifi_tx_cont_pkt.contry_code[0]='U';
                msg_p->request.wifi_tx_cont_pkt.contry_code[1]='S';
            }
            else if (g_rf_test_wifi_cntx.currRFWifiDomain == EM_RF_WIFI_DOMAIN_JP)  /* index = 1 */
            {
                msg_p->request.wifi_tx_cont_pkt.contry_code[0]='J';
                msg_p->request.wifi_tx_cont_pkt.contry_code[1]='P';
            }
            msg_p->request.wifi_tx_cont_pkt.ch_freq = rf_wifi_tx_ch_freq[g_rf_test_wifi_cntx.currRFWifiChFreq];
            msg_p->request.wifi_tx_cont_pkt.tx_rate = (U8)g_rf_test_wifi_cntx.currRFWifiTxRate;
            msg_p->request.wifi_tx_cont_pkt.tx_ant = g_rf_test_wifi_cntx.int_ant;
            msg_p->request.wifi_tx_cont_pkt.gain = g_rf_test_wifi_cntx.int_gain;        
            msg_p->request.wifi_tx_cont_pkt.pkt_count = g_rf_test_wifi_cntx.int_pktcount;
            msg_p->request.wifi_tx_cont_pkt.pkt_interval = g_rf_test_wifi_cntx.int_pktinterval;
            msg_p->request.wifi_tx_cont_pkt.pkt_length = g_rf_test_wifi_cntx.int_pktlength;

            msg_p->request.wifi_tx_cont_pkt.tx_pattern = g_rf_test_wifi_cntx.currRFWifiTxPattern;
            msg_p->request.wifi_tx_cont_pkt.short_peramble= g_rf_test_wifi_cntx.currRFWifiTxShortPeramble;            

            for (i=0; i<24; i++)
                msg_p->request.wifi_tx_cont_pkt.mac_header[i] = g_rf_test_wifi_cntx.hex_mac_header[i];
            
            break;       	
        }
        case RF_TEST_WIFI_RX_CONT_PKT:
        {
            msg_p->request.wifi_rx_cont_pkt.ch_freq = rf_wifi_tx_ch_freq[g_rf_test_wifi_cntx.currRFWifiChFreq];        
            break;       	
        }
        case RF_TEST_WIFI_POWER_SAVE:
        {
            msg_p->request.wifi_power_save.pwr_mgt = (U8)g_rf_test_wifi_cntx.currRFWifiPowerSave;
            break;       	
        }
        case RF_TEST_WIFI_REG_MCR32_WRITE:
        {
            msg_p->request.wifi_mcr32_write.mcr_index = g_rf_test_wifi_cntx.int_address;
            msg_p->request.wifi_mcr32_write.mcr32 = g_rf_test_wifi_cntx.int_data;
            break;       	
        }
        case RF_TEST_WIFI_REG_MCR32_READ:
        {
            msg_p->request.wifi_mcr32_read.mcr_index = g_rf_test_wifi_cntx.int_address;
            break;       	
        }
        case RF_TEST_WIFI_REG_MCR16_WRITE:
        {
            msg_p->request.wifi_mcr16_write.mcr_index = g_rf_test_wifi_cntx.int_address;
            msg_p->request.wifi_mcr16_write.mcr16 = (U16)g_rf_test_wifi_cntx.int_data;
            break;       	
        }
        case RF_TEST_WIFI_REG_MCR16_READ:
        {
            msg_p->request.wifi_mcr16_read.mcr_index = g_rf_test_wifi_cntx.int_address;
            break;       	
        }
        case RF_TEST_WIFI_REG_BBCR_WRITE:
        {
            msg_p->request.wifi_bbcr_write.bbcr_index = g_rf_test_wifi_cntx.int_index;
            msg_p->request.wifi_bbcr_write.bbcr = (U8)g_rf_test_wifi_cntx.int_data;
            break;       	
        }
        case RF_TEST_WIFI_REG_BBCR_READ:
        {
           msg_p->request.wifi_bbcr_read.bbcr_index = g_rf_test_wifi_cntx.int_index;        
            break;       	
        }
        case RF_TEST_WIFI_REG_EEPROM_WRITE:
        {
            msg_p->request.wifi_eeprom_write.eeprom_index = g_rf_test_wifi_cntx.int_address;
            msg_p->request.wifi_eeprom_write.eeprom = (U16)g_rf_test_wifi_cntx.int_data;
            break;       	
        }
        case RF_TEST_WIFI_REG_EEPROM_READ:
        {
            msg_p->request.wifi_eeprom_read.eeprom_index = g_rf_test_wifi_cntx.int_address;        
            break;       	
        }
  	 default:
	     ASSERT(0);
            break;
    }

    EngineerModeSendMsg(MSG_ID_MMI_EQ_RF_TEST_WIFI_REQ, msg_p, NULL);
    
}


/**************************************************************
**	FUNCTION NAME		: EMRFTestWifiSendRes
**
** 	PURPOSE				: RF Test WiFi send request response function. 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTestWifiSendRes(void* inMsg)
{
    mmi_eq_rf_test_wifi_rsp_struct *rsp_p = inMsg;

    switch(rsp_p->request_type)
    {
        case RF_TEST_WIFI_STOP:
        {
            break;
        }
        case RF_TEST_WIFI_TEST_MODE:
        {
            break;
        }
        case RF_TEST_WIFI_NORMAL_MODE:
        {
            break;       	
        }
        case RF_TEST_WIFI_TX_GET_DAC_OFFSET:
        {
            EntryEmRFTestWiFiTXDACOffsetRsp(rsp_p->request.wifi_get_dac.ich, rsp_p->request.wifi_get_dac.qch);
            break;       	
        }
        case RF_TEST_WIFI_TX_OUTPUT_POWER:
        {
            break;       	
        }
        case RF_TEST_WIFI_TX_CARRIER_SUPP:
        {
            break;       	
        }
        case RF_TEST_WIFI_TX_LOCAL_FREQ:
        {
            break;       	
        }
        case RF_TEST_WIFI_TX_CONT_PKT:
        {
            break;       	
        }
        case RF_TEST_WIFI_RX_CONT_PKT:
        {
            EntryEmRFTestWiFiRXContPKTRsp((U8 *)&(rsp_p->request.wifi_rx_cont_pkt));    
            break;       	
        }
        case RF_TEST_WIFI_POWER_SAVE:
        {
            break;       	
        }
        case RF_TEST_WIFI_REG_MCR32_WRITE:
        {
            break;       	
        }
        case RF_TEST_WIFI_REG_MCR32_READ:
        {
            EntryEmRFTestWiFiRegMCRAccessRsp(rsp_p->request.wifi_mcr32_read.mcr32);
            break;       	
        }
        case RF_TEST_WIFI_REG_MCR16_WRITE:
        {
            break;       	
        }
        case RF_TEST_WIFI_REG_MCR16_READ:
        {
            EntryEmRFTestWiFiRegMCRAccessRsp(rsp_p->request.wifi_mcr16_read.mcr16);
            break;       	
        }
        case RF_TEST_WIFI_REG_BBCR_WRITE:
        {
            break;       	
        }
        case RF_TEST_WIFI_REG_BBCR_READ:
        {
            EntryEmRFTestWiFiRegBBCRAccessRsp(rsp_p->request.wifi_bbcr_read.bbcr);
            break;       	
        }
        case RF_TEST_WIFI_REG_EEPROM_WRITE:
        {
            break;       	
        }
        case RF_TEST_WIFI_REG_EEPROM_READ:
        {
            EntryEmRFTestWiFiRegEEPROMAccessRsp(rsp_p->request.wifi_eeprom_read.eeprom);
            break;       	
        }
        default:
            ASSERT(0);
            break;
    }

 }



/**************************************************************

	FUNCTION NAME		: EmStopRFTestWiFi()

  	PURPOSE				: Stop Em RF Test WIFI request

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EmStopRFTestWiFi(void)
{
    if (g_rf_test_wifi_cntx.request_processing == MMI_TRUE)
    {
        g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_STOP;
        g_rf_test_wifi_cntx.request_processing = MMI_FALSE;
        EMRFTestWiFiSendReq();        
    }
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFi
**
**  	PURPOSE				: Highlight function for RF Test WiFi menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFi(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryRFTestWifiEnterCondirm, KEY_EVENT_UP);    

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryRFTestWifiEnterCondirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryRFTestWifiEnterCondirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayConfirm(
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        get_string(EM_RF_TEST_GSM_CONFIRM_NOTIFY_TEST) ,
        IMG_GLOBAL_INFO,
        WARNING_TONE);

    SetLeftSoftkeyFunction(EmRFTestWifiEnterTestMode, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EmRFTestWifiEnterTestMode
**
**  PURPOSE				: Enter RF Test WiFi Test Mode
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EmRFTestWifiEnterTestMode(void)
{
    extern void mmi_em_enter_flight_mode(FuncPtr callback);
    
    /* set request type = WiFi Test Mode*/    
    g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_TEST_MODE;
    
    /* Send request to RF */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();

    mmi_em_enter_flight_mode((FuncPtr)EntryEmRFTestWiFi);

    /* only for Temp test */
//    EntryEmRFTestWiFi();

}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFi
**
**  PURPOSE				: Enrty function for RF Test WiFi menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFi(void)
{
    U16	ItemList[8];
    U16	ItemIcons[8];
    U16	nItems;
    U8*	guiBuffer;
    U8*	PopUpList[8];
    S32	i;

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();
    
    EntryNewScreen(EM_RF_TEST_WIFI_SCR, NULL, EntryEmRFTestWiFi, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_SCR);
    nItems = GetNumOfChild(EM_RF_TEST_WIFI_MENUID);
    GetSequenceStringIds(EM_RF_TEST_WIFI_MENUID, ItemList);
    SetParentHandler(EM_RF_TEST_WIFI_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for(i=0;i<nItems;i++)
    {
        PopUpList[i]=NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1+i);
    }

    ShowCategory52Screen(EM_RF_TEST_WIFI_TEST,0,
							STR_GLOBAL_OK,0,
							STR_GLOBAL_BACK,0,
							nItems, ItemList, ItemIcons, (U8**) PopUpList, 0, 0, guiBuffer);

    SetRightSoftkeyFunction(EmRFTestWifiExitTestMode,KEY_EVENT_UP);

    /* Register END key handler */
    SetKeyHandler(EmRFTestWifiExitTestMode,KEY_END,KEY_EVENT_DOWN);
    
}


/**************************************************************
**	FUNCTION NAME		: EmRFTestWifiExitTestMode
**
**  PURPOSE				: RF Test WiFi menu Exit Test Mode
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EmRFTestWifiExitTestMode(void)
{
    extern void ShutdownSystemOperation(void);

    ShutdownSystemOperation();
}

  
/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiTxTest
**
**  PURPOSE				: Highlight function for RF Test WiFi Tx Tests menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiTxTest(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxTest, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiTxTest
**
**  PURPOSE				: Enrty function for RF Test WiFi Tx Text menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiTxTest(void)
{
    U16		ItemList[8];
    U16		ItemIcons[8];
    U16		nItems;
    U8*		guiBuffer;
    U8*		PopUpList[8];
    S32		i;

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();
    
    EntryNewScreen(EM_RF_TEST_WIFI_TX_TEST_SCR, NULL, EntryEmRFTestWiFiTxTest, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_TEST_SCR);
	
    nItems = GetNumOfChild(EM_RF_WIFI_TX_TESTS_MENUID);
    GetSequenceStringIds(EM_RF_WIFI_TX_TESTS_MENUID, ItemList);
    SetParentHandler(EM_RF_WIFI_TX_TESTS_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for(i=0;i<nItems;i++)
    {
        PopUpList[i]=NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1+i);
    }

    ShowCategory52Screen(EM_RF_WIFI_TX_TESTS_TEXT,0,
							STR_GLOBAL_OK,0,
							STR_GLOBAL_BACK,0,
							nItems, ItemList, ItemIcons, (U8**) PopUpList, 0, 0, guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory,KEY_EVENT_UP);

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiTXDACOffset
**
**  PURPOSE				: Highlight function for RF Test WiFi TX DAC Offset menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiTXDACOffset(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EmRFTestWiFiTXDACOffset, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************

	FUNCTION NAME		: EmRFTestWiFiTXADCOffset

  	PURPOSE				: Get WiFi TX DAC Offset

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EmRFTestWiFiTXDACOffset(void) 
{
    /* set request type = WiFi TX GET DAC OFFSET*/    
    g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_TX_GET_DAC_OFFSET;
    
    /* Send request to RF */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();

}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiTXDACOffsetRsp
**
**  PURPOSE				: Enrty function for RF Test WiFi Tx DAC Offset menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiTXDACOffsetRsp(U8 ich, U8 qch)
{
    U8* guiBuffer;
    S8 buffer[32];
    U8 nItems = 2;
    
    EntryNewScreen(EM_RF_TEST_WIFI_TX_DAC_OFFSET_SCR, NULL, NULL, NULL);
    guiBuffer = GetCurrGuiBuffer (EM_RF_TEST_WIFI_TX_DAC_OFFSET_SCR);		 

    sprintf(buffer,"I CH :  %d", ich);
    mmi_asc_to_ucs2((PS8)subMenuData[0], buffer);
    subMenuDataPtrs[0] = subMenuData[0];

    sprintf(buffer,"Q CH :  %d", qch);
    mmi_asc_to_ucs2((PS8)subMenuData[1], buffer);
    subMenuDataPtrs[1] = subMenuData[1];
    
    ShowCategory6Screen (EM_RF_WIFI_TX_DAC_OFFSET_TEXT, 0,
						  0, 0, STR_GLOBAL_BACK, 0,
						  nItems, (PU8*)subMenuDataPtrs,NULL, 0,
						  guiBuffer); 
						  
    SetRightSoftkeyFunction (GoBackHistory, KEY_EVENT_UP);

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiTXOutputPower
**
**  PURPOSE				: Highlight function for RF Test WiFi TX Output Power menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiTXOutputPower(void)
{
    /* Register function for left soft key */
	SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxOutputPower, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiTxOutputPower
**
**  PURPOSE				: Enrty function for RF Test WiFi TX Output Power
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiTxOutputPower(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[10];
    U8  i;

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    /* set request type = WiFi TX OUTPUT POWER */    
    g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_TX_OUTPUT_POWER;    
    
    EntryNewScreen(EM_RF_TEST_WIFI_TX_OUTPUT_POWER_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_OUTPUT_POWER_SCR);
    RegisterHighlightHandler(HighlightHandlerRFWifiTxOutputPowerInline);

    EMRFWifiTxFillInlineStruct();
    
    for (i=0 ; i<14 ; i++)
    {
        if (i%2)   
            ImageList[i] = 0;                  /* odd */
        else
            ImageList[i] = IMG_STATUS; /* even */
    }

    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_TX_OUTPUT_POWER_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    10, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiTxOutputPowerInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiTxOutputPowerInline(S32 index) 
{
    if ( g_rf_test_wifi_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFTESTWifiTXOutputPowerCheckAndSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxOutputPower, KEY_EVENT_UP);
    }
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiTXOutputPowerCheckAndSendReq
**
**  PURPOSE				: RF Test Wifi Output Power Check & Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiTXOutputPowerCheckAndSendReq(void)
{
    MMI_BOOL result;

    /* to check the parameters is valid and send the request */
    result = EMRFWifiTXCommonCheckAndSendReq();

    /* show RF Test WiFi TX Output Power Done screen */
    if (result == MMI_TRUE)
        EntryEMRFTESTWifiTXOutputPowerDone();    
}


/**************************************************************
**	FUNCTION NAME		: EntryEMRFTESTWifiTXOutputPowerDone
**
**  PURPOSE				: Enrty function for RF Test Wifi Output Power Done
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEMRFTESTWifiTXOutputPowerDone(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[10];
    U8 i;

    EntryNewScreen(EM_RF_TEST_WIFI_TX_OUTPUT_POWER_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_OUTPUT_POWER_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiTxOutputPowerInline);
    
    EMRFWifiTxFillInlineStructForView();
    
    for (i=0 ; i<14 ; i++)
    {
        if (i%2)                    
            ImageList[i] = 0;                    /* odd */
        else
            ImageList[i] = IMG_STATUS;   /* even */
    }

    ShowCategory57Screen(EM_RF_WIFI_TX_OUTPUT_POWER_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    10, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
#endif
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiTXCarrierSupp
**
**  PURPOSE				: Highlight function for RF Test WiFi TX Carrier Supp menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiTXCarrierSupp(void)
{
    /* Register function for left soft key */
	SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxCarrierSupp, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiTxCarrierSupp
**
**  PURPOSE				: Enrty function for RF Test WiFi TX Carrier Supp
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiTxCarrierSupp(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[10];
    U8  i;

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    /* set request type = WiFi TX Caerrier Supp */    
    g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_TX_CARRIER_SUPP;  
    
    EntryNewScreen(EM_RF_TEST_WIFI_TX_CARRIER_SUPP_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_CARRIER_SUPP_SCR);
    RegisterHighlightHandler(HighlightHandlerRFWifiTxCarrierSuppInline);

    EMRFWifiTxFillInlineStruct();
    
    for (i=0 ; i<14 ; i++)
    {
        if (i%2)   
            ImageList[i] = 0;                    /* odd */
        else
            ImageList[i] = IMG_STATUS;   /* even */
    }

    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_TX_CARRIER_SUPP_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    10, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiTxCarrierSuppInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiTxCarrierSuppInline(S32 index) 
{
    if ( g_rf_test_wifi_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFTESTWifiTXCarrierSuppCheckAndSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxCarrierSupp, KEY_EVENT_UP);
    }
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiTXCarrierSuppCheckAndSendReq
**
**  PURPOSE				:  RF Test Wifi Carrier Supp Check & Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiTXCarrierSuppCheckAndSendReq(void)
{
    MMI_BOOL result;
    
    /* to check the parameters is valid and send the request */
    result = EMRFWifiTXCommonCheckAndSendReq();
    
    /* show RF Test WiFi TX Carrier Supp. Done screen */
    if (result == MMI_TRUE)
        EntryEMRFTESTWifiTXCarrierSuppDone();    
}


/**************************************************************
**	FUNCTION NAME		: EntryEMRFTESTWifiTXCarrierSuppDone
**
**  PURPOSE				: Enrty function for RF Test Wifi Carrier Supp Done
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEMRFTESTWifiTXCarrierSuppDone(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[10];
    U8 i;

    EntryNewScreen(EM_RF_TEST_WIFI_TX_CARRIER_SUPP_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_CARRIER_SUPP_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiTxCarrierSuppInline);
    
    EMRFWifiTxFillInlineStructForView();
    
    for (i=0 ; i<14 ; i++)
    {
        if (i%2)   
            ImageList[i] = 0;                    /* odd */
        else
            ImageList[i] = IMG_STATUS;   /* even */
    } 

    ShowCategory57Screen(EM_RF_WIFI_TX_CARRIER_SUPP_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    10, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
#endif
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiTXLocalFreq
**
**  PURPOSE				: Highlight function for RF Test WiFi TX Local Freq. menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiTXLocalFreq(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxLocalFreq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiTxLocalFreq
**
**  PURPOSE				: Enrty function for RF Test WiFi TX Local Frequency
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiTxLocalFreq(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[10];
    U8  i;

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    /* set request type = WiFi TX Local Freq. */    
    g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_TX_LOCAL_FREQ;
    
    EntryNewScreen(EM_RF_TEST_WIFI_TX_LOCAL_FREQ_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_LOCAL_FREQ_SCR);
    RegisterHighlightHandler(HighlightHandlerRFWifiTxLocalFreqInline);

    EMRFWifiTxFillInlineStruct();
    
    for (i=0 ; i<14 ; i++)
    {
        if (i%2)   
            ImageList[i] = 0;                     /* odd */
        else
            ImageList[i] = IMG_STATUS;    /* even */
    }

    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_TX_LOCAL_FREQUENCY_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    10, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiTxLocalFreqInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiTxLocalFreqInline(S32 index) 
{
    if ( g_rf_test_wifi_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFTESTWifiTXLocalFreqCheckAndSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxLocalFreq, KEY_EVENT_UP);
    }
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiTXLocalFreqCheckAndSendReq
**
**  PURPOSE				:  RF Test Wifi Local Frequency Check & Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiTXLocalFreqCheckAndSendReq(void)
{
    MMI_BOOL result;
    
    /* to check the parameters is valid and send the request */
    result = EMRFWifiTXCommonCheckAndSendReq();
    
    /* show RF Test WiFi TX Local Freq. Done screen */
    if (result == MMI_TRUE)
        EntryEMRFTESTWifiTXLocalFreqDone();    
}


/**************************************************************
**	FUNCTION NAME		: EntryEMRFTESTWifiTXLocalFreqDone
**
**  PURPOSE				: Enrty function for RF Test Wifi Local Freq. Done
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEMRFTESTWifiTXLocalFreqDone(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[10];
    U8 i;

    EntryNewScreen(EM_RF_TEST_WIFI_TX_LOCAL_FREQ_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_LOCAL_FREQ_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiTxLocalFreqInline);
    
    EMRFWifiTxFillInlineStructForView();
    
    for (i=0 ; i<14 ; i++)
    {
        if (i%2)   
            ImageList[i] = 0;                      /* odd */
        else
            ImageList[i] = IMG_STATUS;     /* even*/
    }

    ShowCategory57Screen(EM_RF_WIFI_TX_LOCAL_FREQUENCY_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    10, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
#endif
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiTXContPKT
**
**  PURPOSE				: Highlight function for RF Test WiFi TX Cont. PKT menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiTXContPKT(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxContPKT, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiTxContPKT
**
**  PURPOSE				: Enrty function for RF Test WiFi TX Cont. PKT 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiTxContPKT(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];
    U8  i;

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    /* set request type = WiFi TX CONT PKT */    
    g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_TX_CONT_PKT;
    
    EntryNewScreen(EM_RF_TEST_WIFI_TX_CONT_PKT_TX_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_CONT_PKT_TX_SCR);
    RegisterHighlightHandler(HighlightHandlerRFWifiTxContPKTInline);

    EMRFWifiTxFillInlineStruct();

    /* PKT Count */
    SetInlineItemActivation(&wgui_inline_items[10], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[10], (U8*)GetString(EM_RF_WIFI_TX_PKT_COUNT_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[11], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[11], (PU8)g_rf_test_wifi_cntx.pktCount, 11, INPUT_TYPE_NUMERIC);

    /* PKT Interval */
    SetInlineItemActivation(&wgui_inline_items[12], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[12], (U8*)GetString(EM_RF_WIFI_TX_PKT_INTERVAL_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[13], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[13], (PU8)g_rf_test_wifi_cntx.pktInterval, 5, INPUT_TYPE_NUMERIC);

    /* PKT Length */
    SetInlineItemActivation(&wgui_inline_items[14], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[14], (U8*)GetString(EM_RF_WIFI_TX_PKT_LENGTH_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[15], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[15], (PU8)g_rf_test_wifi_cntx.pktLength, 5, INPUT_TYPE_NUMERIC);

    /* TX Pattern */
    SetInlineItemActivation(&wgui_inline_items[16], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[16], (U8*)GetString(EM_RF_WIFI_TX_PATTERN_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiTxPattern[0] = (U8*) GetString(EM_RF_WIFI_TX_PATTERN_ALL_0_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxPattern[1] = (U8*) GetString(EM_RF_WIFI_TX_PATTERN_ALL_1_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxPattern[2] = (U8*) GetString(EM_RF_WIFI_TX_PATTERN_ALTER_BITS_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxPattern[3] = (U8*) GetString(EM_RF_WIFI_TX_PATTERN_RANDOM_TEXT);
    SetInlineItemActivation(&wgui_inline_items[17], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[17], 4, (U8**)g_rf_test_wifi_cntx.pEMRFWifiTxPattern, &g_rf_test_wifi_cntx.currRFWifiTxPattern);

    /* Short Peramble */
    SetInlineItemActivation(&wgui_inline_items[18], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[18], (U8*)GetString(EM_RF_WIFI_TX_SHORT_PERAMBLE_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiTxShortPeramble[0] = (U8*) GetString(EM_RF_WIFI_TX_SHORT_PERAMBLE_TRUE_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxShortPeramble[1] = (U8*) GetString(EM_RF_WIFI_TX_SHORT_PERAMBLE_FALSE_TEXT);
    SetInlineItemActivation(&wgui_inline_items[19], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[19], 2, (U8**)g_rf_test_wifi_cntx.pEMRFWifiTxShortPeramble, &g_rf_test_wifi_cntx.currRFWifiTxShortPeramble);

   /* MAC Header */
    SetInlineItemActivation(&wgui_inline_items[20], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[20], (U8*)GetString(EM_RF_WIFI_TX_MAC_HEADER_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[21], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[21], (PU8)g_rf_test_wifi_cntx.macHeader, 49, INPUT_TYPE_ALPHANUMERIC_LOWERCASE);

    for (i=0 ; i<22 ; i++)
    {
        if (i%2)   
            ImageList[i] = 0;                      /* odd */
        else
            ImageList[i] = IMG_STATUS;     /* even */
    }

    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_TX_CONT_PKT_TX_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    22, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiTxContPKTInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiTxContPKTInline(S32 index) 
{
    if ( g_rf_test_wifi_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFTESTWifiTXContPKTCheckAndSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestWiFiTxContPKT, KEY_EVENT_UP);
    }
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiTXContPKTCheckAndSendReq
**
**  PURPOSE				:  RF Test Wifi Tx Cont. PKT Check & Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiTXContPKTCheckAndSendReq(void)
{
    S8  textbuf[48];
    MMI_BOOL result = MMI_TRUE;
    U8  ant , gain=0 , i, len;
    U32 count, interval, length;

    CloseCategory57Screen();
    
    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.ant)
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.gain)
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.pktCount)
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.pktInterval)
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.pktLength))
        result = MMI_FALSE;

    /* To check if ANT is valid */    
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.ant);
    ant = atoi((const char *) textbuf);
    if ( (ant != 0 ) && (ant != 1))
        result = MMI_FALSE;
    
    if (result == MMI_TRUE)
    {
        /* To check if GAIN is valid , ansii to hex */
        mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.gain);
        len = strlen(textbuf);
        result = EMRFTestWiFiASCII2Hex(textbuf, len);
        for (i=0 ; i<len; i++)
            gain |= textbuf[i]<<4*(len-i-1);
        
        if (gain > 0x3F)
            result = MMI_FALSE;
    }

    /* To check if Interval is valid */
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.pktInterval);
    interval = atoi((const char *) textbuf);
    if (interval < 30 || interval > 5410)
        result = MMI_FALSE;     
    
    /* To check if Length is valid */
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.pktLength);
    length = atoi((const char *) textbuf);
    if (length < 24 || length > 1500)
        result = MMI_FALSE;     
    
    /* To check if macHeader is valid */
    if (  mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.macHeader) != 48)
        result = MMI_FALSE;     
    
    if (result == MMI_TRUE)
    {
        /* Re-convert MAC header. And check if it is valid.  */            
        mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.macHeader);
        len = strlen(textbuf);
        result = EMRFTestWiFiASCII2Hex(textbuf, len);
        for (i=0 ; i < len/2; i++)
            g_rf_test_wifi_cntx.hex_mac_header[i] = (textbuf[2*i]<<4) | textbuf[2*i+1];
    }
    
    /* If one of the parameters is invalid, then pop-up error and return */
    if (result == MMI_FALSE)
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
 	 DeleteScreenIfPresent(EM_RF_TEST_WIFI_TX_CONT_PKT_TX_SCR);
 	 return;
    }

    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.pktCount);
    count = atoi((const char *) textbuf);

    /* set the atoi result to global context */
    g_rf_test_wifi_cntx.int_ant = ant;
    g_rf_test_wifi_cntx.int_gain = gain;
    g_rf_test_wifi_cntx.int_pktcount = count;
    g_rf_test_wifi_cntx.int_pktinterval = interval;
    g_rf_test_wifi_cntx.int_pktlength = length;    
    
    /* Send request to RF */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();

    /* show RF Test WiFi TX Cont. PKT Done screen */
    EntryEMRFTESTWifiTXContPKTDone();    
}


/**************************************************************
**	FUNCTION NAME		: EntryEMRFTESTWifiTXContPKTDone
**
**  PURPOSE				: Enrty function for RF Test Wifi Cont PKT Done
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEMRFTESTWifiTXContPKTDone(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];
    U8 i;

    EntryNewScreen(EM_RF_TEST_WIFI_TX_CONT_PKT_TX_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_TX_CONT_PKT_TX_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiTxContPKTInline);
    
    EMRFWifiTxFillInlineStructForView();

    /* PKT Count */
    SetInlineItemActivation(&wgui_inline_items[10], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[10], (U8*)GetString(EM_RF_WIFI_TX_PKT_COUNT_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[11], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[11], (PU8)g_rf_test_wifi_cntx.pktCount);

    /* PKT Interval */
    SetInlineItemActivation(&wgui_inline_items[12], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[12], (U8*)GetString(EM_RF_WIFI_TX_PKT_INTERVAL_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[13], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[13], (PU8)g_rf_test_wifi_cntx.pktInterval);

    /* PKT Length */
    SetInlineItemActivation(&wgui_inline_items[14], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[14], (U8*)GetString(EM_RF_WIFI_TX_PKT_LENGTH_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[15], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[15], (PU8)g_rf_test_wifi_cntx.pktLength);

    /* TX Pattern */
    SetInlineItemActivation(&wgui_inline_items[16], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[16], (U8*)GetString(EM_RF_WIFI_TX_PATTERN_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiTxPattern[0] = (U8*) GetString(EM_RF_WIFI_TX_PATTERN_ALL_0_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxPattern[1] = (U8*) GetString(EM_RF_WIFI_TX_PATTERN_ALL_1_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxPattern[2] = (U8*) GetString(EM_RF_WIFI_TX_PATTERN_ALTER_BITS_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxPattern[3] = (U8*) GetString(EM_RF_WIFI_TX_PATTERN_RANDOM_TEXT);
    SetInlineItemActivation(&wgui_inline_items[17], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[17], (U8*)g_rf_test_wifi_cntx.pEMRFWifiTxPattern[g_rf_test_wifi_cntx.currRFWifiTxPattern]);

    /* Short Peramble */
    SetInlineItemActivation(&wgui_inline_items[18], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[18], (U8*)GetString(EM_RF_WIFI_TX_SHORT_PERAMBLE_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiTxShortPeramble[0] = (U8*) GetString(EM_RF_WIFI_TX_SHORT_PERAMBLE_TRUE_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxShortPeramble[1] = (U8*) GetString(EM_RF_WIFI_TX_SHORT_PERAMBLE_FALSE_TEXT);
    SetInlineItemActivation(&wgui_inline_items[19], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[19], (U8*)g_rf_test_wifi_cntx.pEMRFWifiTxShortPeramble[g_rf_test_wifi_cntx.currRFWifiTxShortPeramble]);

   /* MAC Header */
    SetInlineItemActivation(&wgui_inline_items[20], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[20], (U8*)GetString(EM_RF_WIFI_TX_MAC_HEADER_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[21], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[21], (PU8)g_rf_test_wifi_cntx.macHeader);
    
    for (i=0 ; i<22 ; i++)
    {
        if (i%2)   
            ImageList[i] = 0;                          /* odd */
        else
            ImageList[i] = IMG_STATUS;         /* even */
    }

    ShowCategory57Screen(EM_RF_WIFI_TX_CONT_PKT_TX_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    22, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
#endif
}


/**************************************************************

	FUNCTION NAME		: EMRFWifiTXCommonCheckAndSendReq

  	PURPOSE				: Check RF Wifi TX Common parameter

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
MMI_BOOL EMRFWifiTXCommonCheckAndSendReq(void) 
{
    S8  textbuf[20];
    MMI_BOOL result = MMI_TRUE;
    U8  ant , gain = 0 , i , len;

    CloseCategory57Screen();
    
    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.ant)
           ||  !mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.gain))
        result = MMI_FALSE;

    /* To check if ANT is valid */    
    mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.ant);
    ant = atoi((const char *) textbuf);
    if ( (ant != 0 ) && (ant != 1))
        result = MMI_FALSE;

    if (result == MMI_TRUE)
    {
        /* To check if GAIN is valid , ansii to hex */
        mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.gain);
        len = strlen(textbuf);
        result = EMRFTestWiFiASCII2Hex(textbuf, len);
        for (i=0 ; i<len; i++)
            gain |= textbuf[i]<<4*(len-i-1);
        
        if (gain > 0x3F)
            result = MMI_FALSE;
    }

    /* If one of the parameters is invalid, then pop-up error and return */
    if (result ==MMI_FALSE)
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
 	 DeleteScreenIfPresent(EM_RF_TEST_WIFI_TX_CONT_PKT_TX_SCR);
 	 return result;
    }

    /* set the atoi result to global context */
    g_rf_test_wifi_cntx.int_ant = ant;
    g_rf_test_wifi_cntx.int_gain = gain;

    /* Send request to RF */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();

    return result;
}


/**************************************************************
**	FUNCTION NAME		: EMRFWifiTxFillInlineStruct
**
**  PURPOSE				: To Fill Inline struct of RF WIFI Test
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFWifiTxFillInlineStruct(void)
{
    /* Domain */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_TX_DOMAIN_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiDomain[0] = (U8*)GetString(EM_RF_WIFI_TX_DOMAIN_US_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiDomain[1] = (U8*)GetString(EM_RF_WIFI_TX_DOMAIN_JP_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 2, (U8**)g_rf_test_wifi_cntx.pEMRFWifiDomain, &g_rf_test_wifi_cntx.currRFWifiDomain);
    
    /* CH Freq */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_WIFI_TX_CH_FREQ_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[0] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_1_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[1] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_2_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[2] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_3_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[3] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_4_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[4] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_5_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[5] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_6_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[6] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_7_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[7] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_8_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[8] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_9_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[9] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_10_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[10] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_11_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[11] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_12_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[12] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_13_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[13] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_14_TEXT);
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[3], 14, (U8**)g_rf_test_wifi_cntx.pEMRFWifiChFreq, &g_rf_test_wifi_cntx.currRFWifiChFreq);

    /* TX Rate */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_WIFI_TX_RATE_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[0] = (U8*) GetString(EM_RF_WIFI_TX_RATE_1_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[1] = (U8*) GetString(EM_RF_WIFI_TX_RATE_2_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[2] = (U8*) GetString(EM_RF_WIFI_TX_RATE_3_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[3] = (U8*) GetString(EM_RF_WIFI_TX_RATE_4_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[4] = (U8*) GetString(EM_RF_WIFI_TX_RATE_5_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[5] = (U8*) GetString(EM_RF_WIFI_TX_RATE_6_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[6] = (U8*) GetString(EM_RF_WIFI_TX_RATE_7_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[7] = (U8*) GetString(EM_RF_WIFI_TX_RATE_8_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[8] = (U8*) GetString(EM_RF_WIFI_TX_RATE_9_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[9] = (U8*) GetString(EM_RF_WIFI_TX_RATE_10_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[10] = (U8*) GetString(EM_RF_WIFI_TX_RATE_11_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[11] = (U8*) GetString(EM_RF_WIFI_TX_RATE_12_TEXT);
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[5], 12, (U8**)g_rf_test_wifi_cntx.pEMRFWifiTxRate, &g_rf_test_wifi_cntx.currRFWifiTxRate);

    /* TxAnt */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_RF_WIFI_TX_ANT_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[7], (PU8)g_rf_test_wifi_cntx.ant, 2, INPUT_TYPE_NUMERIC);

    /* Gain */
    SetInlineItemActivation(&wgui_inline_items[8], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[8], (U8*)GetString(EM_RF_WIFI_TX_GAIN_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[9], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[9], (PU8)g_rf_test_wifi_cntx.gain, 3, INPUT_TYPE_ALPHANUMERIC_LOWERCASE);

}


/**************************************************************
**	FUNCTION NAME		: EMRFWifiTxFillInlineStructForView
**
**  PURPOSE				: To Fill Inline struct of RF WIFI Test for View
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFWifiTxFillInlineStructForView(void)
{
    /* Domain */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_TX_DOMAIN_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiDomain[0] = (U8*)GetString(EM_RF_WIFI_TX_DOMAIN_US_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiDomain[1] = (U8*)GetString(EM_RF_WIFI_TX_DOMAIN_JP_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[1], (U8*)g_rf_test_wifi_cntx.pEMRFWifiDomain[g_rf_test_wifi_cntx.currRFWifiDomain]);
    
    /* CH Freq */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_WIFI_TX_CH_FREQ_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[0] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_1_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[1] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_2_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[2] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_3_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[3] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_4_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[4] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_5_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[5] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_6_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[6] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_7_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[7] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_8_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[8] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_9_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[9] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_10_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[10] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_11_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[11] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_12_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[12] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_13_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[13] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_14_TEXT);
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[3], (U8*)g_rf_test_wifi_cntx.pEMRFWifiChFreq[g_rf_test_wifi_cntx.currRFWifiChFreq]);
    
    /* TX Rate */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_WIFI_TX_RATE_TEXT));
    
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[0] = (U8*) GetString(EM_RF_WIFI_TX_RATE_1_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[1] = (U8*) GetString(EM_RF_WIFI_TX_RATE_2_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[2] = (U8*) GetString(EM_RF_WIFI_TX_RATE_3_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[3] = (U8*) GetString(EM_RF_WIFI_TX_RATE_4_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[4] = (U8*) GetString(EM_RF_WIFI_TX_RATE_5_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[5] = (U8*) GetString(EM_RF_WIFI_TX_RATE_6_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[6] = (U8*) GetString(EM_RF_WIFI_TX_RATE_7_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[7] = (U8*) GetString(EM_RF_WIFI_TX_RATE_8_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[8] = (U8*) GetString(EM_RF_WIFI_TX_RATE_9_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[9] = (U8*) GetString(EM_RF_WIFI_TX_RATE_10_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[10] = (U8*) GetString(EM_RF_WIFI_TX_RATE_11_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiTxRate[11] = (U8*) GetString(EM_RF_WIFI_TX_RATE_12_TEXT);
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[5], (U8*)g_rf_test_wifi_cntx.pEMRFWifiTxRate[g_rf_test_wifi_cntx.currRFWifiTxRate]);

    /* TxAnt */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_RF_WIFI_TX_ANT_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[7], (PU8)g_rf_test_wifi_cntx.ant);

    /* Gain */
    SetInlineItemActivation(&wgui_inline_items[8], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[8], (U8*)GetString(EM_RF_WIFI_TX_GAIN_TEXT));
           
    SetInlineItemActivation(&wgui_inline_items[9], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[9], (PU8)g_rf_test_wifi_cntx.gain);

}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiContPKTRx
**
**  	PURPOSE				: Highlight function for RF Test WiFi Cont PKT Rx menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiContPKTRx(void)
{
    /* Register function for left soft key */
	SetLeftSoftkeyFunction(EntryEmRFTestWiFiRxContPKT, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRxContPKT
**
**  	PURPOSE				: Enrty function for RF Test WiFi RX Cont. PKT 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRxContPKT(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    /* set request type = WiFi RX CONT PKT */    
    g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_RX_CONT_PKT;
    
    EntryNewScreen(EM_RF_TEST_WIFI_CONT_PKT_RX_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_CONT_PKT_RX_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiRxContPKTInline);    

    /* CH Freq */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_TX_CH_FREQ_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[0] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_1_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[1] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_2_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[2] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_3_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[3] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_4_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[4] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_5_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[5] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_6_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[6] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_7_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[7] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_8_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[8] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_9_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[9] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_10_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[10] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_11_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[11] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_12_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[12] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_13_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiChFreq[13] = (U8*) GetString(EM_RF_WIFI_TX_CH_FREQ_14_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 14, (U8**)g_rf_test_wifi_cntx.pEMRFWifiChFreq, &g_rf_test_wifi_cntx.currRFWifiChFreq);
    ImageList[1] = 0;

    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_CONT_PKT_RX_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    2, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiRxContPKTInline
**
**  	PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiRxContPKTInline(S32 index) 
{
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(EMRFTESTWifiRXContPKTSendReq, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiRXContPKTSendReq
**
**  PURPOSE				:  RF Test Wifi Rx Cont. PKT Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiRXContPKTSendReq(void)
{
    /* Send request to RF , now req_type = RF_TEST_WIFI_RX_CONT_PKT */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRXContPKTRsp
**
**  PURPOSE				: Enrty function for RF Test WiFi Rx Cont PKT menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRXContPKTRsp(U8 *rsp)
{
    U8* guiBuffer;
    S8 buffer[32];
    U8 nItems = 13;
    rf_test_wifi_rx_cont_pkt_struct *p = (rf_test_wifi_rx_cont_pkt_struct *)rsp;
    
    EntryNewScreen(EM_RF_TEST_WIFI_CONT_PKT_RX_DONE_SCR, NULL, NULL, NULL);
    guiBuffer = GetCurrGuiBuffer (EM_RF_TEST_WIFI_CONT_PKT_RX_DONE_SCR);		 

    RegisterHighlightHandler(SetHighlightIndex);

    if (p->pau_total == 0)
        sprintf(buffer,"FER (%%) :  0");
    else
        sprintf(buffer,"FER (%%) :  %d", (p->pau_err*100)/p->pau_total);
    mmi_asc_to_ucs2((PS8)subMenuData[0], buffer);
    subMenuDataPtrs[0] = subMenuData[0];

    sprintf(buffer,"PAU Total :  %d", p->pau_total);
    mmi_asc_to_ucs2((PS8)subMenuData[1], buffer);
    subMenuDataPtrs[1] = subMenuData[1];

    sprintf(buffer,"PAU ERR :  %d", p->pau_err);
    mmi_asc_to_ucs2((PS8)subMenuData[2], buffer);
    subMenuDataPtrs[2] = subMenuData[2];

    sprintf(buffer,"PAU CCCA :  %d", p->pau_ccca);
    mmi_asc_to_ucs2((PS8)subMenuData[3], buffer);
    subMenuDataPtrs[3] = subMenuData[3];    

    sprintf(buffer,"PAU FIFO FULL :  %d", p->pau_fifo_full);
    mmi_asc_to_ucs2((PS8)subMenuData[4], buffer);
    subMenuDataPtrs[4] = subMenuData[4];

    sprintf(buffer,"INT OK :  %d", p->int_ok);
    mmi_asc_to_ucs2((PS8)subMenuData[5], buffer);
    subMenuDataPtrs[5] = subMenuData[5];

    sprintf(buffer,"INT ERR :  %d", p->int_err);
    mmi_asc_to_ucs2((PS8)subMenuData[6], buffer);
    subMenuDataPtrs[6] = subMenuData[6];

    sprintf(buffer,"RSSI Mean :  %d", p->rssi_mean);
    mmi_asc_to_ucs2((PS8)subMenuData[7], buffer);
    subMenuDataPtrs[7] = subMenuData[7];

    sprintf(buffer,"RSSI Max :  %d", p->rssi_max);
    mmi_asc_to_ucs2((PS8)subMenuData[8], buffer);
    subMenuDataPtrs[8] = subMenuData[8];

    sprintf(buffer,"RSSI Min :  %d", p->rssi_min);
    mmi_asc_to_ucs2((PS8)subMenuData[9], buffer);
    subMenuDataPtrs[9] = subMenuData[9];

    sprintf(buffer,"RSSI Variance :  %d", p->rssi_variance);
    mmi_asc_to_ucs2((PS8)subMenuData[10], buffer);
    subMenuDataPtrs[10] = subMenuData[10];

    sprintf(buffer,"INT Long Preamble:  %d", p->int_long_preamble);
    mmi_asc_to_ucs2((PS8)subMenuData[11], buffer);
    subMenuDataPtrs[11] = subMenuData[11];

    sprintf(buffer,"INT Short Preamble :  %d", p->int_short_preamble);
    mmi_asc_to_ucs2((PS8)subMenuData[12], buffer);
    subMenuDataPtrs[12] = subMenuData[12];

    ShowCategory6Screen (EM_RF_WIFI_CONT_PKT_RX_TEXT, 0,
						  0, 0, STR_GLOBAL_BACK, 0,
						  nItems, (PU8*)subMenuDataPtrs,NULL, currentHighlightIndex,
						  guiBuffer); 
						  
    SetRightSoftkeyFunction (GoBackHistory, KEY_EVENT_UP);

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
    
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiPowerSave
**
**  PURPOSE				: Highlight function for RF Test WiFi Power Save menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiPowerSave(void)
{
    /* Register function for left soft key */
	SetLeftSoftkeyFunction(EntryEmRFTestWiFiPowerSave, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiPowerSave
**
**  PURPOSE				: Enrty function for RF Test WiFi Power Save 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiPowerSave(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    /* set request type = WiFi Power Save */    
    g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_POWER_SAVE;
    
    EntryNewScreen(EM_RF_TEST_WIFI_POWER_SAVE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_POWER_SAVE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiPowerSaveInline);    

    /* Mode */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_POWER_SAVE_MODE_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiPowerSave[0] = (U8*) GetString(EM_RF_WIFI_POWER_SAVE_NORMAL_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiPowerSave[1] = (U8*) GetString(EM_RF_WIFI_POWER_SAVE_IDLE_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiPowerSave[2] = (U8*) GetString(EM_RF_WIFI_POWER_SAVE_SLEEP_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 3, (U8**)g_rf_test_wifi_cntx.pEMRFWifiPowerSave, &g_rf_test_wifi_cntx.currRFWifiPowerSave);
    ImageList[1] = 0;

    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_POWER_SAVE_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    2, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiPowerSaveInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiPowerSaveInline(S32 index) 
{
    if ( g_rf_test_wifi_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFTESTWifiPowerSaveSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestWiFiPowerSave, KEY_EVENT_UP);
    }
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiPowerSaveSendReq
**
**  PURPOSE				:  RF Test Wifi Power Save Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiPowerSaveSendReq(void)
{
    /* Send request to RF , now req_type = RF_TEST_WIFI_POWER_SAVE */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();
    
    /* Show Power Save Done Screen */
    EntryEmRFTestWiFiPowerSaveDone();    
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiPowerSaveDone
**
**  PURPOSE				: Enrty function for RF Test Wifi Power Save Done
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiPowerSaveDone(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];

    EntryNewScreen(EM_RF_TEST_WIFI_POWER_SAVE_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_POWER_SAVE_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiPowerSaveInline);
    
    /* Mode */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_POWER_SAVE_MODE_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiPowerSave[0] = (U8*) GetString(EM_RF_WIFI_POWER_SAVE_NORMAL_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiPowerSave[1] = (U8*) GetString(EM_RF_WIFI_POWER_SAVE_IDLE_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiPowerSave[2] = (U8*) GetString(EM_RF_WIFI_POWER_SAVE_SLEEP_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[1],  (U8*)g_rf_test_wifi_cntx.pEMRFWifiPowerSave[g_rf_test_wifi_cntx.currRFWifiPowerSave]);
    ImageList[1] = 0;
    
    ShowCategory57Screen(EM_RF_WIFI_TX_CONT_PKT_TX_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    22, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);

#endif
}



/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiRegisterAccess
**
**  PURPOSE				: Highlight function for RF Test WiFi Register Access menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiRegisterAccess(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestWiFiRegisterAccess, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRegisterAccess
**
**  PURPOSE				: Enrty function for RF Test WiFi Register Access menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRegisterAccess(void)
{
    U16		ItemList[8];
    U16		ItemIcons[8];
    U16		nItems;
    U8*		guiBuffer;
    U8*		PopUpList[8];
    S32		i;

    EntryNewScreen(EM_RF_TEST_WIFI_REGISTER_ACCESS_SCR, NULL, EntryEmRFTestWiFiRegisterAccess, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_REGISTER_ACCESS_SCR);
	
    nItems = GetNumOfChild(EM_RF_WIFI_REGISTER_ACCESS_MENUID);
    GetSequenceStringIds(EM_RF_WIFI_REGISTER_ACCESS_MENUID, ItemList);
    SetParentHandler(EM_RF_WIFI_REGISTER_ACCESS_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for(i=0;i<nItems;i++)
    {
        PopUpList[i]=NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1+i);
    }

    ShowCategory52Screen(EM_RF_WIFI_REGISTER_TEXT,0,
							STR_GLOBAL_OK,0,
							STR_GLOBAL_BACK,0,
							nItems, ItemList, ItemIcons, (U8**) PopUpList, 0, 0, guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory,KEY_EVENT_UP);

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);

}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiRegisterMCR
**
**  PURPOSE				: Highlight function for RF Test WiFi Register MCR menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiRegisterMCR(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestWiFiRegisterMCR, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRegisterMCR
**
**  PURPOSE				: Enrty function for RF Test WiFi Register MCR 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRegisterMCR(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    EntryNewScreen(EM_RF_TEST_WIFI_REGISTER_MCR_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_REGISTER_MCR_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiRegMCRInline);    

    /* Type */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_REGISTER_TYPE_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiRegisterType[0] = (U8*) GetString(EM_RF_WIFI_REGISTER_32_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiRegisterType[1] = (U8*) GetString(EM_RF_WIFI_REGISTER_16_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 2, (U8**)g_rf_test_wifi_cntx.pEMRFWifiRegisterType, &g_rf_test_wifi_cntx.currRFWifiRegisterType);
    ImageList[1] = 0;

    /* Access */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_WIFI_REGISTER_ACCESS_TEXT));
    ImageList[2] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[0] = (U8*) GetString(EM_RF_WIFI_REGISTER_READ_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[1] = (U8*) GetString(EM_RF_WIFI_REGISTER_WRITE_TEXT);
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[3], 2, (U8**)g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess, &g_rf_test_wifi_cntx.currRFWifiRegisterAccess);
    RegisterInlineSelectHighlightHandler(&wgui_inline_items[3], HighlightRFWifiRegMCRAccessInline);
    ImageList[3] = 0;
    
   /* Address */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_WIFI_REGISTER_ADDRESS_TEXT));
    ImageList[4] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[5], (PU8)g_rf_test_wifi_cntx.address, 4, INPUT_TYPE_ALPHANUMERIC_LOWERCASE);
    ImageList[5] = 0;
    
   /* Data */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_RF_WIFI_REGISTER_DATA_TEXT));
    ImageList[6] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[7], (PU8)g_rf_test_wifi_cntx.data, 9, INPUT_TYPE_ALPHANUMERIC_LOWERCASE);
    ImageList[7] = 0;

    if(g_rf_test_wifi_cntx.currRFWifiRegisterAccess != EM_RF_WIFI_REGISTER_ACCESS_WRITE)	/* not Write */
    {
        DisableInlineItem(&wgui_inline_items[7], 7);
    }
    
    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_REGISTER_MCR_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    8, ImageList, wgui_inline_items, 5, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightRFWifiRegMCRAccessInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFWifiRegMCRAccessInline(S32 index) 
{
    if(index == EM_RF_WIFI_REGISTER_ACCESS_WRITE) 
    {
        EnableInlineItem(&wgui_inline_items[7], 7); /* register data input */
        g_rf_test_wifi_cntx.data[0] = '\0';
    }
    else if (index == EM_RF_WIFI_REGISTER_ACCESS_READ)
    {
        DisableInlineItem(&wgui_inline_items[7], 7); /* register data input */
        g_rf_test_wifi_cntx.data[0] = '\0';
    }
    else
        ASSERT(0);
        
    RedrawCategory57Screen();
}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiRegMCRInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiRegMCRInline(S32 index) 
{
    if ( g_rf_test_wifi_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFTESTWifiRegMCRSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestWiFiRegisterMCR, KEY_EVENT_UP);
    }
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiRegMCRSendReq
**
**  PURPOSE				:  RF Test Wifi Register MCR Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiRegMCRSendReq(void)
{
    S8  textbuf[20];
    MMI_BOOL result = MMI_TRUE;
    U32  address=0, data=0, i , len;

    CloseCategory57Screen();
    
    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.address))
        result = MMI_FALSE;

    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
        if (!mmi_ucs2strlen((const S8*) g_rf_test_wifi_cntx.data))
            result = MMI_FALSE;

    if (result == MMI_TRUE)
    {
        /* To check if address is valid , ansii to hex  */
        mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.address);
        len = strlen(textbuf);   
        result = EMRFTestWiFiASCII2Hex(textbuf, (U8)len);
        for (i=0 ; i<len; i++)
            address |= textbuf[i]<<4*(len-i-1);;

        if (address > 0x07FF)
            result = MMI_FALSE;
    }

    if (g_rf_test_wifi_cntx.currRFWifiRegisterType == EM_RF_WIFI_REGISTER_TYPE_32)
    {
        if (address % 4)    /* 4 byte alignment */
            result = MMI_FALSE;      
    }
    else
    {
        if (address % 2)    /* 2 byte alignment */
            result = MMI_FALSE;            
    }       

    if (result == MMI_TRUE)
    {
        /* To check if data is valid , ansii to hex  */
        if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
        {
            mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.data);
            len = strlen(textbuf);
            result = EMRFTestWiFiASCII2Hex(textbuf, (U8)len);
            for (i=0 ; i<len; i++)   
                data |= textbuf[i]<<4*(len-i-1);
        }
    }
    
    /* If one of the parameters is invalid, then pop-up error  */
    if (result ==MMI_FALSE)
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
 	 DeleteScreenIfPresent(EM_RF_TEST_WIFI_REGISTER_MCR_SCR);
 	 return;
    }

    /* set the atoi result to global context */
    g_rf_test_wifi_cntx.int_address = address;
    g_rf_test_wifi_cntx.int_data = data;

    if (g_rf_test_wifi_cntx.currRFWifiRegisterType == EM_RF_WIFI_REGISTER_TYPE_16)
    {
        if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_READ)
            g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_REG_MCR16_READ;
        else if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
            g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_REG_MCR16_WRITE;
        else
            ASSERT(0);
    }
    else if (g_rf_test_wifi_cntx.currRFWifiRegisterType == EM_RF_WIFI_REGISTER_TYPE_32)
    {
        if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_READ)
            g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_REG_MCR32_READ;
        else if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
            g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_REG_MCR32_WRITE;
        else
            ASSERT(0);
    }
    else
        ASSERT(0);

    /* Send request to RF */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();
    
    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)
        EntryEmRFTestWiFiRegMCRAccessRsp(0);    
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRegMCRAccessRsp
**
**  PURPOSE				: Enrty function for RF Test Wifi Register Access MCR rsp
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRegMCRAccessRsp(U32 mcr_data)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];
    S8 buffer[32];    

    EntryNewScreen(EM_RF_TEST_WIFI_REGISTER_MCR_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_REGISTER_MCR_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiRegMCRInline);    

    /* Type */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_REGISTER_TYPE_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiRegisterType[0] = (U8*) GetString(EM_RF_WIFI_REGISTER_16_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiRegisterType[1] = (U8*) GetString(EM_RF_WIFI_REGISTER_32_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[1], (U8*)g_rf_test_wifi_cntx.pEMRFWifiRegisterType[g_rf_test_wifi_cntx.currRFWifiRegisterType]);
    ImageList[1] = 0;

    /* Access */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_WIFI_REGISTER_ACCESS_TEXT));
    ImageList[2] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[0] = (U8*) GetString(EM_RF_WIFI_REGISTER_READ_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[1] = (U8*) GetString(EM_RF_WIFI_REGISTER_WRITE_TEXT);
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[3], (U8*)g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[g_rf_test_wifi_cntx.currRFWifiRegisterAccess]);
    ImageList[3] = 0 ;

   /* Address */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_WIFI_REGISTER_ADDRESS_TEXT));
    ImageList[4] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[5], (PU8)g_rf_test_wifi_cntx.address);
    ImageList[5] = 0;

    /* Data */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_RF_WIFI_REGISTER_DATA_TEXT));
    ImageList[6] = IMG_STATUS;   
    
    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_READ)
    {
        sprintf(buffer," %x " , mcr_data);
        mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.data, buffer);
        
        SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&wgui_inline_items[7], (PU8)g_rf_test_wifi_cntx.data);
        ImageList[7] = 0;
    }
    else if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)
    {
        SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&wgui_inline_items[7], (PU8)g_rf_test_wifi_cntx.data);
        ImageList[7] = 0;
    }
    else
        ASSERT(0);
        
    ShowCategory57Screen(EM_RF_WIFI_REGISTER_MCR_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    8, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);

#endif
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiRegisterBBCR
**
**  PURPOSE				: Highlight function for RF Test WiFi Register BBCR menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiRegisterBBCR(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestWiFiRegisterBBCR, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRegisterBBCR
**
**  PURPOSE				: Enrty function for RF Test WiFi Register BBCR 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRegisterBBCR(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    EntryNewScreen(EM_RF_TEST_WIFI_REGISTER_BBCR_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_REGISTER_BBCR_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiRegBBCRInline);    

    /* Access */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_REGISTER_ACCESS_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[0] = (U8*) GetString(EM_RF_WIFI_REGISTER_READ_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[1] = (U8*) GetString(EM_RF_WIFI_REGISTER_WRITE_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 2, (U8**)g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess, &g_rf_test_wifi_cntx.currRFWifiRegisterAccess);
    RegisterInlineSelectHighlightHandler(&wgui_inline_items[1], HighlightRFWifiRegBBCRAccessInline);
    ImageList[1] = 0;

   /* Index */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_WIFI_REGISTER_INDEX_TEXT));
    ImageList[2] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[3], (PU8)g_rf_test_wifi_cntx.index, 3, INPUT_TYPE_ALPHANUMERIC_LOWERCASE);
    ImageList[3] = 0;
    
   /* Data */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_WIFI_REGISTER_DATA_TEXT));
    ImageList[4] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[5], (PU8)g_rf_test_wifi_cntx.data, 3, INPUT_TYPE_ALPHANUMERIC_LOWERCASE);
    ImageList[5] = 0;

    if(g_rf_test_wifi_cntx.currRFWifiRegisterAccess != EM_RF_WIFI_REGISTER_ACCESS_WRITE)	/* not Write */
    {
        DisableInlineItem(&wgui_inline_items[5], 5);
    }
    
    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_REGISTER_BBCR_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    6, ImageList, wgui_inline_items, 3, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightRFWifiRegBBCRAccessInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFWifiRegBBCRAccessInline(S32 index) 
{
    if(index == EM_RF_WIFI_REGISTER_ACCESS_WRITE) 
    {
        EnableInlineItem(&wgui_inline_items[5], 5); /* register data input */
        g_rf_test_wifi_cntx.data[0] = '\0';
    }
    else if (index == EM_RF_WIFI_REGISTER_ACCESS_READ)
    {
        DisableInlineItem(&wgui_inline_items[5], 5); /* register data input */
        g_rf_test_wifi_cntx.data[0] = '\0';
    }
    else
        ASSERT(0);
        
    RedrawCategory57Screen();
}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiRegBBCRInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiRegBBCRInline(S32 index) 
{
    if ( g_rf_test_wifi_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFTESTWifiRegBBCRSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestWiFiRegisterBBCR, KEY_EVENT_UP);
    }
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiRegBBCRSendReq
**
**  PURPOSE				:  RF Test Wifi Register BBCR Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiRegBBCRSendReq(void)
{
    S8  textbuf[20];
    MMI_BOOL result = MMI_TRUE;
    U32  index =0 , data = 0, i, len;

    CloseCategory57Screen();
    
    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.index))
        result = MMI_FALSE;

    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
        if (!mmi_ucs2strlen((const S8*) g_rf_test_wifi_cntx.data))
            result = MMI_FALSE;

    if (result == MMI_TRUE)
    {
        /* To check if index is valid */
        mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.index);
        len = strlen(textbuf);
        result = EMRFTestWiFiASCII2Hex(textbuf, (U8)len);
        for (i=0 ; i<len; i++)   
            index |= textbuf[i]<<4*(len-i-1);

        if (index > 0x7F)
            result = MMI_FALSE;
    }

    if (result == MMI_TRUE)
    {
        if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
        {
            /* To check if data is valid */
            mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.data);
            len = strlen(textbuf);
            result = EMRFTestWiFiASCII2Hex(textbuf, (U8)strlen(textbuf));
            for (i=0 ; i<len; i++)   
                data |= textbuf[i]<<4*(len-i-1);
        }
    }

    /* If one of the parameters is invalid, then pop-up error  */
    if (result ==MMI_FALSE)
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
 	 DeleteScreenIfPresent(EM_RF_TEST_WIFI_REGISTER_BBCR_SCR);
 	 return;
    }

    /* set the atoi result to global context */
    g_rf_test_wifi_cntx.int_index = index;
    g_rf_test_wifi_cntx.int_data = data;    

    /* Send request to RF */
    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_READ)
        g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_REG_BBCR_READ;
    else if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
        g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_REG_BBCR_WRITE;
    else
        ASSERT(0);

    /* Send request to RF */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();
    
    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)    
        EntryEmRFTestWiFiRegBBCRAccessRsp(0);    
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRegBBCRAccessRsp
**
**  PURPOSE				: Enrty function for RF Test Wifi Register Access BBCR rsp
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRegBBCRAccessRsp(U32 bbcr_data)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];
    S8 buffer[32];    

    EntryNewScreen(EM_RF_TEST_WIFI_REGISTER_BBCR_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_REGISTER_BBCR_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiRegBBCRInline);    

    /* Access */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_REGISTER_ACCESS_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[0] = (U8*) GetString(EM_RF_WIFI_REGISTER_READ_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[1] = (U8*) GetString(EM_RF_WIFI_REGISTER_WRITE_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[1], (U8*)g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[g_rf_test_wifi_cntx.currRFWifiRegisterAccess]);
    ImageList[1] = 0;

   /* Index */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_WIFI_REGISTER_INDEX_TEXT));
    ImageList[2] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[3], (PU8)g_rf_test_wifi_cntx.index);
    ImageList[3] = 0;
    
   /* Data */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_WIFI_REGISTER_DATA_TEXT));
    ImageList[4] = IMG_STATUS;
           
    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_READ)
    {
        sprintf(buffer," %x ", bbcr_data);
        mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.data, buffer);

        SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&wgui_inline_items[5], (PU8)g_rf_test_wifi_cntx.data);
        ImageList[5] = 0;
    }
    else if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)
    {

        SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&wgui_inline_items[5], (PU8)g_rf_test_wifi_cntx.data);
        ImageList[5] = 0;
    }
    else
        ASSERT(0);
        
    ShowCategory57Screen(EM_RF_WIFI_REGISTER_BBCR_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    6, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);

#endif
}


/**************************************************************
**	FUNCTION NAME		: HighlightRFTestWiFiEEPROM
**
**  PURPOSE				: Highlight function for RF Test WiFi Register EEPROM menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFTestWiFiRegisterEEPROM(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmRFTestWiFiRegisterEEPROM, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRegisterEEPROM
**
**  PURPOSE				: Enrty function for RF Test WiFi Register EEPROM 
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRegisterEEPROM(void)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];

    /* check if request is processing. If yes, then stop it. */
    EmStopRFTestWiFi();

    EntryNewScreen(EM_RF_TEST_WIFI_REGISTER_EEPROM_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_REGISTER_EEPROM_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiRegEEPROMInline);    

    /* Access */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_REGISTER_ACCESS_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[0] = (U8*) GetString(EM_RF_WIFI_REGISTER_READ_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[1] = (U8*) GetString(EM_RF_WIFI_REGISTER_WRITE_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 2, (U8**)g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess, &g_rf_test_wifi_cntx.currRFWifiRegisterAccess);
    RegisterInlineSelectHighlightHandler(&wgui_inline_items[1], HighlightRFWifiRegEEPROMAccessInline);
    ImageList[1] = 0;

   /* Address */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_WIFI_REGISTER_ADDRESS_TEXT));
    ImageList[2] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[3], (PU8)g_rf_test_wifi_cntx.address, 4, INPUT_TYPE_ALPHANUMERIC_LOWERCASE);
    ImageList[3] = 0;
    
   /* Data */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_WIFI_REGISTER_DATA_TEXT));
    ImageList[4] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[5], (PU8)g_rf_test_wifi_cntx.data, 5, INPUT_TYPE_ALPHANUMERIC_LOWERCASE);
    ImageList[5] = 0;

    if(g_rf_test_wifi_cntx.currRFWifiRegisterAccess != EM_RF_WIFI_REGISTER_ACCESS_WRITE)	/* not Write */
    {
        DisableInlineItem(&wgui_inline_items[5], 5);
    }
    
    DisableCategory57ScreenDone();

    ShowCategory57Screen(EM_RF_WIFI_REGISTER_EEPROM_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    6, ImageList, wgui_inline_items, 3, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);
   
#endif

}


/**************************************************************
**	FUNCTION NAME		: HighlightRFWifiRegEEPROMAccessInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightRFWifiRegEEPROMAccessInline(S32 index) 
{
    if(index == EM_RF_WIFI_REGISTER_ACCESS_WRITE) 
    {
        EnableInlineItem(&wgui_inline_items[5], 5); /* register data input */
        g_rf_test_wifi_cntx.data[0] = '\0';
    }
    else if (index == EM_RF_WIFI_REGISTER_ACCESS_READ)
    {
        DisableInlineItem(&wgui_inline_items[5], 5); /* register data input */
        g_rf_test_wifi_cntx.data[0] = '\0';        
    }
    else
        ASSERT(0);
        
    RedrawCategory57Screen();
}


/**************************************************************
**	FUNCTION NAME		: HighlightHandlerRFWifiRegEEPROMInline
**
**  PURPOSE				: Highlight handler of inline editor in input screen.
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void HighlightHandlerRFWifiRegEEPROMInline(S32 index) 
{
    if ( g_rf_test_wifi_cntx.request_processing == MMI_FALSE )
    {
        ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
        SetLeftSoftkeyFunction(EMRFTESTWifiRegEEPROMSendReq, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ABORT, 0);
        SetLeftSoftkeyFunction(EntryEmRFTestWiFiRegisterEEPROM, KEY_EVENT_UP);
    }
}


/**************************************************************
**	FUNCTION NAME		: EMRFTESTWifiRegEEPROMSendReq
**
**  PURPOSE				:  RF Test Wifi Register EEPROM Send Req
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EMRFTESTWifiRegEEPROMSendReq(void)
{
    S8  textbuf[20];
    MMI_BOOL result = MMI_TRUE;
    U32  address=0, data=0;
    U8 i, len;

    CloseCategory57Screen();
    
    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_rf_test_wifi_cntx.address))
        result = MMI_FALSE;

    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
        if (!mmi_ucs2strlen((const S8*) g_rf_test_wifi_cntx.data))
            result = MMI_FALSE;

    if (result == MMI_TRUE)
    {
        /* To check if address is valid */
        mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.address);
        len = strlen(textbuf);
        result = EMRFTestWiFiASCII2Hex(textbuf, len);
        for (i=0 ; i<len; i++)   
            address |= textbuf[i]<<4*(len-i-1);
   
        if ( (address > 0x199) || (address%2))  /* address > 0x199 or not 2 byte alignment */
            result = MMI_FALSE;
    }
    
    if (result == MMI_TRUE)
    {
        if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
        {
            /* To check if data is valid */
            mmi_ucs2_to_asc((PS8)textbuf,  (PS8)g_rf_test_wifi_cntx.data);
            len = strlen(textbuf);
            result = EMRFTestWiFiASCII2Hex(textbuf, (U8)strlen(textbuf));
            for (i=0 ; i<len; i++)   
                data |= textbuf[i]<<4*(len-i-1);
        }
    }    
   
    /* If one of the parameters is invalid, then pop-up error  */
    if (result ==MMI_FALSE)
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
 	 DeleteScreenIfPresent(EM_RF_TEST_WIFI_REGISTER_EEPROM_SCR);
 	 return;
    }

    /* set the atoi result to global context */
    g_rf_test_wifi_cntx.int_address = address;
    g_rf_test_wifi_cntx.int_data = data;

    /* Send request to RF */
    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_READ)
        g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_REG_EEPROM_READ;
    else if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)              
        g_rf_test_wifi_cntx.req_type = RF_TEST_WIFI_REG_EEPROM_WRITE;
    else
        ASSERT(0);

    /* Send request to RF */
    g_rf_test_wifi_cntx.request_processing = MMI_TRUE;
    EMRFTestWiFiSendReq();
    
    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)    
        EntryEmRFTestWiFiRegEEPROMAccessRsp(0);    
}


/**************************************************************
**	FUNCTION NAME		: EntryEmRFTestWiFiRegEEPROMAccessRsp
**
**  PURPOSE				: Enrty function for RF Test Wifi Register Access EEPROM rsp
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmRFTestWiFiRegEEPROMAccessRsp(U32 eeprom_data)
{
#ifdef __MTK_TARGET__
    U8* guiBuffer;
    U16 ImageList[22];
    S8 buffer[32];    

    EntryNewScreen(EM_RF_TEST_WIFI_REGISTER_EEPROM_DONE_SCR, ExitEmRFTestInlineSelectScreen, NULL, NULL);
    InitializeCategory57Screen();
	
    guiBuffer = GetCurrGuiBuffer(EM_RF_TEST_WIFI_REGISTER_EEPROM_DONE_SCR);

    RegisterHighlightHandler(HighlightHandlerRFWifiRegEEPROMInline);    

    /* Access */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_RF_WIFI_REGISTER_ACCESS_TEXT));
    ImageList[0] = IMG_STATUS;
    
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[0] = (U8*) GetString(EM_RF_WIFI_REGISTER_READ_TEXT);
    g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[1] = (U8*) GetString(EM_RF_WIFI_REGISTER_WRITE_TEXT);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[1], (U8*)g_rf_test_wifi_cntx.pEMRFWifiRegisterAccess[g_rf_test_wifi_cntx.currRFWifiRegisterAccess]);
    ImageList[1] = 0;

   /* Address */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_RF_WIFI_REGISTER_ADDRESS_TEXT));
    ImageList[2] = IMG_STATUS;
           
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[3], (PU8)g_rf_test_wifi_cntx.address);
    ImageList[3] = 0;
    
   /* Data */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_RF_WIFI_REGISTER_DATA_TEXT));
    ImageList[4] = IMG_STATUS;
           
    if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_READ)
    {
        sprintf(buffer," %x ", eeprom_data);
        mmi_asc_to_ucs2((PS8)g_rf_test_wifi_cntx.data, buffer);

        SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&wgui_inline_items[5], (PU8)g_rf_test_wifi_cntx.data);
        ImageList[5] = 0;
    }
    else if (g_rf_test_wifi_cntx.currRFWifiRegisterAccess == EM_RF_WIFI_REGISTER_ACCESS_WRITE)
    {

        SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&wgui_inline_items[5], (PU8)g_rf_test_wifi_cntx.data);
        ImageList[5] = 0;
    }
    else
        ASSERT(0);
        
    ShowCategory57Screen(EM_RF_WIFI_REGISTER_EEPROM_TEXT, 0, 
       	                                  STR_GLOBAL_OK, 
       	                                  IMG_GLOBAL_OK, 
       	                                  STR_GLOBAL_BACK, 
       	                                  IMG_GLOBAL_BACK,
				                    6, ImageList, wgui_inline_items, 0, guiBuffer);	
    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

    /* Register END key handler */
    SetKeyHandler(GoBackHistory,KEY_END,KEY_EVENT_DOWN);

#endif
}

#endif /* #if defined(__WIFI_SUPPORT__)  */

#ifdef __MMI_TOUCH_SCREEN__

#undef EM_PEN_TEST_HANW

#include "wgui_touch_screen.h"

#ifdef EM_PEN_TEST_HANW
#include "hw.h"
#endif 

/* Previous point in pen test program */
static mmi_pen_point_struct gEmPenPreviousPoint;

/* Capture pen events by test drawing program */
static BOOL gEmPenTestCapture = MMI_FALSE;

/* Line color */
static color gEmPenLineColor = {0, 0, 0, 100};

/* Stroke test */
#define EM_PEN_STROKE_BUFFER_SIZE 500
static mmi_pen_point_struct *gEmPenStrokeBuffer;

/* Max distance between points of successive pen move event */
static S16 gEmPenMaxDisplacementX = 0;
static S16 gEmPenMaxDisplacementY = 0;

static mmi_pen_handwriting_area_struct gEmPenStrokeArea;

#ifdef EM_PEN_TEST_HANW
/* Single line input box for display candidates for hand writing */
static single_line_input_box touchCandidateArea;
extern unsigned char bufRam[12 * 1024];
extern const unsigned char hand_writing_data[];
#endif /* EM_PEN_TEST_HANW */ 


/*****************************************************************************
 * FUNCTION
 *  EmPenTestPenDown
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestPenDown(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 test_x1 = (S16) MMI_content_x;
    S16 test_x2 = (S16) (MMI_content_x + MMI_content_width - 1);
    S16 test_y1 = (S16) MMI_content_y;
    S16 test_y2 = (S16) (MMI_content_y + MMI_content_height - 1);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (pos.x < test_x1 || pos.x > test_x2 || pos.y < test_y1 || pos.y > test_y2)
    {
        gEmPenPreviousPoint.x = -1;
        gEmPenPreviousPoint.y = -1;
        wgui_general_pen_down_hdlr(pos);
        gEmPenTestCapture = MMI_FALSE;
    }
    else
    {
        gEmPenPreviousPoint.x = pos.x;
        gEmPenPreviousPoint.y = pos.y;
        gEmPenTestCapture = MMI_TRUE;
        gEmPenLineColor = gui_color(0, 0, 0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestPenLongTap
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestPenLongTap(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!gEmPenTestCapture)
    {
        wgui_general_pen_long_tap_hdlr(pos);
    }
    else
    {
        gEmPenLineColor = gui_color(255, 0, 0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestPenAbort
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestPenAbort(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!gEmPenTestCapture)
    {
        wgui_general_pen_abort_hdlr(pos);
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestPenRepeat
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestPenRepeat(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!gEmPenTestCapture)
    {
        wgui_general_pen_repeat_hdlr(pos);
    }
    else
    {
        gEmPenLineColor = gui_color(19, 7, 248);
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestPenMove
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestPenMove(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 test_x1 = MMI_content_x;
    S16 test_x2 = MMI_content_x + MMI_content_width - 1;
    S16 test_y1 = MMI_content_y;
    S16 test_y2 = MMI_content_y + MMI_content_height - 1;
    S16 disp_x, disp_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!gEmPenTestCapture)
    {
        wgui_general_pen_move_hdlr(pos);
        return;
    }

    if (pos.x < test_x1)
    {
        pos.x = test_x1;
    }
    if (pos.x > test_x2)
    {
        pos.x = test_x2;
    }
    if (pos.y < test_y1)
    {
        pos.y = test_y1;
    }
    if (pos.y > test_y2)
    {
        pos.y = test_y2;
    }
    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    gui_line(gEmPenPreviousPoint.x, gEmPenPreviousPoint.y, pos.x, pos.y, gEmPenLineColor);

    disp_x = PEN_ABS(pos.x, gEmPenPreviousPoint.x);
    disp_y = PEN_ABS(pos.y, gEmPenPreviousPoint.y);
    if (disp_x > gEmPenMaxDisplacementX)
    {
        gEmPenMaxDisplacementX = disp_x;
    }
    if (disp_y > gEmPenMaxDisplacementY)
    {
        gEmPenMaxDisplacementY = disp_y;
    }

    gui_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(
        PEN_MIN(gEmPenPreviousPoint.x, pos.x),
        PEN_MIN(gEmPenPreviousPoint.y, pos.y),
        PEN_MAX(gEmPenPreviousPoint.x, pos.x),
        PEN_MAX(gEmPenPreviousPoint.y, pos.y));

    gEmPenPreviousPoint.x = pos.x;
    gEmPenPreviousPoint.y = pos.y;
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestPenUp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestPenUp(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!gEmPenTestCapture)
    {
        wgui_general_pen_up_hdlr(pos);
    }
    else
    {
        gui_lock_double_buffer();

        EmPenTestPenMove(pos);

        gui_line(pos.x - 2, pos.y - 2, pos.x + 2, pos.y + 2, gEmPenLineColor);
        gui_line(pos.x - 2, pos.y + 2, pos.x + 2, pos.y - 2, gEmPenLineColor);
        gui_unlock_double_buffer();
        gui_BLT_double_buffer(pos.x - 2, pos.y - 2, pos.x + 2, pos.y + 2);
        gEmPenPreviousPoint.x = -1;
        gEmPenPreviousPoint.y = -1;
        gEmPenLineColor = gui_color(0, 0, 0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestStrokeDown
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestStrokeDown(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gEmPenPreviousPoint.x = pos.x;
    gEmPenPreviousPoint.y = pos.y;
    gEmPenLineColor = gui_color(0, 255, 0);
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestStrokeMove
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestStrokeMove(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    gui_line(gEmPenPreviousPoint.x, gEmPenPreviousPoint.y, pos.x, pos.y, gEmPenLineColor);
    gui_line(gEmPenPreviousPoint.x + 1, gEmPenPreviousPoint.y, pos.x + 1, pos.y, gEmPenLineColor);
    gui_line(gEmPenPreviousPoint.x, gEmPenPreviousPoint.y + 1, pos.x, pos.y + 1, gEmPenLineColor);
    gui_line(gEmPenPreviousPoint.x - 1, gEmPenPreviousPoint.y, pos.x - 1, pos.y, gEmPenLineColor);
    gui_line(gEmPenPreviousPoint.x, gEmPenPreviousPoint.y - 1, pos.x, pos.y - 1, gEmPenLineColor);

    gui_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(
        PEN_MIN(gEmPenPreviousPoint.x, pos.x) - 1,
        PEN_MIN(gEmPenPreviousPoint.y, pos.y) - 1,
        PEN_MAX(gEmPenPreviousPoint.x, pos.x) + 1,
        PEN_MAX(gEmPenPreviousPoint.y, pos.y) + 1);

    gEmPenPreviousPoint.x = pos.x;
    gEmPenPreviousPoint.y = pos.y;
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestStrokeUpTimerHdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestStrokeUpTimerHdlr(void)
{
#ifdef EM_PEN_TEST_HANW
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL has_unfinished_stroke;
    U16 *psBufferTouch;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_pen_peek_stroke_state(&has_unfinished_stroke);
    if (!has_unfinished_stroke)
    {
        int num = 0, i = 0;
        char szResult[40];
        UI_character_type curCh;

        mmi_pen_end_strokes_of_character();

        psBufferTouch = (U16*) OslMalloc((10 + 2) * sizeof(U16));
        gui_create_single_line_input_box_use_buffer(
            &touchCandidateArea,
            MMI_multitap_x,
            MMI_multitap_y - 2, /* +1, */
            MMI_multitap_width,
            MMI_multitap_height,
            psBufferTouch,
            ((10 + 1) * sizeof(U16)));
        touchCandidateArea.flags |= UI_SINGLE_LINE_INPUT_BOX_DISABLE_SCROLLING;
        touchCandidateArea.flags |= UI_SINGLE_LINE_INPUT_BOX_CHARACTER_HIGHLIGHT;

        HWSetDictionary((DWORD) bufRam, (DWORD) hand_writing_data);
        gui_single_line_input_box_delete_all(&touchCandidateArea);

        num = HWRecognize((U16*) gEmPenStrokeBuffer, szResult, 5, ALC_CHINESE_COMMON);
        for (; i < num * 2; i += 2)
        {
            U16 c1 = szResult[i];
            U16 c2 = szResult[i + 1];

            curCh = c1 | (c2 << 8);
            gui_single_line_input_box_insert_character(&touchCandidateArea, (UI_character_type) curCh);
        }
        gui_single_line_input_box_goto_first_character(&touchCandidateArea);
        gui_single_line_input_box_next(&touchCandidateArea);
        touchCandidateArea.flags |= UI_SINGLE_LINE_INPUT_BOX_STATE_MULTITAP;
        touchCandidateArea.flags |= UI_SINGLE_LINE_INPUT_BOX_FULL_HEIGHT_BLOCK_CURSOR;
        gui_lock_double_buffer();
        gui_show_single_line_input_box(&touchCandidateArea);
        gui_unlock_double_buffer();
        gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
        mmi_pen_begin_strokes_of_character();

        OslMfree(psBufferTouch);
    }
#else /* EM_PEN_TEST_HANW */ 
    MMI_BOOL has_unfinished_stroke;

    mmi_pen_peek_stroke_state(&has_unfinished_stroke);
    if (!has_unfinished_stroke)
    {
        mmi_pen_end_strokes_of_character();
        mmi_pen_begin_strokes_of_character();
    }
#endif /* EM_PEN_TEST_HANW */ 
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestStrokeUp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestStrokeUp(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmPenTestStrokeMove(pos);
    gEmPenPreviousPoint.x = -1;
    gEmPenPreviousPoint.y = -1;
    gui_cancel_timer(EmPenTestStrokeUpTimerHdlr);
    gui_start_timer(1000, EmPenTestStrokeUpTimerHdlr);
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestShowBorder
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void EmPenTestShowBorder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_draw_rectangle(
        gEmPenStrokeArea.x1,
        gEmPenStrokeArea.y1,
        gEmPenStrokeArea.x2,
        gEmPenStrokeArea.y2,
        gui_color(128, 128, 128));
}


/*****************************************************************************
 * FUNCTION
 *  EmPenTestClear
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmPenTestClear(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    RedrawCategory400Screen();
    EmPenTestShowBorder();
    gui_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmPenStatisticsList
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmPenStatisticsList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_TOUCHSCREEN_TEST_STATISTICS_SCR, NULL, EntryEmPenStatisticsList, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_TOUCHSCREEN_TEST_STATISTICS_SCR);

    sprintf(
        (char*)EMFMAsciiDisplayBuf,
        "Max_distance_X: %d \n Max_distance_Y: %d\n",
        gEmPenMaxDisplacementX,
        gEmPenMaxDisplacementY);

    mmi_asc_to_ucs2((S8*) EMFMUnicodeDisplayBuf, (S8*) EMFMAsciiDisplayBuf);

    ShowCategory74Screen(
        EM_TOUCHSCREEN_TEST_STATISTICS_TEXT,
        0,
        (U16) NULL,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (PU8) EMFMUnicodeDisplayBuf,
        sizeof(EMFMUnicodeDisplayBuf),
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EmPenLeaveTest
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmPenLeaveTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GoBeyondMarkerScr(EM_TOUCHSCREEN_TEST_SCR);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmPenOptions
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmPenOptions(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_TOUCHSCREEN_TEST_OPTION_SCR, NULL, EntryEmPenOptions, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_TOUCHSCREEN_TEST_OPTION_SCR);

    nItems = GetNumOfChild(EM_TOUCHSCREEN_TEST_OPTION_MENUID);
    GetSequenceStringIds(EM_TOUCHSCREEN_TEST_OPTION_MENUID, ItemList);
    SetParentHandler(EM_TOUCHSCREEN_TEST_OPTION_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);
    }

    ShowCategory52Screen(
        EM_TOUCHSCREEN_TEST_STATISTICS_TEXT,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmPenTest
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmPenTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_pen_stop_capture_strokes();
    OslMfree(gEmPenStrokeBuffer);
    gEmPenStrokeBuffer = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmPenTest
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmPenTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    mmi_pen_handwriting_area_struct ext_stroke;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ext_stroke.x1 = 0;
    ext_stroke.y1 = 0;
    ext_stroke.x2 = UI_device_width - 1;
    ext_stroke.y2 = UI_device_height - 1;
    gEmPenPreviousPoint.x = -1;
    gEmPenPreviousPoint.y = -1;
    EntryNewScreen(EM_TOUCHSCREEN_TEST_SCR, ExitEmPenTest, EntryEmPenTest, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_TOUCHSCREEN_TEST_SCR);

    gui_lock_double_buffer();
    ShowCategory400Screen(
        EM_TOUCHSCREEN_TEST_TEXT,
        0,
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,
        STR_GLOBAL_CLEAR,
        IMG_GLOBAL_CLEAR,
        guiBuffer);

    gEmPenStrokeArea.x1 = MMI_content_x + (MMI_content_width >> 3);
    gEmPenStrokeArea.x2 = MMI_content_x + MMI_content_width - (MMI_content_width >> 3);
    gEmPenStrokeArea.y1 = MMI_content_y + (MMI_content_height >> 3);
    gEmPenStrokeArea.y2 = MMI_content_y + MMI_content_height - (MMI_content_height >> 3);

    EmPenTestShowBorder();

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);

    wgui_register_pen_down_handler(EmPenTestPenDown);
    wgui_register_pen_move_handler(EmPenTestPenMove);
    wgui_register_pen_up_handler(EmPenTestPenUp);
    wgui_register_pen_repeat_handler(EmPenTestPenRepeat);
    wgui_register_pen_long_tap_handler(EmPenTestPenLongTap);
    wgui_register_pen_abort_handler(EmPenTestPenAbort);

    gEmPenStrokeBuffer = (mmi_pen_point_struct*) OslMalloc(sizeof(mmi_pen_point_struct) * EM_PEN_STROKE_BUFFER_SIZE);
    mmi_pen_start_capture_strokes(EM_PEN_STROKE_BUFFER_SIZE, gEmPenStrokeBuffer, 1, &gEmPenStrokeArea, &ext_stroke);
    mmi_pen_register_stroke_down_handler(EmPenTestStrokeDown);
    mmi_pen_register_stroke_move_handler(NULL, NULL, EmPenTestStrokeMove);
    mmi_pen_register_stroke_up_handler(EmPenTestStrokeUp);
    mmi_pen_begin_strokes_of_character();

    SetLeftSoftkeyFunction(EntryEmPenOptions, KEY_EVENT_UP);
    SetRightSoftkeyFunction(EmPenTestClear, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmPenStatistics
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmPenStatistics(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(EntryEmPenStatisticsList, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmPenExit
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmPenExit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(EmPenLeaveTest, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmPen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmPen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(EntryEmPenTest, KEY_EVENT_UP);
}

#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  EntryEmAutoAnswer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAutoAnswer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    S16 error = 0;
    U16 i = 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* EntryNewScreen(EM_AUTO_ANSWER_MENUID, NULL, EntryEmAutoAnswer, NULL); */

    for (i = 0; i < 4; i++)
    {
        gprofiles[i].answeringMode.automatic = 1 - gprofiles[i].answeringMode.automatic;
    }

#if defined(__MTK_TARGET__)
    if (WriteRecord(
            NVRAM_EF_PROFILES_LID,
            1,
            &gprofiles[0],
            NVRAM_PROFILES_RECORD_SIZE,
            &error) < NVRAM_PROFILES_RECORD_SIZE)
    {
        EngineerModeErrorNotice(EM_AUD_SET_ERROR_TEXT);
    }
    if (gactivatedprofile == gprofileId)
    {
        memcpy(&gcurrentprofile, &gprofiles[gprofileId], sizeof(PROFILE));
    }
#endif /* defined(__MTK_TARGET__)) */ 

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    if (gprofiles[0].answeringMode.automatic == 1)
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }

    RedrawCategoryFunction();
    HighlightEmAutoAnswer();
}


/*****************************************************************************
 * FUNCTION
 *  HightlightEMCellReselect
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HightlightEMCellReselect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_left_softkey(STR_GLOBAL_OK, 0);
    redraw_left_softkey();

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmCellReselect, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmCellReselect
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmCellReselect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 ItemList[] = 
    {
        EM_MISC_CELL_RESELECT_SUSPEND_TEXT,
        EM_MISC_CELL_RESELECT_RESUME_IN_TRANSFER_TEXT,
        EM_MISC_CELL_RESELECT_RESUME_IN_ALL_TEXT
    };

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_MISC_CELL_RESELECTION_SCR_ID, NULL, EntryEmCellReselect, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_MISC_CELL_RESELECTION_SCR_ID);
    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_MISC_CELL_RESELECT_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        3,
        ItemList,
        (U16) g_cell_reselection_item,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetLeftSoftkeyFunction(EMCellReselectDoneFunc, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EMCellReselectDoneFunc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMCellReselectDoneFunc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_em_cell_resel_suspend_req_struct *msg_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_cell_reselection_item = currentHighlightIndex;

    msg_p = OslConstructDataPtr(sizeof(mmi_em_cell_resel_suspend_req_struct));

    if (currentHighlightIndex == 0) /* highlight on resume */
    {
        EngineerModeSendMsg(MSG_ID_MMI_EM_CELL_RESEL_RESUME_REQ, msg_p, NULL);
    }
    else if (currentHighlightIndex == 1)    /* highlight on suspend (transfer state) */
    {
        msg_p->status = CELL_RESELECT_SUSPEND_IN_TRANSFER;
        EngineerModeSendMsg(MSG_ID_MMI_EM_CELL_RESEL_SUSPEND_REQ, msg_p, NULL);
    }
    else    /* highlight on suspend (all state) */
    {
        msg_p->status = CELL_RESELECT_SUSPEND_IN_ALL;
        EngineerModeSendMsg(MSG_ID_MMI_EM_CELL_RESEL_SUSPEND_REQ, msg_p, NULL);
    }

    DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
    DeleteUptoScrID(EM_MISC_MENU_SCR);
}


#if defined(__MMI_EM_FIXED_GAIN_FOR_HELIOS2__)
/*****************************************************************************
 * FUNCTION
 *  HightlightEMFixedGainForHelios2
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HightlightEMFixedGainForHelios2(void)
{
#ifdef __MTK_TARGET__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 DSPdata[8];
    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);

    Ret = ReadRecord(NVRAM_EF_SYS_CACHE_OCTET_LID,
                     NVRAM_SYS_FIXED_GAIN_MECH_FOR_HELIOS2,
                     DSPdata,
                     NVRAM_EF_SYS_CACHE_OCTET_SIZE,
                     &ErrorCode);

    FixedGain_On = DSPdata[0];

    if (FixedGain_On)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMFixedGainForHelios2, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

#endif /* __MTK_TARGET__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  EntryEMFixedGainForHelios2
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMFixedGainForHelios2(void)
{
#ifdef __MTK_TARGET__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 Ret;
    S16 ErrorCode;
    U8 DSPdata[8];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (FixedGain_On == FALSE)
    {
        FixedGain_On = TRUE;
        
        memset(DSPdata, 0, sizeof(DSPdata));
        DSPdata[0] = FixedGain_On;
    
        Ret = WriteRecord(NVRAM_EF_SYS_CACHE_OCTET_LID,
                          NVRAM_SYS_FIXED_GAIN_MECH_FOR_HELIOS2,
                          DSPdata,
                          NVRAM_EF_SYS_CACHE_OCTET_SIZE,
                          &ErrorCode);

        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        FixedGain_On = FALSE;

        memset(DSPdata, 0, sizeof(DSPdata));
        DSPdata[0] = FixedGain_On;
    
        Ret = WriteRecord(NVRAM_EF_SYS_CACHE_OCTET_LID,
                          NVRAM_SYS_FIXED_GAIN_MECH_FOR_HELIOS2,
                          DSPdata,
                          NVRAM_EF_SYS_CACHE_OCTET_SIZE,
                          &ErrorCode);

        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    RedrawCategoryFunction();
    HightlightEMFixedGainForHelios2();
    
#endif /* __MTK_TARGET__ */
}

#endif /* __MMI_EM_FIXED_GAIN_FOR_HELIOS2__ */


#if defined(__MMI_EM_MT6223_DEBUG_MODE__)
/*****************************************************************************
 * FUNCTION
 *  HightlightEMMT6223DebugMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HightlightEMMT6223DebugMode(void)
{
#ifdef __MTK_TARGET__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_left_softkey(STR_GLOBAL_OK, 0);
    redraw_left_softkey();

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmMT6223DebugMode, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
#endif /* __MTK_TARGET__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmMT6223DebugMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmMT6223DebugMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 ItemList[] = 
    {
        EM_MISC_MT6223_DEBUG_NORMAL_MODE_TEXT,
        EM_MISC_MT6223_DEBUG_ICE_TASK_MODE_TEXT,
        EM_MISC_MT6223_DEBUG_SWDBG_MODE_TEXT
    };

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_MISC_MT6223_DEBUG_MODE_SCR_ID, NULL, EntryEmMT6223DebugMode, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_MISC_MT6223_DEBUG_MODE_SCR_ID);
    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_MISC_MT6223_DEBUG_MODE_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        3,
        ItemList,
        (U16) g_MT6223_Debug_mode_type,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetLeftSoftkeyFunction(EMMT6223DebugModeDoneFunc, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EMMT6223DebugModeDoneFunc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMMT6223DebugModeDoneFunc(void)
{
#ifdef __MTK_TARGET__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_MT6223_Debug_mode_type = currentHighlightIndex;

    if (currentHighlightIndex == 0) /* highlight on normal mode */
    {
        swdbg_config_GPIO(SWDBG_GPIO_NORMAL);
    }
    else if (currentHighlightIndex == 1)    /* highlight on Ice & task Id Mode */
    {
        swdbg_config_GPIO(SWDBG_GPIO_ICE);
    }
    else    /* highlight on SWDBG mode */
    {
        swdbg_config_GPIO(SWDBG_GPIO_SWDBG);
    }

    DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
    DeleteUptoScrID(EM_MISC_MENU_SCR);

#endif /* #ifdef __MTK_TARGET__ */
    
}



#endif /* __MMI_EM_MT6223_DEBUG_MODE__ */


#if defined(MT6223P)
/*****************************************************************************
 * FUNCTION
 *  HightlightEMLSDSlowerMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HightlightEMLSDSlowerMode(void)
{
#ifdef __MTK_TARGET__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_left_softkey(STR_GLOBAL_OK, 0);
    redraw_left_softkey();

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmLSDSlowerMode, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    
#endif /* __MTK_TARGET__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmLSDSlowerMode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmLSDSlowerMode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *history_buffer;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_MISC_LSD_SLOWER_SCR_ID, NULL, NULL, NULL);
    history_buffer = GetCurrGuiBuffer(EM_MISC_LSD_SLOWER_SCR_ID);

    ShowCategory5Screen(
        EM_MISC_LSD_SLOWER_TICKS_TEXT,
        (U16) NULL,
        STR_GLOBAL_OK,
        (U16) NULL,
        STR_GLOBAL_BACK,
        (U16) NULL,
        INPUT_TYPE_NUMERIC,
        (U8*) InputBuf,
        2,
        history_buffer);

    SetLeftSoftkeyFunction(EmSetLSDSlowerHandler, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_END, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/**************************************************************
**	FUNCTION NAME		: EmSetLSDSlowerHandler
**
**  	PURPOSE			: 
**
**	INPUT PARAMETERS	: index
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EmSetLSDSlowerHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 value = 0;
    U8 ParamBuf[3];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MTK_TARGET__

    mmi_ucs2_to_asc((S8*)ParamBuf, (S8*)InputBuf);
    value = atoi((S8*)ParamBuf);
    if ((!mmi_ucs2strlen((const S8*)InputBuf) || (value > 6)))
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
        return;
    }
    
    LSD_Slower((U8)value);

    EngineerModeSuccessNotice(EM_NOTICE_SUCCESS_TEXT);
    
#endif 
}
#endif /* defined(MT6223P) */


/*****************************************************************************
 * FUNCTION
 *  EntryVideoHiBitrate
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT)
void EntryVideoHiBitrate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    {
        U8 mode;

        mode = media_vid_get_em_mode();

        if (mode == VID_EM_MODE_DISABLED)
        {
            media_vid_set_em_mode(VID_EM_MODE_ULTRA_HIGH_BITRATE);
            Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
        }
        else if (mode == VID_EM_MODE_ULTRA_HIGH_BITRATE)
        {
            media_vid_set_em_mode(VID_EM_MODE_DISABLED);
            Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
        }
        else
        {
            ASSERT(0);
        }
    }

    RedrawCategoryFunction();
    HighlightVideoHiBitrate();
}
#endif /* defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT) */ 


/*****************************************************************************
 * FUNCTION
 *  EntryEmHighSpeedSIM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmHighSpeedSIM(void)
{
#if defined(__MTK_TARGET__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (High_Speed_SIM)
    {
        High_Speed_SIM = KAL_FALSE;
    }
    else
    {
        High_Speed_SIM = KAL_TRUE;
    }
    EngineerModeSetHighSpeedSIMReq();
#endif /* defined(__MTK_TARGET__)) */ 

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    if (High_Speed_SIM)
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }
    RedrawCategoryFunction();
    HighlightEmHighSpeedSIM();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmWAP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmWAP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_WAP_MENU_SCR, NULL, EntryEmWAP, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_WAP_MENU_SCR);

    nItems = GetNumOfChild(EM_WAP_MENUID);
    GetSequenceStringIds(EM_WAP_MENUID, ItemList);
    SetParentHandler(EM_WAP_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

#if defined(WAP_SUPPORT)
    if (wap_enable_debug_assert)
    {
        PopUpList[0] = (U8*) get_string(STR_GLOBAL_ON);
    }
    else
    {
        PopUpList[0] = (U8*) get_string(STR_GLOBAL_OFF);
    }

    if (global_offline_page)
    {
        PopUpList[4] = (U8*) get_string(STR_GLOBAL_ON);
    }
    else
    {
        PopUpList[4] = (U8*) get_string(STR_GLOBAL_OFF);
    }

#endif /* defined(WAP_SUPPORT) */ 

    ShowCategory52Screen(
        EM_WAP_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmWAPEnableDebug
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmWAPEnableDebug(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(WAP_SUPPORT)
    wap_enable_debug_assert = 1 - wap_enable_debug_assert;
#endif 

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    ReplaceNewScreenHandler(EM_WAP_ENABLE_DEBUG_MENU_SCR, ExitEmWAPEnableDebug, NULL);

#if defined(WAP_SUPPORT)
    if (wap_enable_debug_assert)
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }
#endif /* defined(WAP_SUPPORT) */ 

    RedrawCategoryFunction();
    HighlightEmWAPEnableDebug();
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmWAPEnableDebug
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmWAPEnableDebug(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;
    S16 nHistory = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currHistory.scrnID = EM_WAP_ENABLE_DEBUG_MENU_SCR;
    currHistory.entryFuncPtr = EntryEmWAPEnableDebug;
    mmi_ucs2cpy((S8*) currHistory.inputBuffer, (S8*) & nHistory);
    GetCategoryHistory(currHistory.guiBuffer);
    AddHistory(currHistory);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmOfflinePage
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmOfflinePage(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    global_offline_page = 1 - global_offline_page;
#if defined(WAP_SUPPORT)
    em_wap_change_setting((kal_uint8) EM_WAP_OFFLINE_PAGE_OPT, (kal_uint8) global_offline_page);
#endif 
#endif /* defined(WAP_SUPPORT) */ 

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    ReplaceNewScreenHandler(EM_WAP_OFFLINE_PAGE_MENU_SCR, ExitEmOfflinePage, NULL);

#if defined(WAP_SUPPORT)
    if (global_offline_page)
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }
#endif /* defined(WAP_SUPPORT) */ 

    RedrawCategoryFunction();
    HighlightEmWAPOfflinePage();
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmOfflinePage
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmOfflinePage(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;
    S16 nHistory = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currHistory.scrnID = EM_WAP_OFFLINE_PAGE_MENU_SCR;
    currHistory.entryFuncPtr = EntryEmOfflinePage;
    mmi_ucs2cpy((S8*) currHistory.inputBuffer, (S8*) & nHistory);
    GetCategoryHistory(currHistory.guiBuffer);
    AddHistory(currHistory);
}


/*****************************************************************************
 * FUNCTION
 *  SendUserAgentReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendUserAgentReq(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    global_wap_user_agent = currentHighlightIndex;
    em_wap_change_setting(EM_WAP_USERAGENT_OPT, global_wap_user_agent);
#endif /* defined(WAP_SUPPORT) */ 
    DisplayPopup(
        (U8*) GetString(STR_GLOBAL_DONE),
        (U16) IMG_GLOBAL_ACTIVATED,
        (U8) 1,
        EM_NOTIFY_DURATION,
        (U8) SUCCESS_TONE);
}


/*****************************************************************************
 * FUNCTION
 *  EmAssignUserAgentMenuItem
 * DESCRIPTION
 *  
 * PARAMETERS
 *  nStrItemList        [?]     
 *  nNumofItem          [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EmAssignUserAgentMenuItem(U16 *nStrItemList, U8 *nNumofItem)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(WAP_SUPPORT)
    if (nStrItemList)
    {
        U8 i=0;

        for (i=0; i<EM_WAP_USERAGENT_MAX ; i++)
        {
            nStrItemList[idx] = EM_WAP_USER_AGENT_MAUI_E800_TEXT+i;
            idx++;
        }
    }

#endif /* defined(WAP_SUPPORT) */

#if 0    
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(WAP_SUPPORT) */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined (WAP)SUPPORT) */
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if defined(WAP_SUPPORT)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
/* under construction !*/
/* under construction !*/
#endif 

    if (nNumofItem)
    {
        *nNumofItem = idx;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmUserAgent
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmUserAgent(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nStrItemList[EM_WAP_USERAGENT_MAX];
#else /* defined(WAP_SUPPORT) */ 
    U16 nStrItemList[6];
#endif /* defined(WAP_SUPPORT) */ 
    U8 nNumofItem;
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmAssignUserAgentMenuItem(nStrItemList, &nNumofItem);

#if defined(WAP_SUPPORT)
    currentHighlightIndex =
        (global_wap_user_agent < EM_WAP_USERAGENT_MAX) ? global_wap_user_agent : EM_WAP_USERAGENT_MAUI_E800;
#endif /* defined(WAP_SUPPORT) */ 

    EntryNewScreen(EM_WAP_USER_AGENT_MENU_SCR, NULL, EntryEmUserAgent, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_WAP_USER_AGENT_MENU_SCR);

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_WAP_USER_AGENT_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nNumofItem,
        nStrItemList,
        currentHighlightIndex,
        guiBuffer);

    SetLeftSoftkeyFunction(SendUserAgentReq, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  SendAcceptHeaderReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendAcceptHeaderReq(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    global_wap_accept_header = currentHighlightIndex;
    em_wap_change_setting(EM_WAP_ACCEPTHEADER_OPT, global_wap_accept_header);
#endif /* defined(WAP_SUPPORT) */ 
    DisplayPopup(
        (U8*) GetString(STR_GLOBAL_DONE),
        (U16) IMG_GLOBAL_OK,
        (U8) NULL,
        EM_NOTIFY_DURATION,
        (U8) SUCCESS_TONE);
}


/*****************************************************************************
 * FUNCTION
 *  EmAssignAcceptHeaderMenuItem
 * DESCRIPTION
 *  
 * PARAMETERS
 *  nStrItemList        [?]     
 *  nNumofItem          [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EmAssignAcceptHeaderMenuItem(U16 *nStrItemList, U8 *nNumofItem)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (nStrItemList)
    {
        nStrItemList[idx] = EM_WAP_ACCEPT_HEADER_WAP121_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_WAP_ACCEPTHEADER_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;

        nStrItemList[idx] = EM_WAP_ACCEPT_HEADER_WAP20_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_WAP_ACCEPTHEADER_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;

        nStrItemList[idx] = EM_WAP_ACCEPT_HEADER_WML_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_WAP_ACCEPTHEADER_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;

        nStrItemList[idx] = EM_WAP_ACCEPT_HEADER_XHTML_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_WAP_ACCEPTHEADER_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;

        nStrItemList[idx] = EM_WAP_ACCEPT_HEADER_HTML_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_WAP_ACCEPTHEADER_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;
    }

    if (nNumofItem)
    {
        *nNumofItem = idx;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmAcceptHeader
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAcceptHeader(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nStrItemList[EM_WAP_ACCEPTHEADER_MAX];
#else /* defined(WAP_SUPPORT) */ 
    U16 nStrItemList[5];
#endif /* defined(WAP_SUPPORT) */ 
    U8 nNumofItem;
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmAssignAcceptHeaderMenuItem(nStrItemList, &nNumofItem);

#if defined(WAP_SUPPORT)
    currentHighlightIndex =
        (global_wap_accept_header < EM_WAP_ACCEPTHEADER_MAX) ? global_wap_accept_header : EM_WAP_ACCEPTHEADER_WAP121;
#endif /* defined(WAP_SUPPORT) */ 

    EntryNewScreen(EM_WAP_ACCEPT_HEADER_MENU_SCR, NULL, EntryEmAcceptHeader, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_WAP_ACCEPT_HEADER_MENU_SCR);

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_WAP_ACCEPT_HEADER_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nNumofItem,
        nStrItemList,
        currentHighlightIndex,
        guiBuffer);

    SetLeftSoftkeyFunction(SendAcceptHeaderReq, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}

#if (defined(MT6229) || defined(MT6227) || defined(MT6228) || defined(MT6225) || defined(MT6268T) || defined(MT6230) || defined(MT6227D) || defined(MT6223) || defined(MT6226D) || defined(MT6223P)) 


/*****************************************************************************
 * FUNCTION
 *  HighlightEMSWDBG
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMSWDBG(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_em_set_uart_req_type = EM_SET_UART_SWDBG;
    
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EngineerModeGetUartReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  SetSWDBG
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SetSWDBG(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (currentHighlightIndex < EM_SWDBG_RESET)
    {
        mmi_eq_set_uart_req_struct *msg_p;

        SWDBG_Profile = currentHighlightIndex + 1;  /* SWDBG is 1-based */

        msg_p = OslConstructDataPtr(sizeof(mmi_eq_set_uart_req_struct));

        msg_p->func_id = UART_NVRAM_LID_FUNC_SWDBG;
        
    #if defined(__DSPIRDBG__)&& defined(__MMI_USB_SUPPORT__)
        if (currentHighlightIndex == EM_SWDBG_MCU_DSP_IRDBG)
        {
            if( (EmAppPortArray[EM_APP_PS]==uart_port_usb) || 
                (EmAppPortArray[EM_APP_TST_PS]==uart_port_usb) ||
                (EmAppPortArray[EM_APP_TST_L1]==uart_port_usb) ||
                (EmAppPortArray[EM_APP_CTI]==uart_port_usb))
            {
                EmAppPortArray[EM_APP_TST_PS] = uart_port2;
                EmAppPortArray[EM_APP_TST_L1] = uart_port2;
                EmAppPortArray[EM_APP_PS] = uart_port1;
                EmAppPortArray[EM_APP_CTI] = uart_port_null;
            }
//            else if (EmUartPortCTIHighlight == EM_USB_PORT+1)
//            {
//                EmUartPortCTIHighlight = 0;
//            }
        }
    #endif /* __DISPIRDBG__) */

        msg_p->ps_port = EmAppPortArray[EM_APP_PS];
        msg_p->tst_port_ps = EmAppPortArray[EM_APP_TST_PS];
        msg_p->tst_port_l1 = EmAppPortArray[EM_APP_TST_L1];
        msg_p->cti_uart_port = EmAppPortArray[EM_APP_CTI];

        msg_p->ps_baud_rate = EM_GetBaudRateByIdx(EmAppBaudArray[EM_APP_PS]);
        msg_p->tst_baud_rate_ps = EM_GetBaudRateByIdx(EmAppBaudArray[EM_APP_TST_PS]);
        msg_p->tst_baud_rate_l1 = EM_GetBaudRateByIdx(EmAppBaudArray[EM_APP_TST_L1]);
        msg_p->cti_baud_rate = EM_GetBaudRateByIdx(EmAppBaudArray[EM_APP_CTI]);

        msg_p->High_Speed_SIM_Enabled = High_Speed_SIM;
        msg_p->swdbg = SWDBG_Profile;

        msg_p->uart_power_setting = UART_POWER_SETTING;


        UART_setting = FALSE;

    #ifdef __SWDBG_SUPPORT__
    #ifdef __DSPIRDBG__
        if (currentHighlightIndex == EM_SWDBG_MCU_DSP_IRDBG)
        {
            /* swdbg_dd_disable(); */
        }
    #endif /* __DSPIRDBG__ */ 
    #ifndef L4_NOT_PRESENT
        if (PS_UART_PORT == TST_PORT)
        {
            EngineerModeErrorNotice(NULL);
        }
        else
        {
            EngineerModeSendMsg(MSG_ID_MMI_EQ_SET_UART_REQ, msg_p, NULL);
        }
    #endif /* L4_NOT_PRESENT */ 
    #else /* __SWDBG_SUPPORT__ */ 
        EngineerModeSendMsg(MSG_ID_MMI_EQ_SET_UART_REQ, msg_p, NULL);
    #endif /* __SWDBG_SUPPORT__ */ 
    }
    else    /* RESET */
    {
    #ifdef __SWDBG_SUPPORT__
        swdbg_reset();
    #endif 
        EngineerModeSuccessNotice(EM_AUD_SET_SUCCESS_TEXT);
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmAssignSWDBGMenuItem
 * DESCRIPTION
 *  
 * PARAMETERS
 *  nStrItemList        [?]     
 *  nNumofItem          [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EmAssignSWDBGMenuItem(U16 *nStrItemList, U8 *nNumofItem)
{
#if (defined(MT6227) || defined(MT6227D) || defined(MT6226D))
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (nStrItemList)
    {
        nStrItemList[0] = EM_SWDBG_OFF_TEXT;
        nStrItemList[1] = EM_SWDBG_DSP_L1_PS_TEXT;
        nStrItemList[2] = EM_SWDBG_L1_PS_TEXT;
        nStrItemList[3] = EM_SWDBG_MCU_TEXT;
        nStrItemList[4] = EM_SWDBG_RESET_TEXT;
    }

    if (nNumofItem)
    {
        *nNumofItem = EM_SWDBG_MAX;
    }

#elif defined(MT6228)

    if (nStrItemList)
    {
        nStrItemList[0] = EM_SWDBG_OFF_TEXT;
        nStrItemList[1] = EM_SWDBG_DSP_L1_PS_TEXT;
        nStrItemList[2] = EM_SWDBG_L1_PS_TEXT;
        nStrItemList[3] = EM_SWDBG_MCU_TEXT;
        nStrItemList[4] = EM_SWDBG_MCU_DSP_TEXT;
        nStrItemList[5] = EM_SWDBG_RESET_TEXT;
    }

    if (nNumofItem)
    {
        *nNumofItem = EM_SWDBG_MAX;
    }

#else 

    if (nStrItemList)
    {
        nStrItemList[0] = EM_SWDBG_OFF_TEXT;
        nStrItemList[1] = EM_SWDBG_DSP_L1_TEXT;
        nStrItemList[2] = EM_SWDBG_DSP_PS_TEXT;
        nStrItemList[3] = EM_SWDBG_L1_PS_TEXT;
        nStrItemList[4] = EM_SWDBG_MCU_TEXT;
        nStrItemList[5] = EM_SWDBG_MCU_DSP_TEXT;
    #ifdef __DSPIRDBG__
        nStrItemList[6] = EM_SWDBG_MCU_DSP_IRDBG_TEXT;
        nStrItemList[7] = EM_SWDBG_RESET_TEXT;
    #else /* __DSPIRDBG__ */ 
        nStrItemList[6] = EM_SWDBG_RESET_TEXT;
    #endif /* __DSPIRDBG__ */ 
    }

    if (nNumofItem)
    {
        *nNumofItem = EM_SWDBG_MAX;
    }

#endif 
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSWDBG
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSWDBG(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nStrItemList[EM_SWDBG_MAX];
    U8 nNumofItem;
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmAssignSWDBGMenuItem(nStrItemList, &nNumofItem);

    currentHighlightIndex = SWDBG_Profile - 1;  /* SWDBG is 1-based */
    EntryNewScreen(EM_SET_SWDBG_SCR, NULL, EntryEmSWDBG, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_SET_SWDBG_SCR);

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_SWDBG_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nNumofItem,
        nStrItemList,
        currentHighlightIndex,
        guiBuffer);

    SetLeftSoftkeyFunction(SetSWDBG, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}
#endif /* #if (defined(MT6229) || defined(MT6227) || defined(MT6228) || defined(MT6225) || defined(MT6268T) || defined(MT6230) || defined(MT6227D)) || defined(MT6226D) */ 
/* Lisen 05032005     End */


/*****************************************************************************
 * FUNCTION
 *  SendMMSVersionReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SendMMSVersionReq(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    global_mms_version = currentHighlightIndex;
    em_wap_change_setting(EM_MMS_VERSION_OPT, global_mms_version);
#endif /* defined(WAP_SUPPORT) */ 
    DisplayPopup(
        (U8*) GetString(STR_GLOBAL_DONE),
        (U16) IMG_GLOBAL_OK,
        (U8) NULL,
        EM_NOTIFY_DURATION,
        (U8) SUCCESS_TONE);
}


/*****************************************************************************
 * FUNCTION
 *  EmAssignMMSVersionMenuItem
 * DESCRIPTION
 *  
 * PARAMETERS
 *  nStrItemList        [?]     
 *  nNumofItem          [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EmAssignMMSVersionMenuItem(U16 *nStrItemList, U8 *nNumofItem)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (nStrItemList)
    {
        nStrItemList[idx] = EM_WAP_MMS_VERSION_MMS_DEFAULT_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_MMS_VERSION_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;

        nStrItemList[idx] = EM_WAP_MMS_VERSION_MMS10_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_MMS_VERSION_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;

        nStrItemList[idx] = EM_WAP_MMS_VERSION_MMS11_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_MMS_VERSION_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;
        nStrItemList[idx] = EM_WAP_MMS_VERSION_MMS12_TEXT;
    #if defined(WAP_SUPPORT)
        if (idx >= EM_MMS_VERSION_MAX)
        {
            return;
        }
    #endif /* defined(WAP_SUPPORT) */ 
        idx++;
    }

    if (nNumofItem)
    {
        *nNumofItem = idx;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMMMSVersion
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMMMSVersion(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nStrItemList[EM_MMS_VERSION_MAX];
#else /* defined(WAP_SUPPORT) */ 
    U16 nStrItemList[3];
#endif /* defined(WAP_SUPPORT) */ 
    U8 nNumofItem;
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmAssignMMSVersionMenuItem(nStrItemList, &nNumofItem);

#if defined(WAP_SUPPORT)
    currentHighlightIndex = (global_mms_version < EM_MMS_VERSION_MAX) ? global_mms_version : EM_MMS_VERSION_10;
#endif 

    EntryNewScreen(EM_WAP_MMS_VERSION_MENU_SCR, NULL, EntryEMMMSVersion, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_WAP_MMS_VERSION_MENU_SCR);

    RegisterHighlightHandler(SetHighlightIndex);

    ShowCategory11Screen(
        EM_WAP_MMS_VERSION_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nNumofItem,
        nStrItemList,
        currentHighlightIndex,
        guiBuffer);

    SetLeftSoftkeyFunction(SendMMSVersionReq, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmAutoAnswer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAutoAnswer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gprofiles[0].answeringMode.automatic == 1)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmAutoAnswer, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightVideoHiBitrate
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT)
void HighlightVideoHiBitrate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    {
        U8 mode;

        /*----------------------------------------------------------------*/
        /* Code Body                                                      */
        /*----------------------------------------------------------------*/
        mode = media_vid_get_em_mode();

        if (mode == VID_EM_MODE_DISABLED)
        {
            ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
        }
        else if (mode == VID_EM_MODE_ULTRA_HIGH_BITRATE)
        {
            ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
        }
        else
        {
            ASSERT(0);
        }
    }

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryVideoHiBitrate, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}
#endif /* defined(__MMI_VIDEO_RECORDER__) && defined(ISP_SUPPORT) */ 


/*****************************************************************************
 * FUNCTION
 *  HighlightEmHighSpeedSIM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmHighSpeedSIM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_em_set_uart_req_type = EM_SET_UART_HIGH_SPEED_SIM;
    
    if (High_Speed_SIM)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EngineerModeGetUartReq, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmMiscBacklight
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmMiscBacklight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (backlight_mode == BACKLIGHT_NORMAL)
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmMiscBacklight, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSerialPortEnable
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSerialPortEnable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSerialPortEnable, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmAutoReset
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAutoReset(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmAutoReset, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

#if defined(__AMR_SUPPORT__)


/*****************************************************************************
 * FUNCTION
 *  HighlightEmAMR
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmAMR(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);

    if (AMR_ON)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMFAMR, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMFAMR
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMFAMR(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 Ret;
    S16 ErrorCode;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (AMR_ON == FALSE)
    {
        mscap[0] = 0x1f;
        Ret = WriteRecord(NVRAM_EF_MSCAP_LID, 1, &mscap, NVRAM_EF_MSCAP_SIZE, &ErrorCode);
        if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_MSCAP_SIZE))
        {
            ASSERT(0);
        }
        AMR_ON = TRUE;
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
    #if !defined(MT6205)
        mscap[0] = 0x07;
    #else 
        mscap[0] = 0x05;
    #endif 
        Ret = WriteRecord(NVRAM_EF_MSCAP_LID, 1, &mscap, NVRAM_EF_MSCAP_SIZE, &ErrorCode);
        if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_MSCAP_SIZE))
        {
            ASSERT(0);
        }
        AMR_ON = FALSE;
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    RedrawCategoryFunction();
    HighlightEmAMR();
}
#endif /* defined(__AMR_SUPPORT__) */ 


/*****************************************************************************
 * FUNCTION
 *  HighlightEMWAP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMWAP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmWAP, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmWAPEnableDebug
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmWAPEnableDebug(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wap_enable_debug_assert)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }
#endif /* defined(WAP_SUPPORT) */ 

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmWAPEnableDebug, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

/* Lisen 012605 */


/*****************************************************************************
 * FUNCTION
 *  HighlightEmMMIDebug
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmMMIDebug(void)
{
#ifdef DEBUG_ASSERT
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_frm_enable_debug_assert)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }
#endif /* DEBUG_ASSERT */ 

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmMMIDebug, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmMemoryDump
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmMemoryDump(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Lisen 04072005 */
    if (INT_MemoryDumpFlag == EX_FORCEMEMORYDUMP)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmMemoryDump, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmFRMProfiling
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmFRMProfiling(void)
{
#ifdef __MMI_INTERACTIVE_PROFILNG__	
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmFRMProfiling, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
#endif    
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmWAPOfflinePage
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmWAPOfflinePage(void)
{
#if defined(WAP_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (global_offline_page)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }
#endif /* defined(WAP_SUPPORT) */ 

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmOfflinePage, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEMUserAgent
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMUserAgent(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmUserAgent, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEMAcceptHeader
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMAcceptHeader(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmAcceptHeader, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEMMMSVersion
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMMMSVersion(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMMMSVersion, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  GetSelectedTestList
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
U16 GetSelectedTestList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count, testitem;
    U16 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadSettingsFromNVRAM();

    if (gAutoTestListSize > MAX_AUTO_TEST_ITEMS)
    {
        gAutoTestListSize = MAX_AUTO_TEST_ITEMS;
    }

    for (count = 0; count < MAX_AUTO_TEST_ITEMS; count++)
    {
        AutoTestSelectedItems[count] = NULL;
    }

    for (count = 0; count < gAutoTestListSize; count++, index++)
    {
        testitem = nvramTestItemArray.priority[count];
        /* AutoTestSelectedItems[count] = (PU8) AutoTestItemList[testitem]; */
        AutoTestSelectedItems[count] = (PU8) Tests[testitem].name;
    }
    return count;
}


/*****************************************************************************
 * FUNCTION
 *  ReadTestResultFromNVRAM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ReadTestResultFromNVRAM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

#if defined(__MTK_TARGET__)
    nvram_ef_autotest_struct testdata;
    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&testdata, 0, sizeof(testdata));
    Ret = ReadRecord(NVRAM_EF_AUTOTEST_LID, 2, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
    if (!(ErrorCode == NVRAM_READ_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
    {
        ASSERT(0);
    }

    nvramTestResultArray.count = testdata.testcount;

    for (i = 0; i < testdata.testcount; i++)
    {
        nvramTestResultArray.result[i] =
            (testdata.testlist[i] < FM_TEST_PASSED) ? testdata.testlist[i] : FM_TEST_PASSED;
    }

#endif /* defined(__MTK_TARGET__)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  WriteTestResultToNVRAM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void WriteTestResultToNVRAM(void)
{
#if defined(__MTK_TARGET__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;
    nvram_ef_autotest_struct testdata;
    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&testdata, 0, sizeof(testdata));

    testdata.testcount = gAutoTestListSize;
    for (i = 0; i < testdata.testcount; i++)
    {
        testdata.testlist[i] = nvramTestResultArray.result[i];
    }

    Ret = WriteRecord(NVRAM_EF_AUTOTEST_LID, 2, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
    if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
    {
        ASSERT(0);
    }
#endif /* defined(__MTK_TARGET__)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ReadTimeFromNVRAM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ReadTimeFromNVRAM(void)
{
#if defined(__MTK_TARGET__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ef_autotest_struct testdata;
    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&testdata, 0, sizeof(testdata));
    Ret = ReadRecord(NVRAM_EF_AUTOTEST_LID, 1, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
    if (!(ErrorCode == NVRAM_READ_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
    {
        ASSERT(0);
    }

    myclocktime.rtc_sec = testdata.rtc_sec;
    myclocktime.rtc_min = testdata.rtc_min;
    myclocktime.rtc_hour = testdata.rtc_hour;
    myclocktime.rtc_day = testdata.rtc_day;
    myclocktime.rtc_mon = testdata.rtc_mon;
    myclocktime.rtc_wday = testdata.rtc_wday;
    myclocktime.rtc_year = testdata.rtc_year;

#endif /* defined(__MTK_TARGET__)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  WriteCurrentTimeToNVRAM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void WriteCurrentTimeToNVRAM(void)
{
#if defined(__MTK_TARGET__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    nvram_ef_autotest_struct testdata;
    MYTIME t;
    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&testdata, 0, sizeof(testdata));
    Ret = ReadRecord(NVRAM_EF_AUTOTEST_LID, 1, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
    if (!(ErrorCode == NVRAM_READ_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
    {
        ASSERT(0);
    }

    DTGetRTCTime(&t);

    testdata.rtc_sec = t.nSec;
    testdata.rtc_min = t.nMin;
    testdata.rtc_hour = t.nHour;
    testdata.rtc_day = t.nDay;
    testdata.rtc_mon = t.nMonth;
    testdata.rtc_wday = 0;
    testdata.rtc_year = (kal_uint8) (t.nYear - 2000);

    Ret = WriteRecord(NVRAM_EF_AUTOTEST_LID, 1, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
    if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
    {
        ASSERT(0);
    }
#endif /* ( defined(__MTK_TARGET__)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ReadSettingsFromNVRAM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ReadSettingsFromNVRAM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

#if defined(__MTK_TARGET__)
    nvram_ef_autotest_struct testdata;
    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&testdata, 0, sizeof(testdata));
    Ret = ReadRecord(NVRAM_EF_AUTOTEST_LID, 1, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
    if (!(ErrorCode == NVRAM_READ_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
    {
        ASSERT(0);
    }

    nvramTestItemArray.count = testdata.testcount;

    for (i = 0; i < testdata.testcount; i++)
    {
        nvramTestItemArray.priority[i] = testdata.testlist[i];
    }

    gAutoTestListSize = nvramTestItemArray.count;

    myclocktime.rtc_sec = testdata.rtc_sec;
    myclocktime.rtc_min = testdata.rtc_min;
    myclocktime.rtc_hour = testdata.rtc_hour;
    myclocktime.rtc_day = testdata.rtc_day;
    myclocktime.rtc_mon = testdata.rtc_mon;
    myclocktime.rtc_wday = testdata.rtc_wday;
    myclocktime.rtc_year = testdata.rtc_year;

#endif /* (defined(__MTK_TARGET__)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  SaveNewItemToNVRAM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SaveNewItemToNVRAM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 p_val = gPriorityValue - 1; /* convert to 0-based */
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < gAutoTestListSize; i++)
        if (nvramTestItemArray.priority[i] == gHiliteAllTestListIdx)    /* the item is already in the list */
        {
            /* pop up warning */
            DisplayPopup((PU8) GetString(STR_GLOBAL_UNFINISHED), IMG_GLOBAL_UNFINISHED, 1, 1000, ERROR_TONE);
            DeleteUptoScrID(EM_AUTO_TEST_SETTING_MENU_SCR);
            return;
        }

    gAutoTestListSize += 1;
    nvramTestItemArray.count = (U8) gAutoTestListSize;

    /* Shift the list */
    for (i = gAutoTestListSize - 1; i > p_val; i--)
    {
        nvramTestItemArray.priority[i] = nvramTestItemArray.priority[i - 1];
    }

    nvramTestItemArray.priority[p_val] = (U8) gHiliteAllTestListIdx;

#if defined(__MTK_TARGET__)
    {
        nvram_ef_autotest_struct testdata;
        S16 ErrorCode, Ret;

        memset(&testdata, 0, sizeof(testdata));

        testdata.testcount = nvramTestItemArray.count;
        for (i = 0; i < testdata.testcount; i++)
        {
            testdata.testlist[i] = nvramTestItemArray.priority[i];
        }

        testdata.rtc_sec = myclocktime.rtc_sec;
        testdata.rtc_min = myclocktime.rtc_min;
        testdata.rtc_hour = myclocktime.rtc_hour;
        testdata.rtc_day = myclocktime.rtc_day;
        testdata.rtc_mon = myclocktime.rtc_mon;
        testdata.rtc_wday = myclocktime.rtc_wday;
        testdata.rtc_year = myclocktime.rtc_year;

        Ret = WriteRecord(NVRAM_EF_AUTOTEST_LID, 1, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
        if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
        {
            ASSERT(0);
        }
        else
        {
            DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
            DeleteUptoScrID(EM_AUTO_TEST_SETTING_MENU_SCR);
        }
    }
#endif /* ( defined(__MTK_TARGET__)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  SavePriorityChangeToNVRAM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SavePriorityChangeToNVRAM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 new_pri = gPriorityValue - 1;           /* convert to 0-based */
    U16 old_pri = gHiliteAutoTestCurrSelIdx;    /* 0-based */
    U16 temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (new_pri == old_pri) /* the priority is the same */
    {
        DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
        DeleteUptoScrID(EM_AUTO_TEST_SETTING_MENU_SCR);
        return;
    }

    /* Switch the items of new_pri and old_pri */
    temp = nvramTestItemArray.priority[new_pri];
    nvramTestItemArray.priority[new_pri] = nvramTestItemArray.priority[old_pri];
    nvramTestItemArray.priority[old_pri] = (U8) temp;

#if defined(__MTK_TARGET__)
    {
        nvram_ef_autotest_struct testdata;
        S16 ErrorCode, Ret;
        U8 i;

        memset(&testdata, 0, sizeof(testdata));

        testdata.testcount = nvramTestItemArray.count;
        for (i = 0; i < testdata.testcount; i++)
        {
            testdata.testlist[i] = nvramTestItemArray.priority[i];
        }

        testdata.rtc_sec = myclocktime.rtc_sec;
        testdata.rtc_min = myclocktime.rtc_min;
        testdata.rtc_hour = myclocktime.rtc_hour;
        testdata.rtc_day = myclocktime.rtc_day;
        testdata.rtc_mon = myclocktime.rtc_mon;
        testdata.rtc_wday = myclocktime.rtc_wday;
        testdata.rtc_year = myclocktime.rtc_year;

        Ret = WriteRecord(NVRAM_EF_AUTOTEST_LID, 1, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
        if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
        {
            ASSERT(0);
        }
        else
        {
            DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
            DeleteUptoScrID(EM_AUTO_TEST_SETTING_MENU_SCR);
        }
    }
#endif /* (  defined(__MTK_TARGET__)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  SaveRemoveItemToNVRAM
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SaveRemoveItemToNVRAM(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 p_val = gHiliteAutoTestCurrSelIdx;
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gAutoTestListSize -= 1;
    nvramTestItemArray.count = (U8) gAutoTestListSize;

    /* Shift the list */
    for (i = p_val; i < gAutoTestListSize; i++)
    {
        nvramTestItemArray.priority[i] = nvramTestItemArray.priority[i + 1];
    }

#if defined(__MTK_TARGET__)
    {
        nvram_ef_autotest_struct testdata;
        S16 ErrorCode, Ret;

        memset(&testdata, 0, sizeof(testdata));

        testdata.testcount = nvramTestItemArray.count;
        for (i = 0; i < testdata.testcount; i++)
        {
            testdata.testlist[i] = nvramTestItemArray.priority[i];
        }

        testdata.rtc_sec = myclocktime.rtc_sec;
        testdata.rtc_min = myclocktime.rtc_min;
        testdata.rtc_hour = myclocktime.rtc_hour;
        testdata.rtc_day = myclocktime.rtc_day;
        testdata.rtc_mon = myclocktime.rtc_mon;
        testdata.rtc_wday = myclocktime.rtc_wday;
        testdata.rtc_year = myclocktime.rtc_year;

        Ret = WriteRecord(NVRAM_EF_AUTOTEST_LID, 1, &testdata, NVRAM_EF_AUTOTEST_SIZE, &ErrorCode);
        if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_AUTOTEST_SIZE))
        {
            ASSERT(0);
        }
        else
        {
            DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
            DeleteUptoScrID(EM_AUTO_TEST_SETTING_MENU_SCR);
        }
    }
#endif /* ( defined(__MTK_TARGET__)) */ 
}


/*****************************************************************************
 * FUNCTION
 *  EntryConfirmRemoveTestItem
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryConfirmRemoveTestItem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayConfirm(
        STR_GLOBAL_YES,
        IMG_GLOBAL_YES,
        STR_GLOBAL_NO,
        IMG_GLOBAL_NO,
        get_string(STR_GLOBAL_DELETE),
        IMG_GLOBAL_QUESTION,
        WARNING_TONE);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetLeftSoftkeyFunction(SaveRemoveItemToNVRAM, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryScrEnterItemPriority
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryScrEnterItemPriority(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUTO_TEST_ENTER_PRIORITY_MENU_SCR, NULL, EntryScrEnterItemPriority, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUTO_TEST_ENTER_PRIORITY_MENU_SCR);

    gPriorityValue = gAutoTestListSize + 1;
    ShowCategory87Screen(
        EM_AUTO_TEST_ENTER_PRIORITY_TEXT,
        EM_AUTO_TEST_ENTER_PRIORITY_ICON,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        1,
        (S32) (gAutoTestListSize + 1),
        (S32*) & gPriorityValue,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetLeftSoftkeyFunction(SaveNewItemToNVRAM, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryScrChangePriority
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryScrChangePriority(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUTO_TEST_CHANGE_PRIORITY_MENU_SCR, NULL, EntryScrChangePriority, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUTO_TEST_CHANGE_PRIORITY_MENU_SCR);

    gPriorityValue = gHiliteAutoTestCurrSelIdx + 1;
    ShowCategory87Screen(
        EM_AUTO_TEST_ENTER_PRIORITY_TEXT,
        EM_AUTO_TEST_ENTER_PRIORITY_ICON,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        1,
        (S32) gAutoTestListSize,
        (S32*) & gPriorityValue,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetLeftSoftkeyFunction(SavePriorityChangeToNVRAM, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HiliteAllTestIdx
 * DESCRIPTION
 *  
 * PARAMETERS
 *  hiliteIdx       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void HiliteAllTestIdx(S32 hiliteIdx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gHiliteAllTestListIdx = (U16) hiliteIdx;
}


/*****************************************************************************
 * FUNCTION
 *  EntryGetAllTestItemList
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryGetAllTestItemList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;
    PU8 guiBuffer;
    PU8 testItemList[MAX_AUTO_TEST_ITEMS];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUTO_TEST_ADD_MENU_SCR, NULL, EntryGetAllTestItemList, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUTO_TEST_ADD_MENU_SCR);

    RegisterHighlightHandler(HiliteAllTestIdx);

    for (index = 0; index < MAX_AUTO_TEST_ITEMS; index++)
    {
        /* testItemList[index] = AutoTestItemList[index]; */
        testItemList[index] = (PU8) Tests[index].name;
    }

    ShowCategory6Screen(
        EM_AUTO_TEST_ADD_TEXT,
        EM_AUTO_TEST_ADD_ICON,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_AUTO_TEST_ITEMS,
        testItemList,
        NULL,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetLeftSoftkeyFunction(EntryScrEnterItemPriority, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HiliteAutoTestAddFromList
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HiliteAutoTestAddFromList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(EntryGetAllTestItemList, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HiliteAutoTestChangePriority
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HiliteAutoTestChangePriority(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(EntryScrChangePriority, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HiliteAutoTestRemove
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HiliteAutoTestRemove(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(EntryConfirmRemoveTestItem, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HiliteAutoTestCurrSelIdx
 * DESCRIPTION
 *  
 * PARAMETERS
 *  hiliteIdx       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void HiliteAutoTestCurrSelIdx(S32 hiliteIdx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gHiliteAutoTestCurrSelIdx = (U16) hiliteIdx;
}


/*****************************************************************************
 * FUNCTION
 *  GoBackAutoTestSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void GoBackAutoTestSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GoBackToHistory(EM_AUTO_TEST_SETTING_MENU_SCR);
}


/*****************************************************************************
 * FUNCTION
 *  EM_InitAutoTest
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EM_InitAutoTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* U16 count; */

    SetHiliteHandler(EM_AUTO_TEST_ADD_MENUID, HiliteAutoTestAddFromList);
    SetHiliteHandler(EM_AUTO_TEST_CHANGE_PRIORITY_MENUID, HiliteAutoTestChangePriority);
    SetHiliteHandler(EM_AUTO_TEST_REMOVE_MENUID, HiliteAutoTestRemove);

    /*
     * for (count = 0; count < MAX_AUTO_TEST_ITEMS; count++)
     * memset(AutoTestItemList[count], 0, MAX_TEST_ITEM_NAME_LEN*ENCODING_LENGTH);
     * for (count = 0 ; count< MAX_AUTO_TEST_ITEMS; count++) 
     * {
     * mmi_asc_to_ucs2((S8*)pOutBuffer, (S8*) (Tests[count].name));
     * mmi_ucs2cpy((S8*)AutoTestItemList[count], (const S8*)pOutBuffer);
     * }
     */
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmAutoTestSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAutoTestSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EM_InitAutoTest();

    EntryNewScreen(EM_AUTO_TEST_SETTING_MENU_SCR, NULL, EntryEmAutoTestSetting, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUTO_TEST_SETTING_MENU_SCR);

    GetSelectedTestList();

    RegisterHighlightHandler(HiliteAutoTestCurrSelIdx);
    if (!gAutoTestListSize)
    {
        AutoTestSelectedItems[0] = (U8*) GetString(STR_GLOBAL_EMPTY);
        ShowCategory6Screen(
            EM_AUTO_TEST_SETTING_TEXT,
            EM_AUTO_TEST_SETTING_ICON,
            STR_GLOBAL_OPTIONS,
            IMG_GLOBAL_OPTIONS,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            1,
            AutoTestSelectedItems,
            NULL,
            0,
            guiBuffer);
    }
    else
    {
        ShowCategory6Screen(
            EM_AUTO_TEST_SETTING_TEXT,
            EM_AUTO_TEST_SETTING_ICON,
            STR_GLOBAL_OPTIONS,
            IMG_GLOBAL_OPTIONS,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            gAutoTestListSize,
            AutoTestSelectedItems,
            NULL,
            0,
            guiBuffer);
    }

    ChangeLeftSoftkey(STR_GLOBAL_OPTIONS, IMG_GLOBAL_OPTIONS);
    SetLeftSoftkeyFunction(EntryScrShowAutoTestOptions, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightAutoTestSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightAutoTestSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmAutoTestSetting, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryScrShowAutoTestOptions
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryScrShowAutoTestOptions(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 guiBuffer;
    U16 nStrItemList[15];   /* Stores the strings id of submenus returned */
    U16 nNumofItem;         /* Stores no of children in the submenu */
    U16 nDispAttribute;     /* Stores display attribue */
    U16 ItemIcons[15];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_AUTO_TEST_OPTIONS_MENU_SCR, NULL, EntryScrShowAutoTestOptions, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_AUTO_TEST_OPTIONS_MENU_SCR);

    nNumofItem = GetNumOfChild(EM_AUTO_TEST_OPTIONS_MENUID);

    nDispAttribute = GetDispAttributeOfItem(EM_AUTO_TEST_OPTIONS_MENUID);

    ItemIcons[0] = IMG_GLOBAL_L1;
    ItemIcons[1] = IMG_GLOBAL_L2;
    ItemIcons[2] = IMG_GLOBAL_L3;
    ItemIcons[3] = IMG_GLOBAL_L4;
    GetSequenceStringIds(EM_AUTO_TEST_OPTIONS_MENUID, nStrItemList);
    SetParentHandler(EM_AUTO_TEST_OPTIONS_MENUID);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    if (gAutoTestListSize == 0)
    {
        nNumofItem = 1;
    }

    ShowCategory15Screen(
        EM_AUTO_TEST_OPTIONS_TEXT,
        MAIN_MENU_TITLE_SETTINGS_ICON,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        nNumofItem,
        nStrItemList,
        ItemIcons,
        LIST_MENU,
        0,
        guiBuffer);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmPWRDownCtrl
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmPWRDownCtrl(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmPWRDownCtrl, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSWPatch
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSWPatch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSWPatch, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EMPWRDownCtrlHighlightHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMPWRDownCtrlHighlightHandler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  EMSWPatchHighlightHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMSWPatchHighlightHandler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  EMPWRDownCtrlDoneFunc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMPWRDownCtrlDoneFunc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 textbuf[PWRDOWNSTRLEN];
    CONFIG_PDN_TYPE PDN;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    /* convert the textedit buffer to currPWMFreq and currPWMDuty */
    mmi_ucs2_to_asc((PS8) textbuf, (PS8) Buf_PDN_CON0);
    PDN.pdn_con0 = (kal_uint16) atoi((S8*) textbuf);
    mmi_ucs2_to_asc((PS8) textbuf, (PS8) Buf_PDN_CON1);
    PDN.pdn_con1 = (kal_uint16) atoi((S8*) textbuf);
    mmi_ucs2_to_asc((PS8) textbuf, (PS8) Buf_PDN_CON2);
    PDN.pdn_con2 = (kal_uint16) atoi((S8*) textbuf);
    mmi_ucs2_to_asc((PS8) textbuf, (PS8) Buf_PDN_CON3);
    PDN.pdn_con3 = (kal_uint16) atoi((S8*) textbuf);

    /* Call setting func */
    INT_SetPowerDownStatus(&PDN);
    /* DisplayPopup((PU8)GetString(EM_NOTICE_SUCCESS_TEXT), IMG_GLOBAL_DEFAULT, 0, EM_NOTIFY_DURATION, 0); */
    EngineerModeSuccessNotice(EM_NOTICE_SUCCESS_TEXT);
    DeleteScreenIfPresent(EM_PWR_DOWN_CONTROL_MENU_SCR);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmPWRDownCtrl
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmPWRDownCtrl(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CONFIG_PDN_TYPE PDN;
    U8 *guiBuffer;
    U8 *inputBuffer;
    U16 inputBufferSize;
    U16 ImageList[8];
    U8 textbuf[PWRDOWNSTRLEN];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_PWR_DOWN_CONTROL_MENU_SCR, ExitEmPWRDownCtrl, NULL, NULL);

    InitializeCategory57Screen();

    guiBuffer = GetCurrGuiBuffer(EM_PWR_DOWN_CONTROL_MENU_SCR);

    inputBuffer = GetCurrNInputBuffer(EM_PWR_DOWN_CONTROL_MENU_SCR, &inputBufferSize);

    RegisterHighlightHandler(EMPWRDownCtrlHighlightHandler);

    /* Get the current setting */
    INT_QueryPowerDownStatus(&PDN);

    /* Desc. String */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&(wgui_inline_items[0]), (U8*) GetString(EM_STR_PWNDOWN_CTRL_PDN_CON0));
    ImageList[0] = IMG_STATUS;

    /* PDN_CON0 */
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    memset((void*)textbuf, 0, PWRDOWNSTRLEN);
    sprintf((S8*) textbuf, "%d", PDN.pdn_con0);
    mmi_asc_to_ucs2((S8*) Buf_PDN_CON0, (S8*) textbuf);
    SetInlineItemTextEdit(&wgui_inline_items[1], (PU8) Buf_PDN_CON0, 10, INPUT_TYPE_NUMERIC);
    ImageList[1] = 0;

    /* Desc. String */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&(wgui_inline_items[2]), (U8*) GetString(EM_STR_PWNDOWN_CTRL_PDN_CON1));
    ImageList[2] = IMG_STATUS;

    /* PDN_CON1 */
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    memset((void*)textbuf, 0, PWRDOWNSTRLEN);
    sprintf((S8*) textbuf, "%d", PDN.pdn_con1);
    mmi_asc_to_ucs2((S8*) Buf_PDN_CON1, (S8*) textbuf);
    SetInlineItemTextEdit(&wgui_inline_items[3], (PU8) Buf_PDN_CON1, 10, INPUT_TYPE_NUMERIC);
    ImageList[3] = 0;

    /* Desc. String */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&(wgui_inline_items[4]), (U8*) GetString(EM_STR_PWNDOWN_CTRL_PDN_CON2));
    ImageList[4] = IMG_STATUS;

    /* PDN_CON2 */
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    memset((void*)textbuf, 0, PWRDOWNSTRLEN);
    sprintf((S8*) textbuf, "%d", PDN.pdn_con2);
    mmi_asc_to_ucs2((S8*) Buf_PDN_CON2, (S8*) textbuf);
    SetInlineItemTextEdit(&wgui_inline_items[5], (PU8) Buf_PDN_CON2, 10, INPUT_TYPE_NUMERIC);
    ImageList[5] = 0;

    /* Desc. String */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&(wgui_inline_items[6]), (U8*) GetString(EM_STR_PWNDOWN_CTRL_PDN_CON3));
    ImageList[6] = IMG_STATUS;

    /* PDN_CON3 */
    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    memset((void*)textbuf, 0, PWRDOWNSTRLEN);
    sprintf((S8*) textbuf, "%d", PDN.pdn_con3);
    mmi_asc_to_ucs2((S8*) Buf_PDN_CON3, (S8*) textbuf);
    SetInlineItemTextEdit(&wgui_inline_items[7], (PU8) Buf_PDN_CON3, 10, INPUT_TYPE_NUMERIC);
    ImageList[7] = 0;

    if (inputBuffer != NULL)
    {
        SetCategory57Data(wgui_inline_items, 8, inputBuffer);
    }

    ShowCategory57Screen(
        EM_PWR_DOWN_CONTROL_TEXT,
        EM_PWR_DOWN_CONTROL_ICON,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        8,
        ImageList,
        wgui_inline_items,
        0,
        guiBuffer);

    SetCategory57RightSoftkeyFunctions(EMPWRDownCtrlDoneFunc, GoBackHistory);

}

#undef PWRDOWNSTRLEN


/*****************************************************************************
 * FUNCTION
 *  EMSWPatchDoneFunc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMSWPatchDoneFunc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 textbuf[10];
    U8 DSPdata[8];

    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    mmi_ucs2_to_asc((PS8) textbuf, (PS8) Buf_PDN_CON0);
    DSPpatch = atoi((S8*) textbuf);
    memset(DSPdata, 0, sizeof(DSPdata));
    DSPdata[0] = DSPpatch;

    Ret = WriteRecord(
            NVRAM_EF_SYS_CACHE_OCTET_LID,
            NVRAM_SYS_DSP_PATCH,
            DSPdata,
            NVRAM_EF_SYS_CACHE_OCTET_SIZE,
            &ErrorCode);
    if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_SYS_CACHE_OCTET_SIZE))
    {
        ASSERT(0);
    }
    EngineerModeSuccessNotice(EM_NOTICE_SUCCESS_TEXT);
    /* DeleteScreenIfPresent(EM_SW_PATCH_MENU_SCR); */
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSWPatch
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSWPatch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U8 *inputBuffer;
    U16 inputBufferSize;
    U16 ImageList[8];
    U8 textbuf[10];
    U8 DSPdata[8];

    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_SW_PATCH_MENU_SCR, ExitEmSWPatch, NULL, NULL);

    InitializeCategory57Screen();

    guiBuffer = GetCurrGuiBuffer(EM_SW_PATCH_MENU_SCR);

    inputBuffer = GetCurrNInputBuffer(EM_SW_PATCH_MENU_SCR, &inputBufferSize);

    RegisterHighlightHandler(EMSWPatchHighlightHandler);

    /* Reading DSP patch setting from NVRAM */
    memset(DSPdata, 0, sizeof(DSPdata));
    Ret = ReadRecord(
            NVRAM_EF_SYS_CACHE_OCTET_LID,
            NVRAM_SYS_DSP_PATCH,
            DSPdata,
            NVRAM_EF_SYS_CACHE_OCTET_SIZE,
            &ErrorCode);
    if (!(ErrorCode == NVRAM_READ_SUCCESS && Ret == NVRAM_EF_SYS_CACHE_OCTET_SIZE))
    {
        ASSERT(0);
    }
    DSPpatch = DSPdata[0];

    /* Desc. String */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&(wgui_inline_items[0]), (U8*) GetString(EM_STR_SW_PATCH_DSP));
    ImageList[0] = IMG_STATUS;

    /* DSP */
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    memset((void*)textbuf, 0, 10);
    sprintf((S8*) textbuf, "%d", DSPpatch);
    /* Resuse global buffer Buf_PDN_CON0 */
    mmi_asc_to_ucs2((S8*) Buf_PDN_CON0, (S8*) textbuf);
    SetInlineItemTextEdit(&wgui_inline_items[1], (PU8) Buf_PDN_CON0, 10, INPUT_TYPE_NUMERIC);
    ImageList[1] = 0;

    if (inputBuffer != NULL)
    {
        SetCategory57Data(wgui_inline_items, 2, inputBuffer);
    }

    ShowCategory57Screen(
        EM_SW_PATCH_TEXT,
        EM_SW_PATCH_ICON,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        2,
        ImageList,
        wgui_inline_items,
        0,
        guiBuffer);

    SetCategory57RightSoftkeyFunctions(EMSWPatchDoneFunc, GoBackHistory);

}


/*****************************************************************************
 * FUNCTION
 *  ExitEmPWRDownCtrl
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmPWRDownCtrl(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;
    U16 inputBufferSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    currHistory.scrnID = EM_PWR_DOWN_CONTROL_MENU_SCR;
    currHistory.entryFuncPtr = EntryEmPWRDownCtrl;

    GetCategoryHistory(currHistory.guiBuffer);
    inputBufferSize = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) currHistory.inputBuffer);
    AddNHistory(currHistory, inputBufferSize);

}


/*****************************************************************************
 * FUNCTION
 *  ExitEmSWPatch
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmSWPatch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;
    U16 inputBufferSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    currHistory.scrnID = EM_SW_PATCH_MENU_SCR;
    currHistory.entryFuncPtr = EntryEmSWPatch;

    GetCategoryHistory(currHistory.guiBuffer);
    inputBufferSize = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) currHistory.inputBuffer);
    AddNHistory(currHistory, inputBufferSize);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightOnCertainSerialPortMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightOnCertainSerialPortMenu(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 is_on = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentHighlightIndex = (U8) index;

    switch (currentHighlightIndex)
    {
        case EM_MENU_SERIAL_PORT_EN_1:
            is_on = custom_em_get_uart_detection_status(CUSTOM_EM_UART_PORT1);
            break;
        case EM_MENU_SERIAL_PORT_EN_2:
            is_on = custom_em_get_uart_detection_status(CUSTOM_EM_UART_PORT2);
            break;
        case EM_MENU_SERIAL_PORT_EN_3:
            is_on = custom_em_get_uart_detection_status(CUSTOM_EM_UART_PORT3);
            break;
        default:
            break;
    }

    if (is_on == MMI_TRUE)
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
        /* Category53ChangeItemDescription( index, (U8*)get_string(STR_GLOBAL_ON)  ); */
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
        /* Category53ChangeItemDescription( index, (U8*)get_string(STR_GLOBAL_OFF)  ); */
    }

    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(SerialPortMenuLSKHandler, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    /* RedrawCategoryFunction(); */

}


/*****************************************************************************
 * FUNCTION
 *  SerialPortMenuLSKHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void SerialPortMenuLSKHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 is_on = MMI_FALSE, port = CUSTOM_EM_UART_PORT1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (currentHighlightIndex)
    {
        case EM_MENU_SERIAL_PORT_EN_1:
            is_on = custom_em_get_uart_detection_status(CUSTOM_EM_UART_PORT1);
            port = CUSTOM_EM_UART_PORT1;
            break;
        case EM_MENU_SERIAL_PORT_EN_2:
            is_on = custom_em_get_uart_detection_status(CUSTOM_EM_UART_PORT2);
            port = CUSTOM_EM_UART_PORT2;
            break;
        case EM_MENU_SERIAL_PORT_EN_3:
            is_on = custom_em_get_uart_detection_status(CUSTOM_EM_UART_PORT3);
            port = CUSTOM_EM_UART_PORT3;
            break;
        default:
            break;
    }

    if (is_on == MMI_TRUE)
    {
        custom_em_set_uart_detection_status(port, MMI_FALSE);
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
        Category53ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_OFF));
    }
    else
    {
        custom_em_set_uart_detection_status(port, MMI_TRUE);
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
        Category53ChangeItemDescription(currentHighlightIndex, (U8*) get_string(STR_GLOBAL_ON));
    }

    RedrawCategoryFunction();

}

#ifdef __J2ME__
extern void EntryScrJavaEM(void);


/*****************************************************************************
 * FUNCTION
 *  HighlightEmMiscJ2meTck
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmMiscJ2meTck(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryScrJavaEM, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}
#endif /* __J2ME__ */ 


/*****************************************************************************
 * FUNCTION
 *  EntryEmMiscBacklight
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmMiscBacklight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (backlight_mode == BACKLIGHT_NORMAL)
    {   /* Backlight on forever */
        SetBacklightModeExe(0);
        backlight_mode = BACKLIGHT_FOREVER;
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }
    else
    {   /* Backlight back to normal */
        SetBacklightModeExe(1);
        backlight_mode = BACKLIGHT_NORMAL;
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    RedrawCategoryFunction();
    HighlightEmMiscBacklight();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSerialPortEnable
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSerialPortEnable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U8 i;
    U8 *PopUpList[32];
    U16 ItemIcons[EM_MENU_SERIAL_PORT_EN_MAX];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_SERIAL_PORT_EN_MENU_SCR, NULL, EntryEmSerialPortEnable, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_SERIAL_PORT_EN_MENU_SCR);

    RegisterHighlightHandler(HighlightOnCertainSerialPortMenu);

    subMenuDataPtrs[0] = (PU8) GetString(EM_DEV_UART_1_TEXT);
    subMenuDataPtrs[1] = (PU8) GetString(EM_DEV_UART_2_TEXT);
    subMenuDataPtrs[2] = (PU8) GetString(EM_DEV_UART_3_TEXT);

    for (i = 0; i < EM_MENU_SERIAL_PORT_EN_MAX; i++)
        if (custom_em_get_uart_detection_status(CUSTOM_EM_UART_PORT1 + i) == MMI_TRUE)
        {
            PopUpList[i] = (PU8) GetString(STR_GLOBAL_ON);
        }
        else
        {
            PopUpList[i] = (PU8) GetString(STR_GLOBAL_OFF);
        }

    for (i = 0; i < EM_MENU_SERIAL_PORT_EN_MAX; i++)
    {
        ItemIcons[i] = IMG_GLOBAL_L1 + i;
    }

    ShowCategory53Screen(
        EM_SERIAL_PORT_EN_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        EM_MENU_SERIAL_PORT_EN_MAX,
        (PU8*) subMenuDataPtrs,
        (U16*) ItemIcons,
        PopUpList,
        0,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(SerialPortMenuLSKHandler, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmAutoReset
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmAutoReset(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* ASSERT(0); */
    EXT_ASSERT(0, 0, 0, 0);
}

/* Lisen 012605 */


/*****************************************************************************
 * FUNCTION
 *  EntryEmMMIDebug
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmMMIDebug(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef DEBUG_ASSERT
    g_mmi_frm_enable_debug_assert = 1 - g_mmi_frm_enable_debug_assert;
#endif 

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    ReplaceNewScreenHandler(EM_MMI_DEBUG_SCR, ExitEmMMIDebug, NULL);

#ifdef DEBUG_ASSERT
    if (g_mmi_frm_enable_debug_assert)
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }
#endif /* DEBUG_ASSERT */ 

    RedrawCategoryFunction();
    HighlightEmMMIDebug();
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmMMIDebug
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmMMIDebug(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;
    S16 nHistory = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currHistory.scrnID = EM_MMI_DEBUG_SCR;
    currHistory.entryFuncPtr = EntryEmMMIDebug;
    mmi_ucs2cpy((S8*) currHistory.inputBuffer, (S8*) & nHistory);
    GetCategoryHistory(currHistory.guiBuffer);
    AddHistory(currHistory);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmMemoryDump
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmMemoryDump(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (INT_MemoryDumpFlag == EX_FORCEMEMORYDUMP)
    {
        INT_MemoryDumpFlag = 0;
    }
    else
    {
        INT_MemoryDumpFlag = EX_FORCEMEMORYDUMP;
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    ReplaceNewScreenHandler(EM_MEMORY_DUMP_SCR, ExitEmMemoryDump, NULL);

    if (INT_MemoryDumpFlag == EX_FORCEMEMORYDUMP)
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }

    RedrawCategoryFunction();
    HighlightEmMemoryDump();
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmMemoryDump
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmMemoryDump(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;
    S16 nHistory = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currHistory.scrnID = EM_MEMORY_DUMP_SCR;
    currHistory.entryFuncPtr = EntryEmMemoryDump;
    mmi_ucs2cpy((S8*) currHistory.inputBuffer, (S8*) & nHistory);
    GetCategoryHistory(currHistory.guiBuffer);
    AddHistory(currHistory);
}

#ifdef __MMI_INTERACTIVE_PROFILNG__

/*****************************************************************************
 * FUNCTION
 *  EmProfilingSetDefaultText
 * DESCRIPTION
 *  
 * PARAMETERS
 *  buffer      [OUT]
 *  value       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
#if MMI_EM_MAX_PROFILING_LEN != 4
#error "Please modify EmProfilingSetDefaultText if input buffer length is changed"
#endif
static void EmProfilingSetDefaultText(U8 *buffer, U32 value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 ascii_buffer[MMI_EM_MAX_PROFILING_LEN + 1];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (value >= 10000)
    {
        value = 9999;
    }
    sprintf((char*) ascii_buffer, "%d", (int) value); 
    mmi_asc_to_ucs2((S8*)buffer, (S8*)ascii_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  EmProfilingGoBack
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmProfilingGoBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GoBeyondMarkerScr(EM_FRM_PROFILING_SCR);
}


/*****************************************************************************
 * FUNCTION
 *  EmProfilingHighlightHdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmProfilingDoneFunc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 ascii_buffer[MMI_EM_MAX_PROFILING_LEN + 1];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_profiling_interactive_enable((MMI_BOOL) g_em_profiling_cntx.on_off_index);

    mmi_frm_profiling_gdi_profile_enable((MMI_BOOL) g_em_profiling_cntx.gdi_on_off_index);

    mmi_ucs2_to_asc(ascii_buffer, (S8*) g_em_profiling_cntx.screen_delay);
    mmi_frm_profiling_delay_set(MMI_FRM_PROFILING_DELAY_SCREEN, atoi(ascii_buffer));

    mmi_ucs2_to_asc(ascii_buffer, (S8*) g_em_profiling_cntx.list_delay);
    mmi_frm_profiling_delay_set(MMI_FRM_PROFILING_DELAY_LIST_HIGHLIGHT, atoi(ascii_buffer));

    mmi_ucs2_to_asc(ascii_buffer, (S8*) g_em_profiling_cntx.matrix_delay);
    mmi_frm_profiling_delay_set(MMI_FRM_PROFILING_DELAY_MATRIX_HIGHLIGHT, atoi(ascii_buffer));

    mmi_ucs2_to_asc(ascii_buffer, (S8*) g_em_profiling_cntx.delay_offset);
    mmi_frm_profiling_delay_set(MMI_FRM_PROFILING_DELAY_OFFSET, atoi(ascii_buffer));

    DisplayPopupCallBack(
        (PU8)GetString(STR_GLOBAL_DONE), 
        IMG_GLOBAL_ACTIVATED, 
        1, 
        UI_POPUP_NOTIFYDURATION_TIME, 
        SUCCESS_TONE,
        EmProfilingGoBack);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmFRMProfiling
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmFRMProfiling(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 item_idx;
    U8* guiBuffer;
    U16 icon_list[] = 
    {
        IMG_GLOBAL_L1,
        0,
        IMG_GLOBAL_L2,
        0,
        IMG_GLOBAL_L3,
        0,
        IMG_GLOBAL_L4,
        0,       
        IMG_GLOBAL_L5,
        0,               
        IMG_GLOBAL_L6,
        0               
    };
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(
        EM_FRM_PROFILING_SCR /* please change the screen ID */,
        ExitEmFRMProfiling,
        NULL,
        NULL);

    guiBuffer = GetCurrGuiBuffer(SCR_ID_EM_FS_TRACE);
    InitializeCategory57Screen();

    item_idx = 0;

    /* On/off */
    SetInlineItemCaption(
        &wgui_inline_items[item_idx++],
        (PU8) GetString((U16) (EM_PROFILING_DISPLAY_TIME_TEXT)));

    g_em_profiling_cntx.on_off_list[0] = (U8*) GetString(STR_GLOBAL_OFF);
    g_em_profiling_cntx.on_off_list[1] = (U8*) GetString(STR_GLOBAL_ON);
    g_em_profiling_cntx.on_off_index = (S32)mmi_frm_profiling_interactive_is_enabled();
    //g_em_profiling_cntx.on_off_index = (S32) frm_profiling_flag;
    SetInlineItemActivation(&wgui_inline_items[item_idx], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(
        &wgui_inline_items[item_idx++],
        2,
        g_em_profiling_cntx.on_off_list,
        &g_em_profiling_cntx.on_off_index);

    /* GDI On/off */
    SetInlineItemCaption(
        &wgui_inline_items[item_idx++],
        (PU8) GetString((U16) (EM_PROFILING_GDI_PROFILE_TEXT)));

    g_em_profiling_cntx.gdi_on_off_list[0] = (U8*) GetString(STR_GLOBAL_OFF);
    g_em_profiling_cntx.gdi_on_off_list[1] = (U8*) GetString(STR_GLOBAL_ON);
    g_em_profiling_cntx.gdi_on_off_index = (S32)mmi_frm_profiling_gdi_profile_is_enabled();
    SetInlineItemActivation(&wgui_inline_items[item_idx], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(
        &wgui_inline_items[item_idx++],
        2,
        g_em_profiling_cntx.gdi_on_off_list,
        &g_em_profiling_cntx.gdi_on_off_index);

    /* Screen delay */
    SetInlineItemCaption(
        &wgui_inline_items[item_idx++],
        (PU8) GetString(EM_PROFILING_SCREEN_DELAY_TEXT));

    SetInlineItemActivation(&wgui_inline_items[item_idx], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);  
    EmProfilingSetDefaultText(
        g_em_profiling_cntx.screen_delay, 
        mmi_frm_profiling_delay_get(MMI_FRM_PROFILING_DELAY_SCREEN));
    SetInlineItemTextEdit(
        &wgui_inline_items[item_idx++],
        g_em_profiling_cntx.screen_delay,
        MMI_EM_MAX_PROFILING_LEN + 1, 
        INPUT_TYPE_NUMERIC);

    /* List delay */
    SetInlineItemCaption(
        &wgui_inline_items[item_idx++],
        (PU8) GetString(EM_PROFILING_LIST_DELAY_TEXT));

    SetInlineItemActivation(&wgui_inline_items[item_idx], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);  
    EmProfilingSetDefaultText(
        g_em_profiling_cntx.list_delay, 
        mmi_frm_profiling_delay_get(MMI_FRM_PROFILING_DELAY_LIST_HIGHLIGHT));        
    SetInlineItemTextEdit(
        &wgui_inline_items[item_idx++],
        g_em_profiling_cntx.list_delay,
        MMI_EM_MAX_PROFILING_LEN + 1, 
        INPUT_TYPE_NUMERIC);

    /* Matrix delay */
    SetInlineItemCaption(
        &wgui_inline_items[item_idx++],
        (PU8) GetString(EM_PROFILING_MATRIX_DELAY_TEXT));

    SetInlineItemActivation(&wgui_inline_items[item_idx], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);  
    EmProfilingSetDefaultText(
        g_em_profiling_cntx.matrix_delay, 
        mmi_frm_profiling_delay_get(MMI_FRM_PROFILING_DELAY_MATRIX_HIGHLIGHT));        
    SetInlineItemTextEdit(
        &wgui_inline_items[item_idx++],
        g_em_profiling_cntx.matrix_delay,
        MMI_EM_MAX_PROFILING_LEN + 1, 
        INPUT_TYPE_NUMERIC);

    /* Delay offset */
    SetInlineItemCaption(
        &wgui_inline_items[item_idx++],
        (PU8) GetString(EM_PROFILING_DELAY_OFFSET_TEXT));

    SetInlineItemActivation(&wgui_inline_items[item_idx], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);  
    EmProfilingSetDefaultText(
        g_em_profiling_cntx.delay_offset, 
        mmi_frm_profiling_delay_get(MMI_FRM_PROFILING_DELAY_OFFSET));        
    SetInlineItemTextEdit(
        &wgui_inline_items[item_idx++],
        g_em_profiling_cntx.delay_offset,
        MMI_EM_MAX_PROFILING_LEN + 1, 
        INPUT_TYPE_NUMERIC);

    ShowCategory57Screen(
        STR_ID_EM_PROFILING, 
        0, 
        STR_GLOBAL_OK, 
        IMG_GLOBAL_OK, 
        STR_GLOBAL_BACK, 
        IMG_GLOBAL_BACK,
        item_idx, 
        icon_list, 
        wgui_inline_items, 
        0,
        guiBuffer);
      
    SetCategory57RightSoftkeyFunctions(EmProfilingDoneFunc, GoBackHistory);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmFRMProfiling
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmFRMProfiling(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history currHistory;
    U16 inputBufferSize;    /* added for inline edit history */    
    S16 nHistory = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
    
    currHistory.scrnID = EM_FRM_PROFILING_SCR;
    currHistory.entryFuncPtr = EntryEmFRMProfiling;
    mmi_ucs2cpy((S8*) currHistory.inputBuffer, (S8*) &nHistory);
    GetCategoryHistory(currHistory.guiBuffer);
    
    /* added for inline edit history */
    inputBufferSize = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) currHistory.inputBuffer);
    AddNHistory(currHistory, inputBufferSize);
}
#endif /* __MMI_INTERACTIVE_PROFILNG__ */


#if defined(__MMI_CASCADE_MENU__)
/*****************************************************************************
 * FUNCTION
 *  HighlightCascadeMenuTest
 * DESCRIPTION
 *  Cascade menu test highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightCascadeMenuTest(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_em_entry_cascade_menu_test, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_entry_cascade_menu_test
 * DESCRIPTION
 *  Cascade menu test entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_entry_cascade_menu_test(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* NOT FINISHED YET */
    DisplayPopup((PU8)GetString(STR_GLOBAL_UNFINISHED), IMG_GLOBAL_UNFINISHED, 1, UI_POPUP_NOTIFYDURATION_TIME, ERROR_TONE);
}
#endif /* defined(__MMI_CASCADE_MENU__) */


#ifdef __MMI_UI_BENCHMARK__
/*****************************************************************************
 * FUNCTION
 *  HighlightEmUIBenchmark
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmUIBenchmark(void)
{
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(mmi_em_entry_ui_bench, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_entry_ui_bench
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_entry_ui_bench(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_UI_BENCHMARK_PROCESSING_SCR, mmi_em_exit_ui_bench, mmi_em_entry_ui_bench, NULL);

    /* Clear all key handlers so as to restrict duplicate reqs */
    ClearInputEventHandler(MMI_DEVICE_ALL);

    ShowCategory66Screen(
        EM_UI_BENCHMARK_TEXT,
        0,
        0,
        0,
        STR_GLOBAL_BACK,
        0,
        (PU8) GetString(EM_GLOBAL_PROCESSING_TEXT),
        0,
        NULL);

    SetRightSoftkeyFunction(mmi_em_ui_bench_stop, KEY_EVENT_UP);
    SetKeyHandler(mmi_em_ui_bench_stop, KEY_LEFT_ARROW, KEY_EVENT_DOWN);

    mmi_frm_benchmark_start(mmi_em_ui_bench_callback);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_exit_ui_bench
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_exit_ui_bench(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_benchmark_stop();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_ui_bench_stop
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_ui_bench_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_benchmark_stop();
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_ui_bench_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_ui_bench_callback(const U8 *message)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ui_benchmark_buffer_p = message;

    mmi_em_entry_ui_bench_result();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_entry_ui_bench_result
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_em_entry_ui_bench_result(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 bufferSize;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_UI_BENCHMARK_RESULT_SCR, NULL, mmi_em_entry_ui_bench_result, NULL);

    bufferSize = mmi_ucs2strlen((S8*)g_ui_benchmark_buffer_p);

    ShowCategory74Screen(
        EM_UI_BENCHMARK_TEXT,
        0,
        0,
        0,
        STR_GLOBAL_BACK,
        0,
        (PU8) g_ui_benchmark_buffer_p,
        bufferSize,
        NULL);


    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);

    DeleteScreenIfPresent(EM_UI_BENCHMARK_PROCESSING_SCR);
}
#endif    



/*****************************************************************************
 * FUNCTION
 *  EngineerModeNoticeText
 * DESCRIPTION
 *  
 * PARAMETERS
 *  string      [?]         
 *  icon        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EngineerModeNoticeText(U8 *string, U16 icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayPopup(string, icon, 0, EM_NOTIFY_DURATION, 0);
}


/*****************************************************************************
 * FUNCTION
 *  EngineerModeSuccessNotice
 * DESCRIPTION
 *  
 * PARAMETERS
 *  stringId        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EngineerModeSuccessNotice(U16 stringId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayPopup((PU8) GetString(EM_NOTICE_SUCCESS_TEXT), IMG_GLOBAL_WARNING, 0, EM_NOTIFY_DURATION, 0);
}


/*****************************************************************************
 * FUNCTION
 *  EngineerModeSuccessRebootNotice
 * DESCRIPTION
 *  
 * PARAMETERS
 *  stringId        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EngineerModeSuccessRebootNotice(U16 stringId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(GLOBAL_SCR_DUMMY, NULL, NULL, NULL);

    ShowCategory64Screen(EM_NOTICE_SUCCESS_REBOOT_TEXT, IMG_GLOBAL_WARNING, 0);
    StartTimer(EM_NOTIFYDURATION_TIMER, 3000, ShutdownSystemOperation);

    ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_END, KEY_LONG_PRESS);
}


/*****************************************************************************
 * FUNCTION
 *  EngineerModeErrorNotice
 * DESCRIPTION
 *  
 * PARAMETERS
 *  stringId        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EngineerModeErrorNotice(U16 stringId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayPopup((PU8) GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_WARNING, 0, EM_NOTIFY_DURATION, 0);
}


/*****************************************************************************
 * FUNCTION
 *  EngineerModeWarningNotice
 * DESCRIPTION
 *  
 * PARAMETERS
 *  stringId        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EngineerModeWarningNotice(U16 stringId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayPopup((PU8) GetString(EM_NOTICE_WARNING_TEXT), IMG_GLOBAL_WARNING, 0, EM_NOTIFY_DURATION, 0);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEMDebugInfo
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMDebugInfo(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMDebugInfo, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMDebugInfo
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMDebugInfo(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_DEBUG_INFO_SCR, NULL, EntryEMDebugInfo, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_DEBUG_INFO_SCR);
    nItems = GetNumOfChild(EM_DEBUG_INFO_MENUID);
    GetSequenceStringIds(EM_DEBUG_INFO_MENUID, ItemList);
    SetParentHandler(EM_DEBUG_INFO_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
    }
    for (i = 0; i < nItems; i++)
    {
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }


    ShowCategory52Screen(
        STR_ID_EM_DEBUG_INFO,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

#if defined(__FS_TRACE_SUPPORT__)


/*****************************************************************************
 * FUNCTION
 *  HighlightEMFsTrace
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMFsTrace(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Lisen 0710 */

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMFsTrace, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMFsTrace
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMFsTrace(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* guiBuffer;
    U16 ImageList[2];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_EM_FS_TRACE, ExitEmFSTraceScreen, EntryEMFsTrace, NULL); 
    
    InitializeCategory57Screen();
    guiBuffer = GetCurrGuiBuffer(SCR_ID_EM_FS_TRACE);

    RegisterHighlightHandler(HighlightHdlrFSTraceInline);
    
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(STR_ID_EM_FS_TRACE));
    ImageList[0] = IMG_STATUS;

    g_em_fs_trace_cntx.pEMFSTraceSetting[0] = (U8*)GetString(STR_ID_EM_FS_TRACE_ALL_OFF);
    g_em_fs_trace_cntx.pEMFSTraceSetting[1] = (U8*)GetString(STR_ID_EM_FS_TRACE_ALL_ERROR);
    g_em_fs_trace_cntx.pEMFSTraceSetting[2] = (U8*)GetString(STR_ID_EM_FS_TRACE_ALL_API_ERROR);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 3, (U8**)g_em_fs_trace_cntx.pEMFSTraceSetting, &g_em_fs_trace_cntx.currFsTraceSetting);    
    ImageList[1] = 0;

    DisableCategory57ScreenDone();
     	
    ShowCategory57Screen(STR_ID_EM_FS_TRACE, 0, 
                         STR_GLOBAL_OK, 
                         IMG_GLOBAL_OK, 
                         STR_GLOBAL_BACK, 
                         IMG_GLOBAL_BACK,
 	                     2, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );


}


/**************************************************************

	FUNCTION NAME		: ExitEmFSTraceScreen()

  	PURPOSE				: Exit Em FS Trace inline edit screen

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void ExitEmFSTraceScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
}


/**************************************************************

	FUNCTION NAME		: HighlightHdlrFSTraceInline()

  	PURPOSE				: FS Trace Settings inline highlight handler

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void HighlightHdlrFSTraceInline(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(EmSetFSTrace, KEY_EVENT_UP);
}


/**************************************************************

	FUNCTION NAME		: EmSetFSTrace()

  	PURPOSE				: To set FS Trace

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EmSetFSTrace(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();


    if (g_em_fs_trace_cntx.currFsTraceSetting == 0)  /* ALL Off */
    {
        FS_SetTrace( FS_TRACE_DISABLE | FS_TRACE_ALL_TASK, FS_INFINITE);
    }
    else if (g_em_fs_trace_cntx.currFsTraceSetting == 1) /* ALL Error */
    {
        FS_SetTrace( FS_TRACE_ERROR | FS_TRACE_ALL_TASK, FS_INFINITE);
    }
    else if (g_em_fs_trace_cntx.currFsTraceSetting == 2) /* ALL API + Error */
    {
        FS_SetTrace(  FS_TRACE_API | FS_TRACE_ERROR | FS_TRACE_ALL_TASK, FS_INFINITE);
    }
    else
        ASSERT(0);
   
    DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
    DeleteUptoScrID(EM_DEBUG_INFO_SCR);
    
}

#endif /* defined(__FS_TRACE_SUPPORT__) */ 


/*****************************************************************************
 * FUNCTION
 *  HighlightEMLastException
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMLastException(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMLastException, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

extern void nvram_report_last_exception(void *task_name_p, void *type_p, void *time_p, void *status_p);


/*****************************************************************************
 * FUNCTION
 *  EntryEMLastException
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMLastException(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    kal_char task_name[8];
    exception_type type = 0;
    ex_rtc_struct time;
    kal_bool status = FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_LAST_EXCEPTION_SCR, NULL, EntryEMLastException, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_LAST_EXCEPTION_SCR);
    SetParentHandler(EM_LAST_EXCEPTION_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    nvram_report_last_exception((void*)&task_name, (void*)&type, (void*)&time, (void*)&status);

    if (status)
    {
        sprintf(
            (S8*) EMFMAsciiDisplayBuf,
            "Last Exception: \n Type: %x\n Task: %s\n Time: \n (%2d/%2d) %2d:%2d\n",
            type,
            task_name,
            time.rtc_mon,
            time.rtc_day,
            time.rtc_hour,
            time.rtc_min);
    }
    else
    {
        sprintf((S8*) EMFMAsciiDisplayBuf, "No record: \n ");
    }

    mmi_asc_to_ucs2((S8*) EMFMUnicodeDisplayBuf, (S8*) EMFMAsciiDisplayBuf);
    ShowCategory7Screen(
        STR_ID_EM_LAST_EXCEPTION,
        IMG_ID_EM_LAST_EXCEPTION,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (PU8) EMFMUnicodeDisplayBuf,
        NULL);

    SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEMSysStat
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMSysStat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMSysStat, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMSysStat
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSysStat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_SYS_STATS_SCR, NULL, EntryEMSysStat, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_SYS_STATS_SCR);
    nItems = GetNumOfChild(EM_SYS_STATS_MENUID);
    GetSequenceStringIds(EM_SYS_STATS_MENUID, ItemList);
    SetParentHandler(EM_SYS_STATS_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
    }
    for (i = 0; i < nItems; i++)
    {
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);
    }

    if (PWROFF_SAVING_STATS)
    {
        PopUpList[1] = (U8*) get_string(STR_GLOBAL_ON);
    }
    else
    {
        PopUpList[1] = (U8*) get_string(STR_GLOBAL_OFF);
    }

    ShowCategory52Screen(
        STR_ID_EM_SYS_STATS,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEMWriteSysStats
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMWriteSysStats(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMWriteSysStats, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

extern kal_bool stack_update_sys_statistics(stack_statistics_struct *prev_stats);


/*****************************************************************************
 * FUNCTION
 *  EntryEMWriteSysStats
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMWriteSysStats(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool update;
    stack_statistics_struct statistic;
    S16 ErrorCode, Ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*
     * EntryNewScreen(EM_WRITE_SYS_STATS_SCR, NULL, EntryEMWriteSysStats, NULL);
     * 
     * guiBuffer = GetCurrGuiBuffer(EM_LAST_EXCEPTION_SCR);
     * SetParentHandler(EM_WRITE_SYS_STATS_MENUID);
     * RegisterHighlightHandler(ExecuteCurrHiliteHandler);
     */
    ASSERT(sizeof(stack_statistics_struct) < 2048);

    Ret = ReadRecord(NVRAM_EF_SYS_STATISTICS_LID, 1, &statistic, NVRAM_EF_SYS_STATISTICS_SIZE, &ErrorCode);
    if (!(ErrorCode == NVRAM_READ_SUCCESS && Ret == NVRAM_EF_SYS_STATISTICS_SIZE))
    {
        ASSERT(0);
    }

    update = stack_update_sys_statistics(&statistic);

    if (update)
    {
        Ret = WriteRecord(NVRAM_EF_SYS_STATISTICS_LID, 1, &statistic, NVRAM_EF_SYS_STATISTICS_SIZE, &ErrorCode);
        if (!(ErrorCode == NVRAM_WRITE_SUCCESS && Ret == NVRAM_EF_SYS_STATISTICS_SIZE))
        {
            ASSERT(0);
        }
        else
        {
            EngineerModeSuccessNotice((U16) NULL);
        }

    }
    else
    {
        EngineerModeWarningNotice((U16) NULL);
    }

    /*
     * SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
     * SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
     */
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEMSavingStatPWROFF
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMSavingStatPWROFF(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PWROFF_SAVING_STATS == FALSE)
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
    }

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMSavingStatPWROFF, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMSavingStatPWROFF
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSavingStatPWROFF(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PWROFF_SAVING_STATS == FALSE)
    {
        PWROFF_SAVING_STATS = TRUE;
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));
    }
    else
    {
        PWROFF_SAVING_STATS = FALSE;
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));
    }

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    RedrawCategoryFunction();
    HighlightEMSavingStatPWROFF();
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEMPowerOnDuration
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEMPowerOnDuration(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEMPowerOnDurationMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

extern S8 UnicodeDisplayBuf[MAX_TEST_STRING_BUF * 4];


/*****************************************************************************
 * FUNCTION
 *  EntryEMPowerOnDurationMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMPowerOnDurationMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    MYTIME currentTime, timeDiff;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_POWER_ON_DURATION_MENU_SCR, NULL, EntryEMPowerOnDurationMenu, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_POWER_ON_DURATION_MENU_SCR);
    SetParentHandler(EM_POWER_ON_DURATION_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    memset(UnicodeDisplayBuf, 0, sizeof(UnicodeDisplayBuf));

    DTGetRTCTime(&currentTime);

    GetTimeDifference(&currentTime, &StartUpTime, &timeDiff);

    memset(EMFMAsciiDisplayBuf, 0, sizeof(EMFMAsciiDisplayBuf));
    memset(EMFMUnicodeDisplayBuf, 0, sizeof(EMFMUnicodeDisplayBuf));
    sprintf(
        (S8*) EMFMAsciiDisplayBuf,
        "[PWR Time]\n %02d/%02d %02d:%02d:%02d\n",
        StartUpTime.nMonth,
        StartUpTime.nDay,
        StartUpTime.nHour,
        StartUpTime.nMin,
        StartUpTime.nSec);
    mmi_asc_to_ucs2((S8*) EMFMUnicodeDisplayBuf, (S8*) EMFMAsciiDisplayBuf);
    mmi_ucs2cpy((S8*) UnicodeDisplayBuf, (const S8*)EMFMUnicodeDisplayBuf);

    memset(EMFMAsciiDisplayBuf, 0, sizeof(EMFMAsciiDisplayBuf));
    memset(EMFMUnicodeDisplayBuf, 0, sizeof(EMFMUnicodeDisplayBuf));
    sprintf(
        (S8*) EMFMAsciiDisplayBuf,
        "[Current Time]\n %02d/%02d %02d:%02d:%02d\n",
        currentTime.nMonth,
        currentTime.nDay,
        currentTime.nHour,
        currentTime.nMin,
        currentTime.nSec);
    mmi_asc_to_ucs2((S8*) EMFMUnicodeDisplayBuf, (S8*) EMFMAsciiDisplayBuf);
    mmi_ucs2cat((S8*) UnicodeDisplayBuf, (const S8*)EMFMUnicodeDisplayBuf);

    memset(EMFMAsciiDisplayBuf, 0, sizeof(EMFMAsciiDisplayBuf));
    memset(EMFMUnicodeDisplayBuf, 0, sizeof(EMFMUnicodeDisplayBuf));
    sprintf(
        (S8*) EMFMAsciiDisplayBuf,
        "[Duration]\n %02d/%02d %02d:%02d:%02d\n",
        timeDiff.nMonth,
        timeDiff.nDay,
        timeDiff.nHour,
        timeDiff.nMin,
        timeDiff.nSec);
    mmi_asc_to_ucs2((S8*) EMFMUnicodeDisplayBuf, (S8*) EMFMAsciiDisplayBuf);
    mmi_ucs2cat((S8*) UnicodeDisplayBuf, (const S8*)EMFMUnicodeDisplayBuf);

    memset(EMFMAsciiDisplayBuf, 0, sizeof(EMFMAsciiDisplayBuf));
    memset(EMFMUnicodeDisplayBuf, 0, sizeof(EMFMUnicodeDisplayBuf));
    sprintf(
        (S8*) EMFMAsciiDisplayBuf,
        "[Last Duration]\n %02d/%02d %02d:%02d:%02d\n",
        LastDuration.nMonth,
        LastDuration.nDay,
        LastDuration.nHour,
        LastDuration.nMin,
        LastDuration.nSec);
    mmi_asc_to_ucs2((S8*) EMFMUnicodeDisplayBuf, (S8*) EMFMAsciiDisplayBuf);
    mmi_ucs2cat((S8*) UnicodeDisplayBuf, (const S8*)EMFMUnicodeDisplayBuf);

    ShowCategory74Screen(
        EM_POWER_ON_DURATION_TEXT,
        0,
        (U16) NULL,
        0,
        STR_GLOBAL_BACK,
        0,
        (PU8) UnicodeDisplayBuf,
        sizeof(UnicodeDisplayBuf),
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    memcpy(&LastDuration, &timeDiff, sizeof(LastDuration));

}

/* Lisen 03092005 */


/*****************************************************************************
 * FUNCTION
 *  HightlightEMRAMTestHdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HightlightEMRAMTestHdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    change_left_softkey(STR_GLOBAL_OK, 0);
    SetLeftSoftkeyFunction(EntryEMRAMTestMenu, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    redraw_left_softkey();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMRAMTestMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMRAMTestMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (SST_AdvRAMTest() == KAL_TRUE)
    {
        EngineerModeSuccessNotice((U16) NULL);
    }
    else
    {
        EngineerModeErrorNotice((U16) NULL);
    }
}

#ifdef __TCPIP__


/*****************************************************************************
 * FUNCTION
 *  EmSocketInitResult
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketInitResult(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketResult = EN_SOC_SUCCESS;
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmSocket
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmSocket(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSocketMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSocketMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSocketMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_SOCKET_MENU_SCR, NULL, EntryEmSocketMenu, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_SOCKET_MENU_SCR);
    nItems = GetNumOfChild(EM_SOCKET_MENUID);
    GetSequenceStringIds(EM_SOCKET_MENUID, ItemList);
    SetParentHandler(EM_SOCKET_MENUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    EmSocketInitResult();
    if (EmSocketResultBuffer != NULL)
    {
        OslMfree(EmSocketResultBuffer);
        EmSocketResultBuffer = NULL;
    }

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   /* ReturnRequiredNumberImageId(i); */
    }

    ShowCategory52Screen(
        EM_SOCKET_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmDNSQuery
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmDNSQuery(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentSocketAppType = DNS;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmDNSQuery, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmDNSQuery
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmDNSQuery(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U8 *history_buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketInitResult();

    EntryNewScreen(EM_SOCKET_DNS_INPUT_SCR, NULL, EntryEmDNSQuery, NULL);
    history_buffer = GetCurrGuiBuffer(EM_SOCKET_DNS_INPUT_SCR);

    if (history_buffer == NULL)
    {
        memset(EmSocketInputBuff, 0, sizeof(EmSocketInputBuff));
    }
    ShowCategory5Screen(
        EM_SOCKET_DNS_DOMAIN_NAME_TEXT,
        (U16) NULL,
        STR_GLOBAL_OPTIONS,
        (U16) NULL,
        STR_GLOBAL_BACK,
        (U16) NULL,
        INPUT_TYPE_ALPHANUMERIC_SENTENCECASE,
        (PU8) EmSocketInputBuff,
        EM_SOCKET_MAX_INPUT_LEN,
        history_buffer);

    SetLeftSoftkeyFunction(EntryEmDNSOption, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    RegisterInputMethodScreenCloseFunction(EmSocketGoBack2History);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmDNSOption
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmDNSOption(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 numItems = 0;
    U16 nStrItemList[32];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_SOCKET_DNS_OPTION_SCR, NULL, EntryEmDNSOption, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_SOCKET_DNS_OPTION_SCR);
    numItems = GetNumOfChild(EM_SOCKET_DNS_OPTION_MENUID);
    GetSequenceStringIds(EM_SOCKET_DNS_OPTION_MENUID, nStrItemList);
    SetParentHandler(EM_SOCKET_DNS_OPTION_MENUID);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory52Screen(
        STR_GLOBAL_OPTIONS,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        numItems,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        NULL,
        0,
        0,
        guiBuffer);
}


/*****************************************************************************
 * FUNCTION
 *  EmSocketSendReq
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketSendReq(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U8 emSocketAccountId = custom_get_csd_profile_num();
    mmi_soc_demo_app_result emSocketTmpResult = EN_SOC_SUCCESS;
    S8 AscTmp[16];
    PS8 emSocketInputdata = OslMalloc((EM_SOCKET_MAX_INPUT_LEN + 1) * ENCODING_LENGTH);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketIsCallbackFuncCalled = FALSE;

    if (currentSocketAppType == HTTP || currentSocketAppType == DNS || currentSocketAppType == ECHO || currentSocketAppType == TRACERT)
    {
        mmi_ucs2_to_asc(emSocketInputdata, EmSocketInputBuff);
    }

    if (currentSocketAppType == DAYTIME || currentSocketAppType == ECHO)
    {
        mmi_ucs2_to_asc(AscTmp, (S8*) EmSocketIP1);
        EmServerIPAddress[0] = (U8) atoi(AscTmp);
        mmi_ucs2_to_asc(AscTmp, (S8*) EmSocketIP2);
        EmServerIPAddress[1] = (U8) atoi(AscTmp);
        mmi_ucs2_to_asc(AscTmp, (S8*) EmSocketIP3);
        EmServerIPAddress[2] = (U8) atoi(AscTmp);
        mmi_ucs2_to_asc(AscTmp, (S8*) EmSocketIP4);
        EmServerIPAddress[3] = (U8) atoi(AscTmp);
    }

    if (currentSocketAppType == DNS)
    {
        emSocketTmpResult = mmi_soc_demo_app_request(
                                DNS,
                                emSocketAccountId,
                                NULL,
                                emSocketInputdata,
                                strlen(emSocketInputdata),
                                NULL,
                                0,
                                EmSocketRsp);
    }
    else if (currentSocketAppType == HTTP)
    {
        emSocketTmpResult = mmi_soc_demo_app_request(
                                HTTP,
                                emSocketAccountId,
                                NULL,
                                emSocketInputdata,
                                strlen(emSocketInputdata),
                                NULL,
                                0,
                                EmSocketRsp);
    }
    else if (currentSocketAppType == ECHO)
    {
        emSocketTmpResult = mmi_soc_demo_app_request(
                                ECHO,
                                emSocketAccountId,
                                (char*)EmServerIPAddress,
                                NULL,
                                0,
                                emSocketInputdata,
                                strlen(emSocketInputdata),
                                EmSocketRsp);
    }
    else if (currentSocketAppType == DAYTIME)
    {
        emSocketTmpResult = mmi_soc_demo_app_request(
                                DAYTIME,
                                emSocketAccountId,
                                (char*)EmServerIPAddress,
                                NULL,
                                0,
                                NULL,
                                0,
                                EmSocketRsp);
    }
    else if (currentSocketAppType == TRACERT)
    {
        emSocketTmpResult = mmi_soc_demo_app_request(
                                TRACERT,
                                emSocketAccountId,
                                NULL,
                                emSocketInputdata,
                                strlen(emSocketInputdata),
                                NULL,
                                0,
                                EmSocketRsp);
    }
    else
    {
        emSocketTmpResult = EN_SOC_UNKNOWN_APP;
    }

    /* To handle the scenario that  callback function is called before mmi_soc_demo_app_request() returns  
       by checking if value of EmSocketResult is still the same as its default value (EN_SOC_SUCCESS) */
    if (EmSocketResult == EN_SOC_SUCCESS)
    {
        EmSocketResult = emSocketTmpResult;
    }

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSocketInProgress
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSocketInProgress(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_SOCKET_PROGRESS_SCR, NULL, EntryEmSocketInProgress, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_SOCKET_PROGRESS_SCR);
    if (guiBuffer == NULL)
    {
        mmi_soc_demo_app_request_abort();
        if (currentSocketAppType != TRACERT)
        {
            EmSocketSendReq();
        }
        else
        {
            EmSocketIsCallbackFuncCalled = FALSE;
            EmSocketResult = EN_SOC_SUCCESS;
        }
    }
    if (EmSocketIsCallbackFuncCalled == FALSE)
    {
        if (EmSocketResult == EN_SOC_SUCCESS)
        {
            /* clear End key */
            ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
            ClearKeyHandler(KEY_END, KEY_LONG_PRESS);

            /* Show progress screen */
            ShowCategory66Screen(
                EM_SOCKET_TEXT,
                0,
                0,
                0,
                STR_GLOBAL_CANCEL,
                0,
                (U8*) GetString(EM_SOCKET_IN_PROGRESS_TEXT),
                IMG_GLOBAL_PROGRESS,
                NULL);

            /* Set RSK to abort progress */
            SetRightSoftkeyFunction(EmSocketInProgressAbort, KEY_EVENT_UP);

            SetKeyHandler(EmSocketInProgressAbort, KEY_END, KEY_EVENT_DOWN);

        }
        else
        {
            EmSocketShowErrorMsg();
        }
    }
    else
    {
        EntryEmSocketResult();
    }

    if (currentSocketAppType == TRACERT)
    {
        EmSocketSendReq();
    }
}


/*****************************************************************************
 * FUNCTION
 *  EmSocketInProgressAbort
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketInProgressAbort(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_soc_demo_app_request_abort();

    if (currentSocketAppType == DNS || currentSocketAppType == HTTP)
    {
        GoBacknHistory(1);
    }

    else if (currentSocketAppType == ECHO || currentSocketAppType == DAYTIME)
    {
        GoBackHistory();
    }
    else
    {
        GoBackHistory();
    }
}

/*****************************************************************************
 * FUNCTION
 *  EmSocketShowErrorMsgByCause
 * DESCRIPTION
 *  Show error message by given cause
 * PARAMETERS
 *  msg        [IN]        error cause
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketShowErrorMsgByCause(int msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketResult= msg;
    EmSocketShowErrorMsg();

}

/*****************************************************************************
 * FUNCTION
 *  EmSocketShowErrorMsg
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketShowErrorMsg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (EmSocketResult)
    {
        case EN_SOC_INVAL_PARA:
            DisplayPopup((PU8) GetString(EM_SOCKET_ERROR_INVAL_PARA_TEXT), IMG_GLOBAL_ERROR, 0, 1000, ERROR_TONE);
            break;

        case EN_SOC_ERROR:
            DisplayPopup((PU8) GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, 1000, ERROR_TONE);
            break;

        case EN_SOC_PEER_NOT_REACHABLE:
            DisplayPopup(
                (PU8) GetString(EM_SOCKET_ERROR_PEER_NOT_REACHABLE_TEXT),
                IMG_GLOBAL_ERROR,
                0,
                1000,
                ERROR_TONE);
            break;

        case EN_SOC_PEER_NO_RESPONSE:
            DisplayPopup((PU8) GetString(EM_SOCKET_ERROR_PEER_NO_RESPONSE_TEXT), IMG_GLOBAL_ERROR, 0, 1000, ERROR_TONE);
            break;

        case EN_SOC_CNT_RESET_BY_PEER:
            DisplayPopup(
                (PU8) GetString(EM_SOCKET_ERROR_CNT_RESET_BY_PEER_TEXT),
                IMG_GLOBAL_ERROR,
                0,
                1000,
                ERROR_TONE);
            break;

        case EN_SOC_BEARER_FAIL:
            DisplayPopup((PU8) GetString(EM_SOCKET_ERROR_BEARER_FAIL_TEXT), IMG_GLOBAL_ERROR, 0, 1000, ERROR_TONE);
            break;

        case EN_SOC_UNKNOWN_APP:
            DisplayPopup((PU8) GetString(EM_SOCKET_ERROR_UNKNOWN_APP_TEXT), IMG_GLOBAL_ERROR, 0, 1000, ERROR_TONE);
            break;

        case EN_SOC_BUSY:
            DisplayPopup((PU8) GetString(EM_SOCKET_ERROR_BUSY_TEXT), IMG_GLOBAL_ERROR, 0, 1000, ERROR_TONE);
            break;

        case EN_SOC_NO_MEMORY:
            DisplayPopup((PU8) GetString(EM_SOCKET_ERROR_NO_MEMORY_TEXT), IMG_GLOBAL_ERROR, 0, 1000, ERROR_TONE);
            break;

        default:
            ASSERT(0);
    }

    switch (EmSocketResult)
    {
        case EN_SOC_INVAL_PARA:
        case EN_SOC_PEER_NOT_REACHABLE:
        case EN_SOC_PEER_NO_RESPONSE:
        case EN_SOC_CNT_RESET_BY_PEER:
        case EN_SOC_BEARER_FAIL:
        case EN_SOC_BUSY:
        case EN_SOC_NO_MEMORY:
            switch (currentSocketAppType)
            {
                case DNS:
                    DeleteUptoScrID(EM_SOCKET_DNS_INPUT_SCR);
                    break;
                case HTTP:
                    DeleteUptoScrID(EM_SOCKET_HTTP_INPUT_SCR);
                    break;
                case ECHO:
                    DeleteUptoScrID(EM_SOCKET_ECHO_INPUT_SCR);
                    break;
                case DAYTIME:
                    DeleteUptoScrID(EM_SOCKET_DATE_INPUT_SCR);
                    break;
                case TRACERT:
                    DeleteScreenIfPresent(EM_SOCKET_TRACERT_PROCESS_SCR);
                    break;
                default:
                    ASSERT(0);
            }
            break;

        case EN_SOC_ERROR:
        case EN_SOC_UNKNOWN_APP:
            DeleteUptoScrID(EM_SOCKET_MENU_SCR);
            break;

        default:
            ASSERT(0);
    }

}

/*****************************************************************************
 * FUNCTION
 *  EmStartTraceRtResult
 * DESCRIPTION
 *  Start to show traceroute result
 * PARAMETERS
 *  string        [IN]     initialing string
 * RETURNS
 *  void
 *****************************************************************************/
void EmStartTraceRtResult(S8* string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 str_buf[64];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (EmSocketResultBuffer != NULL)
    {
        OslMfree(EmSocketResultBuffer);
        EmSocketResultBuffer = NULL;
    }
    EmSocketResultBuffer = (S8*)OslMalloc(MAX_TRACERT_RESULT_SIZE<<1);
    memset(EmSocketResultBuffer, 0, MAX_TRACERT_RESULT_SIZE);

    mmi_ucs2cpy(EmSocketResultBuffer, (S8*)get_string(EM_SOCKET_TRACERT_START_TEXT));

    mmi_asc_to_ucs2((S8*)str_buf, string);
    mmi_ucs2cat(EmSocketResultBuffer, (S8*)str_buf);
    EmShowTraceRtResult();
}

/*****************************************************************************
 * FUNCTION
 *  EmAppendTraceRtResult
 * DESCRIPTION
 *  Append traceroute result
 * PARAMETERS
 *  string        [IN]     string to append
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL EmAppendTraceRtResult(S8* string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 str_buf[64];
    S32 buf_len = 0, str_len = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    buf_len = strlen(string);
    str_len = mmi_ucs2strlen((S8*) EmSocketResultBuffer);
    if ( buf_len + str_len >= MAX_TRACERT_RESULT_SIZE)
    {
        return MMI_FALSE;
    }
    mmi_asc_to_ucs2((S8*)str_buf, string);
    mmi_ucs2cat((S8*)EmSocketResultBuffer, (S8*)str_buf);
    RedrawCategoryFunction();
    return MMI_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  EmDeinitTraceRt
 * DESCRIPTION
 *  Deinitialize traceroute AP
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmDeinitTraceRt(void)
{
    if (EmSocketResultBuffer)
    {
        OslMfree(EmSocketResultBuffer);
        EmSocketResultBuffer = NULL;
    }
    GoBackHistory();
}

/*****************************************************************************
 * FUNCTION
 *  EmEndTraceRt
 * DESCRIPTION
 *  End of traceroute
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmEndTraceRt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);
    SetRightSoftkeyFunction(EmDeinitTraceRt, KEY_EVENT_UP);
    
}

/*****************************************************************************
 * FUNCTION
 *  EmAbortTraceRtResult
 * DESCRIPTION
 *  Abort traceroute
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmAbortTraceRtResult(void)
{
    mmi_soc_demo_app_request_abort();
    EmEndTraceRt();
}

/*****************************************************************************
 * FUNCTION
 *  EmShowTraceRtResult
 * DESCRIPTION
 *  Show traceroute result
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmShowTraceRtResult(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *history = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    EntryNewScreen(EM_SOCKET_TRACERT_PROCESS_SCR, NULL, EmShowTraceRtResult, NULL);
    DeleteScreenIfPresent(EM_SOCKET_PROGRESS_SCR);
    history = GetCurrGuiBuffer(EM_SOCKET_RESULT_SCR);

    ShowCategory74Screen(
        0,
        GetRootTitleIcon(EM_SOCKET_TRACERT_MENUID),
        0,
        0,
        STR_GLOBAL_ABORT,
        0,
        (U8*)EmSocketResultBuffer,
        sizeof(EmSocketResultBuffer),
        history        
        );

    SetRightSoftkeyFunction(EmAbortTraceRtResult, KEY_EVENT_UP);
}

/*****************************************************************************
 * FUNCTION
 *  EmSocketCheckAmPm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  response        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketCheckAmPm(char *response)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (strlen(response) >= 4)
    {
        if (response[0] == -92 && response[1] == 85 && response[2] == -92 && response[3] == -56)
        {
            response[0] = 32;
            response[1] = 'P';
            response[2] = 'M';
            response[3] = 32;
        }
        else if (response[0] == -92 && response[1] == 87 && response[2] == -92 && response[3] == -56)
        {
            response[0] = 32;
            response[1] = 'A';
            response[2] = 'M';
            response[3] = 32;
        }

    }

}


/*****************************************************************************
 * FUNCTION
 *  EmSocketRsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  app_id_enum         [IN]        
 *  result              [IN]        
 *  response            [?]         
 *  response_len        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketRsp(mmi_soc_demo_app_enum app_id_enum, int result, char *response, int response_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U16 currScrnID = GetExitScrnID();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketResult = result;
    if (EmSocketResult == EN_SOC_SUCCESS)
    {
        EmSocketResultBufferSize = (response_len + 1) * ENCODING_LENGTH;
        currentSocketAppType = (mmi_soc_demo_app_enum) app_id_enum;
        if (EmSocketResultBuffer != NULL)
        {
            OslMfree(EmSocketResultBuffer);
            EmSocketResultBuffer = NULL;
        }
        EmSocketResultBuffer = OslMalloc(EmSocketResultBufferSize);

        EmSocketCheckAmPm(response);

        if (EmSocketResultBuffer != NULL)
        {
            mmi_asc_to_ucs2(EmSocketResultBuffer, response);
        }
    }

    EmSocketIsCallbackFuncCalled = TRUE;

    /* prevent that display of result interrupts current screen except for EM_SOCKET_PROGRESS_SCR */
    if (currScrnID == EM_SOCKET_PROGRESS_SCR || currScrnID == EM_SOCKET_TRACERT_PROCESS_SCR)
    {
        EntryEmSocketResult();
    }
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSocketResult
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSocketResult(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (EmSocketResult == EN_SOC_SUCCESS)
    {

        EntryNewScreen(EM_SOCKET_RESULT_SCR, NULL, EntryEmSocketResult, NULL);
        DeleteScreenIfPresent(EM_SOCKET_TRACERT_PROCESS_SCR);
        guiBuffer = GetCurrGuiBuffer(EM_SOCKET_RESULT_SCR);

        /* clear End key */
        ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
        ClearKeyHandler(KEY_END, KEY_LONG_PRESS);

        ShowCategory74Screen(
            EM_SOCKET_RESULT_TEXT,
            0,
            0,
            0,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            (PU8) EmSocketResultBuffer,
            EmSocketResultBufferSize,
            guiBuffer);

        /* go back to socket test menu */
        SetRightSoftkeyFunction(GoToMainEmSocketScreen, KEY_EVENT_UP);
        SetKeyHandler(GoToMainEmSocketScreen, KEY_END, KEY_EVENT_DOWN);
    }
    else
    {
        EmSocketShowErrorMsg();
    }
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmDNSQueryDone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmDNSQueryDone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSocketInProgress, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmHTTPGetDone
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmHTTPGetDone(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmSocketInProgress, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmDNSQueryInputMethod
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmDNSQueryInputMethod(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryInputMethodScreen, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmHTTPGetInputMethod
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmHTTPGetInputMethod(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryInputMethodScreen, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmHTTPGet
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmHTTPGet(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentSocketAppType = HTTP;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmHTTPGet, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

/*****************************************************************************
 * FUNCTION
 *  EntryEmTracert
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmTracert(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U8 *history_buffer;
#ifndef __MTK_TARGET__
	S16 buf[] = L"WWW.CNN.COM";
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketInitResult();

    EntryNewScreen(EM_SOCKET_DNS_INPUT_SCR, NULL, EntryEmTracert, NULL);
    history_buffer = GetCurrGuiBuffer(EM_SOCKET_DNS_INPUT_SCR);

    if (history_buffer == NULL)
    {
        memset(EmSocketInputBuff, 0, sizeof(EmSocketInputBuff));
    #ifndef __MTK_TARGET__
		memcpy(EmSocketInputBuff, buf, 24);
    #endif
    }
    ShowCategory5Screen(
        EM_SOCKET_TRACERT_REMOTE_IP_TEXT,
        (U16) NULL,
        STR_GLOBAL_OPTIONS,
        (U16) NULL,
        STR_GLOBAL_BACK,
        (U16) NULL,
        INPUT_TYPE_ALPHANUMERIC_SENTENCECASE,
        (PU8) EmSocketInputBuff,
        EM_SOCKET_MAX_INPUT_LEN,
        history_buffer);

    SetLeftSoftkeyFunction(EntryEmDNSOption, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    RegisterInputMethodScreenCloseFunction(EmSocketGoBack2History);

}

/*****************************************************************************
 * FUNCTION
 *  HighlightEmTracert
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmTracert(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentSocketAppType = TRACERT;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmTracert, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmHTTPGet
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmHTTPGet(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U8 *history_buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketInitResult();

    EntryNewScreen(EM_SOCKET_HTTP_INPUT_SCR, NULL, EntryEmHTTPGet, NULL);
    history_buffer = GetCurrGuiBuffer(EM_SOCKET_HTTP_INPUT_SCR);

    if (history_buffer == NULL)
    {
        kal_wsprintf((U16*) EmSocketInputBuff, "%s", "http://");
    }

    ShowCategory5Screen(
        EM_SOCKET_HTTP_URL_TEXT,
        (U16) NULL,
        STR_GLOBAL_OPTIONS,
        (U16) NULL,
        STR_GLOBAL_BACK,
        (U16) NULL,
        INPUT_TYPE_ALPHANUMERIC_SENTENCECASE,
        (PU8) EmSocketInputBuff,
        EM_SOCKET_MAX_INPUT_LEN,
        history_buffer);

    SetLeftSoftkeyFunction(EntryEmHTTPOption, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    RegisterInputMethodScreenCloseFunction(EmSocketGoBack2History);
}


/*****************************************************************************
 * FUNCTION
 *  EmSocketGoBack2History
 * DESCRIPTION
 *  Go back two screen history
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketGoBack2History(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GoBacknHistory(1);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmHTTPOption
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmHTTPOption(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    U16 numItems = 0;
    U16 nStrItemList[32];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_SOCKET_HTTP_OPTION_SCR, NULL, EntryEmHTTPOption, NULL);

    guiBuffer = GetCurrGuiBuffer(EM_SOCKET_HTTP_OPTION_SCR);
    numItems = GetNumOfChild(EM_SOCKET_HTTP_OPTION_MENUID);
    GetSequenceStringIds(EM_SOCKET_HTTP_OPTION_MENUID, nStrItemList);
    SetParentHandler(EM_SOCKET_HTTP_OPTION_MENUID);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory52Screen(
        STR_GLOBAL_OPTIONS,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        numItems,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        NULL,
        0,
        0,
        guiBuffer);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmEcho
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmEcho(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentSocketAppType = ECHO;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmEcho, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmEcho
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmEcho(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *inputBuffer;
    U8 *guiBuffer;
    U16 inputBufferSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketInitResult();

    EntryNewScreen(EM_SOCKET_ECHO_INPUT_SCR, ExitEmEcho, NULL, NULL);

    InitializeCategory57Screen();
    guiBuffer = GetCurrGuiBuffer(EM_SOCKET_ECHO_INPUT_SCR);
    inputBuffer = GetCurrNInputBuffer(EM_SOCKET_ECHO_INPUT_SCR, &inputBufferSize);      /* added for inline edit history */
    EmSocketEchoFillInlineStruct();

    if (inputBuffer != NULL)
    {
        SetCategory57Data(wgui_inline_items, ENUM_ECHO_TOTAL, inputBuffer);
    }

    ShowCategory57Screen(
        EM_SOCKET_ECHO_TEXT,
        0,
        STR_GLOBAL_EDIT,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        ENUM_ECHO_TOTAL,
        0,
        wgui_inline_items,
        0,
        guiBuffer);
    SetCategory57RightSoftkeyFunctions(EntryEmSocketConfirm, GoBackHistory);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmEcho
 * DESCRIPTION
 *  Exit from EM Echo
 *  
 *  This is used to exit screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmEcho(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;
    U16 inputBufferSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
    h.scrnID = EM_SOCKET_ECHO_INPUT_SCR;
    h.entryFuncPtr = EntryEmEcho;
    GetCategoryHistory(h.guiBuffer);
    inputBufferSize = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) h.inputBuffer);
    AddNHistory(h, inputBufferSize);
}


/*****************************************************************************
 * FUNCTION
 *  EmSocketEchoFillInlineStruct
 * DESCRIPTION
 *  Call the Inline Functions.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketEchoFillInlineStruct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(EmSocketInputBuff, 0, sizeof(EmSocketInputBuff));

    ReturnThreeDigitString(EmSocketIP1, 0);
    ReturnThreeDigitString(EmSocketIP2, 0);
    ReturnThreeDigitString(EmSocketIP3, 0);
    ReturnThreeDigitString(EmSocketIP4, 0);

    /* server IP caption */
    SetInlineItemActivation(&wgui_inline_items[ENUM_SERVER_IP_CAPTION], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[ENUM_SERVER_IP_CAPTION], (U8*) GetString(EM_SOCKET_ECHO_SERVER_IP_TEXT));

    /* server IP  */
    SetInlineItemActivation((&wgui_inline_items[ENUM_SERVER_IP]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemIP4(
        (&wgui_inline_items[ENUM_SERVER_IP]),
        (U8*) EmSocketIP1,
        (U8*) EmSocketIP2,
        (U8*) EmSocketIP3,
        (U8*) EmSocketIP4,
        PreparedIPAddressString);

    /* Echo String caption */
    SetInlineItemActivation(&wgui_inline_items[ENUM_ECHO_STRING_CAPTION], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[ENUM_ECHO_STRING_CAPTION], (U8*) GetString(EM_SOCKET_ECHO_STRING_TEXT));

    /* Echo String  */
    SetInlineItemActivation((&wgui_inline_items[ENUM_ECHO_STRING]), KEY_LSK, KEY_EVENT_UP);
    SetInlineItemFullScreenEdit(
        (&wgui_inline_items[ENUM_ECHO_STRING]),
        EM_SOCKET_ECHO_STRING_TEXT,
        0,
        (U8*) EmSocketInputBuff,
        EM_SOCKET_MAX_INPUT_LEN,
        INPUT_TYPE_ALPHANUMERIC_SENTENCECASE | INPUT_TYPE_USE_ENCODING_BASED_LENGTH);
    SetInlineFullScreenEditCustomFunction(&wgui_inline_items[ENUM_ECHO_STRING], EmSocketFullLineEditScreen);

}


/*****************************************************************************
 * FUNCTION
 *  EntryEmSocketConfirm
 * DESCRIPTION
 *  Notification Screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmSocketConfirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayConfirm(
        STR_GLOBAL_YES,
        IMG_GLOBAL_YES,
        STR_GLOBAL_NO,
        IMG_GLOBAL_NO,
        get_string(STR_GLOBAL_SEND),
        IMG_GLOBAL_QUESTION,
        WARNING_TONE);

    SetLeftSoftkeyFunction(EntryEmSocketInProgress, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoToMainEmSocketScreen, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  GoToMainEmSocketScreen
 * DESCRIPTION
 *  Go back to Em Socket test Main
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void GoToMainEmSocketScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    stopRequestedTone(WARNING_TONE);

    GoBackToHistory(EM_SOCKET_MENU_SCR);
}


/*****************************************************************************
 * FUNCTION
 *  EmSocketFullLineEditScreen
 * DESCRIPTION
 *  EM Socket test for Full Line Edit Screen.
 *  
 *  This is used to edit Data Account.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketFullLineEditScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OPTIONS, IMG_GLOBAL_OPTIONS);

    SetLeftSoftkeyFunction(EntryScrForInputMethodAndDone, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmDate
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmDate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    currentSocketAppType = DAYTIME;

    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmDate, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmDate
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmDate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *inputBuffer;
    U8 *guiBuffer;
    U16 inputBufferSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EmSocketInitResult();

    EntryNewScreen(EM_SOCKET_DATE_INPUT_SCR, ExitEmDate, NULL, NULL);

    InitializeCategory57Screen();
    guiBuffer = GetCurrGuiBuffer(EM_SOCKET_DATE_INPUT_SCR);
    inputBuffer = GetCurrNInputBuffer(EM_SOCKET_DATE_INPUT_SCR, &inputBufferSize);      /* added for inline edit history */
    EmSocketDateFillInlineStruct();

    if (inputBuffer != NULL)
    {
        SetCategory57Data(wgui_inline_items, ENUM_DATE_TOTAL, inputBuffer);
    }

    ShowCategory57Screen(
        EM_SOCKET_DATE_TEXT,
        0,
        STR_GLOBAL_EDIT,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        ENUM_DATE_TOTAL,
        0,
        wgui_inline_items,
        0,
        guiBuffer);
    SetCategory57RightSoftkeyFunctions(EntryEmSocketConfirm, GoBackHistory);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmDate
 * DESCRIPTION
 *  Exit from EM Date
 *  
 *  This is used to exit screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmDate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;
    U16 inputBufferSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
    h.scrnID = EM_SOCKET_DATE_INPUT_SCR;
    h.entryFuncPtr = EntryEmDate;
    GetCategoryHistory(h.guiBuffer);
    inputBufferSize = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) h.inputBuffer);
    AddNHistory(h, inputBufferSize);
}


/*****************************************************************************
 * FUNCTION
 *  EmSocketDateFillInlineStruct
 * DESCRIPTION
 *  Call the Inline Functions.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSocketDateFillInlineStruct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReturnThreeDigitString(EmSocketIP1, 0);
    ReturnThreeDigitString(EmSocketIP2, 0);
    ReturnThreeDigitString(EmSocketIP3, 0);
    ReturnThreeDigitString(EmSocketIP4, 0);

    /* server IP caption */
    SetInlineItemActivation(&wgui_inline_items[ENUM_DATE_SERVER_IP_CAPTION], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(
        &wgui_inline_items[ENUM_DATE_SERVER_IP_CAPTION],
        (U8*) GetString(EM_SOCKET_ECHO_SERVER_IP_TEXT));

    /* server IP  */
    SetInlineItemActivation((&wgui_inline_items[ENUM_DATE_SERVER_IP]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemIP4(
        (&wgui_inline_items[ENUM_DATE_SERVER_IP]),
        (U8*) EmSocketIP1,
        (U8*) EmSocketIP2,
        (U8*) EmSocketIP3,
        (U8*) EmSocketIP4,
        PreparedIPAddressString);

}


/* BEGIN OF IPERF */

/*****************************************************************************
* FUNCTION
*   em_iperf_disp_not_support_popup
* DESCRIPTION
*   Common function to display "Not Available" popup
* PARAMETERS
*   None.
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_disp_not_support_popup(void)
{
    TurnOnBacklight(TRUE);

    DisplayPopup ((U8*)GetString(STR_GLOBAL_NOT_AVAILABLE),
                  IMG_GLOBAL_ERROR, 
                  1, UI_POPUP_NOTIFYDURATION_TIME, (U8)ERROR_TONE);
}


#define Iperf_Hilite
/**************************************************************
*   FUNCTION NAME		: HighlightEmIperf
*
*   PURPOSE				: Highlight function for Iperf
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void HighlightEmIperf(void)
{
    /* Register function for left soft key */
#ifdef __IPERF__
    SetLeftSoftkeyFunction(PreEntryEmIperf, KEY_EVENT_UP);
#else /* !IPERF_SUPPORT */
    SetLeftSoftkeyFunction(em_iperf_disp_not_support_popup, KEY_EVENT_UP);
#endif /* __IPERF__ */

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory,KEY_EVENT_UP);
}

#ifdef __IPERF__

/**************************************************************
*   FUNCTION NAME		: HighlightEmIperfTcp
*
*   PURPOSE				: Highlight function for IperfTcp
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void HighlightEmIperfTcp(void)
{
	/* Register function for left soft key */
	SetLeftSoftkeyFunction(PreEntryEmIperfTcp,KEY_EVENT_UP);

	/* Register function for right soft key */
	SetRightSoftkeyFunction(em_iperf_exit_iperf_setting,KEY_EVENT_UP);
}

/**************************************************************
*   FUNCTION NAME		: HighlightEmIperfUdp
*
*   PURPOSE				: Highlight function for IperfUdp
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void HighlightEmIperfUdp(void)
{
	/* Register function for left soft key */
	SetLeftSoftkeyFunction(PreEntryEmIperfUdp,KEY_EVENT_UP);

	/* Register function for right soft key */
	SetRightSoftkeyFunction(em_iperf_exit_iperf_setting,KEY_EVENT_UP);
}

#define Iperf_Pre_Entry
/**************************************************************
*   FUNCTION NAME		: PreEntryEmIperf
*
*   PURPOSE				:Pre Entry function for EM Iperf (Iperf->Iperf Setting)
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void PreEntryEmIperf(void)
{

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_PRE_ENTRY_IPERF);

    /* memory allocation for Iperf*/
    
    if(iperf_p->iperf_misc== NULL)
    {
      iperf_p->iperf_misc = (em_iperf_misc_struct*)OslMalloc(sizeof(em_iperf_misc_struct));
      memset(iperf_p->iperf_misc, 0, sizeof(em_iperf_misc_struct));
    }

    if(iperf_p->iperf_edit_tcp== NULL)
    {
      iperf_p->iperf_edit_tcp = (em_iperf_edit_struct*)OslMalloc(sizeof(em_iperf_edit_struct));
      memset(iperf_p->iperf_edit_tcp, 0, sizeof(em_iperf_edit_struct));
    }

    
    if(iperf_p->iperf_edit_udp== NULL)
    {
      iperf_p->iperf_edit_udp = (em_iperf_edit_struct*)OslMalloc(sizeof(em_iperf_edit_struct));
      memset(iperf_p->iperf_edit_udp, 0, sizeof(em_iperf_edit_struct));
    }

    /* call iperf entry function */
    EntryEmIperf();
}


/**************************************************************
*   FUNCTION NAME		: PreEntryEmIperfTcp
*
*   PURPOSE				: Pre Entry function for EM IperfTcp (Iperf Setting -> Protocol(TCP) Seting)
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void PreEntryEmIperfTcp(void)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_PRE_ENTRY_IPERF_TCP);

    /* Set Protocol to identify which protocol setting screen*/
    iperf_p->iperf_misc->prot = TCP;    

    /* call protocol setting entry function*/
    EntryEmIperfSetting();
}

/**************************************************************
*   FUNCTION NAME		: EntryEmIperfUdp
*
*   PURPOSE				: Entry function for EM IperfUdp (Iperf Setting -> Protocol(UDP) Seting)
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void PreEntryEmIperfUdp(void)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_PRE_ENTRY_IPERF_UDP);

    /* Set Protocol to identify which protocol setting screen*/
    iperf_p->iperf_misc->prot = UDP;    

    /* call protocol setting entry function*/
    EntryEmIperfSetting();
}

#define Iperf_Entry
/**************************************************************
*   FUNCTION NAME		: EntryEmIperf
*
*   PURPOSE				: Entry function for EM Iperf Setting
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void EntryEmIperf(void)
{

    U16 numItems;
    U16 nStrItemList[2]; 
    U8* guiBuffer;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_ENTRY_IPERF);

    //Read setting data from file
    em_iperf_read_file();

    EntryNewScreen(EM_SOCKET_IPERF_SETTING_SCR, NULL, EntryEmIperf, NULL);         
    guiBuffer = GetCurrGuiBuffer (EM_SOCKET_IPERF_SETTING_SCR);
    SetParentHandler (EM_SOCKET_IPERF_MENUID);
    numItems = GetNumOfChild (EM_SOCKET_IPERF_MENUID);
    GetSequenceStringIds (EM_SOCKET_IPERF_MENUID, nStrItemList);
    RegisterHighlightHandler (ExecuteCurrHiliteHandler);
    ShowCategory52Screen (EM_SOCKET_IPERF_IPERF_SETTING_STR, EM_SOCKET_IPERF_ICON, 
                            STR_GLOBAL_OK, IMG_GLOBAL_OK,
                            STR_GLOBAL_BACK, IMG_GLOBAL_BACK,
                            numItems, nStrItemList, (U16*)gIndexIconsImageList,
                            NULL, 0, 0,  guiBuffer);

    SetRightSoftkeyFunction (GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler (GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);

    /* Set delete call back function for release allocated memory */
    SetDelScrnIDCallbackHandler (EM_SOCKET_IPERF_SETTING_SCR, 
                                 (HistoryDelCBPtr)em_iperf_setting_del_callback);

}


/**************************************************************
*   FUNCTION NAME		: EntryEmIperfSetting
*
*   PURPOSE				: Entry function for EM Iperf Protocol Setting
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void EntryEmIperfSetting(void)
{
    U8* guiBuffer;
    U8* inputBuffer;
    U16 inputBufferSize;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_ENTRY_IPERF_SETTING);

    /* Entry different screens for different protocols*/
    if(iperf_p->iperf_misc->prot == TCP)  
        EntryNewScreen(EM_SOCKET_IPERF_PROT_SETTING_SCR, em_iperf_exit_tcp_setting, NULL, NULL);        
    if(iperf_p->iperf_misc->prot == UDP)  
        EntryNewScreen(EM_SOCKET_IPERF_PROT_SETTING_SCR, em_iperf_exit_udp_setting, NULL, NULL);

    InitializeCategory57Screen();
    em_iperf_setting_fill_inline_struct();
  
    guiBuffer = GetCurrGuiBuffer (EM_SOCKET_IPERF_PROT_SETTING_SCR);
    inputBuffer = GetCurrNInputBuffer (EM_SOCKET_IPERF_PROT_SETTING_SCR, &inputBufferSize);

    if(inputBuffer!=NULL)															
        SetCategory57Data(wgui_inline_items, IPERF_INLINE_COUNT, inputBuffer);	
    
    /* trick to set done flag for protocol setting inline screen*/
    wgui_inline_list_menu_changed = 1;
    
    if(iperf_p->iperf_misc->prot == TCP)  
        ShowCategory57Screen (EM_SOCKET_IPERF_TCP_SETTING_STR, EM_SOCKET_IPERF_ICON,	
                    STR_GLOBAL_EDIT, IMG_GLOBAL_BACK,
                    STR_GLOBAL_DONE, IMG_GLOBAL_BACK,
                    IPERF_INLINE_COUNT, (U16*)g_iperf_inline_icons, 
                    wgui_inline_items, 0, guiBuffer);

    if(iperf_p->iperf_misc->prot == UDP)
        ShowCategory57Screen (EM_SOCKET_IPERF_UDP_SETTING_STR, EM_SOCKET_IPERF_ICON,    
                    STR_GLOBAL_EDIT, IMG_GLOBAL_BACK,
                    STR_GLOBAL_DONE, IMG_GLOBAL_BACK,
                    IPERF_INLINE_COUNT, (U16*)g_iperf_inline_icons, 
                    wgui_inline_items, 0, guiBuffer);
    
    SetCategory57RightSoftkeyFunctions (em_iperf_run, GoBackHistory);
  
}

/*****************************************************************************
* FUNCTION
*  em_iperf_show_progressing_screen
* DESCRIPTION
*  This function is to display progressing screen.
*
* PARAMETERS
*  None.
* RETURNS
*  NONE.
* GLOBALS AFFECTED
*  None.
*****************************************************************************/
void em_iperf_show_progressing_screen(void)
{
	
    U8* guiBuffer;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_ENTRY_PROGRESSING_SCREEN);

    EntryNewScreen(EM_SOCKET_IPERF_PROGRESSING_SCR, NULL, em_iperf_show_progressing_screen, NULL );

    /* Clear all key handlers so as to restrict duplicate reqs */		
    /* New api should be used "ClearInputEventHandler(MMI_DEVICE_ALL);"*/
    ClearInputEventHandler(MMI_DEVICE_ALL);
    //ClearAllKeyHandler();
    
    ClearKeyHandler(KEY_END,KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_END,KEY_LONG_PRESS);

    guiBuffer = GetCurrGuiBuffer(EM_SOCKET_IPERF_PROGRESSING_SCR);
    
    /* Show progressing screen */
    ShowCategory66Screen(EM_SOCKET_IPERF_STR, 0,
                            0, 0, STR_GLOBAL_ABORT, 0, 
                            (U8*)GetString(EM_SOCKET_IPERF_PROGRESSING_STR), IMG_GLOBAL_PROGRESS, guiBuffer);

    
    /* del confirm screen */
    DeleteUptoScrID(EM_SOCKET_IPERF_PROT_SETTING_SCR);

    /* Set Right softkey function to abort */
    SetRightSoftkeyFunction(em_iperf_progress_abort,KEY_EVENT_UP);

}

/**************************************************************
*   FUNCTION NAME		: EntryEmIperfReport
*
*   PURPOSE				: Entry function for EM Iperf Report
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void EntryEmIperfReport(void)
{

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_ENTRY_IPERF_REPORT);

    EntryNewScreen(EM_SOCKET_IPERF_REPORT_SCR, NULL, EntryEmIperfReport, NULL);         


    ShowCategory7Screen( EM_SOCKET_IPERF_REPORT_STR, 0,
                            0, IMG_GLOBAL_OK, STR_GLOBAL_BACK,
                            IMG_GLOBAL_BACK, (U8*)iperf_p->iperf_report->report_UI_buffer, NULL );

    /* delete progressing screen */
    DeleteNHistory(1);

    SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
    SetRightSoftkeyFunction(em_iperf_report_back, KEY_EVENT_UP);
            
}

#define Iperf_Exit
/**************************************************************
*   FUNCTION NAME		: em_iperf_exit_iperf_setting
*
*   PURPOSE				: Release allocated memory (Iperf Setting Screen -> Socket Test Screen)
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void em_iperf_exit_iperf_setting(void)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_EXIT_IPERF);

    /* Release allocated memory */
    
    if(iperf_p->iperf_misc != NULL)
       {
          OslMfree(iperf_p->iperf_misc);
          iperf_p->iperf_misc = NULL;
       }
    
    if(iperf_p->iperf_edit_tcp!= NULL)
       {
          OslMfree(iperf_p->iperf_edit_tcp);
          iperf_p->iperf_edit_tcp= NULL;
       }
    
    if(iperf_p->iperf_edit_udp!= NULL)
       {
          OslMfree(iperf_p->iperf_edit_udp);
          iperf_p->iperf_edit_udp= NULL;
       }

    if(iperf_p->iperf_report!= NULL)
       {
          OslMfree(iperf_p->iperf_report);
          iperf_p->iperf_report= NULL;
       }
    
    GoBackHistory();

}

/**************************************************************
*   FUNCTION NAME		: em_iperf_exit_tcp_setting
*
*   PURPOSE				: Exit function for inlnine editor screen of Iperf TCP Setting
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void em_iperf_exit_tcp_setting(void)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_EXIT_IPERF_TCP);

    /* add history node for inline screen */
    GenericExitInlineScreen(EM_SOCKET_IPERF_PROT_SETTING_SCR, PreEntryEmIperfTcp);
}


/**************************************************************
*   FUNCTION NAME		: em_iperf_exit_udp_setting
*
*   PURPOSE				: Exit function for inlnine editor screen of Iperf UDP Setting
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void em_iperf_exit_udp_setting(void)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_EXIT_IPERF_UDP);

    /* add history node for inline screen */
    GenericExitInlineScreen(EM_SOCKET_IPERF_PROT_SETTING_SCR, PreEntryEmIperfUdp);
}

/*****************************************************************************
* FUNCTION
*	em_iperf_setting_del_callback
* DESCRIPTION
*	Callback function when iperf setting is deleted.
* PARAMETERS
*	param		IN		parameter from framework
* RETURNS
*	None.
* GLOBALS AFFECTED
*	None.
*****************************************************************************/
U8 em_iperf_setting_del_callback (void *param)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_DEL_CB);

    /* Release allocated memory */
      
    if(iperf_p->iperf_misc != NULL)
    {
        OslMfree(iperf_p->iperf_misc);
        iperf_p->iperf_misc = NULL;
    }
    
    if(iperf_p->iperf_edit_tcp!= NULL)
    {
        OslMfree(iperf_p->iperf_edit_tcp);
        iperf_p->iperf_edit_tcp= NULL;
    }
    
    if(iperf_p->iperf_edit_udp!= NULL)
    {
        OslMfree(iperf_p->iperf_edit_udp);
        iperf_p->iperf_edit_udp= NULL;
    }
    
    if(iperf_p->iperf_report!= NULL)
    {
        OslMfree(iperf_p->iperf_report);
        iperf_p->iperf_report= NULL;
    }

	return FALSE;
}

#define Iperf_Inline
/**************************************************************
*   FUNCTION NAME		: em_iperf_setting_fill_inline_struct
*
*   PURPOSE				: Fill inline editor structure of Iperf Protocol Setting
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void em_iperf_setting_fill_inline_struct()
{
    em_iperf_edit_struct *activate;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_SETTING_FILL_INLINE);

    /* default TCP Testing */
    activate = iperf_p->iperf_edit_tcp;
    
    if(iperf_p->iperf_misc->prot == UDP)
        activate = iperf_p->iperf_edit_udp;
    
    /* prepare Client / Server options for inline editor */
    iperf_p->iperf_misc->client_server_list[0] = (U8*) GetString(EM_SOCKET_IPERF_CLIENT_STR);
    iperf_p->iperf_misc->client_server_list[1] = (U8*) GetString(EM_SOCKET_IPERF_SERVER_STR);

    /* prepare RW File options for inline editor */
    iperf_p->iperf_misc->rw_file_list[0] = (U8*) GetString(STR_GLOBAL_OFF);
    iperf_p->iperf_misc->rw_file_list[1] = (U8*) GetString(STR_GLOBAL_ON);

    /* prepare ToS Types for inline editor */
    iperf_p->iperf_misc->tos_list[0] = (U8*) GetString(EM_SOCKET_IPERF_BEST_EFFORT_STR);
    iperf_p->iperf_misc->tos_list[1] = (U8*) GetString(EM_SOCKET_IPERF_BACK_GROUND_STR);
    iperf_p->iperf_misc->tos_list[2] = (U8*) GetString(EM_SOCKET_IPERF_VIDEO_STR);
    iperf_p->iperf_misc->tos_list[3] = (U8*) GetString(EM_SOCKET_IPERF_VOICE_STR);

    /* prepare Dualtest options for inline editor */
    iperf_p->iperf_misc->dualtest[0] = (U8*) GetString(STR_GLOBAL_OFF);
    iperf_p->iperf_misc->dualtest[1] = (U8*) GetString(STR_GLOBAL_ON);
    

    /* Data Account */
    SetInlineItemActivation (&wgui_inline_items[0], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*) GetString (EM_SOCKET_IPERF_DATA_ACCOUNT_STR));
    SetInlineItemActivation (&wgui_inline_items[1], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemImageText (&wgui_inline_items[1], (U8*)activate->dt_acct_name,
                                 (UI_image_type)NULL,
                                 NULL, NULL, 
                                 MAX_DATA_ACCOUNT_NAME_LEN,
                                 0, 0, 
                                 INPUT_TYPE_ALPHANUMERIC_SENTENCECASE );
    SetInlineFullScreenEditCustomFunctionImageText (&wgui_inline_items[1], em_iperf_setting_data_acct);
    ShowAsControl (&wgui_inline_items[1]);   
        
    /* Client or Server mode */
    SetInlineItemActivation (&wgui_inline_items[2], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*) GetString (EM_SOCKET_IPERF_CLIENT_SERVER_STR));
    SetInlineItemActivation (&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect (&wgui_inline_items[3], 2, iperf_p->iperf_misc->client_server_list, &activate->client_server);


    /* Foreign Address*/
    SetInlineItemActivation (&wgui_inline_items[4], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption (&wgui_inline_items[4], (U8*) GetString (EM_SOCKET_IPERF_FADDR_STR));
    SetInlineItemActivation(&wgui_inline_items[5],INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT,0);
    SetInlineItemIP4(&wgui_inline_items[5],
                    (U8*)activate->faddr_ip[0],
                    (U8*)activate->faddr_ip[1],
                    (U8*)activate->faddr_ip[2],
                    (U8*)activate->faddr_ip[3],
                    em_iperf_ip_addr_callback);

    /* Len */
    SetInlineItemActivation (&wgui_inline_items[6], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption (&wgui_inline_items[6], (U8*) GetString (EM_SOCKET_IPERF_LEN_STR));
    SetInlineItemActivation (&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[7], (U8*)activate->len, IPERF_LEN, INPUT_TYPE_NUMERIC);
    RightJustifyInlineItem(&wgui_inline_items[7]);
    EnableInlineItemBoundary(&wgui_inline_items[7]);
    DisableInlineItemHighlight(&wgui_inline_items[7]);


    /* Port */
    SetInlineItemActivation (&wgui_inline_items[8], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption (&wgui_inline_items[8], (U8*) GetString (EM_SOCKET_IPERF_PORT_STR));
    SetInlineItemActivation (&wgui_inline_items[9], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[9], (U8*)activate->port, IPERF_PORT, INPUT_TYPE_NUMERIC);
    RightJustifyInlineItem(&wgui_inline_items[9]);
    EnableInlineItemBoundary(&wgui_inline_items[9]);
    DisableInlineItemHighlight(&wgui_inline_items[9]);


    /* Window / Buffer*/
    SetInlineItemActivation (&wgui_inline_items[10], KEY_LSK, KEY_EVENT_UP);
    if (iperf_p->iperf_misc->prot == TCP) 
        SetInlineItemCaption (&wgui_inline_items[10], (U8*) GetString (EM_SOCKET_IPERF_WINDOW_STR));
    if (iperf_p->iperf_misc->prot == UDP) 
        SetInlineItemCaption (&wgui_inline_items[10], (U8*) GetString (EM_SOCKET_IPERF_BUFFER_STR));
    SetInlineItemActivation (&wgui_inline_items[11], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[11], (U8*)activate->window, IPERF_WINDOW, INPUT_TYPE_NUMERIC);
    RightJustifyInlineItem(&wgui_inline_items[11]);
    EnableInlineItemBoundary(&wgui_inline_items[11]);
    DisableInlineItemHighlight(&wgui_inline_items[11]);             

            
    /* MSS / Bandwidth*/
    SetInlineItemActivation (&wgui_inline_items[12], KEY_LSK, KEY_EVENT_UP);
    if (iperf_p->iperf_misc->prot == TCP) 
    {
        SetInlineItemCaption (&wgui_inline_items[12], (U8*) GetString (EM_SOCKET_IPERF_MSS_STR));
        SetInlineItemActivation (&wgui_inline_items[13], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemTextEdit(&wgui_inline_items[13], (U8*)activate->mss, IPERF_MSS, INPUT_TYPE_NUMERIC);
    }
    if (iperf_p->iperf_misc->prot == UDP)
    {
        SetInlineItemCaption (&wgui_inline_items[12], (U8*) GetString (EM_SOCKET_IPERF_BANDWIDTH_STR));
        SetInlineItemActivation (&wgui_inline_items[13], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemTextEdit(&wgui_inline_items[13], (U8*)activate->bandwidth, IPERF_BANDWIDTH, INPUT_TYPE_NUMERIC);        
    }
    RightJustifyInlineItem(&wgui_inline_items[13]);
    EnableInlineItemBoundary(&wgui_inline_items[13]);
    DisableInlineItemHighlight(&wgui_inline_items[13]);             


    /* Dual test */
    SetInlineItemActivation (&wgui_inline_items[14], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption(&wgui_inline_items[14], (U8*) GetString (EM_SOCKET_IPERF_DUAL_STR));
    SetInlineItemActivation (&wgui_inline_items[15], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect (&wgui_inline_items[15], 2, iperf_p->iperf_misc->dualtest, &activate->dualtest);

    /* Num(Bytes) */
    SetInlineItemActivation (&wgui_inline_items[16], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption (&wgui_inline_items[16], (U8*) GetString (EM_SOCKET_IPERF_NUM_BYTES_STR));
    SetInlineItemActivation (&wgui_inline_items[17], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[17], (U8*)activate->num, IPERF_NUM, INPUT_TYPE_NUMERIC);
    RightJustifyInlineItem(&wgui_inline_items[17]);
    EnableInlineItemBoundary(&wgui_inline_items[17]);
    DisableInlineItemHighlight(&wgui_inline_items[17]);
        
    /* Time(Sec) */
    SetInlineItemActivation (&wgui_inline_items[18], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption (&wgui_inline_items[18], (U8*) GetString (EM_SOCKET_IPERF_TIME_SECS_STR));
    SetInlineItemActivation (&wgui_inline_items[19], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[19], (U8*)activate->time, IPERF_TIME, INPUT_TYPE_NUMERIC);
    RightJustifyInlineItem(&wgui_inline_items[19]);
    EnableInlineItemBoundary(&wgui_inline_items[19]);
    DisableInlineItemHighlight(&wgui_inline_items[19]);
        
    /* ToS type */
    SetInlineItemActivation (&wgui_inline_items[20], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption(&wgui_inline_items[20], (U8*) GetString (EM_SOCKET_IPERF_TOS_STR));
    SetInlineItemActivation (&wgui_inline_items[21], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect (&wgui_inline_items[21], 4, iperf_p->iperf_misc->tos_list, &activate->tos);
                            
    /* Read / Write file  */
    SetInlineItemActivation (&wgui_inline_items[22], KEY_LSK, KEY_EVENT_UP);
    SetInlineItemCaption(&wgui_inline_items[22], (U8*) GetString (EM_SOCKET_IPERF_RW_FILE_STR));
    SetInlineItemActivation (&wgui_inline_items[23], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect (&wgui_inline_items[23], 2, iperf_p->iperf_misc->rw_file_list, &activate->rw_file);
}

/**************************************************************
*   FUNCTION NAME		: em_iperf_setting_data_acct
*
*   PURPOSE				: get the data account for iperf protocol setting 
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void em_iperf_setting_data_acct(void)
{
    /* data account api for select account with assigned callback function */
    mmi_dtcnt_select_account(em_iperf_dt_callback, 0, DATA_ACCOUNT_BEARER_GPRS | DATA_ACCOUNT_BEARER_WIFI);
}

/**************************************************************
*   FUNCTION NAME		: em_iperf_dt_callback
*
*   PURPOSE				: get the account name for iperf protocol setting 
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void em_iperf_dt_callback(U32 account_id)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_DT_CB);    
    
    /* set account id depends on user selected and get the account name */
    if(iperf_p->iperf_misc->prot == TCP)
    {
        iperf_p->iperf_edit_tcp->account_id = (U8)account_id;
        /* data account api for getting account name*/
        mmi_dtcnt_get_account_name((U8)account_id, (S8*)iperf_p->iperf_edit_tcp->dt_acct_name, MAX_DATA_ACCOUNT_NAME_LEN);
    }
    else
    {
        iperf_p->iperf_edit_udp->account_id = (U8)account_id;
        /* data account api for getting account name*/
        mmi_dtcnt_get_account_name((U8)account_id, (S8*)iperf_p->iperf_edit_udp->dt_acct_name, MAX_DATA_ACCOUNT_NAME_LEN);
    }
    
    /* delete data account setting screens*/
    DeleteUptoScrID(EM_SOCKET_IPERF_PROT_SETTING_SCR);

    IPERF_DBG(kal_print("Account ID : %u",account_id););

    GoBackHistory();

    /* set inline menu changed */
    SetInlineListMenuChanged();
}

/*****************************************************************************
* FUNCTION
*   em_iperf_ip_addr_callback
* DESCRIPTION
*   Callback function for IP address editor in inline editor screen
* PARAMETERS
*  string_buffer
*  IP1
*  IP2
*  IP3
*  IP4
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_ip_addr_callback(U8* string_buffer,U8 *IP1,U8 *IP2,U8 *IP3,U8 *IP4)
{
    kal_uint8 Point[4];
 
    /* {'.','\0'}->{'.','\0','\0','\0'} */
    mmi_asc_to_ucs2((S8*)Point,(S8*)".");
 
    mmi_ucs2cpy((PS8)string_buffer,(PS8)IP1);
    mmi_ucs2cat((PS8)string_buffer,(PS8)Point);
    mmi_ucs2cat((PS8)string_buffer,(PS8)IP2);
    mmi_ucs2cat((PS8)string_buffer,(PS8)Point);
    mmi_ucs2cat((PS8)string_buffer,(PS8)IP3);
    mmi_ucs2cat((PS8)string_buffer,(PS8)Point);
    mmi_ucs2cat((PS8)string_buffer,(PS8)IP4);
}


#define Iperf_Utility
    
/**************************************************************
*   FUNCTION NAME		: em_iperf_run
*
*   PURPOSE				: Iperf Run Confirm
*
*   INPUT PARAMETERS	: nil
*
*   OUTPUT PARAMETERS	: void
*
*   RETURNS				: void
*
*   REMARKS			: 
**************************************************************/
void em_iperf_run(void)
{
    //ckeck Iperf parameter validation   
    em_iperf_run_confirm(EM_SOCKET_IPERF_RUN_STR, em_iperf_check, em_iperf_not_run);
}

/*****************************************************************************
* FUNCTION
*	em_iperf_run_confirm
* DESCRIPTION
*	Common function to display confirmation screem
* PARAMETERS
*	msg         IN    string index of message to be displayed in confirmation screen
*	lskFuncPtr    IN    LSK handler of the confirmation screen
*	rskFuncPtr    IN    RSK handler of the confirmation screen
* RETURNS
*	None.
* GLOBALS AFFECTED
*	None.
*****************************************************************************/
void em_iperf_run_confirm(U16 msg, FuncPtr lskFuncPtr, FuncPtr rskFuncPtr)
{
    DisplayConfirm(STR_GLOBAL_YES, IMG_GLOBAL_YES,
                   STR_GLOBAL_NO, IMG_GLOBAL_NO,
                   (UI_string_type)GetString(msg), IMG_GLOBAL_QUESTION, WARNING_TONE); 

    SetLeftSoftkeyFunction (lskFuncPtr, KEY_EVENT_UP);
    SetRightSoftkeyFunction (rskFuncPtr, KEY_EVENT_UP);
}

/*****************************************************************************
* FUNCTION
*	em_iperf_not_run
* DESCRIPTION
*	Give up running iperf and go back to iperf setting screen
* PARAMETERS
*	None.
* RETURNS
*	None.
* GLOBALS AFFECTED
*	None.
*****************************************************************************/
void em_iperf_not_run(void)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_NOT_RUN);    

    /* delete screens to iperf protocol setting screen */
	DeleteUptoScrID(EM_SOCKET_IPERF_PROT_SETTING_SCR);

    /* go back to iperf setting screen*/
    GoBacknHistory(1);
}

/*****************************************************************************
* FUNCTION
*	em_iperf_check
* DESCRIPTION
*	check iperf setting to run and save to file
* PARAMETERS
*	None.
* RETURNS
*	None.
* GLOBALS AFFECTED
*	None.
*****************************************************************************/
void em_iperf_check(void)
{
   
    em_iperf_edit_struct *iperf_edit;
    kal_int32   len;
    kal_uint32  port;
    kal_int32   window;
    kal_int32   mss;
    kal_uint32  bandwidth;
    kal_uint32  ip0;
    kal_uint32  ip1;
    kal_uint32  ip2;
    kal_uint32  ip3;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_CHECK_SETTINGS);     

    if(iperf_p->iperf_misc->prot == TCP)
        iperf_edit = iperf_p->iperf_edit_tcp;
    else
        iperf_edit = iperf_p->iperf_edit_udp;
    
    len = (S32)gui_atoi(iperf_edit->len);
    port = (U32)gui_atoi(iperf_edit->port);
    window = (S32)gui_atoi(iperf_edit->window);

    /* check iperf settings */

    /* check len */
    if(len > 2880)
    {
         em_iperf_disp_err_popup(EM_SOCKET_IPERF_LEN_ERR_STR);
         return;    
    }

    /* check port*/
    if(port > 65535)
    {
         em_iperf_disp_err_popup(EM_SOCKET_IPERF_PORT_ERR_STR);
         return;    
    }

    /* check mss and window */
    if(iperf_p->iperf_misc->prot == TCP) 
    {
        mss = (S32)gui_atoi(iperf_edit->mss);
        if(window > 36000) //36*1000
        {
            em_iperf_disp_err_popup(EM_SOCKET_IPERF_WINDOW_ERR_STR);
            return;
        }        
        if(mss > 1500)
        {
             em_iperf_disp_err_popup(EM_SOCKET_IPERF_MSS_ERR_STR);
             return;    
        }
    }
     /* check bandwidth and window */        
    if(iperf_p->iperf_misc->prot == UDP) 
    {
        bandwidth = (U32)gui_atoi(iperf_edit->bandwidth);
        if(window > 36000) //36*1000
        {
            em_iperf_disp_err_popup(EM_SOCKET_IPERF_BUFFER_ERR_STR);
            return;    
        }
        if(bandwidth > 54000)
        {
            em_iperf_disp_err_popup(EM_SOCKET_IPERF_BANDWIDTH_ERR_STR);
            return;    
        }
    }
    
    /* check faddr for client mode */
    if (iperf_edit->client_server == 0)
    {
    	ip0 = (U32)gui_atoi(iperf_edit->faddr_ip[0]);
    	ip1 = (U32)gui_atoi(iperf_edit->faddr_ip[1]);
    	ip2 = (U32)gui_atoi(iperf_edit->faddr_ip[2]);
    	ip3 = (U32)gui_atoi(iperf_edit->faddr_ip[3]);

    	if(ip0 == 0 && ip1 == 0 && ip2 == 0 && ip3 == 0)
    	{
        	em_iperf_disp_err_popup(EM_SOCKET_IPERF_FADDR_ERR_STR);
        	return;
    	}
    }
    
    /* check server - dual testing mode */
    if(iperf_edit->dualtest == 1 && iperf_edit->client_server == 1)
    {
        em_iperf_disp_err_popup(EM_SOCKET_IPERF_SERVER_DUAL_ERR_STR);
        return;    
    }
    
    IPERF_DBG(kal_print("Valid Iperf Settings !! \n"););

    /* show progressing screen and set protocol event handler */
    em_iperf_show_progressing_screen();

    /* fill the req struct and send req to iperf task */
    em_iperf_send_req(); 

}

/*****************************************************************************
* FUNCTION
*   em_iperf_progress_abort
* DESCRIPTION
*   abort iperf
* PARAMETERS
*   str_id  IN    id of string to be displayed
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_progress_abort(void)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_PROGRESS_ABORT);
    
    /* clear protocol event handler */
    ClearProtocolEventHandler(MSG_ID_MMI_IPERF_RUN_CNF);
    ClearProtocolEventHandler(MSG_ID_MMI_IPERF_REPORT_IND);
   
    /* call abort function */
#ifdef __MTK_TARGET__
    IPERF_DBG(kal_print("call iperf_stop function!!\n"););
    iperf_stop(0, iperf_cur_job_id % 2);
#endif
    /* show fail popup to notify user */
    em_iperf_disp_fail_popup(STR_GLOBAL_ABORTING);

    /* delete progressing screen */
    DeleteNHistory(1);
}

/*****************************************************************************
* FUNCTION
*   em_iperf_report_back
* DESCRIPTION
*   report screen back to prot setting screen 
* PARAMETERS
*   str_id  IN    id of string to be displayed
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_report_back(void)
{
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_REPORT_BACK);

    /* release allocated report memory */
    if(iperf_p->iperf_report!= NULL)
    {
        OslMfree(iperf_p->iperf_report);
        iperf_p->iperf_report= NULL;
    }

    GoBackHistory();
}

/*****************************************************************************
* FUNCTION
*   em_iperf_disp_fail_popup
* DESCRIPTION
*   Common function to display fail popup (abort, cnf_fail, report_fail)
* PARAMETERS
*   str_id  IN    id of string to be displayed
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_disp_fail_popup(U16 str_id)
{
    TurnOnBacklight(TRUE);

    DisplayPopup ((U8*)GetString(str_id),
                   IMG_GLOBAL_UNFINISHED, 
                   1, UI_POPUP_NOTIFYDURATION_TIME, (U8)WARNING_TONE);
}

/*****************************************************************************
* FUNCTION
*   em_iperf_disp_err_popup
* DESCRIPTION
*   Common function to display error popup (setting error)
* PARAMETERS
*   str_id  IN    id of string to be displayed
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_disp_err_popup(U16 str_id)
{
    TurnOnBacklight(TRUE);

    DisplayPopup ((U8*)GetString(str_id),
                   IMG_GLOBAL_ERROR, 
                   1, UI_POPUP_NOTIFYDURATION_TIME, (U8)ERROR_TONE);
}


#define Iperf_FS
/*****************************************************************************
* FUNCTION
*   em_iperf_save
* DESCRIPTION
*   Save the settings to file
* PARAMETERS
*   None.
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_save(void)
{

    FS_HANDLE   fd;
    kal_uint32  writtenbytes;
    kal_int32   ret;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_SAVE);

    fd = FS_Open((WCHAR*)IPERF_SETTING_FILE, FS_READ_WRITE | FS_CREATE);
    if(fd < 0)
    {
        IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(fd)););
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_SAVE_OPEN_FAILED);
        return;
    }

    /* Save UDP settings */
    if(iperf_p->iperf_misc->prot == UDP)
    {
        /* Seek file pointer to udp saving position */
        if((ret = FS_Seek(fd, sizeof(em_iperf_edit_struct), FS_FILE_BEGIN)) < 0)
        {
            IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(fd)););
            MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_SAVE_SEEK_FAILED);            
            FS_Close(fd);
            return;
        }
        
        ret= FS_Write(fd, iperf_p->iperf_edit_udp, sizeof(em_iperf_edit_struct), &writtenbytes);      
        FS_Close(fd);
        if (ret != FS_NO_ERROR || writtenbytes != sizeof(em_iperf_edit_struct))
        {
            IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(ret)););
            MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_WRITE_UDP_FAILED);            
            return;
        }

        IPERF_DBG(kal_print("em_Iperf_save UDP--- FS_Seek and FS_Write!!! \n"););
        return;
    }

    /* Save TCP settings */
    IPERF_DBG(kal_print("em_Iperf_save TCP--- FS_Write!!! \n"););
    ret= FS_Write(fd, iperf_p->iperf_edit_tcp, sizeof(em_iperf_edit_struct), &writtenbytes);      
    FS_Close(fd);
    if (ret != FS_NO_ERROR || writtenbytes != sizeof(em_iperf_edit_struct))
    {
        IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(ret)););
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_WRITE_TCP_FAILED);            
        return;
    }
}


/*****************************************************************************
* FUNCTION
*   em_iperf_read_file
* DESCRIPTION
*   read both TCP and UDP settings from file
* PARAMETERS
*   None.
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_read_file(void)
{
    
    FS_HANDLE   fd;
    kal_uint32  readbytes;
    kal_int32   ret;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_READ); 

    /*if occurs any file error, try to reload the default settings for both prots */
    
    fd = FS_Open((WCHAR*)IPERF_SETTING_FILE, FS_READ_ONLY);
    if(fd < 0)
    {
        IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(fd)););
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_READ_OPEN_FAILED);
        /* load default settings */
        em_iperf_load_default();
        return;
    }

    /* read TCP setting first */
    IPERF_DBG(kal_print("em_Iperf_read--- FS_Read_TCP_Setting!!! \n"););
    ret= FS_Read(fd, iperf_p->iperf_edit_tcp, sizeof(em_iperf_edit_struct), &readbytes);    
    if (ret != FS_NO_ERROR || readbytes != sizeof(em_iperf_edit_struct))
    {
        IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(ret)););
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_READ_TCP_FAILED);            
        /* load default settings */
        em_iperf_load_default();
        return;
    }
    /* read UDP setting */    
    IPERF_DBG(kal_print("em_Iperf_read--- FS_Read_UDP_Setting!!! \n"););
    ret= FS_Read(fd, iperf_p->iperf_edit_udp, sizeof(em_iperf_edit_struct), &readbytes);      
    FS_Close(fd);
    if (ret != FS_NO_ERROR || readbytes != sizeof(em_iperf_edit_struct))
    {
        IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(ret)););
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_READ_UDP_FAILED);            
        /* load default settings */
        em_iperf_load_default();
        return;
    }
    
}

/*****************************************************************************
* FUNCTION
*   em_iperf_load_default
* DESCRIPTION
*   load default setting to iperf_p and write default file
* PARAMETERS
*   None.
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_load_default(void)
{
    kal_uint8 Zero[4];
    kal_uint8 Port[10];    
    kal_uint8 Thousand[10];
    kal_uint8 Zero_ip[8];
    kal_uint8 Ten[9];
    FS_HANDLE   fd;
    kal_uint32  writtenbytes;
    kal_int32   ret;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_LOAD_DEFAULT);

    /* prepare default unicode string */
    mmi_asc_to_ucs2((S8*)Zero,(S8*)"0");
    mmi_asc_to_ucs2((S8*)Port,(S8*)"5001");
    mmi_asc_to_ucs2((S8*)Thousand,(S8*)"1000");
    mmi_asc_to_ucs2((S8*)Ten,(S8*)"10");
    mmi_asc_to_ucs2((S8*)Zero_ip,(S8*)"000");
        
    /* Data account id */
#ifdef __WIFI_SUPPORT__
    
    iperf_p->iperf_edit_tcp->account_id = 20; //WiFi id
    iperf_p->iperf_edit_udp->account_id = 20;
    
#else /* !__WIFI_SUPPORT__ */

    /* call data account api to get the first id of GPRS */
    iperf_p->iperf_edit_tcp->account_id = mmi_dtcnt_get_first_account_id(DATA_ACCOUNT_BEARER_GPRS);
    iperf_p->iperf_edit_udp->account_id = mmi_dtcnt_get_first_account_id(DATA_ACCOUNT_BEARER_GPRS);
    
#endif /* __WIFI_SUPPORT__ */
   

    /* Data account name using dt api */
    mmi_dtcnt_get_account_name((U8)iperf_p->iperf_edit_tcp->account_id, 
                                (S8*)iperf_p->iperf_edit_tcp->dt_acct_name, MAX_DATA_ACCOUNT_NAME_LEN);  
    mmi_dtcnt_get_account_name((U8)iperf_p->iperf_edit_udp->account_id, 
                                (S8*)iperf_p->iperf_edit_udp->dt_acct_name, MAX_DATA_ACCOUNT_NAME_LEN);  

    /* Faddr {000.000.000.000}*/
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->faddr_ip[0], (S8*)Zero_ip);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->faddr_ip[1], (S8*)Zero_ip);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->faddr_ip[2], (S8*)Zero_ip);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->faddr_ip[3], (S8*)Zero_ip);

    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->faddr_ip[0], (S8*)Zero_ip);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->faddr_ip[1], (S8*)Zero_ip);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->faddr_ip[2], (S8*)Zero_ip);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->faddr_ip[3], (S8*)Zero_ip);

    /* Len, Window/Buffer */
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->len, (S8*)Zero);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->len, (S8*)Zero);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->window, (S8*)Zero);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->window, (S8*)Zero);

    /* Port */
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->port, (S8*)Port);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->port, (S8*)Port);

    /* Num, Time */
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->num, (S8*)Thousand);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->num, (S8*)Thousand);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->time, (S8*)Ten);
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->time, (S8*)Ten);

    /* TCP MSS, UDP Bandwidth */
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_tcp->mss, (S8*)Zero);        
    mmi_ucs2cpy((S8*)iperf_p->iperf_edit_udp->bandwidth, (S8*)Thousand);
    
    IPERF_DBG(kal_print("em_iperf_load_default_complete!!! \n"););
    
    /* Save settings */
    fd = FS_Open((WCHAR*)IPERF_SETTING_FILE, FS_READ_WRITE | FS_CREATE);
    if(fd < 0)
    {
        IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(fd)););
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_SAVE_OPEN_FAILED);
        return;
    }
    /* Save TCP settings */
    ret= FS_Write(fd, iperf_p->iperf_edit_tcp, sizeof(em_iperf_edit_struct), &writtenbytes);      
    if (ret != FS_NO_ERROR || writtenbytes != sizeof(em_iperf_edit_struct))
    {
        IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(ret)););
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_WRITE_TCP_FAILED);
        return;
    }
    /* Save UDP settings */
    ret= FS_Write(fd, iperf_p->iperf_edit_udp, sizeof(em_iperf_edit_struct), &writtenbytes);      
    FS_Close(fd);
    if (ret != FS_NO_ERROR || writtenbytes != sizeof(em_iperf_edit_struct))
    {
        IPERF_DBG(kal_print("s%\n",(U16)GetFileSystemErrorString(ret)););
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_WRITE_UDP_FAILED);
        return;
    }
    IPERF_DBG(kal_print("em_Iperf_save_default_file_complete!!! \n"););
}


#define Iperf_PS

/*****************************************************************************
* FUNCTION
*   em_iperf_send_req
* DESCRIPTION
*   send req to iperf task 
* PARAMETERS
*   None.
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_send_req(void)
{
    MYQUEUE    Message; 
    mmi_iperf_run_req_struct* req;
    em_iperf_edit_struct* act;
    U8 temp_ip[4] = {0,0,0,0};
    
    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_SEND_REQ);         

    req = (mmi_iperf_run_req_struct*)OslConstructDataPtr(sizeof(mmi_iperf_run_req_struct));

	/* Memory initialize */
	IPERF_MEMSET(req);

    /* outstanding cur_job_id switches between 0 and 1 */
    req->job_id = (++iperf_cur_job_id) % 2;
    
    /* set prots related data */
    
    /* default TCP Testing*/
    act = iperf_p->iperf_edit_tcp;
    
    /* TCP Testing */
    if(iperf_p->iperf_misc->prot == TCP)
    {
    	req->udp = 0;   
    	req->mss = (S32)gui_atoi(act->mss);
    	IPERF_DBG(kal_print("TCP MSS: %u\n",req->mss););	
  	}
    
    /* change pointer for UDP Testing */
    if(iperf_p->iperf_misc->prot == UDP)
    {
        act = iperf_p->iperf_edit_udp;
        req->udp = 1;   //udp
        req->bandwidth  = (U32)gui_atoi(act->bandwidth);
        req->bandwidth  *= 1000;    //kbps -> bps
        IPERF_DBG(kal_print("UDP Bandwidth: %u\n",req->bandwidth););
    }
    
    /* account id */
    req->account_id = act->account_id;

    /* client/server */
    if(act->client_server == 0)
    {
        req->client = 1;
        req->server = 0;           
    }
    if(act->client_server == 1)
    {
        req->client = 0;
        req->server = 1;           
    }

    /* fadder */
    // unicode -> int
    temp_ip[0] = (U8)gui_atoi(act->faddr_ip[0]);
    temp_ip[1] = (U8)gui_atoi(act->faddr_ip[1]); 
    temp_ip[2] = (U8)gui_atoi(act->faddr_ip[2]);
    temp_ip[3] = (U8)gui_atoi(act->faddr_ip[3]);
    // reassemble faddr
    req->faddr = (temp_ip[0]) << 24 |
                 (temp_ip[1]) << 16 |
                 (temp_ip[2]) <<  8 |
                 (temp_ip[3]);
    IPERF_DBG(kal_print("faddr(host): %u\n",req->faddr););
    // host to network layer address transfer
    req->faddr = htonl(req->faddr);
    IPERF_DBG(kal_print("faddr(nl): %u\n",req->faddr););


    /*len, port, window, num, time*/    
    req->len    = (U32)gui_atoi(act->len);
    req->port   = (U16)gui_atoi(act->port);
    req->window = (S32)gui_atoi(act->window);
    req->num    = (U32)gui_atoi(act->num);
    req->time   = (U32)gui_atoi(act->time);
    IPERF_DBG(kal_print("num: %u\n",req->num););
    IPERF_DBG(kal_print("time: %u\n",req->time););

    /* dualtest */
    if(act->dualtest == 0)
        req->dual = 0;
    if(act->dualtest == 1)
        req->dual = 1;
   
    /* tos */
    switch(act->tos)
    {
        case 0:
            req->tos = BEST_EFFORT;
            IPERF_DBG(kal_print("ToS_BE: %u\n",act->tos););
            break;
        case 1:
            req->tos = BACK_GROUND;
            IPERF_DBG(kal_print("ToS_BG: %u\n",act->tos););
            break;
        case 2:
            req->tos = VIDEO;
            IPERF_DBG(kal_print("ToS_VI: %u\n",act->tos););
            break;
        case 3:
            req->tos = VOICE;
            IPERF_DBG(kal_print("ToS_VO: %u\n",act->tos););
            break;
        default:
            //mine assert (should never happens)
            MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_SEND_REQ_TOS);                     
            IPERF_DBG(kal_print("ToS_DE: %u\n",act->tos););
    }
    
    /* RW File */
    if (act->rw_file == 0)
        req->rw_file = KAL_FALSE;
    else if (act->rw_file == 1)
        req->rw_file = KAL_TRUE;
    
    IPERF_DBG(kal_print("em_iperf_fill_req_complete!!! \n"););

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_SEND_REQ_ILM);                     
    Message.oslSrcId = MOD_MMI;	
    Message.oslDestId = MOD_IPERF;
    Message.oslSapId = IPERF_MMI_SAP;
    Message.oslMsgId = MSG_ID_MMI_IPERF_RUN_REQ;
    Message.oslDataPtr = (oslParaType *)req;
    Message.oslPeerBuffPtr = NULL;

    
    /* set protocol event handler to handle run_cnf msg and report_ind msg */
    SetProtocolEventHandler(em_iperf_run_cnf_hf, MSG_ID_MMI_IPERF_RUN_CNF);
    SetProtocolEventHandler(em_iperf_report_ind_hf, MSG_ID_MMI_IPERF_REPORT_IND);


    /* Send Message to iperf task */ 
    IPERF_DBG(kal_print("em_iperf_send_req!!! \n"););
    OslMsgSendExtQueue(&Message);
    IPERF_DBG(kal_print("em_iperf_send_req_complete!!! \n"););

    /* save settings to file */
    em_iperf_save();
    
}


/*****************************************************************************
* FUNCTION
*   em_iperf_run_cnf_hf
* DESCRIPTION
*   Handler for MSG_ID_MMI_IPERF_RUN_CNF.
* PARAMETERS
*   msg IN  result of confirm
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_run_cnf_hf(void* msg)
{
    mmi_iperf_run_cnf_struct* cnf = (mmi_iperf_run_cnf_struct*)msg;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_RUN_CNF_HF);         

    /* clear protocol event handler */
    ClearProtocolEventHandler(MSG_ID_MMI_IPERF_RUN_CNF);

    /* confirm fail*/
    if(cnf->result == 0)
    {
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_RUN_CNF_HF_FALSE);         
    
        /* clear protocol event handler */
        ClearProtocolEventHandler(MSG_ID_MMI_IPERF_REPORT_IND);

        /* show fail popup */
        em_iperf_disp_fail_popup(EM_SOCKET_IPERF_CNF_FAILED_ERR_STR);
       
        /* delete progressing screen */
        DeleteNHistory(1);
    }
    
}


/*****************************************************************************
* FUNCTION
*   em_iperf_report_ind_hf
* DESCRIPTION
*   Handler for MSG_ID_MMI_IPERF_REPORT_IND.
* PARAMETERS
*   msg IN  result of indication
* RETURNS
*   None.
* GLOBALS AFFECTED
*   None.
*****************************************************************************/
void em_iperf_report_ind_hf(void* msg)
{
    mmi_iperf_report_ind_struct* ind = (mmi_iperf_report_ind_struct*)msg;

    MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_REPORT_IND_HF);       
     
    /* clear protocol event handler */
    ClearProtocolEventHandler(MSG_ID_MMI_IPERF_REPORT_IND);

    /* report fail */
    if(ind->result == 0)
    {
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_REPORT_IND_HF_FALSE);       
        
        /* show fail popup */
        em_iperf_disp_fail_popup(EM_SOCKET_IPERF_TEST_FAILED_ERR_STR);
       
        /*delete progressing screen*/
        DeleteNHistory(1);
    }
    else
    {
        MMI_TRACE(MMI_TRACE_FUNC,MMI_IPERF_ENTRY_REPORT_SCREEN);       

        /* show report screen and delete progressing screen */
        /* allocated memory for showing report */
        if(iperf_p->iperf_report== NULL)
        {
          iperf_p->iperf_report = (em_iperf_report_struct*)OslMalloc(sizeof(em_iperf_report_struct));
          memset(iperf_p->iperf_report, 0, sizeof(em_iperf_report_struct));
        }
        /* prepare report buffer */
        if(ind->prot == TCP)
        {
            #define _p1 "Prot : TCP\n"
            #define _i "Interval(secs) : %.1f\n"
            #define _tx "Transfer: %4.1f %s\n"
            #define _th "Thrpt : %6.3f %s\n"
            #define _s "Size : %u\n"
            sprintf((S8*)iperf_p->iperf_report->report_buff, _p1 _i _tx _th _s, 
                ind->interval,
                ind->transfer > 1000000 ? ind->transfer/1000000.0 :
                ind->transfer > 1000 ? ind->transfer/1000.0 : ind->transfer,
                ind->transfer > 1000000 ? "MBytes" : ind->transfer > 1000 ? "KBytes" : "Bytes",            
                ind->thruput > 1000000 ? ind->thruput/1000000 :
                ind->thruput > 1000 ? ind->thruput/1000 : ind->thruput,
                ind->thruput > 1000000 ? "Mbps" : ind->thruput > 1000 ? "Kbps" : "bps",
                ind->size);

        }
        else /* UDP */
        {
            #define _p2 "Prot : UDP\n"
            #define _d "Datagram Size : %u\n"
            #define _j "Jitter : %5.3f ms\n"           
            #define _l "Lost pkt : %4d\n"
            #define _t "Total pkt : %5d\n"
            #define _r "Loss Rate : %.2f%%"

            sprintf((S8*)iperf_p->iperf_report->report_buff, _p2 _i _tx _th _s _d _j _l _t _r,
                ind->interval,
                ind->transfer > 1000000 ? ind->transfer/1000000.0 :
                ind->transfer > 1000 ? ind->transfer/1000.0 : ind->transfer,
                ind->transfer > 1000000 ? "MBytes" : ind->transfer > 1000 ? "KBytes" : "Bytes",            
                ind->thruput > 1000000 ? ind->thruput/1000000 :
                ind->thruput > 1000 ? ind->thruput/1000 : ind->thruput,
                ind->thruput > 1000000 ? "Mbps" : ind->thruput > 1000 ? "Kbps" : "bps",
                ind->size,
                ind->datagram_size,
                ind->jitter,
                ind->lost_pkt,
                ind->total_pkt,
                ind->loss_rate);
        }

        /* prepare UI buffer */
        mmi_asc_to_ucs2((S8*)iperf_p->iperf_report->report_UI_buffer, (S8*)iperf_p->iperf_report->report_buff);

        /* call report screen entry function */
        EntryEmIperfReport();

    }

}

#endif /* __IPERF__ */
/* END OF IPERF */

#endif /* __TCPIP__ */ 

/*****************************************************************************
*
* TV-Out Tunning
*
*****************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_hint_switch
 * DESCRIPTION
 *  hint tvout menu item
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_hint_switch(U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset((PS8) hintData[(index)], 0, sizeof(hintData[(index)]));

    if (gIsTVOut)
    {
        mmi_ucs2cpy((S8*) hintData[index], (S8*) GetString(STR_GLOBAL_ON));
    }
    else
    {
        mmi_ucs2cpy((S8*) hintData[index], (S8*) GetString(STR_GLOBAL_OFF));
    }
}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_init
 * DESCRIPTION
 *  init tvout tunning
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_em_tvout_cntx.true_false_str[0] = (UI_string_type) GetString((U16) (STR_GLOBAL_OFF));
    g_em_tvout_cntx.true_false_str[1] = (UI_string_type) GetString((U16) (STR_GLOBAL_ON));

    g_em_tvout_cntx.group_idx = 0;

    /* TODO: get from driver */
    g_em_tvout_cntx.group_count = 2;
}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_entry_setting_scr
 * DESCRIPTION
 *  entry tvout setting screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_entry_setting_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 item_list[16];
    U16 item_icons[16];
    U16 num_item;
    U8 *gui_buffer;
    U8 *popup_list[16];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_EM_TVOUT_SETTING, NULL, mmi_em_tvout_entry_setting_scr, NULL);

    gui_buffer = GetCurrGuiBuffer(SCR_ID_EM_TVOUT_SETTING);
    num_item = GetNumOfChild(EM_DEV_TVOUT_SETTING_MENUID);

    GetSequenceStringIds(EM_DEV_TVOUT_SETTING_MENUID, item_list);
    GetSequenceImageIds(EM_DEV_TVOUT_SETTING_MENUID, item_icons);
    SetParentHandler(EM_DEV_TVOUT_SETTING_MENUID);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < num_item; i++)
    {
        item_icons[i] = (U16) (IMG_GLOBAL_L1 + i);
    }

    for (i = 0; i < num_item; i++)
    {
        popup_list[i] = NULL;
    }

    ConstructHintsList(EM_DEV_TVOUT_SETTING_MENUID, popup_list);

    ShowCategory52Screen(
        EM_DEV_TVOUT_SETTING_TEXT,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        num_item,
        item_list,
        item_icons,
        (U8 **) popup_list,
        0,
        0,
        gui_buffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
#ifdef __MMI_FOURWAYS_KEY_DISABLE__
    SetKeyHandler(GoBackHistory, KEY_VOL_DOWN, KEY_EVENT_DOWN);
#endif 

}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_highlight_setting
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_highlight_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_em_tvout_entry_setting_scr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    SetKeyHandler(mmi_em_tvout_entry_setting_scr, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
#ifdef __MMI_FOURWAYS_KEY_DISABLE__
    SetKeyHandler(mmi_em_tvout_entry_setting_scr, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(GoBackHistory, KEY_VOL_DOWN, KEY_EVENT_DOWN);
#endif /* __MMI_FOURWAYS_KEY_DISABLE__ */ 

}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_highlight_switch
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_highlight_switch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_em_tvout_switch_on_off, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    if (gIsTVOut)
    {
        change_left_softkey(STR_GLOBAL_OFF, 0);
    }
    else
    {
        change_left_softkey(STR_GLOBAL_ON, 0);
    }

}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_switch_on_off
 * DESCRIPTION
 *  switch tvout on/off
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_switch_on_off(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gIsTVOut)
    {
        ChangeLeftSoftkey(STR_GLOBAL_ON, 0);
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_OFF));

        /* turn off */
        mmi_phnset_tvout_event_hdlr(MDI_RES_TV_DISABLE);
        gIsTVOut = FALSE;
    }
    else
    {
        ChangeLeftSoftkey(STR_GLOBAL_OFF, 0);
        Category52ChangeItemDescription(GetCurrHiliteID(), (U8*) get_string(STR_GLOBAL_ON));

        /* turn on */
        mdi_tvout_force_init();
        mmi_phnset_tvout_event_hdlr(MDI_RES_TV_ENABLE);
        gIsTVOut = TRUE;
    }

    /* Redraw */
    RedrawCategoryFunction();

}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_highlight_tunning
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_highlight_tunning(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_em_tvout_entry_tunning_scr, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    SetKeyHandler(mmi_em_tvout_entry_tunning_scr, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
#ifdef __MMI_FOURWAYS_KEY_DISABLE__
    SetKeyHandler(mmi_em_tvout_entry_tunning_scr, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(GoBackHistory, KEY_VOL_DOWN, KEY_EVENT_DOWN);
#endif /* __MMI_FOURWAYS_KEY_DISABLE__ */ 

}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_entry_tunning_scr
 * DESCRIPTION
 *  entry tvout tunning screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_entry_tunning_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 gui_buffer;
    S32 i;
    S32 item_id;
    S32 buffer_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_ID_EM_TVOUT_SETTING_TUNNING, mmi_em_tvout_exit_tunning_scr, NULL, NULL);

    /* pause TVOUT from MMI */
    /* driver will re-active it with 640x480 size */
    /* we allocate a 640x480x1.5(1.5 for YUV) buffer from media task */
    if (mdi_tvout_is_enable())
    {
        g_em_tvout_cntx.is_tvout_enable = TRUE;
        mdi_tvout_pause_for_em_mode();
    }
    else
    {
        g_em_tvout_cntx.is_tvout_enable = FALSE;
    }

    buffer_size = (720 * 576) * 2;  /* 720*576*rgb */
    media_get_ext_buffer(MOD_MMI, (void **)&g_em_tvout_cntx.tvout_buf_p, buffer_size);

    /* check if buffer is valid */
    ASSERT(g_em_tvout_cntx.tvout_buf_p);

    /* notify driver to enter tvout eng mode, to draw testing patten */
    enter_tv_engmode((kal_uint32) g_em_tvout_cntx.tvout_buf_p);

    gui_buffer = GetCurrGuiBuffer(SCR_ID_EM_TVOUT_SETTING_TUNNING);

    InitializeCategory57Screen();

    /* load group info first */
    mmi_em_tvout_get_group_info(g_em_tvout_cntx.group_idx);

    item_id = 0;

    for (i = 0; i < g_em_tvout_cntx.group_data.item_count; i++)
    {
        SetInlineItemCaption(&wgui_inline_items[item_id++], (PU8) g_em_tvout_cntx.group_data.items[i].name_buf);

        if (g_em_tvout_cntx.group_data.items[i].is_read_only)
        {
            /* read only, cant modify */
            SetInlineItemActivation(&wgui_inline_items[item_id], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemDisplayOnly(
                &wgui_inline_items[item_id++],
                (PU8) g_em_tvout_cntx.group_data.items[i].digit_buf);
        }
        else
        {
            if (g_em_tvout_cntx.group_data.items[i].is_true_false)
            {
                SetInlineItemActivation(&wgui_inline_items[item_id], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
                SetInlineItemSelect(
                    &wgui_inline_items[item_id++],
                    2,
                    (U8 **) g_em_tvout_cntx.true_false_str,
                    &g_em_tvout_cntx.group_data.items[i].value);
            }
            else
            {
                SetInlineItemActivation(&wgui_inline_items[item_id], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
                SetInlineItemTextEdit(
                    &wgui_inline_items[item_id],
                    (PU8) g_em_tvout_cntx.group_data.items[i].digit_buf,
                    MMI_EM_TVOUT_ITEM_DIG_BUF_LEN,
                    INPUT_TYPE_NUMERIC);
                DisableInlineItemHighlight(&wgui_inline_items[item_id++]);
            }

        }
    }

    RegisterHighlightHandler(mmi_em_tvout_tunning_highlight_hdlr);

    ShowCategory57Screen(
        EM_DEV_TVOUT_SETTING_TUNNING_TEXT,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        g_em_tvout_cntx.group_data.item_count * 2,  /* num of items *//* 2 line per item */
        NULL,                                       /* icon list */
        wgui_inline_items,                          /* inline data */
        g_em_tvout_cntx.hilight_idx,                /* highlight idx */
        NULL);

    /* set key hdlr */
    SetCategory57RightSoftkeyFunctions(GoBackHistory, GoBackHistory);
    set_left_softkey_function(mmi_em_tvout_tunning_set_value, KEY_EVENT_UP);
    DisableCategory57ScreenDone();
}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_exit_tunning_scr
 * DESCRIPTION
 *  exit tunning screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_exit_tunning_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 input_buffer_size;
    history h;
    S16 n_history = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = SCR_ID_EM_TVOUT_SETTING_TUNNING;
    CloseCategory57Screen();
    h.entryFuncPtr = mmi_em_tvout_entry_tunning_scr;
    mmi_ucs2cpy((S8*) h.inputBuffer, (S8*) & n_history);
    GetCategory57History(h.guiBuffer);
    input_buffer_size = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) h.inputBuffer);
    AddNHistory(h, input_buffer_size);

    /* notify driver to exit eng mode */
    exit_tv_engmode();

    /* free buffer */
    media_free_ext_buffer(MOD_MMI, (void **)&g_em_tvout_cntx.tvout_buf_p);
    g_em_tvout_cntx.tvout_buf_p = NULL;

    if (g_em_tvout_cntx.is_tvout_enable)
    {
        /* start mode1 */
        mdi_tvout_set_mode(
            MDI_TV_MODE_LCD_SCR,
            0,  /* layer_width - not used */
            0); /* layer_height - not used */

        mdi_tvout_force_init();
        mdi_tvout_resume_for_em_mode();
    }
}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_tunning_set_value
 * DESCRIPTION
 *  set value to driver
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_tunning_set_value(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 value;
    S32 index;
    S32 max, min;
    S8 buffer[128];
    S8 uni_buffer[256];
    S8 disp_buffer[256];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* convert digit string to value */
    index = g_em_tvout_cntx.hilight_idx / 2;    /* 2 line per item */
    min = g_em_tvout_cntx.group_data.items[index].min_value;
    max = g_em_tvout_cntx.group_data.items[index].max_value;

    /* stop preview. if need to restart preview when apply setting */
    if (g_em_tvout_cntx.group_data.items[index].is_need_restart)
    {
        /* not support */
    }

    /* flush inline edit buffer to app's buffer */
    wgui_update_inline_data();

    /* if not ture false item, need convert from string to digit */
    if (!g_em_tvout_cntx.group_data.items[index].is_true_false)
    {
        value = gui_atoi((UI_string_type) g_em_tvout_cntx.group_data.items[index].digit_buf);

        /* value changed, set to driver */
        if ((value > max) || (value < min))
        {
            sprintf(buffer, "%d-%d", min, max);
            mmi_asc_to_ucs2(uni_buffer, buffer);
            mmi_ucs2cpy(disp_buffer, (PS8) (L"Out of range\n\n"));
            mmi_ucs2cat(disp_buffer, g_em_tvout_cntx.group_data.items[index].name_buf);
            mmi_ucs2cat(disp_buffer, (PS8) (L"\n"));
            mmi_ucs2cat(disp_buffer, uni_buffer);

            DisplayPopup((PU8) disp_buffer, 0, 1, 2000, WARNING_TONE);
            return;
        }

        g_em_tvout_cntx.group_data.items[index].value = value;

    }

    /* Set update data to driver */
    set_tv_engmode_item_value((kal_uint8) index, (kal_uint16) g_em_tvout_cntx.group_data.items[index].value);

    /* re-start, if need to restart preview when apply setting */
    if (g_em_tvout_cntx.group_data.items[index].is_need_restart)
    {
        /* not support */
    }

    /* DisplayPopup((PU8)GetString(STR_GLOBAL_ACTIVATE), 0, 1, 2000, WARNING_TONE); */
    return;
}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_tunning_highlight_hdlr
 * DESCRIPTION
 *  set highlight handler
 * PARAMETERS
 *  index       [IN]        Hilight handler
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_tunning_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_em_tvout_cntx.hilight_idx = index;

    /* hook key from cat57 */
    set_left_softkey_function(mmi_em_tvout_tunning_set_value, KEY_EVENT_UP);
    set_right_softkey_function(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(mmi_em_tvout_tunning_toggle_group, KEY_STAR, KEY_EVENT_UP);
}
#endif /* defined(__MMI_TVOUT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_tunning_toggle_group
 * DESCRIPTION
 *  toggle group, change to next group
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_tunning_toggle_group(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_em_tvout_cntx.group_count == 1)
    {
        return;
    }

    if (g_em_tvout_cntx.group_idx < g_em_tvout_cntx.group_count - 1)
    {
        g_em_tvout_cntx.group_idx++;
    }
    else
    {
        /* loop back */
        g_em_tvout_cntx.group_idx = 0;
    }

    EntryNewScreen(SCR_ID_EM_TVOUT_SETTING_TUNNING, NULL, NULL, NULL);
    DeleteScreenIfPresent(SCR_ID_EM_TVOUT_SETTING_TUNNING);

    mmi_em_tvout_entry_tunning_scr();
}
#endif /* defined(__MMI_TVOUT__) */ /* __FM_CAMERA_TUNNING__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_em_tvout_get_group_info
 * DESCRIPTION
 *  get group's info
 * PARAMETERS
 *  group_index     [IN]        Index
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_TVOUT__)
static void mmi_em_tvout_get_group_info(S32 group_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    S8 buffer[MMI_EM_TVOUT_ITEM_NAME_BUF_LEN];

    tv_engmode_info tvout_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get item count */
    g_em_tvout_cntx.group_data.item_count = get_tv_engmode_item_count();

    g_em_tvout_cntx.group_data.item_idx = 0;

    /* get item info */
    for (i = 0; i < g_em_tvout_cntx.group_data.item_count; i++)
    {
        tvout_info.current_value = 0;
        tvout_info.min_value = 0;
        tvout_info.min_value = 0;

        memset((void*)&g_em_tvout_cntx.group_data.items[i], 0, sizeof(mmi_em_tvout_item_struct));

        get_tv_engmode_item_info(
            (kal_uint8) i,          /* index */
            (kal_uint8*) buffer,    /* name buffer */
            &tvout_info);           /* info */

        mmi_asc_to_ucs2((PS8) g_em_tvout_cntx.group_data.items[i].name_buf, (PS8) buffer);

        /* set item name */
        g_em_tvout_cntx.group_data.items[i].name_buf[MMI_EM_TVOUT_ITEM_NAME_BUF_LEN - 2] = '0';
        g_em_tvout_cntx.group_data.items[i].name_buf[MMI_EM_TVOUT_ITEM_NAME_BUF_LEN - 1] = '0';

        g_em_tvout_cntx.group_data.items[i].is_true_false = FALSE;
        g_em_tvout_cntx.group_data.items[i].is_read_only = FALSE;
        g_em_tvout_cntx.group_data.items[i].is_need_restart = FALSE;
        g_em_tvout_cntx.group_data.items[i].value = tvout_info.current_value;
        g_em_tvout_cntx.group_data.items[i].min_value = tvout_info.min_value;
        g_em_tvout_cntx.group_data.items[i].max_value = tvout_info.max_value;

        /* conver from value to digit */
        gui_itoa(
            g_em_tvout_cntx.group_data.items[i].value,
            (UI_string_type) g_em_tvout_cntx.group_data.items[i].digit_buf,
            10);
    }
}

#endif /* defined(__MMI_TVOUT__) */ /* __FM_CAMERA_TUNNING__ */

#if defined(__VOIP__)
/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmVOIP, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmVOIP
**
** 	PURPOSE				: Enrty function for VOIP menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmVOIP(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ItemList[32];
    U16 ItemIcons[32];
    U16 nItems;
    U8 *guiBuffer;
    U8 *PopUpList[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_VOIP_SCR_ID, NULL, EntryEmVOIP, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_VOIP_SCR_ID);

    nItems = GetNumOfChild(EM_VOIP_MENNUID);
    GetSequenceStringIds(EM_VOIP_MENNUID, ItemList);
    SetParentHandler(EM_VOIP_MENNUID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < nItems; i++)
    {
        PopUpList[i] = NULL;
        ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);   
    }

    ShowCategory52Screen(
        EM_VOIP_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        nItems,
        ItemList,
        ItemIcons,
        (U8 **) PopUpList,
        0,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIPSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmVOIPSetting, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/**************************************************************
**	FUNCTION NAME		: EntryEmVOIPSetting
**
** 	PURPOSE				: Enrty function for VOIP Settings menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmVOIPSetting(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* guiBuffer;
    U16 ImageList[20];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_VOIP_SETTINGS_SCR_ID, ExitEmVOIPSettingScreen, NULL, NULL);
    InitializeCategory57Screen();

	EmGetVOIPSettingInfo();
	
    guiBuffer = GetCurrGuiBuffer(EM_VOIP_SETTINGS_SCR_ID);

    RegisterHighlightHandler(HighlightHdlrVOIPSettingsInline);

    /* Peer to Peer Call */
    SetInlineItemActivation(&wgui_inline_items[0], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(EM_VOIP_P2P_CALL_TEXT));
    ImageList[0] = IMG_STATUS;

    g_em_voip_cntx.pEMVOIPP2PCall[0] = (U8*)GetString(STR_GLOBAL_OFF);
    g_em_voip_cntx.pEMVOIPP2PCall[1] = (U8*)GetString(STR_GLOBAL_ON);
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[1], 2, (U8**)g_em_voip_cntx.pEMVOIPP2PCall, &g_em_voip_cntx.currP2Pcall);    
    ImageList[1] = 0;

    /* Re-register Timer */
    SetInlineItemActivation(&wgui_inline_items[2], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(EM_VOIP_REREGISTER_TIMER_TEXT));
    ImageList[2] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[3], (PU8)g_em_voip_cntx.reregister_timer, 6, INPUT_TYPE_NUMERIC);
    ImageList[3] = 0;

    /* Call Refresh Timer */
    SetInlineItemActivation(&wgui_inline_items[4], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_VOIP_CALL_REFRESH_TIMER_TEXT));
    ImageList[4] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[5], (PU8)g_em_voip_cntx.call_refresh_timer, 6, INPUT_TYPE_NUMERIC);
    ImageList[5] = 0;

    /* Refer Subcribe Timer */
    SetInlineItemActivation(&wgui_inline_items[6], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[6], (U8*)GetString(EM_VOIP_REFER_SUB_TIMER_TEXT));
    ImageList[6] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[7], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[7], (PU8)g_em_voip_cntx.refer_sub_timer, 6, INPUT_TYPE_NUMERIC);
    ImageList[7] = 0;

    /* MWI Subscribe Timer */
    SetInlineItemActivation(&wgui_inline_items[8], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[8], (U8*)GetString(EM_VOIP_MWI_SUB_TIMER_TEXT));
    ImageList[8] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[9], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[9], (PU8)g_em_voip_cntx.mwi_sub_timer, 6, INPUT_TYPE_NUMERIC);
    ImageList[9] = 0;    

    /* MWI Retry Time */
    SetInlineItemActivation(&wgui_inline_items[10], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[10], (U8*)GetString(EM_VOIP_MWI_SUB_TIMER_TEXT));
    ImageList[10] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[11], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTextEdit(&wgui_inline_items[11], (PU8)g_em_voip_cntx.mwi_retry_time, 3, INPUT_TYPE_NUMERIC);
    ImageList[11] = 0;

    /* UAS Refresher */
    SetInlineItemActivation(&wgui_inline_items[12], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[12], (U8*)GetString(EM_VOIP_UAS_Refresher_TEXT));
    ImageList[12] = IMG_STATUS;

    g_em_voip_cntx.pEMVOIPUASRefresher[0] = (U8*)GetString(EM_VOIP_UAC_TEXT);
    g_em_voip_cntx.pEMVOIPUASRefresher[1] = (U8*)GetString(EM_VOIP_UAS_TEXT);
    SetInlineItemActivation(&wgui_inline_items[13], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[13], 2, (U8**)g_em_voip_cntx.pEMVOIPUASRefresher, &g_em_voip_cntx.currUASRefresher);    
    ImageList[13] = 0;

    /* UAC Refresher */
    SetInlineItemActivation(&wgui_inline_items[14], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[14], (U8*)GetString(EM_VOIP_UAC_Refresher_TEXT));
    ImageList[14] = IMG_STATUS;

    SetInlineItemActivation(&wgui_inline_items[15], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[15], 2, (U8**)g_em_voip_cntx.pEMVOIPUASRefresher, &g_em_voip_cntx.currUACRefresher);    
    ImageList[15] = 0;

    /* RPORT Support */
    SetInlineItemActivation(&wgui_inline_items[16], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[16], (U8*)GetString(EM_VOIP_RPORT_SUPPORT_TEXT));
    ImageList[16] = IMG_STATUS;

    g_em_voip_cntx.pEMVOIPRportSupport[0] = (U8*)GetString(STR_GLOBAL_OFF);
    g_em_voip_cntx.pEMVOIPRportSupport[1] = (U8*)GetString(STR_GLOBAL_ON);
    SetInlineItemActivation(&wgui_inline_items[17], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(&wgui_inline_items[17], 2, (U8**)g_em_voip_cntx.pEMVOIPRportSupport, &g_em_voip_cntx.currRPortSupport);    
    ImageList[17] = 0;

    /* Local Address */
    SetInlineItemActivation(&wgui_inline_items[18], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemCaption(&wgui_inline_items[18], (U8*)GetString(EM_VOIP_LOCAL_ADDR_TEXT));
    ImageList[18] = IMG_STATUS;
       
    SetInlineItemActivation(&wgui_inline_items[19], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDisplayOnly(&wgui_inline_items[19], g_em_voip_cntx.EMVOIPLocalAddr);
    ImageList[19] = 0;    
    
    DisableCategory57ScreenDone();
     	
    ShowCategory57Screen(EM_VOIP_SETTINGS_TEXT, 0, 
                         STR_GLOBAL_OK, 
                         IMG_GLOBAL_OK, 
                         STR_GLOBAL_BACK, 
                         IMG_GLOBAL_BACK,
 	                     20, ImageList, wgui_inline_items, 0, guiBuffer);	
      
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );

}


/**************************************************************

	FUNCTION NAME		: EmGetVOIPSettingInfo()

  	PURPOSE				: To get VOIP Setting information.

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EmGetVOIPSettingInfo(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 value;
    S8 buffer[30];    
    U8 addr[4];
    U16 port;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Peer to Peer Call */
    g_em_voip_cntx.currP2Pcall = voip_custom_get_p2p_call_state();

    /* Re-register Timer */
    value = voip_custom_get_reregister_timer();
    sprintf(buffer,"%d", value);
    mmi_asc_to_ucs2((PS8)g_em_voip_cntx.reregister_timer, buffer);
    
    /* Call Refresh Timer */
    value = voip_custom_get_call_refresh_timer();
    sprintf(buffer,"%d", value);
    mmi_asc_to_ucs2((PS8)g_em_voip_cntx.call_refresh_timer, buffer);

    /* Refer Subcribe Timer */
    value = voip_custom_get_refer_sub_timer();
    sprintf(buffer,"%d", value);
    mmi_asc_to_ucs2((PS8)g_em_voip_cntx.refer_sub_timer, buffer);
    
    /* MWI Subscribe Timer */
    value = voip_custom_get_mwi_sub_timer();
    sprintf(buffer,"%d", value);
    mmi_asc_to_ucs2((PS8)g_em_voip_cntx.mwi_sub_timer, buffer);

    /* MWI Retry Time */
    value = voip_custom_get_mwi_retry_times();
    if (value > 99)
    {
        value = 99;
    }    
    sprintf(buffer,"%d", value);
    mmi_asc_to_ucs2((PS8)g_em_voip_cntx.mwi_retry_time, buffer);

    /* UAS Refresher */
    value = voip_custom_get_uas_call_refresher();
    g_em_voip_cntx.currUASRefresher = value;

    /* UAC Refresher */
    value = voip_custom_get_uac_call_refresher();
    g_em_voip_cntx.currUACRefresher = value;

    /* RPort Support */
    value = voip_custom_get_rport_support();
    g_em_voip_cntx.currRPortSupport = value;

    /* Local Address */
    voip_custom_get_local_addr(addr, &port);
    sprintf(buffer,"%d.%d.%d.%d:%d", addr[0], addr[1], addr[2], addr[3], port);
    mmi_asc_to_ucs2((PS8)g_em_voip_cntx.EMVOIPLocalAddr, buffer);

}    


/**************************************************************

	FUNCTION NAME		: ExitEmVOIPSettingScreen()

  	PURPOSE				: Exit Em VOIP Setting inline edit screen

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void ExitEmVOIPSettingScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
}


/**************************************************************

	FUNCTION NAME		: HighlightHdlrVOIPSettingsInline()

  	PURPOSE				: VOIP Settings inline highlight handler

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void HighlightHdlrVOIPSettingsInline(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(EmSetVOIPSettingInfo, KEY_EVENT_UP);
}


/**************************************************************

	FUNCTION NAME		: EmSetVOIPSettingInfo()

  	PURPOSE				: To set VOIP Settings information.

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void EmSetVOIPSettingInfo(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 value;
    S8 buffer[30];    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
    
    /* To check input data is not NULL */
    if (!mmi_ucs2strlen((const S8*)g_em_voip_cntx.reregister_timer)
           ||  !mmi_ucs2strlen((const S8*)g_em_voip_cntx.call_refresh_timer)
           ||  !mmi_ucs2strlen((const S8*)g_em_voip_cntx.refer_sub_timer)
           ||  !mmi_ucs2strlen((const S8*)g_em_voip_cntx.mwi_sub_timer)
           ||  !mmi_ucs2strlen((const S8*)g_em_voip_cntx.mwi_retry_time))
    {
        DisplayPopup((PU8)GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_ERROR, 0, EM_NOTIFY_DURATION, 0);
        return;
    }
    
    /* Peer to Peer Call */
    if (g_em_voip_cntx.currP2Pcall)
    {
        voip_custom_set_p2p_call_state(MMI_TRUE);
    }
    else
    {
        voip_custom_set_p2p_call_state(MMI_FALSE);
    }
    
    /* Re-register Timer */
    mmi_ucs2_to_asc((PS8)buffer, (PS8)g_em_voip_cntx.reregister_timer);
    value = atoi((const char *) buffer);
    voip_custom_set_reregister_timer(value);
    
    /* Call Refresh Timer */
    mmi_ucs2_to_asc((PS8)buffer, (PS8)g_em_voip_cntx.call_refresh_timer);
    value = atoi((const char *) buffer);    
    voip_custom_set_call_refresh_timer(value);

    /* Refer Subcribe Timer */
    mmi_ucs2_to_asc((PS8)buffer, (PS8)g_em_voip_cntx.refer_sub_timer);
    value = atoi((const char *) buffer);        
    voip_custom_set_refer_sub_timer(value);
    
    /* MWI Subscribe Timer */
    mmi_ucs2_to_asc((PS8)buffer, (PS8)g_em_voip_cntx.mwi_sub_timer);
    value = atoi((const char *) buffer);        
    voip_custom_set_mwi_sub_timer(value);

    /* MWI Retry Time */
    mmi_ucs2_to_asc((PS8)buffer, (PS8)g_em_voip_cntx.mwi_retry_time);
    value = atoi((const char *) buffer);        
    voip_custom_set_mwi_retry_times(value);

    /* UAS Refresher */
    voip_custom_set_uas_call_refresher((U32)g_em_voip_cntx.currUASRefresher);

    /* UAC Refresher */
    voip_custom_set_uac_call_refresher((U32)g_em_voip_cntx.currUACRefresher);

    /* RPort Support */
    if (g_em_voip_cntx.currRPortSupport)
    {
        voip_custom_set_rport_support(MMI_TRUE);
    }
    else
    {
        voip_custom_set_rport_support(MMI_FALSE);
    }

    DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
    DeleteUptoScrID(EM_VOIP_SCR_ID);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIPSIPSupported
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPSIPSupported(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmVOIPSIPSupported, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

/**************************************************************
**	FUNCTION NAME		: EntryEmVOIPSIPSupported
**
** 	PURPOSE				: Enrty function for VOIP SIP Supported menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmVOIPSIPSupported(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *history_buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_VOIP_SIP_SUPPORTED_SCR_ID, NULL, NULL, NULL);
    history_buffer = GetCurrGuiBuffer(EM_VOIP_SIP_SUPPORTED_SCR_ID);

    mmi_asc_to_ucs2((PS8)g_em_voip_cntx.input_buf, voip_custom_get_sip_supported());
    
    ShowCategory5Screen(
        EM_VOIP_SIP_SUPPORTED_TEXT,
        (U16) NULL,
        STR_GLOBAL_OK,
        (U16) NULL,
        STR_GLOBAL_BACK,
        (U16) NULL,
        INPUT_TYPE_ALPHANUMERIC_LOWERCASE | INPUT_TYPE_USE_ONLY_ENGLISH_MODES,
        (U8*) g_em_voip_cntx.input_buf,
        VOIP_CUST_STR_LEN, 
        history_buffer);

    SetLeftSoftkeyFunction(LSKEmVOIPSetSIPSupportedHandler, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/**************************************************************

	FUNCTION NAME		: LSKEmVOIPSetSIPSupportedHandler()

  	PURPOSE				: To set VOIP SIP Supported

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void LSKEmVOIPSetSIPSupportedHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 buffer[VOIP_CUST_STR_LEN]; 
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_em_voip_cntx.input_buf!=NULL)
    {
        mmi_ucs2_to_asc((PS8)buffer, (PS8)g_em_voip_cntx.input_buf);
        voip_custom_set_sip_supported(buffer);
    }
    else
    {
        buffer[0] = '\0';
        voip_custom_set_sip_supported(buffer);
    }
    
    DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
    DeleteUptoScrID(EM_VOIP_SCR_ID);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIPSIPRequire
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPSIPRequire(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmVOIPSIPRequire, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}

/**************************************************************
**	FUNCTION NAME		: EntryEmVOIPSIPRequire
**
** 	PURPOSE				: Enrty function for VOIP SIP Require menu
**
**	INPUT PARAMETERS	: nil
**
**	OUTPUT PARAMETERS	: void
**
**	RETURNS				: void
**
**	REMARKS			: 
**************************************************************/
void EntryEmVOIPSIPRequire(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *history_buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_VOIP_SIP_REQUIRE_SCR_ID, NULL, NULL, NULL);
    history_buffer = GetCurrGuiBuffer(EM_VOIP_SIP_REQUIRE_SCR_ID);

    mmi_asc_to_ucs2((PS8)g_em_voip_cntx.input_buf, voip_custom_get_sip_require());

    ShowCategory5Screen(
        EM_VOIP_SIP_REQUIRE_TEXT,
        (U16) NULL,
        STR_GLOBAL_OK,
        (U16) NULL,
        STR_GLOBAL_BACK,
        (U16) NULL,
        INPUT_TYPE_ALPHANUMERIC_LOWERCASE | INPUT_TYPE_USE_ONLY_ENGLISH_MODES,
        (U8*) g_em_voip_cntx.input_buf,
        VOIP_CUST_STR_LEN,
        history_buffer);

    SetLeftSoftkeyFunction(LSKEmVOIPSetSIPRequireHandler, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

}


/**************************************************************

	FUNCTION NAME		: LSKEmVOIPSetSIPRequireHandler()

  	PURPOSE				: To set VOIP SIP Require

	INPUT PARAMETERS	: nil

	OUTPUT PARAMETERS	: nil

	RETURNS				: void

	REMARKS				: nil

**************************************************************/
void LSKEmVOIPSetSIPRequireHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 buffer[VOIP_CUST_STR_LEN]; 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_em_voip_cntx.input_buf!=NULL)
    {
        mmi_ucs2_to_asc((PS8)buffer, (PS8)g_em_voip_cntx.input_buf);    
        voip_custom_set_sip_require(buffer);
    }
    else
    {
        buffer[0] = '\0';
        voip_custom_set_sip_require(buffer);
    }
    
    DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
    DeleteUptoScrID(EM_VOIP_SCR_ID);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIP
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPLog(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmVOIPLog, KEY_EVENT_UP);
    SetKeyHandler(EntryEmVOIPLog, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
 
    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmVOIPLog
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmVOIPLog(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 item_list[32];
    U16 item_icons[32];
    U16 num_items;
    U8 *gui_buffer;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_VOIP_LOG_SCR_ID, NULL, EntryEmVOIPLog, NULL);
    gui_buffer = GetCurrGuiBuffer(EM_VOIP_LOG_SCR_ID);

    num_items = GetNumOfChild(EM_VOIP_LOG_MENU_ID);
    GetSequenceStringIds(EM_VOIP_LOG_MENU_ID, item_list);
    SetParentHandler(EM_VOIP_LOG_MENU_ID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < num_items; i++)
    {
        item_icons[i] = (U16) (IMG_GLOBAL_L1 + i);   
    }

    ShowCategory52Screen(
        EM_VOIP_LOG_TEXT,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        num_items,
        item_list,
        item_icons,
        NULL,
        0,
        0,
        gui_buffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIPLogSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPLogSetting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmVOIPLogSetting, KEY_EVENT_UP);
    SetKeyHandler(EntryEmVOIPLogSetting, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmVOIPLogSetting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmVOIPLogSetting(void)
{


    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* gui_buffer;
    U16 ImageList[EM_VOIP_LOG_INLINE_TOTAL];
    U8  total_drv_num;
    UI_string_type drv_inline_list_p = NULL;
  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_VOIP_LOG_SETTINGS_SCR_ID, ExitEmVOIPLogSettingScreen, NULL, NULL);
    InitializeCategory57Screen();

    gui_buffer = GetCurrGuiBuffer(EM_VOIP_LOG_SETTINGS_SCR_ID);
    RegisterHighlightHandler(HighlightHdlrVOIPLogInline);

    
    SetInlineItemCaption(&wgui_inline_items[0], (U8*)GetString(STR_GLOBAL_ACTIVATE));
    ImageList[EM_VOIP_LOG_INLINE_ACTIVATE_CAPTION] = IMG_STATUS;

    g_em_voip_log_cntx.em_voip_log_activate[EM_VOIP_LOG_ACTIVATE_OFF] = (U8*)GetString(STR_GLOBAL_OFF);
    g_em_voip_log_cntx.em_voip_log_activate[EM_VOIP_LOG_ACTIVATE_ON] = (U8*)GetString(STR_GLOBAL_ON);
    if (g_em_voip_log_cntx.interrupt <= 0)
    {
        g_em_voip_log_cntx.hili_log_activate = g_em_voip_log_cntx.curr_log_activate;
    }
    SetInlineItemActivation(&wgui_inline_items[1], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(
        &wgui_inline_items[1], 2, 
        (U8**)g_em_voip_log_cntx.em_voip_log_activate, 
        &g_em_voip_log_cntx.hili_log_activate); 
    ImageList[EM_VOIP_LOG_INLINE_ACTIVATE] = 0;
    
    SetInlineItemCaption(&wgui_inline_items[2], (U8*)GetString(STR_GLOBAL_SAVE));
    ImageList[EM_VOIP_LOG_INLINE_SAVE_CAPTION] = IMG_STATUS;
    
    mmi_fmgr_get_full_storage_inline_list(0,(U8 *)&total_drv_num, (U32*)(&drv_inline_list_p),NULL);
    if (g_em_voip_log_cntx.interrupt <= 0)
    {
        g_em_voip_log_cntx.hili_log_storage = g_em_voip_log_cntx.curr_log_storage;
    }
    SetInlineItemActivation(&wgui_inline_items[3], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(
    &wgui_inline_items[3], 
    (S32)total_drv_num,
    (U8 **) drv_inline_list_p,
    &g_em_voip_log_cntx.hili_log_storage);    
    ImageList[EM_VOIP_LOG_INLINE_SAVE] = 0;

    SetInlineItemCaption(&wgui_inline_items[4], (U8*)GetString(EM_VOIP_LOG_AUTO_DELETE_TEXT));
    ImageList[EM_VOIP_LOG_INLINE_AUTO_DELETE_CAPTION] = IMG_STATUS;
  
    g_em_voip_log_cntx.em_voip_log_delete[EM_VOIP_LOG_AUTO_DELETE_ALL] = 
        (U8*)GetString(EM_VOIP_LOG_DELETE_ALL_TEXT);
    g_em_voip_log_cntx.em_voip_log_delete[EM_VOIP_LOG_AUTO_DELETE_ONE_DAY] = 
        (U8*)GetString(EM_VOIP_LOG_DELETE_ONE_DAY_TEXT);
    g_em_voip_log_cntx.em_voip_log_delete[EM_VOIP_LOG_AUTO_DELETE_HALF_MONTH] = 
        (U8*)GetString(EM_VOIP_LOG_DELETE_HALF_MONTH_TEXT);
    g_em_voip_log_cntx.em_voip_log_delete[EM_VOIP_LOG_AUTO_DELETE_ONE_MONTH] = 
        (U8*)GetString(EM_VOIP_LOG_DELETE_ONE_MONTH_TEXT);
    if (g_em_voip_log_cntx.interrupt <= 0)
    {
        g_em_voip_log_cntx.hili_log_del_time = g_em_voip_log_cntx.curr_log_del_time;
    }
    SetInlineItemActivation(&wgui_inline_items[5], INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemSelect(
    &wgui_inline_items[5], 4, 
    (U8**)g_em_voip_log_cntx.em_voip_log_delete, 
    &g_em_voip_log_cntx.hili_log_del_time); 
    ImageList[EM_VOIP_LOG_INLINE_AUTO_DELETE] = 0;

    DisableCategory57ScreenDone();
     	
    ShowCategory57Screen(EM_VOIP_LOG_SETTINGS_TEXT, 0, 
                         STR_GLOBAL_OK, 
                         IMG_GLOBAL_OK, 
                         STR_GLOBAL_BACK, 
                         IMG_GLOBAL_BACK,
 	                     EM_VOIP_LOG_INLINE_TOTAL, ImageList, wgui_inline_items, 0, gui_buffer);	

    
    SetCategory57RightSoftkeyFunctions( GoBackHistory, GoBackHistory );  
}


/*****************************************************************************
 * FUNCTION
 *  ExitEmVOIPLogSettingScreen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEmVOIPLogSettingScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;
    U16 input_buffer_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    /* to avoid the call interrupt or pop menu */
    if ( IsBackHistory == MMI_FALSE)
    {
        g_em_voip_log_cntx.interrupt = 1;
    }
    else
    {
        g_em_voip_log_cntx.interrupt = 0;
    }
    
    h.scrnID = EM_VOIP_LOG_SETTINGS_SCR_ID;
    h.entryFuncPtr = EntryEmVOIPLogSetting;
    GetCategoryHistory(h.guiBuffer);
    input_buffer_size = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) h.inputBuffer);
    AddNHistory(h, input_buffer_size);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightHdlrVOIPLogInline
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightHdlrVOIPLogInline(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    SetLeftSoftkeyFunction(EmSetVOIPLogInfo, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EmSetVOIPLogInfo
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EmSetVOIPLogInfo(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
    U8  voip_log_storage;
   

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    EXT_ASSERT( (g_em_voip_log_cntx.hili_log_activate & 0xFFFFFF00) == 0, 
                 g_em_voip_log_cntx.hili_log_activate, 0, 0 );
    
    EXT_ASSERT( (g_em_voip_log_cntx.hili_log_storage & 0xFFFFFF00) == 0, 
                 g_em_voip_log_cntx.hili_log_storage, 0, 0 );
    
    EXT_ASSERT( (g_em_voip_log_cntx.hili_log_del_time & 0xFFFFFF00) == 0, 
                 g_em_voip_log_cntx.hili_log_del_time, 0, 0 );


    if (g_em_voip_log_cntx.hili_log_activate != g_em_voip_log_cntx.curr_log_activate)
    {
        WriteValue(NVRAM_VOIP_LOG_ACTIVATE, 
                  &g_em_voip_log_cntx.hili_log_activate, DS_BYTE, &error);
        g_em_voip_log_cntx.curr_log_activate = g_em_voip_log_cntx.hili_log_activate;
    }

    if (g_em_voip_log_cntx.hili_log_storage != g_em_voip_log_cntx.curr_log_storage)
    {
        WriteValue(NVRAM_VOIP_LOG_STORAGE, 
                  &g_em_voip_log_cntx.hili_log_storage, DS_BYTE, &error);

        g_em_voip_log_cntx.curr_log_storage = g_em_voip_log_cntx.hili_log_storage;
        mmi_fmgr_get_drive_letter_by_inline_index(
                  (U8)g_em_voip_log_cntx.curr_log_storage, (PS8)&voip_log_storage);
        kal_wsprintf((kal_wchar*)g_em_voip_log_cntx.dirpath, "%c:\\", (S8) voip_log_storage);
        mmi_ucs2cat((S8*)g_em_voip_log_cntx.dirpath, (const S8*)EM_VOIP_LOG_DIR_PATH);
    }
    
    if (g_em_voip_log_cntx.hili_log_del_time != g_em_voip_log_cntx.curr_log_del_time)
    {
        WriteValue(NVRAM_VOIP_LOG_DELETE_TIME, 
            &g_em_voip_log_cntx.hili_log_del_time, DS_BYTE, &error);
        g_em_voip_log_cntx.curr_log_del_time = g_em_voip_log_cntx.hili_log_del_time;
    }


    DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 1, 1000, 0);
    DeleteUptoScrID(EM_VOIP_LOG_SCR_ID);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIPLogView
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPLogView(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmVOIPLogOption, KEY_EVENT_UP);
    SetKeyHandler(EntryEmVOIPLogOption, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmVOIPLogOption
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmVOIPLogOption(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILTER filter;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_FILTER_INIT(&filter);
    FMGR_FILTER_SET_ALL(&filter);
#ifdef __MMI_FILE_MANAGER__
    mmi_fmgr_select_path_and_enter(
        APP_ENGINEERMODE,
        FMGR_SELECT_FILE | FMGR_SELECT_REPEAT,
        filter,
        (S8*) g_em_voip_log_cntx.dirpath,
        EntryEMVOIPLogSelected);
#endif

}


/*****************************************************************************
 * FUNCTION
 *  EntryEMVOIPLogSelected
 * DESCRIPTION
 *  file selected
 * PARAMETERS
 *  path            [IN]        Selected folder path
 *  is_short        [IN]        Is short filename
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMVOIPLogSelected(void *path, int is_short)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (path == NULL)
    {
        DeleteUptoScrID(EM_VOIP_LOG_SCR_ID);
        GoBackHistory();
        return;
    }

    if (mmi_ucs2str((S8 *)path, (S8 *)EM_VOIP_LOG_EXT_FILENAME) != NULL)
    {
        memset(g_em_voip_log_cntx.filepath, 0, FMGR_PATH_BUFFER_SIZE);
        mmi_ucs2cpy((PS8) g_em_voip_log_cntx.filepath, (PS8) path);
        /* enter Display Voip Log screen */
        EMVOIPLogDisplayOption();
    }
    else
    {
        /* not supported file type */
        DisplayPopup((PU8) GetString(STR_GLOBAL_ERROR), IMG_GLOBAL_WARNING,
                     0, UI_POPUP_NOTIFYDURATION_TIME, (U8) WARNING_TONE);
        
        DeleteNScrId(EM_VOIP_LOG_OPTION_SCR_ID);
    }

}


/*****************************************************************************
 * FUNCTION
 *  EMVOIPLogDisplayOption
 * DESCRIPTION
 *  display VOIP log option menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMVOIPLogDisplayOption(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 item_list[32];
    U16 item_icons[32];
    U16 num_items;
    U8 *gui_buffer;
    U8 *popup_list[32];
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_VOIP_LOG_OPTION_SCR_ID, NULL, EMVOIPLogDisplayOption, NULL);
    gui_buffer = GetCurrGuiBuffer(EM_VOIP_LOG_OPTION_SCR_ID);

    num_items = GetNumOfChild(EM_VOIP_LOG_OPTION_MENU_ID);
    GetSequenceStringIds(EM_VOIP_LOG_OPTION_MENU_ID, item_list);
    SetParentHandler(EM_VOIP_LOG_OPTION_MENU_ID);
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    for (i = 0; i < num_items; i++)
    {
        popup_list[i] = NULL;
        item_icons[i] = (U16) (IMG_GLOBAL_L1 + i);   
    }

    ShowCategory52Screen(
        STR_GLOBAL_OPTIONS,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        num_items,
        item_list,
        item_icons,
        (U8 **) popup_list,
        0,
        0,
        gui_buffer);

    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    return;

}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIPLogOptionView
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPLogOptionView(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(EntryEmVOIPLogOptionView, KEY_EVENT_UP);
    SetKeyHandler(EntryEmVOIPLogOptionView, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  EntryEmVOIPLogOptionView
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEmVOIPLogOptionView(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U32 readnum;
    S32 ret_code;
    FS_HANDLE fs_handle;
    S8 read_data[MAX_SUB_MENUS][MAX_SUBMENU_CHARACTERS];


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(EM_VOIP_LOG_VIEW_SCR_ID, NULL, EntryEmVOIPLogOptionView, NULL);
    guiBuffer = GetCurrGuiBuffer(EM_VOIP_LOG_VIEW_SCR_ID);


    memset(subMenuData, 0, (MAX_SUB_MENUS * MAX_SUB_MENU_SIZE));
    
    fs_handle = FS_Open((U16*) g_em_voip_log_cntx.filepath, FS_READ_ONLY);
    if (fs_handle < 0)
    {
        DisplayPopup(
                     (PU8) GetString(GetFileSystemErrorString(fs_handle)),
                     IMG_GLOBAL_ERROR,
                     0,
                     1000,
                     ERROR_TONE);
        
        DeleteNScrId(EM_VOIP_LOG_OPTION_SCR_ID);
        return;
    }
    
    ret_code = FS_Read(fs_handle, 
                    (void*)read_data,
                    MAX_SUB_MENUS*MAX_SUBMENU_CHARACTERS , 
                    (U32*) & readnum);
    if (ret_code < 0)
    {
        DisplayPopup(
                     (PU8) GetString(GetFileSystemErrorString(ret_code)),
                     IMG_GLOBAL_ERROR,
                     0,
                     1000,
                     ERROR_TONE);
        
        DeleteNScrId(EM_VOIP_LOG_OPTION_SCR_ID);
        return;
    }
    
    mmi_asc_n_to_ucs2((S8*)subMenuData, (S8*)read_data, readnum);
    FS_Close(fs_handle);

    ShowCategory74Screen(
        EM_VOIP_LOG_CONTENT_TEXT,
        GetRootTitleIcon(MENU_ID_VOIP_MAIN),
        (U16) NULL,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (U8*)subMenuData,
        (MAX_SUB_MENUS * MAX_SUB_MENU_SIZE),
        NULL);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIPLogOptionDelete
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPLogOptionDelete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_em_voip_log_cntx.delete_all = EM_VOIP_LOG_DELETE;
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(entry_em_voip_log_delete_confirm, KEY_EVENT_UP);
    SetKeyHandler(entry_em_voip_log_delete_confirm, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}

/*****************************************************************************
 * FUNCTION
 *  HighlightEmVOIPLogOptionDeleteAll
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightEmVOIPLogOptionDeleteAll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    g_em_voip_log_cntx.delete_all = EM_VOIP_LOG_DELETE_ALL;
    SetLeftSoftkeyFunction(entry_em_voip_log_delete_confirm, KEY_EVENT_UP);
    SetKeyHandler(entry_em_voip_log_delete_confirm, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  entry_em_voip_log_delete_confirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void entry_em_voip_log_delete_confirm(void)
{

     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_em_voip_log_cntx.delete_all == EM_VOIP_LOG_DELETE_ALL)
    {
 	    DisplayConfirm(
        STR_GLOBAL_YES,
        IMG_GLOBAL_YES,
        STR_GLOBAL_NO,
        IMG_GLOBAL_NO,
        get_string(STR_GLOBAL_DELETE_ALL),
        IMG_GLOBAL_QUESTION,
        WARNING_TONE);
    }
    else
    {

 	    DisplayConfirm(
        STR_GLOBAL_YES,
        IMG_GLOBAL_YES,
        STR_GLOBAL_NO,
        IMG_GLOBAL_NO,
        get_string(STR_GLOBAL_DELETE),
        IMG_GLOBAL_QUESTION,
        WARNING_TONE);
    }
    
    if (g_em_voip_log_cntx.delete_all == EM_VOIP_LOG_DELETE_ALL)
    {
        SetLeftSoftkeyFunction(em_voip_log_delete_all_file, KEY_EVENT_UP);
    }
    else
    {
        SetLeftSoftkeyFunction(em_voip_log_delete_file, KEY_EVENT_UP);
    }
    
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_delete_all_file
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 ******************************************************************************/
void em_voip_log_delete_all_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 len = 0;
    S8 *ext;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* delete files */
    ext = mmi_ucs2rchr((const PS8)g_em_voip_log_cntx.filepath, (U16)L'\\');

    if (ext  == NULL)
    {
        DeleteNScrId(EM_VOIP_LOG_OPTION_SCR_ID);
        GoBackHistory();
        return;
    }
    
    ext += 2;
    
    len = mmi_ucs2strlen(ext);
    if (len > 0)
    {
        memset(ext, 0, (len * 2));
        *ext = L'\0';
    }

    mmi_fmgr_send_delete_req((PU8) g_em_voip_log_cntx.filepath, 
        FS_DIR_TYPE, em_voip_log_delete_rsp_hdlr);
 
    entry_em_voip_delete_animation();
}

/*****************************************************************************
 * FUNCTION
 *  em_voip_log_delete_file
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void em_voip_log_delete_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* delete files */
    mmi_fmgr_send_delete_req((PU8) g_em_voip_log_cntx.filepath, 
        FS_FILE_TYPE, em_voip_log_delete_rsp_hdlr);
   
    entry_em_voip_delete_animation();
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_delete_rsp_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  info        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void em_voip_log_delete_rsp_hdlr(void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmt_delete_rsp_strcut *msg_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TurnOffBacklight();
    SetDelScrnIDCallbackHandler (EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID, (HistoryDelCBPtr)NULL);	

    msg_p = (mmi_fmt_delete_rsp_strcut*) info;

    if (msg_p->result >= FS_NO_ERROR)
    {
       
        /* success */
        if (isInCall() == TRUE && GetExitScrnID() != EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID)
        {
            DeleteScreenIfPresent(EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID);
        }
        else
        {
            DisplayPopup((PU8) GetString(STR_GLOBAL_DONE), IMG_GLOBAL_ACTIVATED, 0, 1000, SUCCESS_TONE);
            DeleteScreenIfPresent(EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID);
        }
    }
    else
    {
        /* fail */
        mmi_ucs2_to_asc((PS8) nPrintableStr, (PS8) g_em_voip_log_cntx.filepath);
        PRINT_INFORMATION("delete fail: %s", nPrintableStr);
 
        if (isInCall() == TRUE && GetExitScrnID() != EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID)
        {
           DeleteScreenIfPresent(EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID);
        }
        else
        {
            DisplayPopup(
                (PU8) GetString(GetFileSystemErrorString(msg_p->result)),
                IMG_GLOBAL_ERROR,
                0,
                1000,
                ERROR_TONE);
            DeleteScreenIfPresent(EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID);
        }
    }

    g_em_voip_log_cntx.delete_all = EM_VOIP_LOG_DELETE_NONE;
    return;
}


/*****************************************************************************
 * FUNCTION
 *  entry_fmgr_delete_animation
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void entry_em_voip_delete_animation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TurnOnBacklight(0);

    EntryNewScreen(EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID, exit_em_voip_delete_animation, NULL, NULL);

    ShowCategory66Screen(
        STR_GLOBAL_DELETE,
        0,
        0,
        0,
        0,
        0,
        (PU8) GetString(STR_GLOBAL_PLEASE_WAIT),
        IMG_GLOBAL_PROGRESS,
        NULL);

    ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_END, KEY_LONG_PRESS);

    /* can only delete the screen when the deletetion resp is received */
    if (!IsScreenPresent(EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID))
    {
        if (g_em_voip_log_cntx.delete_all == EM_VOIP_LOG_DELETE_ALL)
        {
            DeleteUptoScrID(EM_VOIP_LOG_SCR_ID);
        }
        else
        {
            DeleteNScrId(EM_VOIP_LOG_OPTION_SCR_ID);
        }
    }

    SetDelScrnIDCallbackHandler(EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID, 
        (HistoryDelCBPtr) em_voip_delete_animation_callback);
}


/*****************************************************************************
 * FUNCTION
 *  exit_em_voip_delete_animation
 * DESCRIPTION
 *  processing the interrupt
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void exit_em_voip_delete_animation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history curr_history;
    S16 num_history = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (isInCall() == FALSE)
    {
        /* pop up interrupt => add to history */
        curr_history.scrnID = EM_VOIP_LOG_DELETE_ANIMATION_SCR_ID;
        curr_history.entryFuncPtr = entry_em_voip_delete_animation;
        mmi_ucs2cpy((S8*) curr_history.inputBuffer, (S8*) & num_history);
        GetCategoryHistory(curr_history.guiBuffer);
        AddHistory(curr_history);
    }
    else
    {
        /* interrupt by Call => abort XDelete */
        if (g_em_voip_log_cntx.delete_all == EM_VOIP_LOG_DELETE_ALL)
        {
            FS_Abort(FS_ABORT_XDELETE);       
        }
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_delete_animation_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  param       [?]     
 * RETURNS
 *  
 *****************************************************************************/
U8 em_voip_delete_animation_callback(void *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_em_voip_log_cntx.delete_all == EM_VOIP_LOG_DELETE_NONE)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_init
 * DESCRIPTION
 *  initialize the voip log mechanism
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 ******************************************************************************/
void em_voip_log_init(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 voip_log_storage;
    S16 error;
    S32 ret_code;
    FS_HANDLE h_file;


   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* initialize VOIP log setting parameters */
    ReadValue(NVRAM_VOIP_LOG_ACTIVATE, &g_em_voip_log_cntx.curr_log_activate, DS_BYTE, &error);
    if ((g_em_voip_log_cntx.curr_log_activate & 0x000000ff) == 0x000000ff) /* initial value is 0xff */
    {
        g_em_voip_log_cntx.curr_log_activate = 0;
        WriteValue(NVRAM_VOIP_LOG_ACTIVATE, &g_em_voip_log_cntx.curr_log_activate, DS_BYTE, &error);
    }

    ReadValue(NVRAM_VOIP_LOG_STORAGE, &g_em_voip_log_cntx.curr_log_storage, DS_BYTE, &error);
    if ((g_em_voip_log_cntx.curr_log_storage & 0x000000ff) == 0x000000ff) /* initial value is 0xff */
    {
        g_em_voip_log_cntx.curr_log_storage = 0;
        WriteValue(NVRAM_VOIP_LOG_STORAGE, &g_em_voip_log_cntx.curr_log_storage, DS_BYTE, &error);
    }

    ReadValue(NVRAM_VOIP_LOG_DELETE_TIME, &g_em_voip_log_cntx.curr_log_del_time, DS_BYTE, &error);
    if ((g_em_voip_log_cntx.curr_log_del_time & 0x000000ff) == 0x000000ff) /* initial value is 0xff */
    {
        g_em_voip_log_cntx.curr_log_del_time = 0;
        WriteValue(NVRAM_VOIP_LOG_DELETE_TIME, &g_em_voip_log_cntx.curr_log_del_time, DS_BYTE, &error);
    }
 
    memset(g_em_voip_log_cntx.call_status, 0xFF, 
        (sizeof(em_voip_log_call_status_struct) * EM_VOIP_LOG_MAX_CALL));
 
    mmi_fmgr_get_full_storage_inline_list(0, NULL, NULL,NULL);
    mmi_fmgr_get_drive_letter_by_inline_index(
        (U8)g_em_voip_log_cntx.curr_log_storage, (PS8)&voip_log_storage);
    

    kal_wsprintf((kal_wchar*)g_em_voip_log_cntx.dirpath, "%c:\\", (S8) voip_log_storage);
    mmi_ucs2cat((S8*)g_em_voip_log_cntx.dirpath, (const S8*)EM_VOIP_LOG_DIR_PATH);

    /* create the log folder */
    h_file = FS_Open((WCHAR *)g_em_voip_log_cntx.dirpath, FS_OPEN_DIR | FS_READ_ONLY);
    
    if ((h_file == FS_FILE_NOT_FOUND) || (h_file == FS_PATH_NOT_FOUND))
    {
        ret_code = FS_CreateDir((WCHAR *)g_em_voip_log_cntx.dirpath);

        if(ret_code < 0)
        {
            return;
        }
    }
    else
    {
        FS_Close(h_file);
    }    

    /* check and delete outdated logs */
    em_voip_log_check_and_delete();
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_check_activate_status
 * DESCRIPTION
 *  return the activation status
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL em_voip_log_check_activate_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return ((g_em_voip_log_cntx.curr_log_activate > 0) ? MMI_TRUE : MMI_FALSE); 
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_change_id
 * DESCRIPTION
 * change the call id and dialog id
 * PARAMETERS
 *  ori_id       [IN]   original identification
 *  new_id       [IN]   new identification
 * RETURNS
 *  void
 *****************************************************************************/
void em_voip_log_change_id(void* ori_id, void* new_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    voip_call_id_struct *voip_ori_id = (voip_call_id_struct *)ori_id;
    voip_call_id_struct *voip_new_id = (voip_call_id_struct *)new_id;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_em_voip_log_cntx.curr_log_activate > 0)
    {
        /* free the used record */
        for (i = 0; i < EM_VOIP_LOG_MAX_CALL; i++)
        {
            if ((g_em_voip_log_cntx.call_status[i].call_id == voip_ori_id->call_id) &&
               (g_em_voip_log_cntx.call_status[i].dialog_id == voip_ori_id->dialog_id))
            {     
                g_em_voip_log_cntx.call_status[i].call_id = voip_new_id->call_id;
                g_em_voip_log_cntx.call_status[i].dialog_id = voip_new_id->dialog_id;
                break;
            }
        } 
    }

    return;  
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_save
 * DESCRIPTION
 * save the log data
 * PARAMETERS
 *  id           [IN]   call identification
 *  buf          [IN]   buffer
 *  buf_len      [IN]   buffer length
 * RETURNS
 *  void
 *****************************************************************************/
void em_voip_log_save(void* id, void *buf, S32 buf_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE h_file;
    S32 i;
    S32 len = 0;
    S32 ret = 0;
    kal_wchar filename[FMGR_MAX_FILE_LEN];
    voip_call_id_struct *call = (voip_call_id_struct *)id;
    S32 call_id;
    S32 dialog_id;
    S8 log_date[100];
    MYTIME current_time;
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_em_voip_log_cntx.curr_log_activate > 0)
    {
        GetDateTime(&current_time);
                    sprintf(
                        (PS8) log_date,
                        "\n%04d-%02d-%02d %02d:%02d:%02d\n",
                        current_time.nYear,current_time.nMonth, current_time.nDay, 
                        current_time.nHour, current_time.nMin, current_time.nSec);
                    
        if ( call != NULL)
        {
            /* Normal case */
            call_id = (S32)call->call_id;
            dialog_id = (S32)call->dialog_id;
            
            for (i = 0; i < EM_VOIP_LOG_MAX_CALL; i++)
            {
                if ((g_em_voip_log_cntx.call_status[i].call_id == call_id) &&
                   (g_em_voip_log_cntx.call_status[i].dialog_id == dialog_id))
                {     
                    if (g_em_voip_log_cntx.call_status[i].status == FS_NO_ERROR)
                    {
                        break;
                    }
                    else
                    {
                        return;
                    }
                }
            }

            if(i >= EM_VOIP_LOG_MAX_CALL)
            {
                return;
            }

            if (mmi_ucs2cmp((PS8)g_em_voip_log_cntx.call_status[i].filename, (PS8)L"") != 0)
            {  
                h_file = FS_Open((U16*) g_em_voip_log_cntx.call_status[i].filename, FS_READ_WRITE);
                
                if (h_file > 0)
                {
                        
                    FS_Seek(h_file, 0, FS_FILE_END);
                      
                    g_em_voip_log_cntx.call_status[i].status = 
                        FS_Write(h_file, log_date, AsciiStrlen((const S8*)log_date), (UINT *)&len);
                    if(g_em_voip_log_cntx.call_status[i].status == FS_NO_ERROR)
                    {
                        g_em_voip_log_cntx.call_status[i].status = 
                            FS_Write(h_file, buf, buf_len, (UINT *)&len);
                    }
                   
                    FS_Close(h_file);
                }
        
            }
        }
        else
        {
            /* for special case */
            
            /* create the log folder if it is not created during initialization */
            h_file = FS_Open((WCHAR *)g_em_voip_log_cntx.dirpath, FS_OPEN_DIR | FS_READ_ONLY);
            if ((h_file == FS_FILE_NOT_FOUND) || (h_file == FS_PATH_NOT_FOUND))
            {
        
                ret = FS_CreateDir((WCHAR *)g_em_voip_log_cntx.dirpath);
            
                if (ret < 0)
                {
                    DisplayPopup(
                        (PU8) GetString(GetFileSystemErrorString(ret)),
                        IMG_GLOBAL_ERROR,
                        0,
                        1000,
                        ERROR_TONE);
                
                    return;
                }
            }
            else
            {
                FS_Close(h_file);
            }    
            
            memset(filename, 0, FMGR_MAX_FILE_LEN * ENCODING_LENGTH);
            mmi_ucs2cpy((S8*)filename, (S8*)g_em_voip_log_cntx.dirpath);
            mmi_ucs2cat((S8*)filename, (const S8*)EM_VOIP_LOG_TEMP_FILE);
            
            /* check to see if this special file has been created */
            h_file = FS_Open((WCHAR *)filename, FS_READ_WRITE);
            if (h_file < 0)
            {
                /* file does not exist */
                h_file = FS_Open((WCHAR *)filename, FS_CREATE | FS_READ_WRITE);

                if (h_file > 0)
                {
                    ret = FS_Write(h_file, log_date, AsciiStrlen((const S8*)log_date), (UINT *)&len);

                    if (ret == FS_NO_ERROR)
                    {
                        ret = FS_Write(h_file, buf, buf_len, (UINT *)&len);
                    }

                    if (ret < 0)
                    {
                        DisplayPopup(
                        (PU8) GetString(GetFileSystemErrorString(ret)),
                        IMG_GLOBAL_ERROR,
                        0,
                        1000,
                        ERROR_TONE);
                    }

                    FS_Close(h_file);
                }
                else
                {
                    DisplayPopup(
                        (PU8) GetString(GetFileSystemErrorString(h_file)),
                        IMG_GLOBAL_ERROR,
                        0,
                        1000,
                        ERROR_TONE);
                }
            }
            else
            {
                /* file has already existed */
                if (FS_Seek(h_file, 0, FS_FILE_BEGIN) >= 0)
                {
                    if (FS_Truncate(h_file) == FS_NO_ERROR)
                    {
                        ret = FS_Write(h_file, log_date, AsciiStrlen((const S8*)log_date), (UINT *)&len);
                        if (ret == FS_NO_ERROR)
                        {
                            ret = FS_Write(h_file, buf, buf_len, (UINT *)&len);
                        }

                        if (ret < 0)
                        {
                            DisplayPopup(
                            (PU8) GetString(GetFileSystemErrorString(ret)),
                            IMG_GLOBAL_ERROR,
                            0,
                            1000,
                            ERROR_TONE);
                        }
                    }
                }
                
                FS_Close(h_file);
            }    
            
        }
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_call_start
 * DESCRIPTION
 * called when the call is started
 * PARAMETERS
 *  id       [IN]   call identification
 *  mdir     [IN]   message direction
 * RETURNS
 *  void
 ******************************************************************************/
void em_voip_log_call_start( void* id, MMI_BOOL mdir)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE h_file;
    MYTIME current_time;
    S8 filename[FMGR_PATH_BUFFER_SIZE];
    S32 i;
    voip_call_id_struct *call = (voip_call_id_struct*)id;
    S32 call_id = (S32)call->call_id;
    S32 dialog_id = (S32)call->dialog_id;
    S32 ret;
    S32 free_slot = -1; /* no free slot */
   

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_em_voip_log_cntx.curr_log_activate > 0)
    {
        /* create the log folder if it is not created during initialization */
        h_file = FS_Open((WCHAR *)g_em_voip_log_cntx.dirpath, FS_OPEN_DIR | FS_READ_ONLY);
        if ((h_file == FS_FILE_NOT_FOUND) || (h_file == FS_PATH_NOT_FOUND))
        {
        
            ret = FS_CreateDir((WCHAR *)g_em_voip_log_cntx.dirpath);
            if (ret < 0)
            {
                DisplayPopup(
                    (PU8) GetString(GetFileSystemErrorString(ret)),
                    IMG_GLOBAL_ERROR,
                    0,
                    1000,
                    ERROR_TONE);
                
                return;
            }
        }
        else
        {
            FS_Close(h_file);
        }    
    
        for (i = 0; i < EM_VOIP_LOG_MAX_CALL; i++)
        {
            if ((g_em_voip_log_cntx.call_status[i].call_id == call_id) &&
               (g_em_voip_log_cntx.call_status[i].dialog_id == dialog_id))
            {      
                /* we have already started this call */
                MMI_TRACE(MMI_TRACE_G7_MISC, MMI_VOIP_LOG_TRC_CALL_ACTIVATED, 
                          call_id,dialog_id);
                return;
            }

            if (free_slot < 0)
            {
                if ((g_em_voip_log_cntx.call_status[i].call_id == 0xFFFFFFFF) &&
                   (g_em_voip_log_cntx.call_status[i].dialog_id == 0xFFFFFFFF))
                {    
                    /* found an available record */
                    free_slot = i;
                }
            }
            
        }

        if (free_slot < 0)
        {
            MMI_TRACE(MMI_TRACE_G7_MISC, MMI_VOIP_LOG_TRC_CALL_OVER_MAX, EM_VOIP_LOG_MAX_CALL);
            return;
        }
       
        /* found an available record */
        g_em_voip_log_cntx.call_status[free_slot].call_id = call_id;
        g_em_voip_log_cntx.call_status[free_slot].dialog_id = dialog_id;
                
        /* generate the log file name based on MDIR + datetime + call_id + dialog_id */
        GetDateTime(&current_time);

        memset(filename, 0, FMGR_PATH_BUFFER_SIZE);
        if (mdir == EM_VOIP_LOG_CALL_OUT)
        {
            kal_wsprintf((kal_wchar*)filename, "MO_%04d%02d%02d%02d%02d%02d_%d%d",
                    current_time.nYear,current_time.nMonth, current_time.nDay, 
                    current_time.nHour, current_time.nMin, current_time.nSec, 
                    call_id, dialog_id);
        }
        else
        {
            kal_wsprintf((kal_wchar*)filename, "MT_%04d%02d%02d%02d%02d%02d_%d%d",
                    current_time.nYear,current_time.nMonth, current_time.nDay, 
                    current_time.nHour, current_time.nMin, current_time.nSec,
                    call_id, dialog_id);
        }

        mmi_ucs2cat((S8*)filename, (S8*)EM_VOIP_LOG_EXT_FILENAME);
        memset(g_em_voip_log_cntx.call_status[free_slot].filename, 0, FMGR_PATH_BUFFER_SIZE);
        mmi_ucs2cpy((S8*)g_em_voip_log_cntx.call_status[free_slot].filename, (const S8*)g_em_voip_log_cntx.dirpath);
        mmi_ucs2cat((S8*)g_em_voip_log_cntx.call_status[free_slot].filename, (S8*)filename);

        /* special file */
        memset(filename, 0, FMGR_PATH_BUFFER_SIZE);
        mmi_ucs2cpy((S8*)filename, (S8*)g_em_voip_log_cntx.dirpath);
        mmi_ucs2cat((S8*)filename, (const S8*)EM_VOIP_LOG_TEMP_FILE);
                
        /* check to see if this special file has been created */
        h_file = FS_Open((WCHAR *)filename, FS_READ_ONLY); 
        if (h_file > 0)
        {
            FS_Close(h_file);
            ret = FS_Rename((WCHAR *)filename, (WCHAR *)g_em_voip_log_cntx.call_status[free_slot].filename);
            if (ret < 0)
            {
                MMI_TRACE(MMI_TRACE_G7_MISC, MMI_VOIP_LOG_TRC_CALL_RENAME_FAIL);
            }
        }

        /* check and delete outdated logs */
        em_voip_log_check_and_delete();

        /* check if we can open or create the log file */
        h_file = FS_Open((U16*)g_em_voip_log_cntx.call_status[free_slot].filename, FS_CREATE | FS_READ_WRITE);

        if (h_file > 0)
        {
            FS_Close( h_file );
            
            g_em_voip_log_cntx.call_status[free_slot].status = FS_NO_ERROR;
        }
        else
        {
            /* cannot open or create the log file */
            g_em_voip_log_cntx.call_status[free_slot].status = h_file;
        }
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_call_end
 * DESCRIPTION
 * called when the you finish a call
 * PARAMETERS
 *  id       [IN]   call identification
 * RETURNS
 *  void
 ******************************************************************************/
void em_voip_log_call_end( void* id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    voip_call_id_struct *call = (voip_call_id_struct *)id;
    S32 call_id = (S32)call->call_id;
    S32 dialog_id = (S32)call->dialog_id;
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_em_voip_log_cntx.curr_log_activate > 0)
    {
        /* free the used record */
        for (i = 0; i < EM_VOIP_LOG_MAX_CALL; i++)
        {
            if ((g_em_voip_log_cntx.call_status[i].call_id == call_id) &&
               (g_em_voip_log_cntx.call_status[i].dialog_id == dialog_id))
            {     
                if (g_em_voip_log_cntx.call_status[i].status < 0)
                {
                    DisplayPopup(
                    (PU8) GetString(GetFileSystemErrorString(g_em_voip_log_cntx.call_status[i].status)),
                    IMG_GLOBAL_ERROR,
                    0,
                    1000,
                    ERROR_TONE);
                }

                MMI_TRACE(MMI_TRACE_G7_MISC, MMI_VOIP_LOG_TRC_CALL_CLEAR, call_id,dialog_id);
                memset(&g_em_voip_log_cntx.call_status[i], 0xff, sizeof(em_voip_log_call_status_struct));
                break;
            }
        } 
    }

    return;  
}


/*****************************************************************************
 * FUNCTION
 *  em_voip_log_check_and_delete
 * DESCRIPTION
 *  This function is used to delete outdated logs
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void em_voip_log_check_and_delete( void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 file_date_value = 0;
    U32 curr_date_value = 0;
    S32 outdate = 0;
    S32 i;
    int h = -1; /* save temp. file handle for find */
    FS_DOSDirEntry info;
    kal_wchar filename[FMGR_MAX_FILE_LEN];
    kal_wchar all_file_path[FMGR_MAX_FILE_LEN];
    U8      filepath[FMGR_PATH_BUFFER_SIZE];
    MYTIME curr_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_em_voip_log_cntx.curr_log_activate > 0)
    {
        /* compute the outdated time */
        switch (g_em_voip_log_cntx.curr_log_del_time)
        {
            case EM_VOIP_LOG_AUTO_DELETE_ALL:
                outdate = 0xFFFFFFFF;
                break;
            case EM_VOIP_LOG_AUTO_DELETE_ONE_DAY:
                outdate = 24*60*60;
                break; 
            case EM_VOIP_LOG_AUTO_DELETE_HALF_MONTH:
                outdate = 15*24*60*60;
                break;    
            case EM_VOIP_LOG_AUTO_DELETE_ONE_MONTH:
                outdate = 31*24*60*60;
                break; 
            default:
                ASSERT(0);
        }
    
    
        mmi_ucs2cpy((S8*)all_file_path, (const S8*)g_em_voip_log_cntx.dirpath);
        mmi_ucs2cat((S8*)all_file_path, (const S8*)(L"*.*"));

        if (outdate != 0xFFFFFFFF)
        {
            GetDateTime(&curr_time);
            if (curr_time.nYear > 1980)
            {
                /* current date */
                curr_date_value = ((curr_time.nYear - 1980)*12*31*24*60*60) +
                                (curr_time.nMonth*31*24*60*60) +
                                (curr_time.nDay*24*60*60) +
                                (curr_time.nHour*60*60) +
                                (curr_time.nMin*60) +
                                (curr_time.nSec >> 1);

                /* outdated time */
                curr_date_value = curr_date_value - outdate;
            }
            else
            {
                return;
            }

            h = FS_FindFirst((WCHAR *)all_file_path, 0, 0, &info, 
                filename, FMGR_MAX_FILE_LEN * ENCODING_LENGTH);

            if (h < 0)
            {
                return;
            } 
            
            do
            {
                /* the date of file */
                file_date_value = (info.DateTime.Year1980*12*31*24*60*60) +
                                (info.DateTime.Month*31*24*60*60) +
                                (info.DateTime.Day*24*60*60) +
                                (info.DateTime.Hour*60*60) +
                                (info.DateTime.Minute*60) +
                                (info.DateTime.Second2);
               
                if (curr_date_value >= file_date_value)
                {
                    /* delete the outdated logs */
                    memset(filepath, 0, FMGR_PATH_BUFFER_SIZE);
                    mmi_ucs2cpy((PS8)filepath, (PS8)g_em_voip_log_cntx.dirpath);
                    mmi_ucs2cat((PS8)filepath, (PS8)filename);
                    FS_Delete((const WCHAR *)filepath);
                }

                memset(filename, 0, FMGR_MAX_FILE_LEN * ENCODING_LENGTH);
            
            } while (FS_FindNext(h, &info, filename, FMGR_MAX_FILE_LEN * ENCODING_LENGTH) == FS_NO_ERROR);
            FS_FindClose(h);
        }
        else
        {
            h = FS_FindFirst((WCHAR *)all_file_path, 0, 0, &info, filename, FMGR_MAX_FILE_LEN * ENCODING_LENGTH);

            if (h < 0)
            {
                return;
            } 
            
            do
            {
                memset(filepath, 0, FMGR_PATH_BUFFER_SIZE);
                mmi_ucs2cpy((PS8)filepath, (PS8)g_em_voip_log_cntx.dirpath);
                mmi_ucs2cat((PS8)filepath, (PS8)filename);
                
                for (i = 0; i < EM_VOIP_LOG_MAX_CALL; i++)
                { 
                    if ((g_em_voip_log_cntx.call_status[i].call_id != 0xFFFFFFFF) &&
                        (g_em_voip_log_cntx.call_status[i].dialog_id != 0xFFFFFFFF))
                    {    
                        /* found an available record */
                        if (!mmi_ucs2cmp((const S8 *)g_em_voip_log_cntx.call_status[i].filename,
                            (const S8 *)filepath))
                        {
                            MMI_TRACE(MMI_TRACE_G7_MISC, MMI_VOIP_LOG_TRC_CALL_STARTED, 
                                      g_em_voip_log_cntx.call_status[i].call_id, 
                                      g_em_voip_log_cntx.call_status[i].dialog_id);
                            break;
                        }
                    }
                }

                if (i >= EM_VOIP_LOG_MAX_CALL)
                {
                    /* not found in table */
                    FS_Delete((const WCHAR *)filepath);
                    
                }

                memset(filename, 0, FMGR_MAX_FILE_LEN * ENCODING_LENGTH);
            } while (FS_FindNext(h, &info, filename, FMGR_MAX_FILE_LEN * ENCODING_LENGTH) == FS_NO_ERROR);

            FS_FindClose(h);
        }
    }
    
    return;
}
#endif   /*  __VOIP__ */


#if defined (__MMI_CSB_BROWSER__)
/*****************************************************************************
 * FUNCTION
 *  HighlightCSB
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightCSB(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Register function for left soft key */
    SetLeftSoftkeyFunction(PreEntryCSBMainMenu, KEY_EVENT_UP);

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}
#endif	/* __MMI_CSB_BROWSER__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_em_audio_debug_info_init
 * DESCRIPTION
 *  set debug info at bootup time
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_em_audio_debug_info_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadValue(NVRAM_AUDIO_DEBUG_INFO1, &AudioParameter.debug_info[0], DS_DOUBLE, &error);
    ReadValue(NVRAM_AUDIO_DEBUG_INFO2, &AudioParameter.debug_info[4], DS_DOUBLE, &error);

    if(AudioParameter.debug_info[0] == 0xFFFF)
    {
        memset(&AudioParameter.debug_info[0], 0 ,8);
        WriteValue(NVRAM_AUDIO_DEBUG_INFO1, &AudioParameter.debug_info[0], DS_DOUBLE, &error);
    }
    if(AudioParameter.debug_info[4] == 0xFFFF)
    {
        memset(&AudioParameter.debug_info[4], 0 ,8);
        WriteValue(NVRAM_AUDIO_DEBUG_INFO2, &AudioParameter.debug_info[4], DS_DOUBLE, &error);        
    }

#ifdef __MTK_TARGET__       
        /* Set debug info param to L1 directly. */
        L1Audio_SetDebugInfo(AudioParameter.debug_info);
#endif /* __MTK_TARGET__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_em_device_is_use_usb_as_uart_port
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_em_device_is_use_usb_as_uart_port(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 ps_port;
    U32 ps_baudrate;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    nvram_get_tst(&ps_port, &ps_baudrate);
    if (ps_port == uart_port_usb)
    {
        return MMI_TRUE;
    }

    nvram_get_tst_l1(&ps_port, &ps_baudrate);
    if (ps_port == uart_port_usb)
    {
        return MMI_TRUE;        
    }

    nvram_get_ps(&ps_port, &ps_baudrate);
    if (ps_port == uart_port_usb)
    {
        return MMI_TRUE;        
    }

    nvram_get_cti(&ps_port, &ps_baudrate);
    if (ps_port == uart_port_usb)
    {
        return MMI_TRUE;        
    }
    return MMI_FALSE;
}

#endif /* __MMI_ENGINEER_MODE__ */ 

