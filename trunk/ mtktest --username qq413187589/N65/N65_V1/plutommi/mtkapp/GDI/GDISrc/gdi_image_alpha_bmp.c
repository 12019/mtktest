/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  gdi_image_alpha_bmp.c
 *
 * Project:
 * --------
 *  PlutoMMI
 *
 * Description:
 * ------------
 *  Alpha BitMap (ABM) - a palette-based bitmap supporting per pixel alpha
 *
 *  ABM currently only supports 16, 24, 32-bit source and destination buffer.
 *  The source and destination layer must be in the same dimension but different
 *  bpps are allowed. (NO GREATER THAN the main base layer bpp)
 *
 *  NOTE: 1. The ARM/thumb inline assembly is deprecated for RVDS 3.3.
 *        2. The layer source color key check is omitted by preventing the output 
 *           blue color from saturation.
 *        3. The ABM image data must be at least 2-byte aligned (HALF WORD ALIGNED).
 *        4. Putting the INTERNCODE section, gdi_image_abm_draw(), into the 
 *           internal SRAM can boost the speed from 2x to 3x.
 *        5. The decoder is fine-tuned to make sure there is NO stack push/pop in
 *           the decoding loop (MAIN_BASE_LAYER_IS_16_BIT). It is recommended to check
 *           assembly code generated by the C compiler after code modification is made.
 *           (with ADS 1.2)
 *        6. If the source layer will change, the result may not be correct since
 *           ABM brings source layer pixels to the destination layer when the 
 *           ABM pixel alpha value is not 1.0.
 *           The only solution is to invoke redrawing when the source layer is changed.
 *
 *  TODO: 1. gdi_image_abm_set_source_layer() is a temporary solution to set the 
 *           source layer without introducing a new API, such as gdi_image_draw_alpha().
 *        2. Support layers with different dimensions
 *        3. Optimize gdi_image_abm_draw() more
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include 
 *****************************************************************************/
#include "gdi_internal.h"
#include "gd_primitive.h"
#include "gdi_image_alpha_bmp.h"
#include "gdi_image_alpha_bmp_internal.h"

/* media memory alloc/free for drawing ABM from files */
#include "med_global.h"
#include "med_utility.h"

#define GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888

/***************************************************************************** 
 * Static Declaration
 *****************************************************************************/ 
static gdi_handle g_abm_src_layer_handle = GDI_ERROR_HANDLE;   /* source layer handle */
static S32 g_abm_src_layer_offset_x = 0, g_abm_src_layer_offset_y = 0;  /* source layer offset */

/* table to calculate ceiling(log2(x)) */
static const U16 log2_table[15] = {2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768};

/*
 * static function prototypes
 */
static GDI_RESULT gdi_image_abm_get_dimension_mem(U8 *data_ptr, S32 *width, S32 *height);
static GDI_RESULT gdi_image_abm_get_dimension_file(S8 *filename, S32 *width, S32 *height);

static S32 gdi_image_abm_pre_process(int offset_x, int offset_y, U8 *abm_data_ptr, abm_info_struct *abm);
static GDI_RESULT gdi_image_abm_draw(S32 offset_x, S32 offset_y, U8 *abm_data_ptr, U8 *abm_bitstream_ptr);
static GDI_RESULT gdi_image_abm_draw_file(S32 offset_x, S32 offset_y, S8 *filename);
static void gdi_image_abm_layer_copy(S32 x1, S32 y1, S32 x2, S32 y2, gdi_handle dst_layer, gdi_handle src_layer);

static U32 log2_ceiling(U32 x);
static RET_VALUE_IN_REGS rect_struct get_draw_rect_in_layer_clip(S32 x1, S32 y1, S32 x2, S32 y2, gdi_handle layer);
static U32 rgb565_to_rgb888(U32 p);
static U32 rgb888_to_rgb565(U32 p);

#if !MAIN_BASE_LAYER_IS_16_BIT
static U32 alpha_blend_24bit_pixel(U32 src_pixel, U32 img_pixel, U32 alpha);
#else /* !MAIN_BASE_LAYER_IS_16_BIT */
static U32 alpha_blend_16bit_pixel(U32 src_pixel, U32 img_pixel, U32 alpha);
#endif /* !MAIN_BASE_LAYER_IS_16_BIT */

/***************************************************************************** 
 * Global Variable
 *****************************************************************************/

/***************************************************************************** 
 * Local Function
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  log2_ceiling
 * DESCRIPTION
 *  calculate ceiling(log2(x))
 * PARAMETERS
 *  x       [IN]    x must be in the range of [0, 65535]
 * RETURNS
 *  ceiling(log2(x))
 *****************************************************************************/
static U32 log2_ceiling(U32 x)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    S32     i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < 15; i++)
    {
        if (x <= log2_table[i])
            break;
    }

    return i + 1;
}


/*****************************************************************************
 * FUNCTION
 *  get_draw_rect_in_layer_clip
 * DESCRIPTION
 *  calculate the overlapped rect between the image rect and layer clip rect
 * PARAMETERS
 *  x1          [IN]    x1 of the draw rect top-left point (x1, y1)
 *  y1          [IN]    y1 of the draw rect top-left point (x1, y1)
 *  x2          [IN]    x2 of the draw rect bottom-right point (x2, y2)
 *  y2          [IN]    y2 of the draw rect bottom-right point (x2, y2)
 *  layer       [IN]    layer handle
 * RETURNS
 *  clipped rect, if out of clip, x1 is INVALID_RECT (-1)
 *****************************************************************************/
static RET_VALUE_IN_REGS rect_struct get_draw_rect_in_layer_clip(S32 x1, S32 y1, S32 x2, S32 y2, gdi_handle layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32                 start_x, start_y, end_x, end_y;
    S32                 layer_clip_x1, layer_clip_y1, layer_clip_x2, layer_clip_y2;
    rect_struct         clip_rect = {INVALID_RECT, INVALID_RECT, INVALID_RECT, INVALID_RECT};
    gdi_layer_struct    *layer_struct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    layer_struct = (gdi_layer_struct*)layer;

    /* get active layer clip */
    layer_clip_x1 = (S32)layer_struct->clipx1;
    layer_clip_y1 = (S32)layer_struct->clipy1;
    layer_clip_x2 = (S32)layer_struct->clipx2;
    layer_clip_y2 = (S32)layer_struct->clipy2;

    /* check if the draw rect is out of the clip */
    if ((x1 > layer_clip_x2) || (y1 > layer_clip_y2) || (x2 < layer_clip_x1) || (y2 < layer_clip_y1))
    {
        return clip_rect;
    }

    /* calculate the overlapped rect */
    start_y = MAX(y1, layer_clip_y1);
    end_y = MIN(y2, layer_clip_y2);
    start_x = MAX(x1, layer_clip_x1);
    end_x = MIN(x2, layer_clip_x2);

    clip_rect.x1 = start_x;
    clip_rect.y1 = start_y;
    clip_rect.x2 = end_x;
    clip_rect.y2 = end_y;

    return clip_rect;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_layer_copy
 * DESCRIPTION
 *  Copy a rect between the source and destination layer. This function supports
 *  16, 24, and 32 bpp only.
 * PARAMETERS
 *  x1          [IN]    x1 of the draw rect top-left point (x1, y1)
 *  y1          [IN]    y1 of the draw rect top-left point (x1, y1)
 *  x2          [IN]    x2 of the draw rect bottom-right point (x2, y2)
 *  y2          [IN]    y2 of the draw rect bottom-right point (x2, y2)
 *  dst_layer   [IN]    destination layer handle
 *  src_layer   [IN]    source layer handle
 * RETURNS
 *  void
 *****************************************************************************/
static void gdi_image_abm_layer_copy(S32 x1, S32 y1, S32 x2, S32 y2, gdi_handle dst_layer, gdi_handle src_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_layer_struct *dst, *src;
    S32     x, y;
    S32     src_line_jump_bytes, dst_line_jump_bytes;
    S32     line_size;
    S32     src_bpp, dst_bpp;
    S32     src_pixel_size, dst_pixel_size; 
    U8      *dst_line_p, *src_line_p;
    S32     line_width;
    U32     color_888;
    rect_struct clip_rect;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* remove a silly compiler warning */
    color_888 = 0;
    
    /* get clip rect */
    clip_rect = get_draw_rect_in_layer_clip(x1, y1, x2, y2, dst_layer);

    if (clip_rect.x1 == INVALID_RECT)
    {
        return;
    }

    x1 = clip_rect.x1;
    y1 = clip_rect.y1;
    x2 = clip_rect.x2;
    y2 = clip_rect.y2;

    /* get layer info */
    src = (gdi_layer_struct*)src_layer;
    dst = (gdi_layer_struct*)dst_layer;

    src_bpp = src->bits_per_pixel;
    dst_bpp = dst->bits_per_pixel;

    src_pixel_size = src_bpp / 8;
    dst_pixel_size = dst_bpp / 8;

    src_line_jump_bytes = src->width * src_pixel_size;
    dst_line_jump_bytes = dst->width * dst_pixel_size;

    src_line_p = src->buf_ptr + src_line_jump_bytes * (y1 + g_abm_src_layer_offset_y) + (x1 + g_abm_src_layer_offset_x) * src_pixel_size;
    dst_line_p = dst->buf_ptr + dst_line_jump_bytes * y1 + x1 * dst_pixel_size;

    line_width = x2 - x1 + 1;
    
    /* do layer copy */
    if (MAIN_BASE_LAYER_IS_16_BIT || (src->bits_per_pixel == dst->bits_per_pixel))
    {   /* same pixel format, memcpy line by line */
        line_size = line_width * src_pixel_size;

        for (y = y2 - y1; y >= 0; y--)
        {
            memcpy(dst_line_p, src_line_p, line_size);

            src_line_p += src_line_jump_bytes;
            dst_line_p += dst_line_jump_bytes;            
        }
    }
    else
    {   /* different pixel format: 16->24, 16->32, 24->16, 24->32, 32->16, 32->24 */
        // TODO: MORE OPTIMIZATION IS REQUIRED.
        src_line_jump_bytes -= line_width * src_pixel_size;
        dst_line_jump_bytes -= line_width * dst_pixel_size;

        for (y = y2 - y1; y >= 0; y--)
        {
            for (x = x2 - x1; x >= 0; x--)
            {
                ABM_READ_PIXEL(src_line_p, color_888, src_bpp);
                ABM_PUT_PIXEL(dst_line_p, color_888, dst_bpp);

                src_line_p += src_bpp / 8;
                dst_line_p += dst_bpp / 8;
            }
            
            src_line_p += src_line_jump_bytes;
            dst_line_p += dst_line_jump_bytes;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_pre_process
 * DESCRIPTION
 *  parse ABM header and calculate necessary data for the core decoder
 * PARAMETERS
 *  offset_x       [IN]     x offset to draw
 *  offset_y       [IN]     y offset to draw
 *  abm_data_ptr   [IN]     pointer to ABM data
 *  abm            [IN]
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
static S32 gdi_image_abm_pre_process(int offset_x, int offset_y, U8 *abm_data_ptr, abm_info_struct *abm)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8      *abm_bitstream_ptr;
    U32     img_w, img_h, color_num;
    
    U32     bpp;
    U8      *src_mem_ptr, *out_mem_ptr;

    U32     line_jump_pixel_num;
    U32     abm_start_pixel_offset;
    
    U16     *abm_data_16_ptr;

    S32     layer_width;
    S32     x1, x2, y1, y2;

    S32     start_x, start_y, end_x, end_y;
    S32     clip_width, clip_height;

    U32     alpha_color_start_index;
    U8      *alpha_ptr;
    U32     alpha_color_num;
    U32     normal_color_num;
    U32     palette_bpp;

    U32     dst_byte_per_pixel, src_byte_per_pixel;
    
    rect_struct clip_rect;

    U32     bb_w1, bb_h1, bb_w2, bb_h2;

    gdi_layer_struct    *src_layer;
    gdi_handle          dst_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    src_layer = (gdi_layer_struct*)g_abm_src_layer_handle;
    gdi_layer_get_active(&dst_layer);
    
    dst_byte_per_pixel = gdi_layer_get_bit_per_pixel() / 8;
    src_byte_per_pixel = src_layer->bits_per_pixel / 8;

    abm->src_bpp = src_byte_per_pixel * 8;
    abm->dst_bpp = dst_byte_per_pixel * 8;

    /* 
     * parse ABM header 
     */
    abm_data_16_ptr = (U16*)abm_data_ptr;
    img_w = abm_data_16_ptr[0];
    img_h = abm_data_16_ptr[1];   
    
    /* bit 15 for palette type. 0: 16-bit. 1: 24-bit. */
    if (img_h & 0x8000)
    {
        palette_bpp = 24;
    }
    else
    {
        palette_bpp = 16;
    }

    abm->palette_bpp = palette_bpp;

    img_h &= 0x7FFF;

    /* discard empty images (only possible from the GDI ABM font and wrong image) */
    if (!img_w || !img_h)
    {       
        return GDI_FAILED;
    }

    /* get color number */    
    normal_color_num = abm_data_16_ptr[2];
    alpha_color_num = abm_data_16_ptr[3];
    abm->alpha_color_num = alpha_color_num;
    
    color_num = normal_color_num + alpha_color_num;
    alpha_color_start_index = normal_color_num;

    /* get image bounding box */
    bb_w1 = abm_data_16_ptr[4] & 0xFF;
    bb_w2 = abm_data_16_ptr[5] & 0xFF;

    bb_h1 = abm_data_16_ptr[4] >> 8;
    bb_h2 = abm_data_16_ptr[5] >> 8;

    /* fill 4 transparent rects outside the bounding box for alpha images */
    if (alpha_color_num && (g_abm_src_layer_handle != dst_layer) && (bb_w1 || bb_w2 || bb_h1 || bb_h2))
    {
        x1 = offset_x;
        y1 = offset_y;
        x2 = x1 + img_w - 1;
        y2 = y1 + img_h - 1;

        gdi_image_abm_layer_copy(x1, y1, x2, y1 + bb_h1 - 1, dst_layer, g_abm_src_layer_handle);        
        gdi_image_abm_layer_copy(x1, y2 - bb_h2 + 1, x2, y2, dst_layer, g_abm_src_layer_handle);
        gdi_image_abm_layer_copy(x1, y1 + bb_h1, x1 + bb_w1 - 1, y2 - bb_h2, dst_layer, g_abm_src_layer_handle);
        gdi_image_abm_layer_copy(x2 - bb_w2 + 1, y1 + bb_h1, x2, y2 - bb_h2, dst_layer, g_abm_src_layer_handle);
    }

    /* 
     * calculate the bounding box rect
     */
    offset_x += bb_w1;
    img_w -= bb_w1 + bb_w2;

    offset_y += bb_h1;
    img_h -= bb_h1 + bb_h2;

    x1 = offset_x;
    y1 = offset_y;
    x2 = x1 + img_w - 1;
    y2 = y1 + img_h - 1;

    /* get active layer information */
    layer_width = GDI_LAYER.width;
    clip_rect = get_draw_rect_in_layer_clip(x1, y1, x2, y2, dst_layer);

    /* if out of clip, simply return without drawing */
    if (clip_rect.x1 == INVALID_RECT)
    {       
        return GDI_FAILED;
    }
    
    /* acquire overlapped rect */
    start_x = clip_rect.x1;
    start_y = clip_rect.y1;
    end_x = clip_rect.x2;
    end_y = clip_rect.y2;
    
    /* get clip width and height */
    clip_width = end_x - start_x + 1;
    clip_height = end_y - start_y + 1;
    abm->r8 = ((clip_width - 1) << 16) | clip_height;

    /* get BITS per pixel */
    bpp = log2_ceiling(color_num);    
    abm->bpp = bpp;    

    /* R9: bit[31:28] 4-bit BPP, bit[27:16] 12-bit ALPHA_CI_START, bit[15:0] BPP_BIT_MASK */
    abm->r9 = (bpp << 28) | (alpha_color_start_index << 16) | ((1 << bpp) - 1);
                    
    /* color 0 is not stored in ABM, so we have to decrease 1 palette size */
    abm->palette_ptr = (U8*)abm_data_16_ptr + 12 - (palette_bpp / 8);

    alpha_ptr = abm->palette_ptr + color_num * (palette_bpp / 8);
    abm->r10 = (U32)alpha_ptr;
    
    abm_bitstream_ptr = alpha_ptr + alpha_color_num;

    /* the bitstream is 2-byte aligned, so there might be one-byte padding */
    if ((U32)abm_bitstream_ptr & 1)
    {
        abm_bitstream_ptr++;
    }   

    abm->abm_bitstream_ptr = abm_bitstream_ptr;

    /*
     * setup variables required by ABM decoder
     */
    /* get the ABM start offset relative to the first pixel */
    abm_start_pixel_offset = start_x - x1 + (start_y - y1) * img_w;
    abm->abm_start_bit_offset = abm_start_pixel_offset * bpp;
        
    /* bits to skipped for a line jump of the source ABM */
    abm->abm_line_jump_bits = (img_w - clip_width) * bpp;
    
    line_jump_pixel_num = layer_width - clip_width;

    /* line jump bytes of the source and destination layer */
    abm->src_line_jump_bytes = line_jump_pixel_num * src_byte_per_pixel;
    abm->dst_line_jump_bytes = line_jump_pixel_num * dst_byte_per_pixel;
    
    /* combine seek bits and jump pixel number into the same register */
    abm->r11 = abm->abm_line_jump_bits + (abm->dst_line_jump_bytes << 16);

    /* intialize source and destination memory pointer */            
    src_mem_ptr = (U8*)src_layer->buf_ptr;
    out_mem_ptr = (U8*)GDI_LAYER.buf_ptr;

    /* set memory pointers to the start pixel */
    out_mem_ptr += (start_y * layer_width + start_x) * dst_byte_per_pixel;
    src_mem_ptr += ((start_y + g_abm_src_layer_offset_y) * layer_width + start_x + g_abm_src_layer_offset_x) * src_byte_per_pixel;

    abm->src_mem_ptr = src_mem_ptr;
    abm->out_mem_ptr = out_mem_ptr;
    
    return GDI_SUCCEED;
}


/*
 * optimization for time
 */
#ifdef __MTK_TARGET__
#pragma Otime
#pragma arm section code = "INTERNCODE"
#endif


/*****************************************************************************
 * FUNCTION
 *  rgb565_to_rgb888
 * DESCRIPTION
 *  convert RGB565 to RGB888
 * PARAMETERS
 *  p       [IN]    RGB565 pixel
 * RETURNS
 *  24-bit RGB888 pixel
 *****************************************************************************/
#ifdef GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888
static U32 rgb565_to_rgb888(U32 p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32     result;
    U32     c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 
     * a higher quality version to avoid the faint green in stead of speed.
     * and also recover the perfect white.
     *
     * rrrrrggggggbbbbb => rrrrrRRRggggggGGbbbbbBBB     
     * RRR = R5[2:0]
     *  GG = G6[1:0]
     * BBB = B5[2:0]
     */
    c = B_OF_RGB565(p);
    result = (c << 3) | (c & 0x7); 
    c = G_OF_RGB565(p);
    result += ((c << 2) | (c & 0x3)) << 8;
    c = R_OF_RGB565(p);
    result += ((c << 3) | (c & 0x7)) << 16;

    return result;
}
    

#else /* GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888 */

static U32 rgb565_to_rgb888(U32 p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32     result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* extend p's B[4:0] to result B[7:0] */
    result = B_OF_RGB565(p) << (0 + 3);

    /* extend p's G[10:5] to result G[15:8] */
    result += G_OF_RGB565(p) << (8 + 2);

    /* extend p's R[15:11] to result R[23:16] */
    result += R_OF_RGB565(p) << (16 + 3);
    
    return result;
}


#endif /* GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888 */


/*****************************************************************************
 * FUNCTION
 *  rgb888_to_rgb565
 * DESCRIPTION
 *  convert RGB888 to RGB565
 * PARAMETERS
 *  p       [IN]    RGB888 pixel
 * RETURNS
 *  16-bit RGB565 pixel
 *****************************************************************************/
static U32 rgb888_to_rgb565(U32 p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32     result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reduce p's B[7:0] to result[4:0] */
    result = B_OF_RGB888(p) >> 3;

    /* reduce p's G[15:8] to result[10:5] */
    result += (G_OF_RGB888(p) >> 2) << 5;

    /* reduce p's R[15:8] to result[15:11] */
    result += (R_OF_RGB888(p) >> 3) << 11;

    return result;
}


#if !MAIN_BASE_LAYER_IS_16_BIT

/*****************************************************************************
 * FUNCTION
 *  alpha_blend_24bit_pixel
 * DESCRIPTION
 *  alpha blend two RGB888 or ARGB8888 pixels.
 *
 *  If the output format is ARGB8888, ARGB's A is set to 255 later in PUT_PIXEL_32().
 *
 *  result pixel = src_pixel * alpha / 256 + img_pixel
 *
 * PARAMETERS
 *  src_pixel       [IN]    source pixel
 *  img_pixel       [IN]    ABM image pixel RGB565 (pre-calculated)
 *  alpha           [IN]    alpha value for the source pixel (0 ~ 255)
 * RETURNS
 *  24-bit pixel or 32-bit pixel (A is untouched)
 *****************************************************************************/
static U32 alpha_blend_24bit_pixel(U32 src_pixel, U32 img_pixel, U32 alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32     src_r, src_g, src_b, result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = img_pixel;
    
#ifdef GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888

    /* 
     * Do saturation check for high quality 16-bit to 24-bit since
     * the LSBs are not 0s.
     */
     
    /* R */    
    src_r = R_OF_RGB888(src_pixel);
    src_r = (src_r * alpha) >> 8;
    src_r += R_OF_RGB888(img_pixel);
    if (src_r > 255)
    {
        src_r = 255;
    }    
    result = src_r << 16;

    /* G */
    src_g = G_OF_RGB888(src_pixel);
    src_g = (src_g * alpha) >> 8; 
    src_g += G_OF_RGB888(img_pixel);
    if (src_g > 255)
    {
        src_g = 255;
    }     
    result += src_g << 8;

    /* B */
    src_b = B_OF_RGB888(src_pixel);
    src_b = (src_b * alpha) >> 8;
    src_b += B_OF_RGB888(img_pixel);
    if (src_b > 255)
    {
        src_b = 255;
    }
    result += src_b;

#else /* GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888 */
   
    /* R */
    src_r = R_OF_RGB888(src_pixel);
    src_r = (src_r * alpha) >> 8;    
    result += src_r << 16;               /* align to R of img_pixel */

    /* G */
    src_g = G_OF_RGB888(src_pixel);
    src_g = (src_g * alpha) >> 8;               
    result += src_g << 8;                /* align to G of img_pixel */

    /* B */
    src_b = B_OF_RGB888(src_pixel);
    src_b = (src_b * alpha) >> 8;
    result += src_b;                     /* align to B of img_pixel */

#endif /* GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888 */

    return result;
}

#else /* !MAIN_BASE_LAYER_IS_16_BIT */

/*****************************************************************************
 * FUNCTION
 *  alpha_blend_16bit_pixel
 * DESCRIPTION
 *  alpha blend 2 16-bit pixels (RGB565 or RGB3553)
 *
 *  result pixel = src_pixel * alpha / 256 + img_pixel
 *
 *  THE RGB565 or RGB3553 CODE PATH IS DECIDED AT COMPILE TIME.
 *  Only 6205B and 6218 utilize RGB3553.
 *
 * PARAMETERS
 *  src_pixel       [IN]    source pixel
 *  img_pixel       [IN]    ABM image pixel (pre-calculated)
 *  alpha           [IN]    alpha value for the source pixel (0 ~ 255)
 * RETURNS
 *  16-bit pixel
 *****************************************************************************/
static U32 alpha_blend_16bit_pixel(U32 src_pixel, U32 img_pixel, U32 alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32 c;
    U32 src_r, src_g, src_b;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* combined two 16-bit pixels into one 32-bit register to save register usage */
    c = (src_pixel << 16) | img_pixel;

    if (RGB_16_BIT_TYPE == COLOR_FORMAT_RGB565)
    {   /* RGB 565 path */
        /* R */
        src_r = R_OF_HIGH_RGB565(c);                   
        c += ((src_r * alpha) >> 8) << 11;  /* align to R of img_pixel */

        /* G */
        src_g = G_OF_HIGH_RGB565(c);
        c += ((src_g * alpha) >> 8) << 5;   /* align to G of img_pixel */

        /* B */
        src_b = B_OF_HIGH_RGB565(c);
        c += (src_b * alpha) >> 8;          /* align to B of img_pixel */
    }
    else 
    {   /* RGB 3553 path, {Gl, B, R, Gh} */                   
        /* B */                
        src_b = (c << 3) >> 27;
        c += ((src_b * alpha) >> 8) << 8;

        /* R */
        src_r = (c << 8) >> 27;
        c += ((src_r * alpha) >> 8) << 3;

        /* G */                 
        src_g = (c >> 29) << 26;
        alpha |= src_g;             /* Gl at alpha[28:26] */
        src_g = (c >> 16) << 29;
        alpha |= src_g;             /* Gh at alpha[31:29] */                    
        src_g = alpha >> 26;        /* src_g = {Gh[2:0], Gl[2:0]} */

        src_g = ((src_g * alpha) >> 8) << 13;   /* G at alpha[31:26] does not affect the result */

        c = (c << 16) >> 16;        /* clear source pixel in c */

        c += src_g;                 /* add Gl */                         
        c += c >> 16;               /* add Gh */
    }   

    return c;
}


#endif /* !MAIN_BASE_LAYER_IS_16_BIT */


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw
 * DESCRIPTION
 *  draw ABM image on the current active layer
 * PARAMETERS
 *  offset_x       [IN]     x offset to draw
 *  offset_y       [IN]     y offset to draw
 *  abm_data_ptr   [IN]     pointer to ABM data
 *  abm_bs_ptr          [IN]     pointer to ABM bitstream data (NULL for normal image mode)
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_draw(S32 offset_x, S32 offset_y, U8 *abm_data_ptr, U8 *abm_bs_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U8      *abm_bitstream_ptr;
    
    U32     p;
    
    U32     bpp;
    U8      *src_mem_ptr, *out_mem_ptr;
    
    S32     x, y; 

    U32     abm_line_jump_bits;
    U32     abm_start_bit_offset;
    
    U8      *palette_ptr;
    U32     palette_bpp;

    U32     alpha_color_num;

    S32     color_index;
    U32     img_pixel;
    U32     alpha;

    U32     dst_bpp, src_bpp;
    U32     src_pixel, out_pixel;

    U32     src_line_jump_bytes, dst_line_jump_bytes;
    
    abm_info_struct abm;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    /* remove a silly compiler warning */
    src_pixel = 0;
    
    /* save r8 to r11 */
    SAVE_REGISTER();
    
    /* return when out of clip */
    if (gdi_image_abm_pre_process(offset_x, offset_y, abm_data_ptr, &abm) == GDI_FAILED)
    {
        return GDI_SUCCEED;
    }
    
    /* set variables by abm_pre_process() */
    set_r8(abm.r8);
    set_r9(abm.r9);
    set_r10(abm.r10);
    set_r11(abm.r11);

    palette_ptr = abm.palette_ptr;
    set_r12((U32)palette_ptr);

    palette_bpp = abm.palette_bpp;

    abm_start_bit_offset = abm.abm_start_bit_offset;
    dst_bpp = abm.dst_bpp;
    src_bpp = abm.src_bpp;
    alpha_color_num = abm.alpha_color_num;
    src_mem_ptr = abm.src_mem_ptr;
    out_mem_ptr = abm.out_mem_ptr;
    src_line_jump_bytes = abm.src_line_jump_bytes;
    dst_line_jump_bytes = abm.dst_line_jump_bytes;
    abm_line_jump_bits = abm.abm_line_jump_bits;
    bpp = abm.bpp;

    /* The header and bitstream are not continuous for font engine. */
    if (abm_bs_ptr)
    {
        abm_bitstream_ptr = abm_bs_ptr;
    }
    else
    {
        abm_bitstream_ptr = abm.abm_bitstream_ptr;
    }

    /* initialize bitstream reader */
    BIT_INIT(abm_bitstream_ptr);

    /* seek to the start pixel */
    BIT_SEEK(abm_start_bit_offset);

    /*
     * ABM decoding loop
     */
#if MAIN_BASE_LAYER_IS_16_BIT

    if (alpha_color_num == 0)
    {   /* ABM without alpha */
        ABM_DECODER_WITHOUT_ALPHA(16);
    }
    else
    {   /* ABM with alpha */
        ALPHA_ABM_DECODER(16, 16);
    }

#elif MAIN_BASE_LAYER_IS_24_BIT /* MAIN_BASE_LAYER_IS_16_BIT */

/* 
 * A dirty fix to use 16-bit bitmap palette under 24-bit for 16-bit ABM images in system themes.
 * The performance hit is somewhat not acceptable, I think.
 */
// TODO: SHOULD FORCE 24-BIT ABM IMAGES IN SYSTEM THEMES
#undef ABM_GET_IMG_PIXEL
#define ABM_GET_IMG_PIXEL(palette_ptr, color_index) \
    ((palette_bpp == 16) ? rgb565_to_rgb888(GET_PALETTE_COLOR_16(palette_ptr, color_index)) : GET_PALETTE_COLOR_24(palette_ptr, color_index))

    if (alpha_color_num == 0)
    {   /* ABM without alpha */
        if (dst_bpp == 24)
        {
            ABM_DECODER_WITHOUT_ALPHA(24);
        }
        else
        {
            ABM_DECODER_WITHOUT_ALPHA(16);
        }            
    }
    else
    {   /* ABM with alpha */
        if ((src_bpp == 16) && (dst_bpp == 24))
        {   /* the most common case: src 16 bpp, target 24 bpp */
            ALPHA_ABM_DECODER(16, 24); 
        }
        else
        {
            ALPHA_ABM_DECODER(src_bpp, dst_bpp);
        }            
    }

#else /* MAIN_BASE_LAYER_IS_16_BIT */

    if (alpha_color_num == 0)
    {   /* ABM without alpha */
        if (dst_bpp == 32)
        {
            ABM_DECODER_WITHOUT_ALPHA(32);
        }
        else
        {   /* 24-bit or 16-bit target layer */
            ABM_DECODER_WITHOUT_ALPHA(dst_bpp);
        }            
    }
    else
    {   /* ABM with alpha */
        if ((src_bpp == 16) && (dst_bpp == 32))
        {   /* the most common case: src 16 bpp, target 32 bpp */
            ALPHA_ABM_DECODER(16, 32);
        }
        else
        {
            ALPHA_ABM_DECODER(src_bpp, dst_bpp);
        }            
    }

#endif /* MAIN_BASE_LAYER_IS_16_BIT */

    /* close bitstream reader */
    BIT_END();

    /* restore r8 to r11 */
    RESTORE_REGISTER();
    
    return GDI_SUCCEED;    
}


/*
 * optimization for space
 */
#ifdef __MTK_TARGET__

#pragma Ospace
#pragma arm section code

#endif


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abmp_draw_file
 * DESCRIPTION
 *  draw ABM image on the current active layer from a file 
 * PARAMETERS
 *  offset_x       [IN]     x offset to draw
 *  offset_y       [IN]     y offset to draw
 *  filename       [IN]     filename
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_draw_file(S32 offset_x, S32 offset_y, S8 *filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE   abm_file_handle;
    U32         read_len;
    U32         file_size;
    U32         file_buffer_size;
    PU8         file_buf_p;
    MMI_BOOL    use_med_memory;

    GDI_RESULT  ret;
     
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef GDI_USING_LCD_WORK_BUFFER
    file_buffer_size = GDI_GIF_TREE_SIZE;
    file_buf_p = (PU8)GDI_TREE_BUFFER;
#else /* GDI_USING_LCD_WORK_BUFFER */
    file_buffer_size = gdi_work_buffer_size;
    file_buf_p = (PU8)gdi_work_buffer;
#endif /* GDI_USING_LCD_WORK_BUFFER */

    abm_file_handle = FS_Open((U16*)filename, FS_READ_ONLY | FS_OPEN_NO_DIR);
    
    if (abm_file_handle < 0)
    {
        return GDI_FAILED;
    }    

    /* check file size */
    if ((FS_GetFileSize(abm_file_handle, &file_size) < 0))
    {
        FS_Close(abm_file_handle);

        return GDI_FAILED;
    }

    /* The file buffer is not enough. Try to use media task memory for the last effort.*/   
    use_med_memory = MMI_FALSE;   
    if (file_buffer_size < file_size)
    {
        use_med_memory = MMI_TRUE;        
        file_buf_p = (PU8)med_alloc_ext_mem(file_size);
        if (file_buf_p == NULL)
        {
            return GDI_FAILED;
        }        
    }
    
    /* read whole file into the file buffer once (fastest and easiest) */
    if (FS_Read(
            abm_file_handle, 
            file_buf_p, 
            file_size, 
            &read_len) < 0)
    {
        FS_Close(abm_file_handle);
        
        return GDI_FAILED;
    }

    FS_Close(abm_file_handle);

    /* draw ABM from memory */
    ret = gdi_image_abm_draw(
            offset_x, 
            offset_y, 
            (U8*)file_buf_p, 
            NULL);    

    /* free the media memory if it is used */
    if (use_med_memory)
    {
        med_free_ext_mem((void**)&file_buf_p);
    }

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_dimension_mem
 * DESCRIPTION
 *  get ABM dimension from memory
 * PARAMETERS
 *  data_ptr       [IN]     pointer to image data  
 *  width          [OUT]    image width
 *  height         [OUT]    image height
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED      
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_get_dimension_mem(U8 *data_ptr, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16    *mem16_ptr;
     
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mem16_ptr = (U16*)data_ptr;

    *width = mem16_ptr[0];              /* width:  byte 0 and 1 */
    *height = mem16_ptr[1] & 0x7FFF;    /* height: byte 2 and 3. Bit 15 is palette type. */

    return GDI_SUCCEED;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_dimension_file
 * DESCRIPTION
 *  get ABM dimension from a file
 * PARAMETERS
 *  filename       [IN]     filename  
 *  width          [OUT]    image width
 *  height         [OUT]    image height
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_get_dimension_file(S8 *filename, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE   abm_file_handle;
    U32         read_len;
    U8          buf[4];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* open file */
    abm_file_handle = FS_Open((U16*)filename, FS_READ_ONLY | FS_OPEN_NO_DIR);
    
    if (abm_file_handle < 0)
    {
        return GDI_FAILED;
    }

    /* read 4 bytes for width and height from the file */
    if (FS_Read(abm_file_handle, buf, 4, &read_len) != FS_NO_ERROR)
    {
        return GDI_FAILED;
    }

    /* close file */
    FS_Close(abm_file_handle);

    /* call get dimension from memory */
    return gdi_image_abm_get_dimension_mem(buf, width, height);
}

 
/***************************************************************************** 
 * Global Function 
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_handler
 * DESCRIPTION
 *  handler to draw ABM
 * PARAMETERS
 *  flag            [IN]    image resource flag    
 *  frame_pos       [IN]    frame number
 *  x               [IN]    x
 *  y               [IN]    y
 *  w               [IN]    width
 *  h               [IN]    height
 *  data_ptr        [IN]    pointer to image data
 *  img_size        [IN]    image size
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
GDI_RESULT gdi_image_abm_draw_handler(
            U32 flag, 
            U32 frame_pos, 
            S32 x, 
            S32 y, 
            S32 w, 
            S32 h, 
            U8 *data_ptr, 
            U32 img_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8      *filename;
    U8      dst_byte_per_pixel;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (flag & GDI_IMAGE_CODEC_FLAG_IS_FILE)
    {
        filename = (S8*)data_ptr;
        
        return gdi_image_abm_draw_file(x, y, filename);    
    }
    else
    {
        /* 
         * make sure 1. The image data pointer is not NULL and half word aligned.
         *           2. The destination layer color format is 16, 24, or 32-bit.
         *           3. g_abm_src_layer_handle is properly intialized.
         */
        dst_byte_per_pixel = gdi_layer_get_bit_per_pixel() / 8;

        if ((data_ptr == NULL) || ((U32)data_ptr & 1) || (dst_byte_per_pixel < 2) || 
            (g_abm_src_layer_handle == GDI_ERROR_HANDLE))
        {
            return GDI_FAILED;
        }        

        return gdi_image_abm_draw(x, y, data_ptr, NULL);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_dimension_handler
 * DESCRIPTION
 *  handler to get ABM dimension
 * PARAMETERS
 *  flag            [IN]   image resource flag     
 *  data_ptr        [IN]   pointer to image data      
 *  img_size        [IN]   image size        
 *  width           [OUT]  image width        
 *  height          [OUT]  image height       
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
GDI_RESULT gdi_image_abm_get_dimension_handler(
            U32 flag, 
            U8 *data_ptr, 
            U32 img_size, 
            S32 *width, 
            S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8      *filename;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (flag & GDI_IMAGE_CODEC_FLAG_IS_FILE)
    {
        filename = (S8*)data_ptr;
        
        return gdi_image_abm_get_dimension_file(filename, width, height);
    }
    else
    {
        return gdi_image_abm_get_dimension_mem(data_ptr, width, height);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_set_source_layer
 * DESCRIPTION
 *  set ABM alpha blending source layer
 * PARAMETERS
 *  src_layer_handle       [IN] gdi handle of the source layer
 * RETURNS
 *  gdi_handle  old source layer handle
 *****************************************************************************/
gdi_handle gdi_image_abm_set_source_layer(gdi_handle src_layer_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle  old_src_layer_handle;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_LOCK;
    
    old_src_layer_handle = g_abm_src_layer_handle;
    g_abm_src_layer_handle = src_layer_handle;  
    
    GDI_UNLOCK;

    return old_src_layer_handle;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_source_layer
 * DESCRIPTION
 *  get ABM alpha blending source layer
 * PARAMETERS
 *  src_layer_handle       [OUT] gdi handle of the source layer
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_image_abm_get_source_layer(gdi_handle *src_layer_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_LOCK;
    
    *src_layer_handle = g_abm_src_layer_handle;
    
    GDI_UNLOCK;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_set_source_layer_position
 * DESCRIPTION
 *  set the source layer offset
 * PARAMETERS
 *  offset_x       [IN]     x offset
 *  offset_y       [IN]     y offset
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_image_abm_set_source_layer_position(S32 offset_x, S32 offset_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_LOCK;
    
    g_abm_src_layer_offset_x = offset_x;
    g_abm_src_layer_offset_y = offset_y;

    GDI_UNLOCK;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_source_layer_position
 * DESCRIPTION
 *  get the source layer offset
 * PARAMETERS
 *  offset_x       [OUT]    x offset
 *  offset_y       [OUT]    y offset
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_image_abm_get_source_layer_position(S32 *offset_x, S32 *offset_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_LOCK;
    
    *offset_x = g_abm_src_layer_offset_x;
    *offset_y = g_abm_src_layer_offset_y;

    GDI_UNLOCK;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_font
 * DESCRIPTION
 *  Draw a 1-bit bitmap font by the ABM decoder
 * PARAMETERS
 *  offset_x             [IN]   x offset
 *  offset_y             [IN]   y offset
 *  abm_header_ptr       [IN]   ABM header
 *  font_data            [IN]   font data
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_image_abm_draw_font(S32 offset_x, S32 offset_y, U8 *abm_header_ptr, U8 *font_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_image_abm_draw(offset_x, offset_y, abm_header_ptr, font_data);
}

