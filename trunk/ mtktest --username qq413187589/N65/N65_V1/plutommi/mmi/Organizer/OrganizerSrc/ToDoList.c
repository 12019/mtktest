/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * ToDoList.c
 *
 * Project:
 * --------
 * MAUI
 *
 * Description:
 * ------------
 * This file implements To Do List application.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
/**
 * Copyright Notice
 * ?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */
/**************************************************************

   FILENAME : ToDoList.c

   PURPOSE     : To Do List Application

   REMARKS     : nil

   AUTHOR      : Arvind

   DATE     : 29th Oct, 2003

**************************************************************/
#include "MMI_include.h"
#ifndef _MMI_TODOLIST_C
#define _MMI_TODOLIST_C

#ifdef __MMI_TODOLIST__

/*  Include: MMI header file */
#include "ProtocolEvents.h"
#include "CommonScreens.h"
#include "mainmenudef.h"
#include "DateTimeGprot.h"
#include "AlarmFrameworkProt.h"
#include "AlarmProt.h"
#include "ToDoListDef.h"
#include "ToDoListEnum.h"
#include "Nvram_enums.h"
#include "Organizerdef.h"
#include "AlarmGprot.h"
#include "gpioInc.h"
#include "ProfileGprots.h"
#include "WrapperGprot.h"
#include "vCalendar.h"
#include "vObjects.h"
#include "vCalendar.h"
#include "SimDetectionGexdcl.h"
#include "SimDetectionGprot.h"
#include "app_datetime.h"
#if defined (__MMI_CLNDR_ICON_SUPPORT__) || defined (__MMI_BIRTHDAY_REMINDER__)
#include "CalendarDef.h"
#endif 

#ifdef __MMI_BIRTHDAY_REMINDER__
#include "SMSapi.h"
#include "PhoneBookGprot.h"
#include "CallManagementGprot.h"
#include "wapadp.h"
#endif 

#ifdef __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__
#include "CalendarProt.h"

#endif /* __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__ */ 
#if (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT))
#include "JMMSGprot.h"
#endif 
#ifdef __J2ME__
#include "j2me_custom_option.h"
#if defined(SUPPORT_JSR_75_PIM)
#include "app_datetime.h"
#include "ToDoListDB.h"
#endif
#endif
/* SyncML */
#ifdef __SYNCML_SUPPORT__
#include "SyncMLDef.h"
#include "SyncMLGProt.h"
#endif /* __SYNCML_SUPPORT__ */ 
/*  Include: PS header file */
/* ... Add More PS header */

#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
#endif	/* __MMI_DUAL_SIM_MASTER__ */

#ifdef __MMI_UCM__
#include "UCMGProt.h"
#endif /*__MMI_UCM__*/
/* 
 * Define
 */
#ifdef __SYNCML_SUPPORT__
#define TDL_SYNCML_EMOME_SERVER "sync.emome.net"
#endif
/* 
 * Typedef 
 */

tdl_context_struct g_tdl_cntx;

/* 
 * Local Variable
 */

// buffer used in inline editors */

/* 
 * Local Function
 */

/* 
 * Global Variable
 */
extern U8 gAlmDayOfWeek[];
S8 *gAlmOnOffStringforTDL[NUM_STATE_FOR_TDL];  /* array to store on/off state of an alarm */
extern U8 gAlmDaysStates[];
extern wgui_inline_item wgui_inline_items[];
/* Add yearly for Anniversary */
const U8 g_tdl_freq_set[TODO_FREQ_NUM + 1] =
    {ALM_FREQ_ONCE, ALM_FREQ_EVERYDAY, ALM_FREQ_DAYS, ALM_FREQ_WEEKLY, ALM_FREQ_MONTHLY, ALM_FREQ_YEARLY};
S8 gnoteString[MAX_TODO_LIST_NOTE];
U16 gTDLicon[NUM_OF_TDL];

#ifdef __MMI_ADVANCED_TODO__
S8 glocationString[MAX_TODO_LIST_NOTE];
S8 *gTdlPriorityString[NUM_OF_TASK_PRIORITY];   /* array to store on/off state of an alarm */
#endif /* __MMI_ADVANCED_TODO__ */ 
/* 
 * Global Function
 */
#ifdef __SYNCML_SUPPORT__
extern S32 mmi_vclndr_reader(S8 *file_path_name, ToDoListNode *TdlNode);
extern S32 mmi_vclndr_writer(ToDoListNode *TDLNode, S8 *file_path_name);
#endif
#ifdef __SYNCML_SUPPORT__
extern vclndr_context_struct g_vclndr_cntx;
#endif


/*****************************************************************************
 * FUNCTION
 *  InitToDoListApp
 * DESCRIPTION
 *  Set highlight handlers and retrieve data from NVRAM.
 *  Register key handlers.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitToDoListApp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetHiliteHandler(ORGANIZER_TODOLIST_MENU, HighlightTDLMenu);

    SetHiliteHandler(MITEM_TODO_LIST_VIEW, HighlightTdlView);
    SetHiliteHandler(MITEM_TODO_LIST_ADD, HighlightTdlAdd);
    SetHiliteHandler(MITEM_TODO_LIST_EDIT, HighlightTdlEdit);
    SetHiliteHandler(MITEM_TODO_LIST_DELETE, HighlightTdlDelete);
    SetHiliteHandler(MITEM_TODO_LIST_DELETE_ALL, HighlightTdlDeleteAll);

    SetHiliteHandler(MITEM_TODO_LIST_SAVE, mmi_tdl_highlight_hdlr_note_option_save);
    SetHiliteHandler(MITEM_TODO_LIST_USE_TEMPLATE, mmi_tdl_highlight_hdlr_note_option_template);
    SetHiliteHandler(MITEM_TODO_LIST_BOPOMOFO, mmi_tdl_highlight_hdlr_note_option_input_method);
    
#if defined(SUPPORT_JSR_75_PIM)
    mmi_tdl_evtdb_handler_init();
#endif

#ifdef __MMI_VCALENDAR__
    mmi_tdl_at_handler_init();
#endif    

#ifdef __MMI_ADVANCED_TODO__
    SetHiliteHandler(MITEM_TODO_LIST_MEETING, mmi_tdl_highlight_meeting);
    SetHiliteHandler(MITEM_TODO_LIST_COURSE, mmi_tdl_highlight_course);
    SetHiliteHandler(MITEM_TODO_LIST_DATE, mmi_tdl_highlight_date);
    SetHiliteHandler(MITEM_TODO_LIST_CALL, mmi_tdl_highlight_call);
    SetHiliteHandler(MITEM_TODO_LIST_ANNIVERSARY, mmi_tdl_highlight_anniversary);
    SetHiliteHandler(MITEM_TODO_LIST_REMINDER, mmi_tdl_highlight_reminder);
#endif /* __MMI_ADVANCED_TODO__ */ 

#ifdef __MMI_BIRTHDAY_REMINDER__
    SetHiliteHandler(MITEM_BIRTHDAY_OPTION_MAKE_CALL, mmi_birthday_highlight_make_call);
    SetHiliteHandler(MITEM_BIRTHDAY_OPTION_SEND_SMS, mmi_birthday_highlight_send_sms);
#ifdef MMS_SUPPORT
    SetHiliteHandler(MITEM_BIRTHDAY_OPTION_SEND_MMS, mmi_birthday_highlight_send_mms);
#endif /*# MMS_SUPPORT */
#endif /* __MMI_BIRTHDAY_REMINDER__ */ 
    TDLReadFromNvram();
}


/*****************************************************************************
 * FUNCTION
 *  TDLExpiryHandler
 * DESCRIPTION
 *  CallBack handler to execute todolist expiry.
 * PARAMETERS
 *  index           [IN]        
 *  period          [?]         
 *  power_on        [IN]        
 *  BOOL(?)         [IN]        Power status
 *  U8(?)           [IN]        Index of alarm item
 * RETURNS
 *  void
 *****************************************************************************/
U8 TDLExpiryHandler(U8 index, U16 *period, BOOL power_on)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryTDLReminder();
    *period = ALM_DEFAULT_EXPIRY_PERIOD;

    if (!power_on)
    {
        g_pwr_context.PowerOnMMIStatus = MMI_POWER_ON_IDLE; /* 0x80: Alarm idle screen */
    }
    return ALM_HAS_IND;
    
}


/*****************************************************************************
 * FUNCTION
 *  TDLExpiryTimeCBH
 * DESCRIPTION
 *  Callback handler to get information of todolist expiry setting.
 * PARAMETERS
 *  index           [IN]            
 *  alarmTime       [?]             
 *  Freq            [?]             
 *  WeekDays        [?]             
 *  MYTIME(?)       [IN/OUT]        Expiry time set by user
 *  U8(?)           [IN/OUT]        Expiry days of week
 * RETURNS
 *  void
 *****************************************************************************/
void TDLExpiryTimeCBH(U8 index, MYTIME *alarmTime, U8 *Freq, U8 *WeekDays, MYTIME *preReminder)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    mmi_tdl_compute_reminder_time(&g_tdl_cntx.TaskList[index], preReminder);
#endif 
    *alarmTime = g_tdl_cntx.TaskList[index].StartTime;
    *Freq = g_tdl_freq_set[g_tdl_cntx.TaskList[index].Repeat];
    *WeekDays = g_tdl_cntx.TaskList[index].Days;
}


/*****************************************************************************
 * FUNCTION
 *  TDLReInitQueueCBH
 * DESCRIPTION
 *  Reinit todolist to alarm queue
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLReInitQueueCBH(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME currTime;

#ifdef __MMI_ADVANCED_TODO__
    MYTIME alarmTime, incTime;
#endif 
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DTGetRTCTime(&currTime);

    for (i = 0; i < NUM_OF_TDL; i++)
    {
        if (g_tdl_cntx.TaskList[i].Present == 1 && g_tdl_cntx.TaskList[i].Alarm >= TODO_LIST_ALARM_ON)
        {
            if (g_tdl_freq_set[g_tdl_cntx.TaskList[i].Repeat] == ALM_FREQ_ONCE)
            {
            #ifdef __MMI_ADVANCED_TODO__
                memset(&incTime, 0, sizeof(MYTIME));
                memcpy(&alarmTime, &g_tdl_cntx.TaskList[i].StartTime, sizeof(MYTIME));
                mmi_tdl_compute_reminder_time(&g_tdl_cntx.TaskList[i], &incTime);
                applib_dt_decrease_time(
                    (applib_time_struct*) & alarmTime,
                    (applib_time_struct*) & incTime,
                    (applib_time_struct*) & alarmTime);
                if (CompareTime(alarmTime, currTime, NULL) == TIME_GREATER)
            #else /* __MMI_ADVANCED_TODO__ */ 
                if (CompareTime(g_tdl_cntx.TaskList[i].StartTime, currTime, NULL) == TIME_GREATER)
            #endif /* __MMI_ADVANCED_TODO__ */ 
                {
                    AlmInsertIntoQueue((U8) (i + ALM_TDL_START), FALSE);
                }
            }
            else
            {
                AlmInsertIntoQueue((U8) (i + ALM_TDL_START), FALSE);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  TDLFCBInit
 * DESCRIPTION
 *  Set callback function needed by alarm framework
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLFCBInit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_alm_set_start_index(ALM_TYPE_TDL, ALM_TDL_START);
    AlmSetExpiryTimeCB(ALM_TYPE_TDL, TDLExpiryTimeCBH);
    AlmSetExpiryHandlerCB(ALM_TYPE_TDL, TDLExpiryHandler);
    AlmSetInitHandlerCB(ALM_TYPE_TDL, InitToDoListApp, TDLReInitQueueCBH);
    AlmSetStopAlarmCB(ALM_TYPE_TDL, TDLExitReminderScreen);

}


/*****************************************************************************
 * FUNCTION
 *  HighlightTDLMenu
 * DESCRIPTION
 *  Highlight handler of To Do List menu item.
 *  Register key handlers.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTDLMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
    ChangeRightSoftkey(STR_GLOBAL_BACK, IMG_GLOBAL_BACK);
    SetLeftSoftkeyFunction(TDLShowAllList, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(TDLShowAllList, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  DeInitToDoListApp
 * DESCRIPTION
 *  Deinitialize To Do List application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DeInitToDoListApp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTDLTaskList
 * DESCRIPTION
 *  Highlight handler of to do list task list, store the index of selected task.
 * PARAMETERS
 *  nIndex      [IN]        Index of selected task.
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTDLTaskList(S32 nIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_BIRTHDAY_REMINDER__
    g_tdl_cntx.CurrSelectedTask = (U8) nIndex;
#else /* __MMI_BIRTHDAY_REMINDER__ */ 
    if (nIndex < g_tdl_cntx.TotalListedTask)
    {
        g_tdl_cntx.CurrSelectedTask = (U8) nIndex;
        ChangeLeftSoftkey(STR_GLOBAL_OPTIONS, IMG_GLOBAL_OPTIONS);
        SetLeftSoftkeyFunction(EntryTDLTaskListOption, KEY_EVENT_UP);
		if (g_tdl_cntx.IsCalledByCalender >= MMI_TRUE)
		{
			SetKeyHandler(mmi_tdl_get_next_day_redraw, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
			SetKeyHandler(mmi_tdl_get_previous_day_redraw, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
		}
		else
		{
			SetKeyHandler(mmi_tdl_task_list_goback, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
			SetKeyHandler(EntryTDLTaskListOption, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
		}
        /* Himanshu Fix MAUI_00228900 START */
    #if defined(__MMI_VCALENDAR__)
    #if (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT))
        if (mmi_jmms_is_from_jmms() > 0)
        {
            ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
            SetLeftSoftkeyFunction(mmi_jmms_insert_vcal_tdl, KEY_EVENT_UP);
            SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
            SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
            SetKeyHandler(NULL, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
        }
    #endif /* (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT)) */ 
    #endif	/* __MMI_VCALENDAR__ */
        /* Himanshu Fix MAUI_00228900 END */
    }
    else if (nIndex >= g_tdl_cntx.TotalListedTask &&
             nIndex < mmi_clndr_get_daily_birthday_amount(g_tdl_cntx.ClndrDate.nDay) + g_tdl_cntx.TotalListedTask)
    {
        SetLeftSoftkeyFunction(mmi_entry_birthday_option_screen, KEY_EVENT_UP);        
        g_tdl_cntx.CurrHighlightBRIndex = g_tdl_cntx.PBIndexList[nIndex - g_tdl_cntx.TotalListedTask];
		SetKeyHandler(mmi_tdl_get_next_day_redraw, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        
    #if !defined(__MMI_DUAL_SIM_MASTER__)
        if (mmi_bootup_is_sim_valid()
	#ifdef __FLIGHT_MODE_SUPPORT__
			&& mmi_bootup_get_active_flight_mode() == 0 /* in flight mode */
    #endif 
		)
    #else   /* __MMI_DUAL_SIM_MASTER__ */
/* under construction !*/
	#ifdef __FLIGHT_MODE_SUPPORT__
/* under construction !*/
        #endif 
/* under construction !*/
    #endif  /* __MMI_DUAL_SIM_MASTER__ */
        {            
            /* Himanshu Fix MAUI_00228900 START */
	 #if defined(__MMI_VCALENDAR__)
        #if (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT))
            if (mmi_jmms_is_from_jmms() > 0)
            {
                ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
                SetLeftSoftkeyFunction(mmi_jmms_insert_vcal_tdl, KEY_EVENT_UP);
                SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
            }
        #endif /* (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT)) */ 
	 #endif	/* __MMI_VCALENDAR__ */
            /* Himanshu Fix MAUI_00228900 END */
        }
    }
#endif /* __MMI_BIRTHDAY_REMINDER__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  TDLGetTotalItem
 * DESCRIPTION
 *  Get number of present task
 * PARAMETERS
 *  void
 * RETURNS
 *  number of task
 *****************************************************************************/
U8 TDLGetTotalItem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    U8 TotalItem = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < NUM_OF_TDL; i++)
        if (g_tdl_cntx.TaskList[i].Present == 1)
        {
            TotalItem++;
        }

    return TotalItem;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_task_list_goback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_task_list_goback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (IsScreenPresent(SCR_TDL_TASK_LIST))
    {
        if (g_tdl_cntx.CurrHiliteOption == TODO_LIST_TASK_OPTION_ADD && GetActiveScreenId() == SCR_TDL_TASK_EDIT)
        {
            /* Back to category selection screen */
            GoBackHistory();
        }
        else
        {
            GoBackToHistory(SCR_TDL_TASK_LIST);
        }
    }
#ifdef __MMI_ADVANCED_TODO__
    else if (IsScreenPresent(SCR_ID_CLNDR_SCREEN))
    {
        GoBackToHistory(SCR_ID_CLNDR_SCREEN);
    }
#endif /* __MMI_ADVANCED_TODO__ */ 
    else
    {
        GoBackHistory();
    }
}

#ifdef __MMI_ADVANCED_TODO__


/*****************************************************************************
 * FUNCTION
 *  EntryTDLTaskList
 * DESCRIPTION
 *  Entry function of To Do List application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLTaskList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    S32 TotalItem = 0;
    GetAsyncItemFuncPtr createMenuPtr;
    S8 datestring[CLNDR_DATE_STRING_LENGTH + 1];    /* yyyy/mm/dd */
#ifdef __MMI_BIRTHDAY_REMINDER__
    U16 bm;
    U8 pbNumber[MAX_PB_NUMBER_LENGTH + 1], pbName[(MAX_PB_NAME_LENGTH +1 )* ENCODING_LENGTH];
#endif     

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __SYNCML_SUPPORT__
        /* popup "please wait" when syncML is executing */
        if (mmi_syncml_is_tdl_sync_now())
        {
            DisplayPopup(
                (U8*) GetString(STR_ID_SYNC_PLEASE_WAIT),
                IMG_GLOBAL_PROGRESS,
                1,
                UI_POPUP_NOTIFYDURATION_TIME,
                (U8) WARNING_TONE);
                return;
        }
#endif

    EntryNewScreen(SCR_TDL_TASK_LIST, ExitTDLTaskList, EntryTDLTaskList, NULL);
    
#ifdef __MMI_ADVANCED_TODO__
    if (g_tdl_cntx.DateUpdate == 1)
    {
        if (IsScreenPresent(SCR_TDL_TASK_LIST))  
        {
            DeleteNScrId(SCR_TDL_TASK_LIST);
        }
    }
#endif /* __MMI_ADVANCED_TODO__ */ 

    memset(g_tdl_cntx.title, 0, (CLNDR_DATE_STRING_LENGTH + 1) * ENCODING_LENGTH);
#ifdef __MMI_BIRTHDAY_REMINDER__
    /* Since PBIndexList is screen based memory, it need to be searched for every time entering TDL daily view */
    if (g_tdl_cntx.IsCalledByCalender == CLNDR_MONTHLY_VIEW)
    {
        mmi_tdl_construct_birthday_memory();
        mmi_clndr_set_birthday_table(g_tdl_cntx.ClndrDate.nYear, g_tdl_cntx.ClndrDate.nMonth);
        bm = mmi_clndr_get_daily_birthday_amount(g_tdl_cntx.ClndrDate.nDay);

        memset(g_tdl_cntx.PBIndexList, 0, TDL_BIRTHDAY_INDEX_POOL);

        mmi_clndr_get_daily_birthday_info(
        g_tdl_cntx.ClndrDate.nYear,
        g_tdl_cntx.ClndrDate.nMonth,
        g_tdl_cntx.ClndrDate.nDay,
        bm,
        g_tdl_cntx.PBIndexList);
    }

#endif 

    if (g_tdl_cntx.IsListModified == TRUE)
    {
    #ifdef __MMI_CALENDAR_V2__
        if (g_tdl_cntx.IsCalledByCalender == CLNDR_MONTHLY_VIEW)        /* Match the Date and list them */
        {
            TDLMakeListOfSelectedDate(CLNDR_MONTHLY_VIEW);
        }
    #ifdef __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__
        else if (g_tdl_cntx.IsCalledByCalender == CLNDR_WEEKLY_VIEW)
        {
            mmi_tdl_get_period_task();
        }
    #endif /* __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__ */
    #else /* __MMI_CALENDAR_V2__ */ 
        if (g_tdl_cntx.IsCalledByCalender >= MMI_TRUE)
        {
            TDLMakeListOfSelectedDate(MMI_TRUE);
        }
    #endif /* __MMI_CALENDAR_V2__ */ 
        else    /* Set the Current Date and list the task in descending order. */
        {
            TDLMakeListOfAllTask();
        }
        g_tdl_cntx.IsListModified = FALSE;
    }

#ifdef __MMI_BIRTHDAY_REMINDER__
    if (g_tdl_cntx.IsCalledByCalender == CLNDR_MONTHLY_VIEW)
    {
		if (mmi_phb_get_name_number(0, pbName, pbNumber) == MMI_FALSE) /* Phonebook is not ready */
		{
			TotalItem = g_tdl_cntx.TotalListedTask;
		}
		else
		{
			TotalItem = g_tdl_cntx.TotalListedTask + mmi_clndr_get_daily_birthday_amount(g_tdl_cntx.ClndrDate.nDay);
		}
    }
    else
    {
        TotalItem = g_tdl_cntx.TotalListedTask;
    }
#else 
    TotalItem = g_tdl_cntx.TotalListedTask;
#endif 
    guiBuffer = GetCurrGuiBuffer(SCR_TDL_TASK_LIST);

    SetParentHandler(0);

    if (g_tdl_cntx.IsCalledByCalender >= MMI_TRUE)
    {
        mmi_tdl_get_date_string(
            g_tdl_cntx.ClndrDate.nYear,
            g_tdl_cntx.ClndrDate.nMonth,
            g_tdl_cntx.ClndrDate.nDay,
            datestring);
        createMenuPtr = mmi_tdl_get_daily_async_items;
        mmi_asc_to_ucs2(g_tdl_cntx.title, datestring);
        wgui_set_touch_title_bar_buttons();
    #ifdef __MMI_TOUCH_SCREEN__
            register_touch_button_handlers(mmi_tdl_get_previous_day_redraw, NULL, mmi_tdl_get_next_day_redraw, NULL);
    #endif        
    }
    else
    {
        createMenuPtr = mmi_tdl_get_all_async_items;
        mmi_ucs2cpy(g_tdl_cntx.title, GetString(STR_TODO_LIST_CAP_TASK_LIST));
    }

    RegisterHighlightHandler(HighlightTDLTaskList);

    if (TotalItem == 0) /* display <Empty> */
    {
        if (TDLGetTotalItem() == NUM_OF_TDL) /* happens in calendar */
        {            
           ShowCategory85Screen(
                (U8*) g_tdl_cntx.title,
                GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
                0, /* Not to display "Add" */
                0,
                STR_GLOBAL_BACK,
                0,
                TotalItem,
                createMenuPtr,
                NULL,
                0,
                IMG_GLOBAL_OK,
                IMG_GLOBAL_OK,
                guiBuffer);
        }
        else
        {
            ShowCategory85Screen(
                (U8*) g_tdl_cntx.title,
                GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
                STR_GLOBAL_ADD,
                0,
                STR_GLOBAL_BACK,
                0,
                TotalItem,
                createMenuPtr,
                NULL,
                0,
                IMG_GLOBAL_OK,
                IMG_GLOBAL_OK,
                guiBuffer);
        }

        g_tdl_cntx.CurrHiliteOption = TODO_LIST_TASK_OPTION_ADD;
    #ifdef __MMI_ADVANCED_TODO__
        SetLeftSoftkeyFunction(mmi_tdl_entry_select_task_type, KEY_EVENT_UP);
        SetKeyHandler(mmi_tdl_entry_select_task_type, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    #else /* __MMI_ADVANCED_TODO__ */ 
        SetLeftSoftkeyFunction(TdlExecEdit, KEY_EVENT_UP);
        SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    #endif /* __MMI_ADVANCED_TODO__ */ 

        /* if task full, disable LSK */
        if (g_tdl_cntx.IsCalledByCalender)
        {
            if (TDLGetTotalItem() == NUM_OF_TDL)
            {
                SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
                SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
            }

        }
    #if (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT))
        if (mmi_jmms_is_from_jmms() > 0)
        {
            ChangeLeftSoftkey(0, 0);
            SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
            SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
            SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
            SetKeyHandler(NULL, KEY_LEFT_ARROW, KEY_EVENT_DOWN);  
            return;
        }
    #endif /* (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT)) */ 
    }
    else    /* display list of task */
    {
        ShowCategory85Screen(
            (U8*) g_tdl_cntx.title,
            GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
            STR_GLOBAL_OPTIONS,
            0,
            STR_GLOBAL_BACK,
            0,
            TotalItem,
            createMenuPtr,
            NULL,
            0,
        IMG_TODO_LIST_ICON_REMINDER,
        IMG_TODO_LIST_ICON_ALARM,
            guiBuffer);

        //SetLeftSoftkeyFunction(EntryTDLTaskListOption, KEY_EVENT_UP);
        //SetKeyHandler(EntryTDLTaskListOption, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    #if defined(__MMI_VCALENDAR__)
    #if (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT))
        if (mmi_jmms_is_from_jmms() > 0)
        {
            ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
            SetLeftSoftkeyFunction(mmi_jmms_insert_vcal_tdl, KEY_EVENT_UP);
            SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
            SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
            SetKeyHandler(NULL, KEY_LEFT_ARROW, KEY_EVENT_DOWN); 
            return;
        }
    #endif /* (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT)) */ 
    #endif	/* __MMI_VCALENDAR__ */
    }

    /* Register function for right soft key */
    SetRightSoftkeyFunction(mmi_tdl_task_list_goback, KEY_EVENT_UP);
    SetKeyHandler(mmi_tdl_task_list_goback, KEY_LEFT_ARROW, KEY_EVENT_DOWN);

    if (g_tdl_cntx.IsCalledByCalender >= MMI_TRUE)
    {
        SetKeyHandler(mmi_tdl_get_next_day_redraw, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_tdl_get_previous_day_redraw, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_all_async_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *  start_index     [IN]        
 *  menuData        [?]         
 *  num_item        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_tdl_get_all_async_items(S32 start_index, gui_iconlist_menu_item *menuData, S32 num_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 dateStr[CLNDR_DATE_STRING_LENGTH + 1];   /* YYYY/MM/DD\0 */
    MYTIME todoTime;
    U32 i, count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (start_index < g_tdl_cntx.TotalListedTask)
    {
        /* construct task list */
        for (i = start_index; count < num_item && i < g_tdl_cntx.TotalListedTask; i++, count++)
        {
            memcpy(&todoTime, &(g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]].StartTime), sizeof(MYTIME));
            mmi_tdl_get_date_string(todoTime.nYear, todoTime.nMonth, todoTime.nDay, dateStr);
            mmi_asc_to_ucs2((S8*) menuData[count].item_list[0], dateStr);

            mmi_ucs2cpy(
                (S8*) menuData[count].item_list[1],
                (S8*) g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]].Note);

            /* Alarm */
            if (g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]].Alarm >= TODO_LIST_ALARM_ON)
            {
                    menuData[count].image_list[0] = (PU8) GetImage(IMG_TODO_LIST_ICON_ALARM);
            }
            else
            {
                menuData[count].image_list[0] = 0;
            }

            /* Type */
            menuData[count].image_list[1] =
                (PU8)
                GetImage((U16) (g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]].Type + IMG_TODO_LIST_ICON_REMINDER));
        }
    }
    return num_item;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_daily_async_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *  start_index     [IN]        
 *  menuData        [?]         
 *  num_item        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_tdl_get_daily_async_items(S32 start_index, gui_iconlist_menu_item *menuData, S32 num_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 timeStr[CLNDR_TIME_STRING_LENGTH * 2 + 1 + 1];   /* MM:SS-MM:SS\0 */
    U32 i, count = 0;

#ifdef __MMI_BIRTHDAY_REMINDER__
    U8 pbNumber[MAX_PB_NUMBER_LENGTH + 1], pbName[(MAX_PB_NAME_LENGTH + 1) * ENCODING_LENGTH];    /* used to get phone number. */
    MMI_BOOL phb_result;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (start_index < g_tdl_cntx.TotalListedTask)
    {
        /* construct task list */
        for (i = start_index; count < num_item && i < g_tdl_cntx.TotalListedTask; i++, count++)
        {
            mmi_tdl_get_time_string(
                &(g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]]),
                &(g_tdl_cntx.ClndrDate),
                timeStr);
            mmi_asc_to_ucs2((S8*) menuData[count].item_list[0], timeStr);

            mmi_ucs2cpy(
                (S8*) menuData[count].item_list[1],
                (S8*) g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]].Note);

            /* Alarm */
            if (g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]].Alarm >= TODO_LIST_ALARM_ON)
            {
                menuData[count].image_list[0] = (PU8) GetImage(IMG_TODO_LIST_ICON_ALARM);
            }
            else
            {
                menuData[count].image_list[0] = 0;
            }

            /* Type */
            menuData[count].image_list[1] =
                (PU8)
                GetImage((U16) (g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]].Type + IMG_TODO_LIST_ICON_REMINDER));
        }
    }

#ifdef __MMI_BIRTHDAY_REMINDER__
    if (count < num_item)   /* display birthday */
    {
        memset(timeStr, 0, CLNDR_TIME_STRING_LENGTH + 1);   /* 00:00\n */

        sprintf(timeStr, "%02d:%02d", 0, 0);

		i = count + start_index - g_tdl_cntx.TotalListedTask;

        for (; count < num_item && i < mmi_clndr_get_daily_birthday_amount(g_tdl_cntx.ClndrDate.nDay);
             i++, count++)
        {
            mmi_asc_to_ucs2((S8*) menuData[count].item_list[0], timeStr);
            
            memset(pbNumber, 0, MAX_PB_NUMBER_LENGTH + 1);
            memset(pbName, 0, (MAX_PB_NAME_LENGTH + 1) * ENCODING_LENGTH);
        
            phb_result = mmi_phb_get_name_number(g_tdl_cntx.PBIndexList[i], 
                pbName,
                pbNumber);
                
            if (phb_result == MMI_FALSE)
            {
                return count;
            }

            if (mmi_ucs2strlen((S8*)pbName) > 0)
            {
                mmi_ucs2cpy((S8*)menuData[count].item_list[1], (S8*)pbName);            
            }
            else
            {
                mmi_asc_to_ucs2((S8*)menuData[count].item_list[1], (S8*)pbNumber);            
            }
            
            if (mmi_ucs2strlen((S8*) menuData[count].item_list[1]) == 0)
            {
                memcpy(menuData[count].item_list[1], GetString(STR_GLOBAL_EMPTY), (mmi_ucs2strlen(GetString(STR_GLOBAL_EMPTY)) + 1) * ENCODING_LENGTH);                
            }
            menuData[count].image_list[0] = 0;
            menuData[count].image_list[1] = (PU8) GetImage(IMG_TODO_LIST_BIRTHDAY_REMINDER);            
        }
    }
#endif /* __MMI_BIRTHDAY_REMINDER__ */ 

    return count;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_time_string
 * DESCRIPTION
 *  
 * PARAMETERS
 *  task            [?]         
 *  year            [IN]        
 *  month           [IN]        
 *  day             [IN]        
 *  timeString      [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_get_time_string(ToDoListNode *task, MYTIME* seletedDate, S8 *timeString)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 *timeString2;
    U8 IsStartDay = 0;
    MYTIME startTime;
    MYTIME endTime;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(timeString, 0, CLNDR_TIME_STRING_LENGTH * 2 + 1 + 1);
    memcpy(&startTime, &(task->StartTime), sizeof(MYTIME));
    memcpy(&endTime, &(task->EndTime), sizeof(MYTIME));

    if (startTime.nYear == seletedDate->nYear && startTime.nMonth == seletedDate->nMonth && startTime.nDay == seletedDate->nDay)
    {
        IsStartDay = MMI_TRUE;
    }
    
    /* start time */
    if (task->Type == TDL_TASK_REMINDER && g_tdl_freq_set[task->Repeat] == ALM_FREQ_ONCE && IsStartDay == MMI_FALSE)
    {
        sprintf((S8*) timeString, "%02d:%02d", 0, 0);
    }
    else
    {
        sprintf((S8*) timeString, "%02d:%02d", startTime.nHour, startTime.nMin);
    }

    switch (task->Type)
    {
        case TDL_TASK_MEETING:
        case TDL_TASK_COURSE:
        case TDL_TASK_REMINDER:

            /* time separator */
            timeString[CLNDR_TIME_STRING_LENGTH] = '-';

            /* end time */
            timeString2 = timeString + CLNDR_TIME_STRING_LENGTH + 1;

            if (task->Type == TDL_TASK_REMINDER && g_tdl_freq_set[task->Repeat] == ALM_FREQ_ONCE)
            {               
                if (endTime.nYear != seletedDate->nYear ||
                    endTime.nMonth != seletedDate->nMonth ||
                    endTime.nDay != seletedDate->nDay)
                {
                    sprintf((S8*) timeString2, "%02d:%02d", 23, 59);
                    return;
                }
            }
            sprintf((S8*) timeString2, "%02d:%02d", endTime.nHour, endTime.nMin);            
            break;
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_date_string
 * DESCRIPTION
 *  
 * PARAMETERS
 *  year            [IN]        
 *  month           [IN]        
 *  day             [IN]        
 *  timeString      [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_get_date_string(U16 year, U8 month, U8 day, S8 *timeString)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(timeString, 0, CLNDR_DATE_STRING_LENGTH + 1);
    sprintf(timeString, "%04d/%02d/%02d", year, month, day);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_next_day_redraw
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_get_next_day_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME incTime;
    S8 datestring[CLNDR_DATE_STRING_LENGTH + 1];    /* yyyy/mm/dd */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Check date */
    if (g_tdl_cntx.ClndrDate.nYear == CLNDR_END_YEAR && g_tdl_cntx.ClndrDate.nMonth == 12 && g_tdl_cntx.ClndrDate.nDay == 31)
    {
        DisplayPopup(
        (U8*) GetString(STR_CLNDR_OUT_OF_CALENDAR),
        IMG_GLOBAL_WARNING,
        0,
        UI_POPUP_NOTIFYDURATION_TIME,
        (U8) WARNING_TONE);
        
        return;
    }
        
    /* Update Date */
    memset(&incTime, 0, sizeof(MYTIME));
    incTime.nDay = 1;
    IncrementTime(g_tdl_cntx.ClndrDate, incTime, &(g_tdl_cntx.ClndrDate));

    /* Month is changed, set birthday information. */
    if (g_tdl_cntx.ClndrDate.nDay== 1)
    {
        mmi_clndr_set_birthday_table(g_tdl_cntx.ClndrDate.nYear, g_tdl_cntx.ClndrDate.nMonth);
    }    

    /* Update Title */
    mmi_tdl_get_date_string(
        g_tdl_cntx.ClndrDate.nYear,
        g_tdl_cntx.ClndrDate.nMonth,
        g_tdl_cntx.ClndrDate.nDay,
        datestring);

    /* TDL Updation flag */
    g_tdl_cntx.IsListModified = TRUE;

    g_tdl_cntx.DateUpdate = 1;
    EntryTDLTaskList();
    g_tdl_cntx.DateUpdate = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_previous_day_redraw
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_get_previous_day_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME incTime;
    S8 datestring[CLNDR_DATE_STRING_LENGTH + 1];    /* yyyy/mm/dd */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Check date */
    if (g_tdl_cntx.ClndrDate.nYear == CLNDR_START_YEAR && g_tdl_cntx.ClndrDate.nMonth == 1 && g_tdl_cntx.ClndrDate.nDay == 1)
    {
        DisplayPopup(
        (U8*) GetString(STR_CLNDR_OUT_OF_CALENDAR),
        IMG_GLOBAL_WARNING,
        0,
        UI_POPUP_NOTIFYDURATION_TIME,
        (U8) WARNING_TONE);
        
        return;
    }
    
    /* Update Date */
    memset(&incTime, 0, sizeof(MYTIME));
    incTime.nDay = 1;
    DecrementTime(g_tdl_cntx.ClndrDate, incTime, &(g_tdl_cntx.ClndrDate));

    /* Month is changed, set birthday information. */
    if (g_tdl_cntx.ClndrDate.nDay== applib_dt_last_day_of_mon(g_tdl_cntx.ClndrDate.nMonth, g_tdl_cntx.ClndrDate.nYear))
    {
        mmi_clndr_set_birthday_table(g_tdl_cntx.ClndrDate.nYear, g_tdl_cntx.ClndrDate.nMonth);
    }    
    /* Update Title */
    mmi_tdl_get_date_string(
        g_tdl_cntx.ClndrDate.nYear,
        g_tdl_cntx.ClndrDate.nMonth,
        g_tdl_cntx.ClndrDate.nDay,
        datestring);

    /* TDL Updation flag */
    g_tdl_cntx.IsListModified = TRUE;

    g_tdl_cntx.DateUpdate = 1;
    EntryTDLTaskList();
    g_tdl_cntx.DateUpdate = 0;

}

#else /* __MMI_ADVANCED_TODO__ */ 
/*****************************************************************************
 * FUNCTION
 *  EntryTDLTaskList
 * DESCRIPTION
 *  Entry function of To Do List application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLTaskList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    S32 i;
    S32 TotalItem = 0;
    U16 nEmptyId = STR_TODO_LIST_EMPTY;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __SYNCML_SUPPORT__
    /* popup "please wait" when syncML is executing */
    if (mmi_syncml_is_tdl_sync_now())
    {
        DisplayPopup(
            (U8*) GetString(STR_ID_SYNC_PLEASE_WAIT),
            IMG_GLOBAL_PROGRESS,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            (U8) WARNING_TONE);
            return;
    }
#endif

    EntryNewScreen(SCR_TDL_TASK_LIST, ExitTDLTaskList, EntryTDLTaskList, NULL);

    if (g_tdl_cntx.IsListModified == TRUE)
    {
    #ifdef __MMI_CALENDAR_V2__
        if (g_tdl_cntx.IsCalledByCalender == CLNDR_MONTHLY_VIEW)        /* Match the Date and list them */
        {
            TDLMakeListOfSelectedDate(CLNDR_MONTHLY_VIEW);
        }
    #ifdef __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__
        else if (g_tdl_cntx.IsCalledByCalender == CLNDR_WEEKLY_VIEW)
        {
            mmi_tdl_get_period_task();
        }
    #endif
    #else /* __MMI_CALENDAR_V2__ */ 
        if (g_tdl_cntx.IsCalledByCalender == MMI_TRUE)  /* Match the Date and list them */
        {
            TDLMakeListOfSelectedDate(MMI_TRUE);
        }
    #endif /* __MMI_CALENDAR_V2__ */ 
        else    /* Set the Current Date and list the task in descending order. */
        {
            TDLMakeListOfAllTask();
        }

        g_tdl_cntx.IsListModified = FALSE;
    }
    TotalItem = g_tdl_cntx.TotalListedTask;
    guiBuffer = GetCurrGuiBuffer(SCR_TDL_TASK_LIST);

    SetParentHandler(0);

    RegisterHighlightHandler(HighlightTDLTaskList);

    if (TotalItem == 0) /* display <Empty> */
    {
        ShowCategory1Screen(
            STR_TODO_LIST_CAP_TASK_LIST,
            GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
            STR_TODO_LIST_ADD,
            0,
            STR_GLOBAL_BACK,
            0,
            1,
            &nEmptyId,
            0,
            guiBuffer);

        g_tdl_cntx.CurrHiliteOption = TODO_LIST_TASK_OPTION_ADD;
        SetLeftSoftkeyFunction(TdlExecEdit, KEY_EVENT_UP);
        SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        /* if task full, disable LSK */
        if (g_tdl_cntx.IsCalledByCalender)
        {
            if (TDLGetTotalItem() == NUM_OF_TDL)
            {
                ChangeLeftSoftkey(0, 0);
                SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
                SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
            }

        }
    #if (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT))
        if (mmi_jmms_is_from_jmms() > 0)
        {
            ChangeLeftSoftkey(0, 0);
            SetLeftSoftkeyFunction(NULL, KEY_EVENT_UP);
            SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        }
    #endif /* (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT)) */ 
    }
    else    /* display list of task */
    {
        /* construct task list */
        for (i = 0; i < g_tdl_cntx.TotalListedTask; i++)
        {
            mmi_ucs2cpy((S8*) subMenuDataPtrs[i], (S8*) g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]].Note);
            gTDLicon[i] = IMG_TODO_ICON;
        }

        ShowCategory84Screen(
            STR_TODO_LIST_CAP_TASK_LIST,
            GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
            STR_GLOBAL_OPTIONS,
            IMG_GLOBAL_OPTIONS,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            TotalItem,
            (U8 **) subMenuDataPtrs,
            (U16*) gTDLicon,
            0,
            0,
            guiBuffer);

        SetLeftSoftkeyFunction(EntryTDLTaskListOption, KEY_EVENT_UP);
        SetKeyHandler(EntryTDLTaskListOption, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    #if defined(__MMI_VCALENDAR__)
    #if (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT))
        if (mmi_jmms_is_from_jmms() > 0)
        {
            ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
            SetLeftSoftkeyFunction(mmi_jmms_insert_vcal_tdl, KEY_EVENT_UP);
            SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        }
    #endif /* (defined (JATAAYU_SUPPORT) && defined(MMS_SUPPORT)) */ 
    #endif	/* __MMI_VCALENDAR__ */
    }

    /* Register function for right soft key */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}
#endif /* __MMI_ADVANCED_TODO__ */ 
/*****************************************************************************
 * FUNCTION
 *  ExitTDLTaskList
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitTDLTaskList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    mmi_clndr_set_date(&g_tdl_cntx.ClndrDate);
#endif 

#ifdef __MMI_BIRTHDAY_REMINDER__
    mmi_tdl_destruct_birthday_memory();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  TdlExecView
 * DESCRIPTION
 *  Execute View option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TdlExecView(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.TotalListedTask != 0)
    {
        g_tdl_cntx.CurrTaskIndex = g_tdl_cntx.SortedList[g_tdl_cntx.CurrSelectedTask];
    }

    g_tdl_cntx.SelectedItemInView = 0;
    TDLInitInlineVariables();
    EntryTDLViewTask();
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTdlView
 * DESCRIPTION
 *  Highlight handler of View option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTdlView(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrHiliteOption = TODO_LIST_TASK_OPTION_VIEW;
    SetLeftSoftkeyFunction(TdlExecView, KEY_EVENT_UP);
    SetKeyHandler(TdlExecView, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  TdlExecEdit
 * DESCRIPTION
 *  Execute Edit option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TdlExecEdit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.TotalListedTask != 0)
    {
        g_tdl_cntx.CurrTaskIndex = g_tdl_cntx.SortedList[g_tdl_cntx.CurrSelectedTask];
    }

    g_tdl_cntx.IsDOWSet = 0;
    g_tdl_cntx.SelectedItemInView = 0;

    TDLInitInlineVariables();

    if (g_tdl_cntx.CurrTaskIndex >= NUM_OF_TDL)
    {
        DisplayPopup(
                (U8*) GetString(STR_TODO_LIST_LIST_FULL_MSG),
                IMG_GLOBAL_ERROR,
                1,
                UI_POPUP_NOTIFYDURATION_TIME,
                ERROR_TONE);
        DeleteUptoScrID(SCR_TDL_TASK_LIST);
        return;
    }
    EntryTDLEditTask();
}


/*****************************************************************************
 * FUNCTION
 *  TdlExecDelete
 * DESCRIPTION
 *  Execute Delete option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TdlExecDelete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.TotalListedTask != 0)
    {
        g_tdl_cntx.CurrTaskIndex = g_tdl_cntx.SortedList[g_tdl_cntx.CurrSelectedTask];
    }

    EntryTDLDelete();
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTdlEdit
 * DESCRIPTION
 *  Highlight handler of Edit option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTdlEdit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrHiliteOption = TODO_LIST_TASK_OPTION_EDIT;
    SetLeftSoftkeyFunction(TdlExecEdit, KEY_EVENT_UP);
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTdlAdd
 * DESCRIPTION
 *  Highlight handler of Add option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTdlAdd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrHiliteOption = TODO_LIST_TASK_OPTION_ADD;
#ifdef __MMI_ADVANCED_TODO__
    SetLeftSoftkeyFunction(mmi_tdl_entry_select_task_type, KEY_EVENT_UP);
    SetKeyHandler(mmi_tdl_entry_select_task_type, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
#else /* __MMI_ADVANCED_TODO__ */ 
    SetLeftSoftkeyFunction(TdlExecEdit, KEY_EVENT_UP);
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
#endif /* __MMI_ADVANCED_TODO__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTdlDelete
 * DESCRIPTION
 *  Highlight handler of Delete option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTdlDelete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrHiliteOption = TODO_LIST_TASK_OPTION_DELETE;
    SetLeftSoftkeyFunction(TdlExecDelete, KEY_EVENT_UP);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTdlDeleteAll
 * DESCRIPTION
 *  Highlight handler of Delete All option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTdlDeleteAll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrHiliteOption = TODO_LIST_TASK_OPTION_DELETE_ALL;
    SetLeftSoftkeyFunction(EntryTDLDeleteAll, KEY_EVENT_UP);
    ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLTaskListOption
 * DESCRIPTION
 *  Show option list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLTaskListOption(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 nStrItemList[6];    /* Stores the strings id of submenus returned */
    U16 nNumofItem;         /* Stores no of children in the submenu */
    U16 MenuId;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_TDL_OPTION_LIST, NULL, EntryTDLTaskListOption, NULL);

    /* view, add, edit, delete, delete all */
    if (TDLGetTotalItem() < NUM_OF_TDL)
    {
        MenuId = MITEM_TODO_LIST_TASK_OPTION_1;
    }
    else    /* view, edit, delete, delete all */
    {
        MenuId = MITEM_TODO_LIST_TASK_OPTION_2;
    }

    nNumofItem = GetNumOfChild(MenuId);

    GetSequenceStringIds(MenuId, nStrItemList);

    SetParentHandler(MenuId);

    guiBuffer = GetCurrGuiBuffer(SCR_TDL_OPTION_LIST);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory15Screen(
        STR_GLOBAL_OPTIONS,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        nNumofItem,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        LIST_MENU,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTDLViewInlineItem
 * DESCRIPTION
 *  Highlight handler of items in View screen
 *  Register key handlers.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTDLViewInlineItem(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.SelectedItemInView = (U8) index;

    ChangeLeftSoftkey(STR_TODO_LIST_LSK_EDIT, 0);
    SetLeftSoftkeyFunction(EditToDoListTask, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLViewTask
 * DESCRIPTION
 *  Display task information using an inline editor screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLViewTask(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U8 *inputBuffer;
    U16 inputBufferSize;
    U8 inline_total;

#ifdef __MMI_ADVANCED_TODO__
    U16 ToDoList_View_icon_list[MAX_INLINE_ITEM_TODO_LIST];
#else /* __MMI_ADVANCED_TODO__ */ 
    U16 ToDoList_View_icon_list[MAX_INLINE_ITEM_TODO_LIST] = 
    {
        IMG_TODO_LIST_DATE, IMG_TODO_LIST_TIME, IMG_TODO_LIST_NOTE,
        0, IMG_TODO_LIST_ALARM, 0, IMG_TODO_LIST_REPEAT, 0, 0
    };
#endif /* __MMI_ADVANCED_TODO__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_TDL_TASK_VIEW, ExitTDLViewTask, NULL, NULL);

    InitializeCategory57Screen();

    guiBuffer = GetCurrGuiBuffer(SCR_TDL_TASK_VIEW);

    inputBuffer = GetCurrNInputBuffer(SCR_TDL_TASK_VIEW, &inputBufferSize);

    SetParentHandler(0);

    inline_total = TDLFillInlineStructForView();

#ifdef __MMI_ADVANCED_TODO__
    memset(&ToDoList_View_icon_list, 0, sizeof(U16) * MAX_INLINE_ITEM_TODO_LIST);
    mmi_tdl_set_inline_icon(ToDoList_View_icon_list, inline_total);
#endif /* __MMI_ADVANCED_TODO__ */ 

    RegisterHighlightHandler(HighlightTDLViewInlineItem);

    if (inputBuffer != NULL)
    {
        SetCategory57Data(wgui_inline_items, MAX_INLINE_ITEM_TODO_LIST, inputBuffer);
    }

    ShowCategory57Screen(
        STR_TODO_REMINDER + g_tdl_cntx.CurrTaskType,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_TODO_LIST_LSK_EDIT,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        inline_total,
        ToDoList_View_icon_list,
        wgui_inline_items,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(mmi_tdl_task_list_goback, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  ExitTDLViewTask
 * DESCRIPTION
 *  Exit function of View screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitTDLViewTask(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history ScrDA;  /* Variable to hold the history data */
    S16 nHistory = 0;
    U16 size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();
    ScrDA.scrnID = SCR_TDL_TASK_VIEW;
    ScrDA.entryFuncPtr = EntryTDLViewTask;

    mmi_ucs2cpy((S8*) ScrDA.inputBuffer, (S8*) & nHistory);
    GetCategoryHistory(ScrDA.guiBuffer);
    size = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) ScrDA.inputBuffer);
    AddNHistory(ScrDA, size);
}


/*****************************************************************************
 * FUNCTION
 *  EditToDoListTask
 * DESCRIPTION
 *  Edit to do list task from View screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EditToDoListTask(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrHiliteOption = TODO_LIST_TASK_OPTION_EDIT;
    EntryTDLEditTask();
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTDLEditInlineItem
 * DESCRIPTION
 *  Highlight handler of edit task screen.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTDLEditInlineItem(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    if (index == g_tdl_cntx.NoteIndex || (index == g_tdl_cntx.LocationIndex && mmi_tdl_get_field_state(TDL_FIELD_MASK_LOCATION)))
    {
        g_tdl_cntx.HilitedInlineEditor = index;

        if (index == g_tdl_cntx.LocationIndex)
        {
            mmi_ucs2cpy(glocationString, g_tdl_cntx.LocationBuff);
        }
        else
        {
            mmi_ucs2cpy(gnoteString, g_tdl_cntx.NoteBuff);
        }
        ChangeLeftSoftkey(STR_TODO_LIST_LSK_EDIT, 0);
        SetLeftSoftkeyFunction(EntryTDLEditNote, KEY_EVENT_UP);
    }
#else /* __MMI_ADVANCED_TODO__ */ 
    if (index == g_tdl_cntx.NoteIndex)
    {
        mmi_ucs2cpy(gnoteString, g_tdl_cntx.NoteBuff);
		ChangeLeftSoftkey(STR_TODO_LIST_LSK_EDIT, 0);
        SetLeftSoftkeyFunction(EntryTDLEditNote, KEY_EVENT_UP);
    }
#endif /* __MMI_ADVANCED_TODO__ */ 

#if defined(__MMI_VCALENDAR__)
    if (g_tdl_cntx.CurrHiliteOption == TODO_FROM_FMGR || g_tdl_cntx.CurrHiliteOption == TODO_FROM_NETWORK)
    {
        ChangeRightSoftkey(STR_GLOBAL_DONE, 0);
        SetRightSoftkeyFunction(EntryTDLSaveConfirm, KEY_EVENT_UP);
    }
#endif /* defined(__MMI_VCALENDAR__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLEditTask
 * DESCRIPTION
 *  Entry edit task screen of To Do List.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLEditTask(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U8 *inputBuffer;
    U16 inputBufferSize;
    U8 inline_total;

#ifdef __MMI_ADVANCED_TODO__
    U16 ToDoList_View_icon_list[MAX_INLINE_ITEM_TODO_LIST];
#else /* __MMI_ADVANCED_TODO__ */ 
    U16 ToDoList_View_icon_list[MAX_INLINE_ITEM_TODO_LIST] = 
    {
        IMG_TODO_LIST_DATE, IMG_TODO_LIST_TIME, IMG_TODO_LIST_NOTE,
        0, IMG_TODO_LIST_ALARM, 0, IMG_TODO_LIST_REPEAT, 0, 0
    };
#endif /* __MMI_ADVANCED_TODO__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __SYNCML_SUPPORT__
    /* popup "please wait" when syncML is executing */
    if (mmi_syncml_is_tdl_sync_now())
    {
        DisplayPopup(
            (U8*) GetString(STR_ID_SYNC_PLEASE_WAIT),
            IMG_GLOBAL_PROGRESS,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            (U8) WARNING_TONE);
            return;
    }
#endif
    EntryNewScreen(SCR_TDL_TASK_EDIT, ExitTDLEditTask, NULL, NULL);

    InitializeCategory57Screen();

    guiBuffer = GetCurrGuiBuffer(SCR_TDL_TASK_EDIT);

    inputBuffer = GetCurrNInputBuffer(SCR_TDL_TASK_EDIT, &inputBufferSize);

    SetParentHandler(0);

    inline_total = TDLFillInlineStruct();

#ifdef __MMI_ADVANCED_TODO__
    memset(&ToDoList_View_icon_list, 0, sizeof(U16) * MAX_INLINE_ITEM_TODO_LIST);
    mmi_tdl_set_inline_icon(ToDoList_View_icon_list, inline_total);
#endif /* __MMI_ADVANCED_TODO__ */ 

    RegisterHighlightHandler(HighlightTDLEditInlineItem);

    if (inputBuffer != NULL)
    {
        SetCategory57Data(wgui_inline_items, MAX_INLINE_ITEM_TODO_LIST, inputBuffer);
    }

    if (TDLIsTaskChanged() && GetInlineDoneFlag(guiBuffer) == 0)
    {
        SetInlineDoneFlag(guiBuffer);
    }

    ShowCategory57Screen(
        STR_TODO_REMINDER + g_tdl_cntx.CurrTaskType,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_TODO_LIST_LSK_EDIT,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        inline_total,
        ToDoList_View_icon_list,
        wgui_inline_items,
        g_tdl_cntx.SelectedItemInView,
        guiBuffer);

    SetCategory57RightSoftkeyFunctions(EntryTDLSaveConfirm, mmi_tdl_task_list_goback);
#if defined(__MMI_VCALENDAR__)

    if (g_tdl_cntx.CurrHiliteOption == TODO_FROM_FMGR)
    {
        ChangeRightSoftkey(STR_GLOBAL_DONE, IMG_GLOBAL_BACK);
        SetRightSoftkeyFunction(EntryTDLSaveConfirm, KEY_EVENT_UP);
    }
#endif /* defined(__MMI_VCALENDAR__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ExitTDLEditTask
 * DESCRIPTION
 *  Exit function of edit task screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitTDLEditTask(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history ScrDA;  /* Variable to hold the history data */
    S16 nHistory = 0;
    U16 size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory57Screen();

    ScrDA.scrnID = SCR_TDL_TASK_EDIT;
    ScrDA.entryFuncPtr = EntryTDLEditTask;

    mmi_ucs2cpy((S8*) ScrDA.inputBuffer, (S8*) & nHistory);
    GetCategoryHistory(ScrDA.guiBuffer);
    size = (U16) GetCategory57DataSize();
    GetCategory57Data((U8*) ScrDA.inputBuffer);
    AddNHistory(ScrDA, size);
}


/*****************************************************************************
 * FUNCTION
 *  TDLGotoListOrOptionScreen
 * DESCRIPTION
 *  Go back to task list or option screen when giving up save.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLGotoListOrOptionScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.TotalListedTask == 0)
    {
        GoBackToHistory(SCR_TDL_TASK_LIST);
    }
    else
    {
        GoBackToHistory(SCR_TDL_OPTION_LIST);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_is_valid_fields
 * DESCRIPTION
 *  Retrieve user input from inline editor screen and save to global context.
 * PARAMETERS
 *  tdlItem     [?]
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_tdl_is_valid_fields(ToDoListNode *tdlItem)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    TIME_EQUALITY equality;
    MMI_TDL_ERROR_ENUM errorCode = MMI_TDL_SUCCESS;
    MYTIME currTime;
	U8 max_repeat;

#ifdef __MMI_ADVANCED_TODO__
    MYTIME incTime, alarmTime;
#endif 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GetDateTime(&currTime);
#ifdef __MMI_ADVANCED_TODO__
    memset(&incTime, 0, sizeof(MYTIME));
    memcpy(&alarmTime, tdlItem, sizeof(MYTIME));
    mmi_tdl_compute_reminder_time(tdlItem, &incTime);
    applib_dt_decrease_time(
        (applib_time_struct*) & alarmTime,
        (applib_time_struct*) & incTime,
        (applib_time_struct*) & alarmTime);
    equality = CompareTime(alarmTime, currTime, NULL);
#else /* __MMI_ADVANCED_TODO__ */ 
    equality = CompareTime(tdlItem->StartTime, currTime, NULL);
#endif /* __MMI_ADVANCED_TODO__ */ 

    /* Check note */
    if (mmi_ucs2strlen((S8*) tdlItem->Note) == 0)
    {
        return MMI_TDL_INVALID_NOTES;
    }

	/* Check repeat */
#ifdef __MMI_ADVANCED_TODO__
	
	if (tdlItem->Type == TDL_TASK_ANNIVERSARY)
	{
		max_repeat = TODO_FREQ_NUM + 1;		
	}
	else
	{
		max_repeat = TODO_FREQ_NUM;		
	}
#else
	max_repeat = TODO_FREQ_NUM;		
#endif /* __MMI_ADVANCED_TODO__ */
    if (tdlItem->Repeat >= max_repeat)
    {
        return MMI_TDL_REPEAT_OUT_OF_BOUNDARY;
    }
#ifdef __MMI_ADVANCED_TODO__
    /* if task duration is more than one day, repeat should set as "once" */
    if (tdlItem->Type == TDL_TASK_REMINDER && 
        (tdlItem->StartTime.nYear != tdlItem->EndTime.nYear ||tdlItem->StartTime.nMonth!= tdlItem->EndTime.nMonth || tdlItem->StartTime.nDay != tdlItem->EndTime.nDay) &&
        g_tdl_freq_set[tdlItem->Repeat] != ALM_FREQ_ONCE)
    {
        return MMI_TDL_INVALID_REPEAT;
    }
#endif

    /* Check alarm */
    if (tdlItem->Alarm >= TODO_LIST_ALARM_TOTAL)
    {
        return MMI_TDL_INVALID_ALARM;
    }
    /* disable alarm state if already expired */
    if (g_tdl_freq_set[tdlItem->Repeat] == ALM_FREQ_ONCE && equality != TIME_GREATER)   /* already expired */
    {
        if (tdlItem->Alarm >= TODO_LIST_ALARM_ON)
        {
            return  MMI_TDL_EXPIRED_ALARM;
        }
    }    

    /* Check Days */
    if (g_tdl_freq_set[tdlItem->Repeat] == ALM_FREQ_DAYS && tdlItem->Days == 0)
    {
        tdlItem->Repeat = mmi_alm_get_freq_order(TODO_FREQ_NUM, g_tdl_freq_set, ALM_FREQ_ONCE);
    }

    /* Check Date */
    /* If end time is before start time*/
#ifdef __MMI_ADVANCED_TODO__    
    if (FindMaxTime(&(tdlItem->EndTime), &(tdlItem->StartTime)) == 0)
    {
        memcpy(&(tdlItem->EndTime), &(tdlItem->StartTime), sizeof(MYTIME));
    }
#else
    if (tdlItem->EndHour < tdlItem->StartTime.nHour || (tdlItem->EndHour == tdlItem->StartTime.nHour && tdlItem->EndMin < tdlItem->StartTime.nMin))
    {
        tdlItem->EndHour = tdlItem->StartTime.nHour;
    	tdlItem->EndMin = tdlItem->StartTime.nMin;    
    }
#endif    

    return errorCode;
}

/*****************************************************************************
 * FUNCTION
 *  TDLSaveTask
 * DESCRIPTION
 *  Retrieve user input from inline editor screen and save to NVRAM.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLSaveTask(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i, j;
    U8 OldStatus;
    U16 doneStr = STR_GLOBAL_SAVED;
    U16 errorCode;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = g_tdl_cntx.CurrTaskIndex;

    /* note */
    if (mmi_ucs2strlen(g_tdl_cntx.NoteBuff) == 0)
    {
        TDLShowPopupScreen(STR_TODO_LIST_EMPTY_NOTE_MSG);
        return;
    }

    if (LastDayOfMonth
        ((U8) gui_atoi((UI_string_type) g_tdl_cntx.MonBuff),
         (U8) gui_atoi((UI_string_type) g_tdl_cntx.YearBuff)) < gui_atoi((UI_string_type) g_tdl_cntx.DayBuff))
    {
        DisplayPopup(
            (PU8) GetString(STR_TODO_LIST_WRONG_DATE_MSG),
            IMG_GLOBAL_WARNING,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            ERROR_TONE);
        return;
    }

    if (!mmi_tdl_get_time_info(i))
    {
#if defined (__MMI_MAINLCD_128X128__)
        doneStr = STR_GLOBAL_SAVED;
#else
        doneStr = STR_TODO_INVALID_END_TIME;
#endif
    }

    mmi_ucs2cpy((S8*) (g_tdl_cntx.TaskList[i].Note), g_tdl_cntx.NoteBuff);
    /* repeat */
    g_tdl_cntx.TaskList[i].Repeat = (U8) g_tdl_cntx.HilitedRepeat;
    g_tdl_cntx.TaskList[i].Days = 0;

    g_tdl_cntx.TaskList[i].Present = 1;
    if (g_tdl_freq_set[g_tdl_cntx.TaskList[i].Repeat] == ALM_FREQ_DAYS)
    {
        for (j = 0; j < MAX_DAY_IN_WEEK; j++)
            if (gAlmDaysStates[j])
            {
                g_tdl_cntx.TaskList[i].Days |= gAlmDayOfWeek[j];
            }

        /* reset to once */
        if (g_tdl_cntx.TaskList[i].Days == 0)
        {
            g_tdl_cntx.TaskList[i].Repeat = mmi_alm_get_freq_order(TODO_FREQ_NUM, g_tdl_freq_set, ALM_FREQ_ONCE);
        }
    }


    /* alarm on/off */
    OldStatus = g_tdl_cntx.TaskList[i].Alarm;
    g_tdl_cntx.TaskList[i].Alarm = (U8) g_tdl_cntx.HilitedAlmState;

#ifdef __MMI_ADVANCED_TODO__
    /* Location */
    if (mmi_ucs2strlen(g_tdl_cntx.LocationBuff) != 0)
    {
        mmi_ucs2cpy((S8*) (g_tdl_cntx.TaskList[i].Location), g_tdl_cntx.LocationBuff);
    }
    else
    {
        memset(g_tdl_cntx.TaskList[i].Location, 0, MAX_TODO_LIST_NOTE);
    }

    /* Priority */
    g_tdl_cntx.TaskList[i].Priority = g_tdl_cntx.HilitedPriorityState;

    /* Type */
    g_tdl_cntx.TaskList[i].Type = g_tdl_cntx.CurrTaskType;

    /* Check for invalid repeat */
    errorCode = mmi_tdl_is_valid_fields(&g_tdl_cntx.TaskList[i]);
    if(errorCode == MMI_TDL_INVALID_REPEAT)
    {
        doneStr = STR_TODO_SET_REPEAT_ONCE;
		g_tdl_cntx.TaskList[i].Repeat = mmi_alm_get_freq_order(TODO_FREQ_NUM, g_tdl_freq_set, ALM_FREQ_ONCE);		
    }    
#endif /* __MMI_ADVANCED_TODO__ */ 

	/* Check for alarm expiry time*/
    errorCode = mmi_tdl_is_valid_fields(&g_tdl_cntx.TaskList[i]);

    if (errorCode == MMI_TDL_EXPIRED_ALARM)
    {
        g_tdl_cntx.TaskList[i].Alarm = TODO_LIST_ALARM_OFF;
#if defined (__MMI_MAINLCD_128X128__)
            doneStr = STR_GLOBAL_SAVED;
#else
            doneStr = STR_TODO_ALARM_OFF_DONE;
#endif
    }

    TDLWriteToNvram(i);
#ifdef __SYNCML_SUPPORT__    
    if (g_tdl_cntx.CurrHiliteOption == TODO_LIST_TASK_OPTION_ADD
    #if defined(__MMI_VCALENDAR__)
        || g_tdl_cntx.CurrHiliteOption == TODO_FROM_FMGR || g_tdl_cntx.CurrHiliteOption == TODO_FROM_NETWORK
    #endif /* defined(__MMI_VCALENDAR__) */ 
        )
    {
        mmi_syncml_tdl_data_changed_notification(SYNCML_RECORD_ADD, i);
    }
    else if (g_tdl_cntx.CurrHiliteOption == TODO_LIST_TASK_OPTION_EDIT)
    {
        mmi_syncml_tdl_data_changed_notification(SYNCML_RECORD_MODIFY, i);
    }
#endif    

    /* alarm is canceled */
    if (OldStatus >= TODO_LIST_ALARM_ON && g_tdl_cntx.TaskList[i].Alarm == TODO_LIST_ALARM_OFF)
    {
        AlmCancelAlarm((U8) (i + ALM_TDL_START));
    }
    else if (g_tdl_cntx.TaskList[i].Alarm >= TODO_LIST_ALARM_ON)
    {
        AlmSetAlarm((U8) (i + ALM_TDL_START));
    }

    TDLShowPopupScreen(doneStr);
}


/*****************************************************************************
 * FUNCTION
 *  TDLFillInlineStruct
 * DESCRIPTION
 *  Fill the inline data sturcture for edit screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 TDLFillInlineStruct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, inline_index = 0;

#ifdef __MMI_ADVANCED_TODO__
    U8 dt_type;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < TODO_FREQ_NUM; i++)
    {
        gAlmFreqList[i] = GetString((U16) (g_tdl_freq_set[i] + ALARM_REPEAT_OFF_INDEX));
    }

    gAlmOnOffStringforTDL[0] = GetString(STR_GLOBAL_OFF);
    gAlmOnOffStringforTDL[1] = GetString(STR_GLOBAL_ON);

#ifdef __MMI_ADVANCED_TODO__
    gAlmOnOffStringforTDL[2] = GetString(STR_TODO_ALARM_BEFORE_5_MINS);
    gAlmOnOffStringforTDL[3] = GetString(STR_TODO_ALARM_BEFORE_15_MINS);
    gAlmOnOffStringforTDL[4] = GetString(STR_TODO_ALARM_BEFORE_30_MINS);

    mmi_tdl_get_fields_of_task(g_tdl_cntx.CurrTaskType);
#if 0    
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    dt_type = mmi_tdl_get_dt_type();
    switch (dt_type)
    {
        case TDL_DT_DATE_AND_TIMEPERIOD:
            /* Date */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemDate(
                &(wgui_inline_items[inline_index]),
                (U8*) g_tdl_cntx.DayBuff,
                (U8*) g_tdl_cntx.MonBuff,
                (U8*) g_tdl_cntx.YearBuff,
                TDLDateEditorCallBack);
            DisableInlineItemHighlight(&wgui_inline_items[inline_index]);
            set_inline_date_boundary(2030, 1970, 12, 1);
            inline_index++;

            /* Time Period */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemTimePeriod(
                &(wgui_inline_items[inline_index]),
                (U8*) g_tdl_cntx.HourBuff1,
                (U8*) g_tdl_cntx.MinBuff1,
                NULL,
                (U8*) g_tdl_cntx.HourBuff2,
                (U8*) g_tdl_cntx.MinBuff2,
                NULL,
                TDLTimeEditorCallBack);
            DisableInlineItemHighlight(&wgui_inline_items[inline_index]);
            inline_index++;
            break;
        case TDL_DT_ONLY_START_DT:
            /* Date */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemDate(
                &(wgui_inline_items[inline_index]),
                (U8*) g_tdl_cntx.DayBuff,
                (U8*) g_tdl_cntx.MonBuff,
                (U8*) g_tdl_cntx.YearBuff,
                TDLDateEditorCallBack);
            DisableInlineItemHighlight(&wgui_inline_items[inline_index]);
            set_inline_date_boundary(2030, 1970, 12, 1);
            inline_index++;

            /* Time */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemTime(
                &(wgui_inline_items[inline_index]),
                (U8*) g_tdl_cntx.HourBuff1,
                (U8*) g_tdl_cntx.MinBuff1,
                NULL,
                mmi_tdl_time_editor_callback);
            DisableInlineItemHighlight(&(wgui_inline_items[inline_index]));
            inline_index++;
            break;
        case TDL_DT_ALL:
            /* Start Time and end date/time */

            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_START_TIME));
            inline_index++;

            /* Start Date */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemDate(
                &(wgui_inline_items[inline_index]),
                (U8*) g_tdl_cntx.DayBuff,
                (U8*) g_tdl_cntx.MonBuff,
                (U8*) g_tdl_cntx.YearBuff,
                TDLDateEditorCallBack);
            DisableInlineItemHighlight(&wgui_inline_items[inline_index]);
            set_inline_date_boundary(2030, 1970, 12, 1);
            inline_index++;

            /* Start Time */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemTime(
                &(wgui_inline_items[inline_index]),
                (U8*) g_tdl_cntx.HourBuff1,
                (U8*) g_tdl_cntx.MinBuff1,
                NULL,
                mmi_tdl_time_editor_callback);
            DisableInlineItemHighlight(&(wgui_inline_items[inline_index]));
            inline_index++;

            /* End Time */

            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_END_TIME));
            inline_index++;

            /* End Date */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemDate(
                &(wgui_inline_items[inline_index]),
                (U8*) g_tdl_cntx.DayBuffEnd,
                (U8*) g_tdl_cntx.MonBuffEnd,
                (U8*) g_tdl_cntx.YearBuffEnd,
                TDLDateEditorCallBack);
            DisableInlineItemHighlight(&wgui_inline_items[inline_index]);
            set_inline_date_boundary(2030, 1970, 12, 1);
            inline_index++;

            /* End Time */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemTime(
                &(wgui_inline_items[inline_index]),
                (U8*) g_tdl_cntx.HourBuff2,
                (U8*) g_tdl_cntx.MinBuff2,
                NULL,
                mmi_tdl_time_editor_callback);
            DisableInlineItemHighlight(&(wgui_inline_items[inline_index]));
            inline_index++;

            break;
    }
#else /* __MMI_ADVANCED_TODO__ */ 
	/* To Read didnt indent the code from first column. */
    SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemDate(
        &(wgui_inline_items[inline_index]),
        (U8*) g_tdl_cntx.DayBuff,
        (U8*) g_tdl_cntx.MonBuff,
        (U8*) g_tdl_cntx.YearBuff,
        TDLDateEditorCallBack);
    DisableInlineItemHighlight(&wgui_inline_items[inline_index]);
    set_inline_date_boundary(2030, 1970, 12, 1);
    inline_index++;
    
    /* Time Period */
    SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    SetInlineItemTimePeriod(
        &(wgui_inline_items[inline_index]),
        (U8*) g_tdl_cntx.HourBuff1,
        (U8*) g_tdl_cntx.MinBuff1,
        NULL,
        (U8*) g_tdl_cntx.HourBuff2,
        (U8*) g_tdl_cntx.MinBuff2,
        NULL,
        TDLTimeEditorCallBack);
    DisableInlineItemHighlight(&wgui_inline_items[inline_index]);
    inline_index++;
#endif /* __MMI_ADVANCED_TODO__ */ 

    /* Note */
#ifdef __MMI_ADVANCED_TODO__
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_NOTE))
    {
#endif /* __MMI_ADVANCED_TODO__ */ 
        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_NOTE));
        inline_index++;

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.NoteBuff);
        g_tdl_cntx.NoteIndex = inline_index;
        inline_index++;

        /* Alarm */
    #ifdef __MMI_ADVANCED_TODO__
    }

    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_ALARM))
    {
    #endif /* __MMI_ADVANCED_TODO__ */ 

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_ALARM));
        inline_index++;

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemSelect(
            &(wgui_inline_items[inline_index]),
            (S32) NUM_STATE_FOR_TDL,
            (U8 **) gAlmOnOffStringforTDL,
            &g_tdl_cntx.HilitedAlmState);
        inline_index++;

        /* Repeat */
    #ifdef __MMI_ADVANCED_TODO__
    }

    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_REPEAT))
    {
    #endif /* __MMI_ADVANCED_TODO__ */ 

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_REPEAT));
        inline_index++;

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemSelect(
            &(wgui_inline_items[inline_index]),
            TODO_FREQ_NUM,
            (U8 **) gAlmFreqList,
            &g_tdl_cntx.HilitedRepeat);
        RegisterInlineSelectHighlightHandler(&(wgui_inline_items[inline_index]), HighlightTDLInlineRepeat);
        SetInlineItemFollowDown(&(wgui_inline_items[inline_index]), inline_index);
        inline_index++;

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDOWSelect(&(wgui_inline_items[inline_index]), inline_index, gAlmDaysStates);

        if (g_tdl_freq_set[g_tdl_cntx.HilitedRepeat] == ALM_FREQ_DAYS)
        {
            EnableInlineItem(&(wgui_inline_items[inline_index]), inline_index);
        }
        else
        {
            DisableInlineItem(&(wgui_inline_items[inline_index]), inline_index);
        }

        g_tdl_cntx.DOWIndex = inline_index;
        inline_index++;

    #ifdef __MMI_ADVANCED_TODO__
    }
    /* Location */

    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_LOCATION))
    {

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_LOCATION));
        inline_index++;

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.LocationBuff);
        g_tdl_cntx.LocationIndex = inline_index;
        inline_index++;

    }

    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_PRIORITY))
    {
        gTdlPriorityString[0] = GetString(STR_TODO_PRIORITY_HIGH);
        gTdlPriorityString[1] = GetString(STR_TODO_PRIORITY_MEDIUM);
        gTdlPriorityString[2] = GetString(STR_TODO_PRIORITY_LOW);

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_PRIORITY));
        inline_index++;

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemSelect(
            &(wgui_inline_items[inline_index]),
            (S32) NUM_OF_TASK_PRIORITY,
            (U8 **) gTdlPriorityString,
            &g_tdl_cntx.HilitedPriorityState);
        inline_index++;

    }
    #endif /* __MMI_ADVANCED_TODO__ */ 

    return inline_index;

}


/*****************************************************************************
 * FUNCTION
 *  HighlightTDLInlineRepeat
 * DESCRIPTION
 *  Highlight handler of inline selection item in edit task screen.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTDLInlineRepeat(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = g_tdl_cntx.CurrTaskIndex;
    if (g_tdl_freq_set[index] == ALM_FREQ_DAYS)
    {
        if (g_tdl_cntx.IsDOWSet == 0)
        {
            /* if the user did not select DOW yet */
            if (g_tdl_cntx.TaskList[i].Days == 0)
            {
                memset(gAlmDaysStates, 1, 7);
                gAlmDaysStates[0] = 0;
                gAlmDaysStates[6] = 0;
            }
            else
            {
                for (j = 0; j < MAX_DAY_IN_WEEK; j++)
                {
                    if (g_tdl_cntx.TaskList[i].Days & gAlmDayOfWeek[j])
                    {
                        gAlmDaysStates[j] = 1;
                    }
                    else
                    {
                        gAlmDaysStates[j] = 0;
                    }
                }
            }
        }

        g_tdl_cntx.IsDOWSet = 1;
        EnableInlineItem(&(wgui_inline_items[g_tdl_cntx.DOWIndex]), g_tdl_cntx.DOWIndex);
    }
    else
    {
        g_tdl_cntx.IsDOWSet = 0;
        memset(gAlmDaysStates, 0, MAX_DAY_IN_WEEK);
        DisableInlineItem(&(wgui_inline_items[g_tdl_cntx.DOWIndex]), g_tdl_cntx.DOWIndex);
    }

    RedrawCategory57Screen();
}


/*****************************************************************************
 * FUNCTION
 *  TDLFillInlineStructForView
 * DESCRIPTION
 *  Fill the inline data sturcture for view screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 TDLFillInlineStructForView(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, inline_index = 0;

#ifdef __MMI_ADVANCED_TODO__
    U8 dt_type;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < TODO_FREQ_NUM; i++)
    {
        gAlmFreqList[i] = GetString((U16) (g_tdl_freq_set[i] + ALARM_REPEAT_OFF_INDEX));
    }

    gAlmOnOffStringforTDL[0] = GetString(STR_GLOBAL_OFF);
    gAlmOnOffStringforTDL[1] = GetString(STR_GLOBAL_ON);

#ifdef __MMI_ADVANCED_TODO__
    gAlmOnOffStringforTDL[2] = GetString(STR_TODO_ALARM_BEFORE_5_MINS);
    gAlmOnOffStringforTDL[3] = GetString(STR_TODO_ALARM_BEFORE_15_MINS);
    gAlmOnOffStringforTDL[4] = GetString(STR_TODO_ALARM_BEFORE_30_MINS);

    mmi_tdl_get_fields_of_task(g_tdl_cntx.CurrTaskType);

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    dt_type = mmi_tdl_get_dt_type();
    switch (dt_type)
    {
        case TDL_DT_DATE_AND_TIMEPERIOD:
            /* Date */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            TDLDateEditorCallBack(
                g_tdl_cntx.DateStrBuff,
                (U8*) g_tdl_cntx.DayBuff,
                (U8*) g_tdl_cntx.MonBuff,
                (U8*) g_tdl_cntx.YearBuff);
            SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.DateStrBuff);
            inline_index++;

            SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            TDLTimeEditorCallBack(
                g_tdl_cntx.TimeStrBuff,
                (U8*) g_tdl_cntx.HourBuff1,
                (U8*) g_tdl_cntx.MinBuff1,
                NULL,
                (U8*) g_tdl_cntx.HourBuff2,
                (U8*) g_tdl_cntx.MinBuff2,
                NULL);
            SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.TimeStrBuff);
            inline_index++;

            break;
        case TDL_DT_ONLY_START_DT:
            /* Date */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            TDLDateEditorCallBack(
                g_tdl_cntx.DateStrBuff,
                (U8*) g_tdl_cntx.DayBuff,
                (U8*) g_tdl_cntx.MonBuff,
                (U8*) g_tdl_cntx.YearBuff);
            SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.DateStrBuff);
            inline_index++;

            /* Time */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            mmi_tdl_time_editor_callback(
                g_tdl_cntx.TimeStrBuff,
                (U8*) g_tdl_cntx.HourBuff1,
                (U8*) g_tdl_cntx.MinBuff1,
                NULL);
            SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.TimeStrBuff);
            inline_index++;
            break;
        case TDL_DT_ALL:
            /* Start Time and end date/time */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_START_TIME));
            inline_index++;

            /* Start Date */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            TDLDateEditorCallBack(
                g_tdl_cntx.DateStrBuff,
                (U8*) g_tdl_cntx.DayBuff,
                (U8*) g_tdl_cntx.MonBuff,
                (U8*) g_tdl_cntx.YearBuff);
            SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.DateStrBuff);
            inline_index++;

            /* Start Time */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            mmi_tdl_time_editor_callback(
                g_tdl_cntx.TimeStrBuff,
                (U8*) g_tdl_cntx.HourBuff1,
                (U8*) g_tdl_cntx.MinBuff1,
                NULL);
            SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.TimeStrBuff);
            inline_index++;

            /* End Time and end date/time */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_END_TIME));
            inline_index++;

            /* End Date */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            TDLDateEditorCallBack(
                g_tdl_cntx.EndDateStrBuff,
                (U8*) g_tdl_cntx.DayBuffEnd,
                (U8*) g_tdl_cntx.MonBuffEnd,
                (U8*) g_tdl_cntx.YearBuffEnd);
            SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.EndDateStrBuff);
            inline_index++;

            /* End Time */
            SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
            mmi_tdl_time_editor_callback(
                g_tdl_cntx.EndTimeStrBuff,
                (U8*) g_tdl_cntx.HourBuff2,
                (U8*) g_tdl_cntx.MinBuff2,
                NULL);
            SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.EndTimeStrBuff);
            inline_index++;

            break;
    }
#else /* __MMI_ADVANCED_TODO__ */ 
    /* To Read didnt indent the code from first column. */
    SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    TDLDateEditorCallBack(
        g_tdl_cntx.DateStrBuff,
        (U8*) g_tdl_cntx.DayBuff,
        (U8*) g_tdl_cntx.MonBuff,
        (U8*) g_tdl_cntx.YearBuff);
    SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.DateStrBuff);
    inline_index++;

    SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
    TDLTimeEditorCallBack(
        g_tdl_cntx.TimeStrBuff,
        (U8*) g_tdl_cntx.HourBuff1,
        (U8*) g_tdl_cntx.MinBuff1,
        NULL,
        (U8*) g_tdl_cntx.HourBuff2,
        (U8*) g_tdl_cntx.MinBuff2,
        NULL);
    SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.TimeStrBuff);
    inline_index++;

#endif /* __MMI_ADVANCED_TODO__ */ 

    /* Note */
#ifdef __MMI_ADVANCED_TODO__
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_NOTE))
    {
#endif /* __MMI_ADVANCED_TODO__ */ 
        SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption((&wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_NOTE));
        inline_index++;

        SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly((&wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.NoteBuff);
        g_tdl_cntx.NoteIndex = inline_index;
        inline_index++;

        /* Alarm */
    #ifdef __MMI_ADVANCED_TODO__
    }
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_ALARM))
    {
    #endif /* __MMI_ADVANCED_TODO__ */ 

        SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption((&wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_ALARM));
        inline_index++;

        SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(
            (&wgui_inline_items[inline_index]),
            (U8*) gAlmOnOffStringforTDL[g_tdl_cntx.HilitedAlmState]);
        inline_index++;

        /* Repeat */
    #ifdef __MMI_ADVANCED_TODO__
    }

    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_REPEAT))
    {
    #endif /* __MMI_ADVANCED_TODO__ */ 

        SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption((&wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_REPEAT));
        inline_index++;

        SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly((&wgui_inline_items[inline_index]), (U8*) gAlmFreqList[g_tdl_cntx.HilitedRepeat]);
        SetInlineItemFollowDown((&wgui_inline_items[inline_index]), inline_index);
        inline_index++;

        SetInlineItemActivation((&wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDOWSelect((&wgui_inline_items[inline_index]), (S32) inline_index, gAlmDaysStates);
        DisableInlineItem((&wgui_inline_items[inline_index]), inline_index);
        g_tdl_cntx.DOWIndex = inline_index;
        inline_index++;
    #ifdef __MMI_ADVANCED_TODO__
    }
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_LOCATION))
    {

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_LOCATION));
        inline_index++;

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(&(wgui_inline_items[inline_index]), (U8*) g_tdl_cntx.LocationBuff);
        g_tdl_cntx.LocationIndex = inline_index;
        inline_index++;

    }
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_PRIORITY))
    {
        gTdlPriorityString[0] = GetString(STR_TODO_PRIORITY_HIGH);
        gTdlPriorityString[1] = GetString(STR_TODO_PRIORITY_MEDIUM);
        gTdlPriorityString[2] = GetString(STR_TODO_PRIORITY_LOW);

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemCaption(&(wgui_inline_items[inline_index]), (U8*) GetString(STR_TODO_PRIORITY));
        inline_index++;

        SetInlineItemActivation(&(wgui_inline_items[inline_index]), INLINE_ITEM_ACTIVATE_WITHOUT_KEY_EVENT, 0);
        SetInlineItemDisplayOnly(
            (&wgui_inline_items[inline_index]),
            (U8*) gTdlPriorityString[g_tdl_cntx.HilitedPriorityState]);
        inline_index++;

    }
    #endif /* __MMI_ADVANCED_TODO__ */ 
    return inline_index;

}

/*****************************************************************************
 * FUNCTION
 *  TDLDateEditorCallBack
 * DESCRIPTION
 *  Construct date string to to display (04/03/12 Thu)
 * PARAMETERS
 *  DateStr     [?]     
 *  day         [?]     
 *  month       [?]     
 *  year        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void TDLDateEditorCallBack(U8 *DateStr, U8 *day, U8 *month, U8 *year)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 mDay, mMonth;
    U16 mYear;
    U16 StrNum, DateStrLen;
    S8 ModifiedDateStr[MAX_LEN_LEAST_VAR];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mDay = (U8) gui_atoi((UI_string_type) day);
    mMonth = (U8) gui_atoi((UI_string_type) month);
    mYear = (U16) gui_atoi((UI_string_type) year);
    memset(DateStr, 0, TDL_MAX_DAY_STR_LEN);

    /* to get the string of week day */
    StrNum = STR_TODO_SUN + DOW(mYear, mMonth, mDay);

    /* to get the last 2 digits of year */
    if (mYear >= 2000)
    {
        mYear = mYear - 2000;
    }
    else
    {
        mYear = mYear - 1900;
    }

    AlmGetStringValue(ModifiedDateStr, (U8) mYear);
    mmi_ucs2cpy((S8*) DateStr, (S8*) ModifiedDateStr);

    mmi_ucs2cat((S8*) DateStr, (S8*) "/");

    AlmGetStringValue(ModifiedDateStr, mMonth);
    mmi_ucs2cat((S8*) DateStr, ModifiedDateStr);

    mmi_ucs2cat((S8*) DateStr, (S8*) "/");

    AlmGetStringValue(ModifiedDateStr, mDay);
    mmi_ucs2cat((S8*) DateStr, (S8*) ModifiedDateStr);

    mmi_ucs2cat((S8*) DateStr, (S8*) " ");
    DateStrLen = TDL_MAX_DAY_STR_LEN/ENCODING_LENGTH - mmi_ucs2strlen((S8*)DateStr);
    mmi_ucs2ncat((S8*) DateStr, (S8*) GetString(StrNum), DateStrLen - 1);

}


/*****************************************************************************
 * FUNCTION
 *  TDLTimeEditorCallBack
 * DESCRIPTION
 *  Construct time string to to display (00:00 - 01:25)
 * PARAMETERS
 *  string_buffer       [?]     
 *  hours_buffer1       [?]     
 *  minutes_buffer1     [?]     
 *  AM_PM_flag1         [?]     
 *  hours_buffer2       [?]     
 *  minutes_buffer2     [?]     
 *  AM_PM_flag2         [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void TDLTimeEditorCallBack(
        U8 *string_buffer,
        U8 *hours_buffer1,
        U8 *minutes_buffer1,
        U8 *AM_PM_flag1,
        U8 *hours_buffer2,
        U8 *minutes_buffer2,
        U8 *AM_PM_flag2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 TimeH1[MAX_LEN_LEAST_VAR], TimeH2[MAX_LEN_LEAST_VAR], TimeM1[MAX_LEN_LEAST_VAR], TimeM2[MAX_LEN_LEAST_VAR];
    U8 TimeValue;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TimeValue = (U8) gui_atoi((UI_string_type) hours_buffer1);
    AlmGetStringValue(TimeH1, TimeValue);

    TimeValue = (U8) gui_atoi((UI_string_type) minutes_buffer1);
    AlmGetStringValue(TimeM1, TimeValue);

    TimeValue = (U8) gui_atoi((UI_string_type) hours_buffer2);
    AlmGetStringValue(TimeH2, TimeValue);

    TimeValue = (U8) gui_atoi((UI_string_type) minutes_buffer2);
    AlmGetStringValue(TimeM2, TimeValue);

    mmi_ucs2cpy((S8*) string_buffer, TimeH1);
    mmi_ucs2cat((S8*) string_buffer, (S8*) ":");
    mmi_ucs2cat((S8*) string_buffer, TimeM1);
    mmi_ucs2cat((S8*) string_buffer, (S8*) " ");
    mmi_ucs2cat((S8*) string_buffer, (S8*) "-");
    mmi_ucs2cat((S8*) string_buffer, (S8*) " ");
    mmi_ucs2cat((S8*) string_buffer, TimeH2);
    mmi_ucs2cat((S8*) string_buffer, (S8*) ":");
    mmi_ucs2cat((S8*) string_buffer, (S8*) TimeM2);

}


/*****************************************************************************
 * FUNCTION
 *  TDLShowSpecificDateList
 * DESCRIPTION
 *  Entry function of To Do List from Calendar application.
 *  Store the date information from Calendar and display to do list.
 * PARAMETERS
 *  CalTime     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void TDLShowSpecificDateList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CALENDAR_V2__
    if (g_tdl_cntx.IsCalledByCalender == CLNDR_MONTHLY_VIEW)
    {
        g_tdl_cntx.ClndrDate.nHour = 23;
        g_tdl_cntx.ClndrDate.nMin = 59;
        g_tdl_cntx.ClndrDate.nSec = 59;
    }
#ifdef __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__    
    else if (g_tdl_cntx.IsCalledByCalender == CLNDR_WEEKLY_VIEW)
    {
        g_tdl_cntx.ClndrDate.nMin = 0;
        g_tdl_cntx.ClndrDate.nSec = 0;
    }
#endif /*__MMI_CLNDR_WEEKLY_VIEW_SUPPORT__*/    
#else /* __MMI_CALENDAR_V2__ */ 
    g_tdl_cntx.ClndrDate.nHour = 23;
    g_tdl_cntx.ClndrDate.nMin = 59;
    g_tdl_cntx.ClndrDate.nSec = 59;

#endif /* __MMI_CALENDAR_V2__ */ 

    g_tdl_cntx.IsListModified = TRUE;

    EntryTDLTaskList();
}


/*****************************************************************************
 * FUNCTION
 *  TDLShowAllList
 * DESCRIPTION
 *  Entry function of To Do List from Organizer
 *  Display all task list.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLShowAllList(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.IsCalledByCalender = FALSE;
    g_tdl_cntx.IsListModified = TRUE;

    EntryTDLTaskList();
}


/*****************************************************************************
 * FUNCTION
 *  TDLReadFromNvram
 * DESCRIPTION
 *  Read data from nvram.
 *  Intialize to default value if data is not intialized
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLReadFromNvram(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    S32 readSize = 0;
    U8 totalRecord = 0;
    while (totalRecord < NUM_OF_TDL)
    {
        readSize = ReadMultiRecord(
            NVRAM_EF_TODO_LIST_LID,
            (U16) totalRecord + 1,
            &(g_tdl_cntx.TaskList[totalRecord]),
            sizeof(ToDoListNode) * NUM_OF_TDL,
            NUM_OF_TDL,
            &error);
        totalRecord += (U8)(readSize / sizeof(ToDoListNode));
    }     
    if (g_tdl_cntx.TaskList[0].Present != 1 && g_tdl_cntx.TaskList[0].Present != 0)
    {
        memset(g_tdl_cntx.TaskList, 0, sizeof(g_tdl_cntx.TaskList));
    }
}


/*****************************************************************************
 * FUNCTION
 *  TDLMakeListOfSelectedDate
 * DESCRIPTION
 *  To initialize task list of selected date from calendar application.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLMakeListOfSelectedDate(U8 Type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 i;
    U8 SelectedDay, Day;
    U8 IsTaskInPreviousDate;
    MYTIME tempTime;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.TotalListedTask = 0;

    memset(g_tdl_cntx.SortedList, 0, sizeof(g_tdl_cntx.SortedList));
    for (i = 0; i < NUM_OF_TDL; i++)
    {
        if (g_tdl_cntx.TaskList[i].Present == 1)
        {
        #ifdef __MMI_CALENDAR_V2__        
            memcpy(&tempTime, &g_tdl_cntx.ClndrDate, sizeof(MYTIME));
        #ifdef __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__
            if (Type == CLNDR_WEEKLY_VIEW)			
            {				
                tempTime.nHour = 23;
                tempTime.nMin = 59;
                tempTime.nSec = 59;
            }
        #endif /*__MMI_CLNDR_WEEKLY_VIEW_SUPPORT__*/            
        #else /*__MMI_CALENDAR_V2__*/
            memcpy(&tempTime, &g_tdl_cntx.ClndrDate, sizeof(MYTIME));
        #endif /*__MMI_CALENDAR_V2__*/
            /* display the task only when the starting day is smaller than selected day */
            if (FindMaxTime(&tempTime, &(g_tdl_cntx.TaskList[i].StartTime)))
            {
                IsTaskInPreviousDate = TRUE;
            }
            else
            {
                IsTaskInPreviousDate = FALSE;
            }

            switch (g_tdl_freq_set[g_tdl_cntx.TaskList[i].Repeat])
            {
                case ALM_FREQ_ONCE: /* find exact match */
            #if defined(__MMI_CALENDAR_V2__) && defined(__MMI_ADVANCED_TODO__)
                    if (Type == CLNDR_MONTHLY_VIEW)
                    {
                        /* sinc time of g_tdl_cntx.ClndrDate is 23:59:59, the last day of task may be missed.*/
                        memcpy(&tempTime, &g_tdl_cntx.ClndrDate, sizeof(MYTIME));
                        tempTime.nHour = 0;
                        tempTime.nMin = 0;
                        tempTime.nSec = 0;
                        
                        if (CompareTime(g_tdl_cntx.ClndrDate, g_tdl_cntx.TaskList[i].StartTime, NULL) >= 0 
							&& CompareTime(g_tdl_cntx.TaskList[i].EndTime, tempTime, NULL) > 0 ||
							CompareTime(g_tdl_cntx.TaskList[i].StartTime, tempTime, NULL) == DT_TIME_EQUAL)
                        {
                            g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = (U8) i;
                            g_tdl_cntx.TotalListedTask++;
                        }
                    }
                #ifdef __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__
                    else
                    {
					    /* sinc time of g_tdl_cntx.ClndrDate is xx:00:00, the last day of task may be missed.*/
                        memcpy(&tempTime, &g_tdl_cntx.ClndrDate, sizeof(MYTIME));
                        tempTime.nHour += (mmi_clndr_get_period_interval() - 1);
                        tempTime.nMin = 59;
                        tempTime.nSec = 59;
						/* temp = (n+1):59, ClndrDate = n:00
						   if ((temp >= start && end > ClndrDate)|| start == ClndrDate && end == ClndrDate)
						*/
                        if ((CompareTime(tempTime, g_tdl_cntx.TaskList[i].StartTime,NULL) >= 0 &&
                            CompareTime(g_tdl_cntx.TaskList[i].EndTime, g_tdl_cntx.ClndrDate, NULL) > 0) ||
							(CompareTime(g_tdl_cntx.TaskList[i].StartTime, g_tdl_cntx.ClndrDate, NULL) == 0 &&
                            CompareTime(g_tdl_cntx.TaskList[i].EndTime, g_tdl_cntx.ClndrDate, NULL) == 0)
							)
                        {
                            g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = (U8) i;
                            g_tdl_cntx.TotalListedTask++;
                        }
                    }
                #endif /*__MMI_CLNDR_WEEKLY_VIEW_SUPPORT__*/
            #else /* __MMI_CALENDAR_V2__ */ 
                    if ((g_tdl_cntx.TaskList[i].StartTime.nYear == g_tdl_cntx.ClndrDate.nYear) &&
                        (g_tdl_cntx.TaskList[i].StartTime.nMonth == g_tdl_cntx.ClndrDate.nMonth) &&
                        (g_tdl_cntx.TaskList[i].StartTime.nDay == g_tdl_cntx.ClndrDate.nDay))
                    {
                        g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = (U8) i;
                        g_tdl_cntx.TotalListedTask++;
                    }
            #endif /* __MMI_CALENDAR_V2__ */ 
                    break;

                case ALM_FREQ_EVERYDAY: /* appear in each date */
                    if (IsTaskInPreviousDate)
                    {
                        g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = (U8) i;
                        g_tdl_cntx.TotalListedTask++;
                    }
                    break;

                case ALM_FREQ_DAYS:
                    if (IsTaskInPreviousDate)
                    {
                        SelectedDay = DOW(g_tdl_cntx.ClndrDate.nYear, g_tdl_cntx.ClndrDate.nMonth, g_tdl_cntx.ClndrDate.nDay);

                        for (Day = 0; Day < MAX_DAY_IN_WEEK; Day++)
                            if ((g_tdl_cntx.TaskList[i].Days & gAlmDayOfWeek[Day]) && (Day == SelectedDay))
                            {
                                g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = (U8) i;
                                g_tdl_cntx.TotalListedTask++;
                            }
                    }
                    break;

                case ALM_FREQ_WEEKLY:
                    if (IsTaskInPreviousDate)
                    {
                        SelectedDay = DOW(g_tdl_cntx.ClndrDate.nYear, g_tdl_cntx.ClndrDate.nMonth, g_tdl_cntx.ClndrDate.nDay);

                        Day = DOW(
                                g_tdl_cntx.TaskList[i].StartTime.nYear,
                                g_tdl_cntx.TaskList[i].StartTime.nMonth,
                                g_tdl_cntx.TaskList[i].StartTime.nDay);

                        if (SelectedDay == Day)
                        {
                            g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = (U8) i;
                            g_tdl_cntx.TotalListedTask++;
                        }
                    }
                    break;

                case ALM_FREQ_MONTHLY:
                    if (IsTaskInPreviousDate)
                    {
                        if (g_tdl_cntx.ClndrDate.nDay == g_tdl_cntx.TaskList[i].StartTime.nDay)
                        {
                            g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = (U8) i;
                            g_tdl_cntx.TotalListedTask++;
                        }
                    }
                    break;
                case ALM_FREQ_YEARLY:
                    if (IsTaskInPreviousDate)
                    {
                        if (g_tdl_cntx.ClndrDate.nMonth== g_tdl_cntx.TaskList[i].StartTime.nMonth&&
                            g_tdl_cntx.ClndrDate.nDay == g_tdl_cntx.TaskList[i].StartTime.nDay)
                        {
                            g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = (U8) i;
                            g_tdl_cntx.TotalListedTask++;
                        }
                    }
                    break;
                default:
                    break;
            }
        }   /* if Present */
    }

    TDLSortTask(g_tdl_cntx.SortedList, g_tdl_cntx.TotalListedTask);
#ifdef __MMI_CALENDAR_V2__
    /* Weekly view won't display birthday information */
    if (Type == CLNDR_WEEKLY_VIEW)
    {
        return;
    }
#endif /*__MMI_CALENDAR_V2__*/


}


/*****************************************************************************
 * FUNCTION
 *  TDLSortTask
 * DESCRIPTION
 *  To sort the task list in decending time order.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLSortTask(U8 *sorted_list, U8 total_task)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i, j, temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < total_task; i++)
    {
        for (j = i; j < total_task; j++)
        {
            if (j > i &&
                FindMaxTime(
                    &g_tdl_cntx.TaskList[sorted_list[j]].StartTime,
                    &g_tdl_cntx.TaskList[sorted_list[i]].StartTime))
            {
                temp = sorted_list[i];
                sorted_list[i] = sorted_list[j];
                sorted_list[j] = temp;
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  TDLMakeListOfAllTask
 * DESCRIPTION
 *  To make the list of all tasks to be displayed.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLMakeListOfAllTask(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.TotalListedTask = 0;

    memset(g_tdl_cntx.SortedList, 0xFF, sizeof(g_tdl_cntx.SortedList));
    for (i = 0; i < NUM_OF_TDL; i++)
    {
        if (g_tdl_cntx.TaskList[i].Present == 1)
        {
            g_tdl_cntx.SortedList[g_tdl_cntx.TotalListedTask] = i;
            g_tdl_cntx.TotalListedTask++;
        }
    }

    TDLSortTask(g_tdl_cntx.SortedList, g_tdl_cntx.TotalListedTask);

}   /* end of Fun */


/*****************************************************************************
 * FUNCTION
 *  TDLWriteToNvram
 * DESCRIPTION
 *  Write todolist data to nvram.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void TDLWriteToNvram(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.IsListModified = TRUE;

    WriteRecord(
        NVRAM_EF_TODO_LIST_LID,
        (U16) (index + 1),
        (void*)&(g_tdl_cntx.TaskList[index]),
        NVRAM_TODO_LIST_RECORD_SIZE,
        &error);
}


/*****************************************************************************
 * FUNCTION
 *  TDLInitInlineVariables
 * DESCRIPTION
 *  Inilialize the variables used in in inline editor screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLInitInlineVariables(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 LocalStr[MAX_LEN_MOST_VAR];
    U8 i, j;

#ifdef __MMI_ADVANCED_TODO__
    U8 dt_type;
#endif 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.CurrHiliteOption == TODO_LIST_TASK_OPTION_ADD)
    {
        TDLAddDefaultRecord();
    }

    i = g_tdl_cntx.CurrTaskIndex;

    if (i >= NUM_OF_TDL)
    {
        return;
    }

    mmi_ucs2cpy(g_tdl_cntx.NoteBuff, (S8*) (g_tdl_cntx.TaskList[i].Note));

    AlmGetStringValue(g_tdl_cntx.MonBuff, g_tdl_cntx.TaskList[i].StartTime.nMonth);
    AlmGetStringValue(g_tdl_cntx.DayBuff, g_tdl_cntx.TaskList[i].StartTime.nDay);

    sprintf(LocalStr, "%d", g_tdl_cntx.TaskList[i].StartTime.nYear);
    mmi_asc_to_ucs2(g_tdl_cntx.YearBuff, LocalStr);

    AlmGetStringValue(g_tdl_cntx.MinBuff1, g_tdl_cntx.TaskList[i].StartTime.nMin);
    AlmGetStringValue(g_tdl_cntx.HourBuff1, g_tdl_cntx.TaskList[i].StartTime.nHour);
#ifdef __MMI_ADVANCED_TODO__
    /* type */
    if (g_tdl_cntx.CurrHiliteOption != TODO_LIST_TASK_OPTION_ADD)
    {
        g_tdl_cntx.CurrTaskType = g_tdl_cntx.TaskList[i].Type;
    }

    /* set field */
    mmi_tdl_get_fields_of_task(g_tdl_cntx.CurrTaskType);

    /* date/time */
    dt_type = mmi_tdl_get_dt_type();
    if (dt_type != TDL_DT_ONLY_START_DT)
    {
        AlmGetStringValue(g_tdl_cntx.MinBuff2, g_tdl_cntx.TaskList[i].EndTime.nMin);
        AlmGetStringValue(g_tdl_cntx.HourBuff2, g_tdl_cntx.TaskList[i].EndTime.nHour);

        if (dt_type == TDL_DT_ALL)
        {
            AlmGetStringValue(g_tdl_cntx.MonBuffEnd, g_tdl_cntx.TaskList[i].EndTime.nMonth);
            AlmGetStringValue(g_tdl_cntx.DayBuffEnd, g_tdl_cntx.TaskList[i].EndTime.nDay);

            sprintf(LocalStr, "%d", g_tdl_cntx.TaskList[i].EndTime.nYear);
            mmi_asc_to_ucs2(g_tdl_cntx.YearBuffEnd, LocalStr);
        }
    }
    /* Priority */
    g_tdl_cntx.HilitedPriorityState = g_tdl_cntx.TaskList[i].Priority;

    /* Location */
    mmi_ucs2cpy(g_tdl_cntx.LocationBuff, (S8*) (g_tdl_cntx.TaskList[i].Location));

#else /* __MMI_ADVANCED_TODO__ */ 
    AlmGetStringValue(g_tdl_cntx.MinBuff2, g_tdl_cntx.TaskList[i].EndMin);
    AlmGetStringValue(g_tdl_cntx.HourBuff2, g_tdl_cntx.TaskList[i].EndHour);
#endif /* __MMI_ADVANCED_TODO__ */ 

    if (g_tdl_freq_set[g_tdl_cntx.TaskList[i].Repeat] == ALM_FREQ_DAYS)
    {
        for (j = 0; j < MAX_DAY_IN_WEEK; j++)
        {
            if (g_tdl_cntx.TaskList[i].Days & gAlmDayOfWeek[j])
            {
                gAlmDaysStates[j] = 1;
            }
            else
            {
                gAlmDaysStates[j] = 0;
            }
        }

    }
    else
    {
        memset(gAlmDaysStates, 0, MAX_DAY_IN_WEEK);
    }

    g_tdl_cntx.HilitedAlmState = g_tdl_cntx.TaskList[i].Alarm;

    g_tdl_cntx.HilitedRepeat = g_tdl_cntx.TaskList[i].Repeat;

}


/*****************************************************************************
 * FUNCTION
 *  TDLAddDefaultRecord
 * DESCRIPTION
 *  Find an empty solt of To Do List array, and initialize default value of the record.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLAddDefaultRecord(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = g_tdl_cntx.CurrTaskIndex = mmi_tdl_pim_util_get_new_index();

    if (i >= NUM_OF_TDL)
    {
        return;
    }

    memset(&g_tdl_cntx.TaskList[i], 0, sizeof(ToDoListNode));

    if (g_tdl_cntx.IsCalledByCalender)
    {
        memcpy(&g_tdl_cntx.TaskList[i].StartTime, &g_tdl_cntx.ClndrDate, sizeof(MYTIME));
    }
    else
    {
        GetDateTime(&g_tdl_cntx.TaskList[i].StartTime);
    }

    g_tdl_cntx.TaskList[i].StartTime.nHour = 0;
    g_tdl_cntx.TaskList[i].StartTime.nMin = 0;
    g_tdl_cntx.TaskList[i].StartTime.nSec = 0;
    g_tdl_cntx.TaskList[i].Days = ALM_WEEK_DAYS;
#ifdef __MMI_ADVANCED_TODO__
    if (g_tdl_cntx.IsCalledByCalender)
    {
        memcpy(&g_tdl_cntx.TaskList[i].EndTime, &g_tdl_cntx.ClndrDate, sizeof(MYTIME));
    }
    else
    {
        GetDateTime(&g_tdl_cntx.TaskList[i].EndTime);
    }
    g_tdl_cntx.TaskList[i].EndTime.nHour = 0;
    g_tdl_cntx.TaskList[i].EndTime.nMin = 0;
    g_tdl_cntx.TaskList[i].EndTime.nSec = 0;

    g_tdl_cntx.TaskList[i].Priority = TDL_TASK_PRIORITY_MEDIUM;

    if (g_tdl_cntx.CurrTaskType == TDL_TASK_ANNIVERSARY)
    {
        g_tdl_cntx.TaskList[i].Repeat = mmi_alm_get_freq_order(TODO_FREQ_NUM + 1, g_tdl_freq_set, ALM_FREQ_YEARLY);
    }
#endif /* __MMI_ADVANCED_TODO__ */ 
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_pim_util_get_new_index
 * DESCRIPTION
 *  Find an empty solt of To Do List array
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_tdl_pim_util_get_new_index(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < NUM_OF_TDL; i++)
    {
        if ((g_tdl_cntx.TaskList[i].Present != 1))
            break;
    }

    return i;
}

/*****************************************************************************
 * FUNCTION
 *  EntryTDLDelete
 * DESCRIPTION
 *  Display confirmation screen for deleting one task.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLDelete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayConfirm(
        STR_GLOBAL_YES,
        IMG_GLOBAL_YES,
        STR_GLOBAL_NO,
        IMG_GLOBAL_NO,
        get_string(STR_TODO_LIST_DELETE_ONE_TASK_QUERY),
        IMG_GLOBAL_QUESTION,
        WARNING_TONE);

    SetLeftSoftkeyFunction(TDLDeleteOneTask, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_tdl_task_list_goback, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  TDLDeleteOneTask
 * DESCRIPTION
 *  Delete one task from To Do List
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLDeleteOneTask(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i, result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = g_tdl_cntx.CurrTaskIndex;

    result = mmi_tdl_delete_record(i);

    if (result)
    {
        TDLShowPopupScreen(STR_GLOBAL_DELETED);
    }
    else
    {
        DisplayPopup(
            (U8*) GetString(STR_GLOBAL_UNFINISHED),
            IMG_GLOBAL_UNFINISHED,
            0,
            UI_POPUP_NOTIFYDURATION_TIME,
            (U8) ERROR_TONE);
	}
}
/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_delete_record
 * DESCRIPTION
 *  Delete one task from To Do List
 * PARAMETERS
 *  index       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_tdl_delete_record(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.TaskList[index].Present == 1)
    {
        AlmCancelAlarm((U8) (index + ALM_TDL_START));

        memset(&g_tdl_cntx.TaskList[index], 0, sizeof(ToDoListNode));
        TDLWriteToNvram(index);
    #ifdef __SYNCML_SUPPORT__
        mmi_syncml_tdl_data_changed_notification(SYNCML_RECORD_DELETE, index);
 	#endif       
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }

}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLDeleteAll
 * DESCRIPTION
 *  Display confirmation screen for deleting all tasks.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLDeleteAll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 str[64];
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2cpy((PS8) str, (PS8)get_string(STR_GLOBAL_DELETE_ALL));
    mmi_ucs2cat((PS8) str, (PS8)L"?");
    
    DisplayConfirm(
        STR_GLOBAL_YES,
        IMG_GLOBAL_YES,
        STR_GLOBAL_NO,
        IMG_GLOBAL_NO,
        (UI_string_type)str,
        IMG_GLOBAL_QUESTION,
        WARNING_TONE);
    
	SetLeftSoftkeyFunction(TDLDeleteAllTask, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_tdl_task_list_goback, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  TDLDeleteAllTask
 * DESCRIPTION
 *  Delete all tasks from To Do List
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLDeleteAllTask(void)
{
#ifdef __MTK_TARGET__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYQUEUE Message;
    MMIEQNVRAMRESETREQ *local_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (g_tdl_cntx.IsCalledByCalender)
	{
		mmi_tdl_reset_handler(NULL);
	}
	else
	{		
		Message.oslSrcId = MOD_MMI;
		Message.oslDestId = MOD_L4C;
		Message.oslMsgId = MSG_ID_MMI_EQ_NVRAM_RESET_REQ;
		local_data = (MMIEQNVRAMRESETREQ*) OslConstructDataPtr(sizeof(MMIEQNVRAMRESETREQ));

		local_data->lid = NVRAM_EF_TODO_LIST_LID;

		local_data->reset_category = NVRAM_RESET_CERTAIN;

		Message.oslDataPtr = (oslParaType*) local_data;
		Message.oslPeerBuffPtr = NULL;
		SetProtocolEventHandler(mmi_tdl_reset_handler, MSG_ID_MMI_EQ_NVRAM_RESET_RSP);
		OslMsgSendExtQueue(&Message);
	}
#else /* __MTK_TARGET__ */ 
    mmi_tdl_reset_handler(NULL);
#endif /* __MTK_TARGET__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_reset_handler
 * DESCRIPTION
 *  Display popup screen with corresponding messages.
 * PARAMETERS
 *  msg         [?]         
 *  Msg(?)      [IN]        Enum value of message type.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_reset_handler(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j;
    U8 cancelAlarmIndex[NUM_OF_TDL];
    U8 Amount = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.IsCalledByCalender)
    {
        for (i = 0; i < g_tdl_cntx.TotalListedTask; i++)
        {
            j = g_tdl_cntx.SortedList[i];
            if (g_tdl_cntx.TaskList[j].Present == 0)
            {
                continue;
            }
            if (g_tdl_cntx.TaskList[j].Alarm == TODO_LIST_ALARM_ON)
            {
                cancelAlarmIndex[Amount] = j + ALM_TDL_START;
                Amount++;
            }

            memset(&g_tdl_cntx.TaskList[j], 0, sizeof(ToDoListNode));
            TDLWriteToNvram(j);
        #ifdef __SYNCML_SUPPORT__
            mmi_syncml_tdl_data_changed_notification(SYNCML_RECORD_DELETE, j);
        #endif
        }
    }
    else
    {
        for (i = 0; i < NUM_OF_TDL; i++)
        {
            if (g_tdl_cntx.TaskList[i].Present == 0)
            {
                continue;
            }

            if (g_tdl_cntx.TaskList[i].Alarm == TODO_LIST_ALARM_ON)
            {
				cancelAlarmIndex[Amount] = i + ALM_TDL_START;
                Amount++;
            }

            memset(&g_tdl_cntx.TaskList[i], 0, sizeof(ToDoListNode));
        #ifndef __MTK_TARGET__
            TDLWriteToNvram(i);
        #endif 
        #ifdef __SYNCML_SUPPORT__
            mmi_syncml_tdl_data_changed_notification(SYNCML_RECORD_DELETE, i);
        #endif
        }
    }

    /*Cancel Alarm */
    AlmCancelMulltiAlarm(cancelAlarmIndex, Amount);
    
    g_tdl_cntx.IsListModified = TRUE;
    TDLShowPopupScreen(STR_GLOBAL_DELETED);
}


/*****************************************************************************
 * FUNCTION
 *  TDLShowPopupScreen
 * DESCRIPTION
 *  Display popup screen with corresponding messages.
 * PARAMETERS
 *  Msg     [IN]        Enum value of message type.
 * RETURNS
 *  void
 *****************************************************************************/
void TDLShowPopupScreen(U16 Msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 ScreenToShow;
    U16 ScreenImageId;
    ALL_TONE_ENUM ScreenTone;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (Msg)
    {
        case STR_TODO_LIST_EMPTY_NOTE_MSG:
        {
            ScreenImageId = IMG_GLOBAL_EMPTY;
            ScreenToShow = SCR_TDL_TASK_EDIT;
            ScreenTone = EMPTY_LIST_TONE;
            break;

        }
        default:    /* case STR_GLOBAL_DONE */
        {
            ScreenImageId = IMG_GLOBAL_ACTIVATED;
            ScreenTone = SUCCESS_TONE;
        #ifdef __MMI_CALENDAR_V2__
            if (g_tdl_cntx.IsCalledByCalender >= CLNDR_MONTHLY_VIEW)
            {
                ScreenToShow = SCR_ID_CLNDR_SCREEN;
            }
            else
        #endif /* __MMI_CALENDAR_V2__ */ 
            {
                ScreenToShow = SCR_TDL_TASK_LIST;
            }
            break;
        }
    }

    DisplayPopup((U8*) GetString(Msg), ScreenImageId, 0, UI_POPUP_NOTIFYDURATION_TIME, (U8) ScreenTone);

#if defined(__MMI_VCALENDAR__)
    if (g_tdl_cntx.CurrHiliteOption == TODO_FROM_NETWORK)
    {
        if (Msg == STR_GLOBAL_SAVED || Msg == STR_TODO_ALARM_OFF_DONE || Msg == STR_TODO_INVALID_END_TIME)
        {
            mmi_vobj_clear_one_file_buffer();
            mmi_vclndr_free_buffer();
            DeleteNScrId(SCR_ID_VCLNDR_RECV_OPT);
            DeleteScreenIfPresent(SCR_ID_VOBJ_RECV_OBJECT);            
            return;
        }
    }
    else if (g_tdl_cntx.CurrHiliteOption == TODO_FROM_FMGR)
    {
        if (Msg == STR_GLOBAL_SAVED || Msg == STR_TODO_ALARM_OFF_DONE || Msg == STR_TODO_INVALID_END_TIME)
        {
            DeleteScreenIfPresent(SCR_TDL_TASK_EDIT);
            return;
        }
    }
#endif /* defined(__MMI_VCALENDAR__) */ 

    DeleteUptoScrID(ScreenToShow);
}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLReminder
 * DESCRIPTION
 *  Display reminder screen when TDL alarm expires.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLReminder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 TimeString[MAX_LEN_MOST_VAR * 2];
    U8 i;
    S32 NoteLen;
    U8 *guiBuffer;
#ifndef __MMI_ADVANCED_TODO__
    MYTIME EndTime;
#else
	S8 DateString[MAX_LEN_MOST_VAR * 2];
#endif /*__MMI_ADVANCED_TODO__*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StopTimer(ALARM_TIMER_WAIT_FOR_CALL);

    i = (g_alm_frm_cntx.CurrAlmIndex - ALM_TDL_START);

    if (g_tdl_cntx.TaskList[i].Present == 0 || i > NUM_OF_TDL)
    {
        return;
    }

    if (g_tdl_freq_set[g_tdl_cntx.TaskList[i].Repeat] == ALM_FREQ_ONCE) /* turn off alarm */
    {
        g_tdl_cntx.TaskList[i].Alarm = 0;
        TDLWriteToNvram(i);
    #ifdef __SYNCML_SUPPORT__
        mmi_syncml_tdl_data_changed_notification(SYNCML_RECORD_MODIFY, i);
    #endif
    }

    if (!IsMyTimerExist(ALARM_ALERT_NOTIFYDURATION_TIMER))
    {
        StartTimer(ALARM_ALERT_NOTIFYDURATION_TIMER, ALM_EXPIRE_DURATION, AlmHandleAlarmTimeout);
    }

    EntryNewScreen(SCR_TDL_REMINDER, ExitTDLReminder, NULL, NULL);
    ClearKeyEvents();
    g_tdl_cntx.IsSaveToHistory = TRUE;

    TurnOnBacklight(1);

    guiBuffer = GetCurrGuiBuffer(SCR_TDL_REMINDER);

    SetParentHandler(0);
    
    mmi_ucs2cpy(g_tdl_cntx.RminderNote, GetString(STR_TODO_LIST_TIME));
    mmi_ucs2cat(g_tdl_cntx.RminderNote, ":");
    mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
#ifdef __MMI_ADVANCED_TODO__
    mmi_tdl_get_fields_of_task(g_tdl_cntx.TaskList[i].Type);
    if (mmi_tdl_get_dt_type() == TDL_DT_ONLY_START_DT)
    {
        date_string(&g_tdl_cntx.TaskList[i].StartTime, (UI_string_type) DateString, DT_IDLE_SCREEN);
        time_string(&g_tdl_cntx.TaskList[i].StartTime, (UI_string_type) TimeString, DT_IDLE_SCREEN);
        mmi_ucs2cat(g_tdl_cntx.RminderNote, DateString);
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, TimeString);    
    }
    else if (mmi_tdl_get_dt_type() == TDL_DT_DATE_AND_TIMEPERIOD)
    {
        date_string(&g_tdl_cntx.TaskList[i].StartTime, (UI_string_type) DateString, DT_IDLE_SCREEN);
        time_string(&g_tdl_cntx.TaskList[i].StartTime, (UI_string_type) TimeString, DT_IDLE_SCREEN);
        mmi_ucs2cat(g_tdl_cntx.RminderNote, DateString);
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, TimeString);            
        time_string(&g_tdl_cntx.TaskList[i].EndTime, (UI_string_type) TimeString, DT_IDLE_SCREEN);        
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "~");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, TimeString);    
    }
    else
    {
        date_string(&g_tdl_cntx.TaskList[i].StartTime, (UI_string_type) DateString, DT_IDLE_SCREEN);
        time_string(&g_tdl_cntx.TaskList[i].StartTime, (UI_string_type) TimeString, DT_IDLE_SCREEN);
        mmi_ucs2cat(g_tdl_cntx.RminderNote, DateString);
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, TimeString);            
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "~");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
        date_string(&g_tdl_cntx.TaskList[i].EndTime, (UI_string_type) DateString, DT_IDLE_SCREEN);
        time_string(&g_tdl_cntx.TaskList[i].EndTime, (UI_string_type) TimeString, DT_IDLE_SCREEN);        
        mmi_ucs2cat(g_tdl_cntx.RminderNote, DateString);
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, TimeString);        
    }
#else /* __MMI_ADVANCED_TODO__ */ 
    time_string(&g_tdl_cntx.TaskList[i].StartTime, (UI_string_type) TimeString, DT_IDLE_SCREEN);
    mmi_ucs2cat(g_tdl_cntx.RminderNote, TimeString);  
    mmi_ucs2cat(g_tdl_cntx.RminderNote, "~");
    
    EndTime.nHour = g_tdl_cntx.TaskList[i].EndHour;
    EndTime.nMin = g_tdl_cntx.TaskList[i].EndMin;
    
    time_string(&EndTime, (UI_string_type) TimeString, DT_IDLE_SCREEN);
    mmi_ucs2cat(g_tdl_cntx.RminderNote, TimeString);  
#endif /* __MMI_ADVANCED_TODO__ */ 

    mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
    mmi_ucs2cat(g_tdl_cntx.RminderNote, GetString(STR_TODO_NOTE));
    mmi_ucs2cat(g_tdl_cntx.RminderNote, ":");
    mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");

    mmi_ucs2cat(g_tdl_cntx.RminderNote, (S8*) g_tdl_cntx.TaskList[i].Note);

#ifdef __MMI_ADVANCED_TODO__
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_LOCATION))
    {
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, GetString(STR_TODO_LOCATION));
        mmi_ucs2cat(g_tdl_cntx.RminderNote, ":");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, "\n");
        mmi_ucs2cat(g_tdl_cntx.RminderNote, (S8*) g_tdl_cntx.TaskList[i].Location);
    }
#endif /*__MMI_ADVANCED_TODO__*/

    NoteLen = mmi_ucs2strlen(g_tdl_cntx.RminderNote);

    ShowCategory74Screen(
        STR_TODO_LIST_CAP_REMINDER,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        0,
        0,
        (U8*) g_tdl_cntx.RminderNote,
        NoteLen,
        guiBuffer);

    ForceSubLCDScreen(EntryAlmSubLcdScreen);

    /* Play the tone after display subLCD screen */
    AlmPlayAlarmTone();

    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);

    SetLeftSoftkeyFunction(TDLExitReminderScreen, KEY_EVENT_UP);

    SetKeyHandler(TDLExitReminderScreen, KEY_END, KEY_EVENT_DOWN);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_context
 * DESCRIPTION
 *  get global context of todolist
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 tdl_context_struct* mmi_tdl_get_context(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return &g_tdl_cntx;
}


/*****************************************************************************
 * FUNCTION
 *  ExitTDLReminder
 * DESCRIPTION
 *  Exit function of reminder screen, stop tone and add screen to history.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitTDLReminder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);
    AlmsStopAlarmTone();

    if (g_tdl_cntx.IsSaveToHistory == TRUE)
    {
        GenericExitScreen(SCR_TDL_REMINDER, EntryTDLReminder);
    }
    if (g_alm_frm_cntx.IsPwronAlarm == FALSE)
    {
        GoBackSubLCDHistory();
    }
}


/*****************************************************************************
 * FUNCTION
 *  TDLExitIndScreen
 * DESCRIPTION
 *  Exit To Do List reminder screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLExitIndScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GetExitScrnID() == SCR_TDL_REMINDER)
    {
        GoBackBothLCDHistory();
    }
    else
    {
        DeleteScreenIfPresent(SCR_TDL_REMINDER);
    }
}


/*****************************************************************************
 * FUNCTION
 *  TDLExitReminderScreen
 * DESCRIPTION
 *  Exit from To Do List Reminder Screen.
 *  Decrease the Alarm id and Go To Previous Screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLExitReminderScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TurnOffBacklight();
    StopTimer(ALARM_ALERT_NOTIFYDURATION_TIMER);

    g_tdl_cntx.IsSaveToHistory = FALSE;
    AlmsStopAlarmTone();

    if (g_alm_frm_cntx.IsPwronAlarm == FALSE)
    {
        TDLExitIndScreen();
        g_alm_frm_cntx.CurrAlmIndex = 0xff;
        if (g_alm_frm_cntx.IsExitByTimer == FALSE)
        {
            AlmExecPwrOnAlarm();
        }
    }
    else
    {

        if (GetCurrScrnId() == (U16) SCR_ID_ALM_PWRON_CONFIRM)
        {
            TDLExitIndScreen();
        }
    #ifdef __NVRAM_IN_USB_MS__            
        else if (g_pwr_context.PowerOnMode == POWER_ON_USB)
        {
            /* USB may be plugged out while alarm is alerting */
            if (GetScreenCountInHistory() > 0)
            {
                TDLExitIndScreen();
            }
        }
    #endif      
        else
        {
            EntryAlmPowerOnConfirmation();
        }
        g_alm_frm_cntx.CurrAlmIndex = 0xff;
    #ifdef __MTK_TARGET__
        if (g_alm_frm_cntx.IsExitByTimer == FALSE)
        {
            AlmExecPwrOffAlarm();
        }
    #endif /* __MTK_TARGET__ */ 
    }    
}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLEditNote
 * DESCRIPTION
 *  Full screen editor to edit note.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLEditNote(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 scrID = 0, titleStr = 0, note_len = 0;
    S8 *noteStr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    if (g_tdl_cntx.HilitedInlineEditor == g_tdl_cntx.LocationIndex)
    {
        scrID = SCR_TDL_EDIT_LOCATION;
        titleStr = STR_TODO_LOCATION;
        noteStr = glocationString;
    }
    else if (g_tdl_cntx.HilitedInlineEditor == g_tdl_cntx.NoteIndex)
    {
        scrID = SCR_TDL_EDIT_NOTE;
        titleStr = STR_TODO_LIST_CAP_NOTE;
        noteStr = gnoteString;
    }
#else /* __MMI_ADVANCED_TODO__ */ 
    scrID = SCR_TDL_EDIT_NOTE;
    titleStr = STR_TODO_LIST_CAP_NOTE;
    noteStr = gnoteString;

#endif /* __MMI_ADVANCED_TODO__ */ 
    EntryNewScreen(scrID, NULL, EntryTDLEditNote, NULL);

    SetParentHandler(0);

    if (g_tdl_cntx.HistoryPtr)
    {
        guiBuffer = g_tdl_cntx.HistoryPtr->guiBuffer;
    }
    else
    {
        guiBuffer = GetCurrGuiBuffer(scrID);
    }

    if (MAX_TODO_NOTE_LEN < GUI_INPUT_BOX_MAX_LENGTH)
    {
        note_len = MAX_TODO_NOTE_LEN;
    }
    else
    {
    	note_len = GUI_INPUT_BOX_MAX_LENGTH;
    }
    ShowCategory5Screen(
        titleStr,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        INPUT_TYPE_ALPHANUMERIC_SENTENCECASE,   /* |INPUT_TYPE_USE_ENCODING_BASED_LENGTH */
        (U8*) noteStr,
        note_len,
        guiBuffer);

    if (g_tdl_cntx.HistoryPtr)
    {
        OslMfree(g_tdl_cntx.HistoryPtr);
        g_tdl_cntx.HistoryPtr = NULL;
    }

    SetLeftSoftkeyFunction(EntryTDLNoteOption, KEY_EVENT_UP);
    SetCategory5RightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  TDLGoBackEditorScreen
 * DESCRIPTION
 *  Go back to full screen editor.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLGoBackEditorScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 scrID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    if (g_tdl_cntx.HilitedInlineEditor == g_tdl_cntx.LocationIndex)
    {
        scrID = SCR_TDL_EDIT_LOCATION;       
    }
    else
    {
        scrID = SCR_TDL_EDIT_NOTE;       
    }
#else  /* __MMI_ADVANCED_TODO__ */       
    scrID = SCR_TDL_EDIT_NOTE;
#endif /* __MMI_ADVANCED_TODO__ */     
    GoBackToHistory(scrID);
}


/*****************************************************************************
 * FUNCTION
 *  TDLGoBackInlineScreen
 * DESCRIPTION
 *  Go back to inline editor screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLGoBackInlineScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    if (g_tdl_cntx.HilitedInlineEditor == g_tdl_cntx.LocationIndex)
    {
        mmi_ucs2cpy(g_tdl_cntx.LocationBuff, glocationString);
    }
    else if (g_tdl_cntx.HilitedInlineEditor == g_tdl_cntx.NoteIndex)
    {
        mmi_ucs2cpy(g_tdl_cntx.NoteBuff, gnoteString);
    }
#else /* __MMI_ADVANCED_TODO__ */ 
    mmi_ucs2cpy(g_tdl_cntx.NoteBuff, gnoteString);
#endif /* __MMI_ADVANCED_TODO__ */ 
    GoBackToHistory(SCR_TDL_TASK_EDIT);
}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLNoteOption
 * DESCRIPTION
 *  Display list of options for editing note
 *  Register key handlers.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLNoteOption(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nStrItemList[3];    /* Stores the strings id of submenus returned */
    U16 nNumofItem;         /* Stores no of children in the submenu */
    U8 *guiBuffer;          /* Buffer holding history data */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    if (g_tdl_cntx.HilitedInlineEditor == g_tdl_cntx.LocationIndex)
    {
        mmi_frm_hide_menu_item(MITEM_TODO_LIST_USE_TEMPLATE);
    }
    else if (g_tdl_cntx.HilitedInlineEditor == g_tdl_cntx.NoteIndex)
    {
        mmi_frm_unhide_menu_item(MITEM_TODO_LIST_USE_TEMPLATE);
    }
#endif /* __MMI_ADVANCED_TODO__ */ 

    /* 1 Call Exit Handler */
    EntryNewScreen(SCR_TDL_NOTE_OPTION, NULL, EntryTDLNoteOption, NULL);

    /* 2 Get current screen to gui buffer  for history purposes */
    guiBuffer = GetCurrGuiBuffer(SCR_TDL_NOTE_OPTION);

    /* 3. Retrieve no of child of menu item to be displayed */
    nNumofItem = GetNumOfChild_Ext(MITEM_TODO_LIST_NOTE_OPTION);

    /* 5. Retrieve string ids in sequence of given menu item to be displayed */
    GetSequenceStringIds_Ext(MITEM_TODO_LIST_NOTE_OPTION, nStrItemList);

    /* 6 Set current parent id */
    SetParentHandler(MITEM_TODO_LIST_NOTE_OPTION);

    /* 7 Register highlight handler to be called in menu screen */
    RegisterHighlightHandler(ExecuteCurrHiliteHandler_Ext);
    /* hide the templete string for location */

    /* 8 Display Category Screen */
    ShowCategory15Screen(
        STR_GLOBAL_OPTIONS,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        nNumofItem,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        LIST_MENU,
        0,
        guiBuffer);

    /* 9.Register function with right softkey */
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);

    /* 10. Register Exit handler */
}


/*****************************************************************************
 * FUNCTION
 *  HighlightTDLTemplateIndex
 * DESCRIPTION
 *  Store index of selected template
 * PARAMETERS
 *  nIndex      [IN]        Index of selected template.
 * RETURNS
 *  void
 *****************************************************************************/
void HighlightTDLTemplateIndex(S32 nIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.SelectedTemplate = (U8) nIndex;
}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLTemplate
 * DESCRIPTION
 *  Display list of template
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLTemplate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 nStrItemList[MAX_TODO_LIST_TEMPLATE];   /* Stores the strings id */
    U8 *guiBuffer;                              /* Buffer holding history data */
    S32 j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_TDL_LIST_TEMPLATE, NULL, EntryTDLTemplate, NULL);

    guiBuffer = GetCurrGuiBuffer(SCR_TDL_LIST_TEMPLATE);

    SetParentHandler(MITEM_TODO_LIST_NOTE_OPTION);

    RegisterHighlightHandler(HighlightTDLTemplateIndex);

    for (j = 0; j < MAX_TODO_LIST_TEMPLATE; j++)
    {
        nStrItemList[j] = (U16) (STR_TODO_TEMPLATE_1 + j);
    }

    ShowCategory15Screen(
        STR_TODO_LIST_USE_TEMPLATE,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_TODO_LIST_TEMPLATE,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        LIST_MENU,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(TDLInsertTemplate, KEY_EVENT_UP);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_hdlr_note_option_save
 * DESCRIPTION
 *  Highlight handler of "Save" for note option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_hdlr_note_option_save(void)
{
    SetLeftSoftkeyFunction(TDLGoBackInlineScreen, KEY_EVENT_UP);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_hdlr_note_option_template
 * DESCRIPTION
 *  Highlight handler of "Use Template" for note option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_hdlr_note_option_template(void)
{
    SetLeftSoftkeyFunction(EntryTDLTemplate, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_hdlr_input_method
 * DESCRIPTION
 *  Highlight handler of "Input Method" for note option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_hdlr_note_option_input_method(void)
{
    SetLeftSoftkeyFunction(EntryInputMethodScreen, KEY_EVENT_UP);
    RegisterInputMethodScreenCloseFunction(TDLGoBackEditorScreen);
}


/*****************************************************************************
 * FUNCTION
 *  TDLInsertTemplate
 * DESCRIPTION
 *  Inssert selected template into buffer and go back to editor screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void TDLInsertTemplate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 Tempbuffer[MAX_TODO_LIST_NOTE];
    S32 TemplateLen;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.HistoryPtr)
    {
        OslMfree(g_tdl_cntx.HistoryPtr);
    }

    g_tdl_cntx.HistoryPtr = OslMalloc(sizeof(history));

    TemplateLen = mmi_ucs2strlen(GetString((U16) (STR_TODO_TEMPLATE_1 + g_tdl_cntx.SelectedTemplate)));

    mmi_ucs2ncpy(Tempbuffer, GetString((U16) (STR_TODO_TEMPLATE_1 + g_tdl_cntx.SelectedTemplate)), TemplateLen);

    GetHistory(SCR_TDL_EDIT_NOTE, g_tdl_cntx.HistoryPtr);

    AppendCategory5String(
        INPUT_TYPE_ALPHANUMERIC_SENTENCECASE,   /* | INPUT_TYPE_USE_ENCODING_BASED_LENGTH */
        (U8*) gnoteString,
        MAX_TODO_NOTE_LEN,
        (U8*) Tempbuffer,
        g_tdl_cntx.HistoryPtr->guiBuffer);

    GoBacknHistory(1);
}


/*****************************************************************************
 * FUNCTION
 *  EntryTDLSaveConfirm
 * DESCRIPTION
 *  Confirmation screen for saving To Do List
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryTDLSaveConfirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DisplayConfirm(
        STR_GLOBAL_YES,
        IMG_GLOBAL_YES,
        STR_GLOBAL_NO,
        IMG_GLOBAL_NO,
        get_string(STR_GLOBAL_SAVE_ASK),
        IMG_GLOBAL_QUESTION,
        WARNING_TONE);

    SetLeftSoftkeyFunction(TDLSaveTask, KEY_EVENT_UP);

#if defined(__MMI_VCALENDAR__)
    if (g_tdl_cntx.CurrHiliteOption == TODO_FROM_NETWORK)
    {
        SetRightSoftkeyFunction(mmi_vclndr_goback_1_history /* mmi_vobj_abort_object */ , KEY_EVENT_UP);
    }
    else if (g_tdl_cntx.CurrHiliteOption == TODO_FROM_FMGR)
    {
        SetRightSoftkeyFunction(mmi_vclndr_goback_1_history, KEY_EVENT_UP);
    }
    else
#endif /* defined(__MMI_VCALENDAR__) */ 
        SetRightSoftkeyFunction(mmi_tdl_task_list_goback, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  TDLIsTaskChanged
 * DESCRIPTION
 *  To verify is task information changed in edit task screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 TDLIsTaskChanged(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

#ifdef __MMI_ADVANCED_TODO__
    U8 dt_type;
#endif 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i = g_tdl_cntx.CurrTaskIndex;

    if (g_tdl_cntx.TaskList[i].StartTime.nDay != (U8) gui_atoi((UI_string_type) g_tdl_cntx.DayBuff))
    {
        return TRUE;
    }

    if (g_tdl_cntx.TaskList[i].StartTime.nMonth != (U8) gui_atoi((UI_string_type) g_tdl_cntx.MonBuff))
    {
        return TRUE;
    }

    if (g_tdl_cntx.TaskList[i].StartTime.nYear != (U16) gui_atoi((UI_string_type) g_tdl_cntx.YearBuff))
    {
        return TRUE;
    }

    if (g_tdl_cntx.TaskList[i].StartTime.nHour != (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff1))
    {
        return TRUE;
    }

    if (g_tdl_cntx.TaskList[i].StartTime.nMin != (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff1))
    {
        return TRUE;
    }
#ifdef __MMI_ADVANCED_TODO__
    dt_type = mmi_tdl_get_dt_type();
    switch (dt_type)
    {
        case TDL_DT_DATE_AND_TIMEPERIOD:
            if (g_tdl_cntx.TaskList[i].EndTime.nHour != (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff2))
            {
                return TRUE;
            }

            if (g_tdl_cntx.TaskList[i].EndTime.nMin != (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff2))
            {
                return TRUE;
            }
            break;
        case TDL_DT_ALL:
            if (g_tdl_cntx.TaskList[i].EndTime.nDay != (U8) gui_atoi((UI_string_type) g_tdl_cntx.DayBuffEnd))
            {
                return TRUE;
            }

            if (g_tdl_cntx.TaskList[i].EndTime.nMonth != (U8) gui_atoi((UI_string_type) g_tdl_cntx.MonBuffEnd))
            {
                return TRUE;
            }

            if (g_tdl_cntx.TaskList[i].EndTime.nYear != (U16) gui_atoi((UI_string_type) g_tdl_cntx.YearBuffEnd))
            {
                return TRUE;
            }
            break;
        case TDL_DT_ONLY_START_DT:
        default:
            break;
    }

    if (mmi_ucs2cmp((S8*)g_tdl_cntx.LocationBuff, (S8*)g_tdl_cntx.TaskList[i].Location) != 0)
    {
        return TRUE;
    }

    if ((U8) g_tdl_cntx.HilitedPriorityState != (U8) g_tdl_cntx.TaskList[i].Priority)
    {
        return TRUE;
    }
#else /* __MMI_ADVANCED_TODO__ */ 

    if (g_tdl_cntx.TaskList[i].EndHour != (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff2))
    {
        return TRUE;
    }

    if (g_tdl_cntx.TaskList[i].EndMin != (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff2))
    {
        return TRUE;
    }

#endif /* __MMI_ADVANCED_TODO__ */ 
    if ((U8) g_tdl_cntx.HilitedAlmState != (U8) g_tdl_cntx.TaskList[i].Alarm)
    {
        return TRUE;
    }

    if ((U8) g_tdl_cntx.HilitedRepeat != (U8) g_tdl_cntx.TaskList[i].Repeat)
    {
        return TRUE;
    }

    if (mmi_ucs2cmp((S8*)g_tdl_cntx.NoteBuff, (S8*)g_tdl_cntx.TaskList[i].Note) != 0)
    {
        return TRUE;
    }

    return FALSE;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_set_clndr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  CalTime     [?]         
 *  Type        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_set_clndr(MYTIME *CalTime, U8 Type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.IsCalledByCalender = Type;

    g_tdl_cntx.ClndrDate.nYear = CalTime->nYear;
    g_tdl_cntx.ClndrDate.nMonth = CalTime->nMonth;
    g_tdl_cntx.ClndrDate.nDay = CalTime->nDay;
    g_tdl_cntx.ClndrDate.nHour = CalTime->nHour;
    g_tdl_cntx.ClndrDate.nMin = CalTime->nMin;
    g_tdl_cntx.ClndrDate.nSec = CalTime->nSec;
    g_tdl_cntx.ClndrDate.DayIndex = CalTime->DayIndex;
}

#ifdef __SYNCML_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_total_index
 * DESCRIPTION
 *  Get store index of all todolist
 * PARAMETERS
 *  list        [IN/OUT]            index list of todolist
 * RETURNS
 *  U16  total amount of todolist
 *****************************************************************************/
U16 mmi_tdl_get_total_index(U16 *list)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i,count = 0;   

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < NUM_OF_TDL; i++)
    {
        if (g_tdl_cntx.TaskList[i].Present == 1)
        {
           if (list != NULL)
           {
               list[count++] = (U16)i;
           }
           else
           {
               count++;
           }
        }
    }

    return count;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_sync_task
 * DESCRIPTION
 *  Synchronize the todolist data
 * PARAMETERS
 *  action        [IN]            sync type
 *  path          [IN/OUT]     file path of sync data
 *  index         [IN/OUT]     index of todolist
 * RETURNS
 *  U16  error code
 *****************************************************************************/
U16 mmi_tdl_sync_task(U8 action, S8 *path, U16 *index, U8 sync_chset)
{
    U8 result = VOBJ_ERR_NO_ERROR;
    S32 writeResult;
    ToDoListNode task;
    U16 checkTDL;
    
    switch(action)
    {           
        case MMI_TDL_SYNCML_ADD:
            *index = (U16)mmi_tdl_pim_util_get_new_index();
            
		case MMI_TDL_SYNCML_MODIFY:
            if (*index >= NUM_OF_TDL)
            {
                return MMI_TDL_SYNCML_ERR_MEMORY_FULL;
            }
            /* parse vCalendar to todolist */
            g_vclndr_cntx.vcalendar_encoding = (mmi_chset_enum) sync_chset;
            result = mmi_vclndr_reader(path, &task);               
            
            /* transfer error code */
            result = mmi_tdl_vcalendar_err_mapping(result);
            
            if (result == MMI_TDL_SYNCML_ERR_NO_ERROR)
            {
            	task.Present = 1;
                checkTDL = mmi_tdl_is_valid_fields(&task);
                if (task.Alarm == TODO_LIST_ALARM_ON && checkTDL == MMI_TDL_SUCCESS)
                {
                    AlmSetAlarm((U8) (*index + ALM_TDL_START));
                }
            	memcpy(&g_tdl_cntx.TaskList[*index], &task, sizeof(ToDoListNode));            
            	TDLWriteToNvram(*index);
                if (action == MMI_TDL_SYNCML_ADD)
                {
                    mmi_syncml_tdl_data_changed_notification(SYNCML_RECORD_ADD, *index);
                }
                else if (action == MMI_TDL_SYNCML_MODIFY)
                {
                    mmi_syncml_tdl_data_changed_notification(SYNCML_RECORD_MODIFY, *index);
                }
            }
            return result;
 
        case MMI_TDL_SYNCML_DELETE:
            if (*index >= NUM_OF_TDL)
            {
                return MMI_TDL_SYNCML_ERR_INVALID_INDEX;
            }
            if (g_tdl_cntx.TaskList[*index].Alarm == TODO_LIST_ALARM_ON)
            {
                AlmCancelAlarm((U8) (*index + ALM_TDL_START));
            }
            result = mmi_tdl_delete_record(*index);
            if (result == MMI_FALSE)
            {
                result = MMI_TDL_SYNCML_ERR_DELETE_FAIL;
            }
            else
            {
                result = MMI_TDL_SYNCML_ERR_NO_ERROR;
            }
            return result;
        case MMI_TDL_SYNCML_GET:
            if (*index >= NUM_OF_TDL)
            {
                return MMI_TDL_SYNCML_ERR_INVALID_INDEX;
            }
            writeResult = mmi_vclndr_writer(&(g_tdl_cntx.TaskList[*index]), path);

            /* convert vtodo to vevent */
            if (writeResult == VOBJ_ERR_NO_ERROR)
            {
            #ifdef __MMI_ADVANCED_TODO__
                if (g_tdl_cntx.TaskList[*index].StartTime.nHour == g_tdl_cntx.TaskList[*index].EndTime.nHour &&
                    g_tdl_cntx.TaskList[*index].StartTime.nMin == g_tdl_cntx.TaskList[*index].EndTime.nMin)
            #else			            
                if (g_tdl_cntx.TaskList[*index].StartTime.nHour == g_tdl_cntx.TaskList[*index].EndHour &&
                    g_tdl_cntx.TaskList[*index].StartTime.nMin == g_tdl_cntx.TaskList[*index].EndMin)
            #endif
                {
                    writeResult = mmi_tdl_synML_convert_vtodo_to_vevent(path);
                }
            }
			if (mmi_syncml_compare_sync_server((U8*)TDL_SYNCML_EMOME_SERVER))
			{
				writeResult = mmi_tdl_synML_quoted_printable_trick(path);
			}
            

            return writeResult;
        default:
            return MMI_TDL_SYNCML_ERR_INVALID_OPERATION;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_vcalendar_err_mapping
 * DESCRIPTION
 *  Mapping error code from vcalendar to syncML
 * PARAMETERS
 *  vCalenar_err        [IN]    error code of vCalendar
 * RETURNS
 *  U16  error code of syncML
 *****************************************************************************/
U16 mmi_tdl_vcalendar_err_mapping(U16 vCalenar_err)
{
    switch(vCalenar_err)
    {
        case VOBJ_ERR_NO_ERROR:
            return MMI_TDL_SYNCML_ERR_NO_ERROR;
        case VOBJ_ERR_EMPTY_NAME:
            return MMI_TDL_SYNCML_ERR_EMPTY_NAME;
        case VOBJ_ERR_DUPLICATE_NAME:
            return MMI_TDL_SYNCML_ERR_DUPLICATE_NAME;
        case VOBJ_ERR_MEMORY_FULL:
            return MMI_TDL_SYNCML_ERR_MEMORY_FULL;
        case VOBJ_ERR_INVALID_FILENAME:
            return MMI_TDL_SYNCML_ERR_INVALID_FILENAME;
        case VOBJ_ERR_SELECT_PATH_TOO_LONG:
            return MMI_TDL_SYNCML_ERR_SELECT_PATH_TOO_LONG;
        case VOBJ_ERR_UNSUPPORT_FORMAT:
            return MMI_TDL_SYNCML_ERR_UNSUPPORT_FORMAT;
        case VOBJ_ERR_UNKNOWN:
            return MMI_TDL_SYNCML_ERR_UNKNOWN;
        default:
            ASSERT(0);
            return MMI_TDL_SYNCML_ERR_UNKNOWN;
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_synML_convert_vtodo_to_vevent
 * DESCRIPTION
 *  
 * PARAMETERS
 *  file_path_name      [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_tdl_synML_convert_vtodo_to_vevent(S8 *file_path_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE fh = 0;             /* file handle */
    S8 *buffer, *inbuff, *vTypeStart, *vTypeEnd;
    S8 *outbuff;//[VOBJ_WRITE_BUFF_LEN]; /* buffer to store output */
    S32 nBytes = 0, len, result;
#ifdef __MMI_ADVANCED_TODO__
	S8 *due;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fh = FS_Open((U16*) file_path_name, FS_READ_WRITE);
    buffer = OslMalloc(VOBJ_WRITE_BUFF_LEN);
    outbuff = OslMalloc(VOBJ_WRITE_BUFF_LEN);

    FS_Read(fh, buffer, VOBJ_WRITE_BUFF_LEN - 1, (UINT *)&nBytes);
    buffer[nBytes] = '\0';
    inbuff = buffer;
    memset(outbuff, 0, VOBJ_WRITE_BUFF_LEN);

    if (!nBytes)
    {
        FS_Close(fh);
        OslMfree(buffer);
        OslMfree(outbuff);
        return fh;
    }

    /* VCLNDR_VTODO_BEGIN */

    vTypeStart = strstr(inbuff, g_vclndr_fileds[VCLNDR_VTODO_BEGIN]);
    if (vTypeStart)
    {
        strncpy(outbuff, inbuff, (U32) vTypeStart - (U32) inbuff);
        strncat(outbuff, g_vclndr_fileds[VCLNDR_VEVENT_BEGIN], strlen(g_vclndr_fileds[VCLNDR_VEVENT_BEGIN]));
        inbuff = vTypeStart + strlen(g_vclndr_fileds[VCLNDR_VTODO_BEGIN]);
    }
    else
    {
        FS_Close(fh);
        OslMfree(buffer);
        OslMfree(outbuff);
        return 0;
    }
#ifdef __MMI_ADVANCED_TODO__    
	due = strstr(inbuff, g_vclndr_fileds[VCLNDR_DUE]);
	if (due)
	{
		strncat(outbuff, inbuff, (U32) due - (U32) inbuff);
		strncat(outbuff, g_vclndr_fileds[VCLNDR_DTEND], strlen(g_vclndr_fileds[VCLNDR_DTEND]));
		inbuff = due + strlen(g_vclndr_fileds[VCLNDR_DUE]);
	}	
#endif    

    vTypeEnd = strstr(inbuff, g_vclndr_fileds[VCLNDR_VTODO_END]);
    if (vTypeEnd)
    {
        strncat(outbuff, inbuff, (U32) vTypeEnd - (U32) inbuff);
        strncat(outbuff, g_vclndr_fileds[VCLNDR_VEVENT_END], strlen(g_vclndr_fileds[VCLNDR_VEVENT_END]));
        inbuff = vTypeEnd + strlen(g_vclndr_fileds[VCLNDR_VTODO_END]);
        strcat(outbuff, inbuff);
    }
    else
    {
        ASSERT(0);
    }

    len = strlen(outbuff);
    MMI_ASSERT(len <= VOBJ_WRITE_BUFF_LEN);

    FS_Seek(fh, 0, SEEK_SET);
    result = FS_Write(fh, outbuff, len, (UINT *)&nBytes);
    FS_Close(fh);

    if (result < 0)
    {
        FS_Delete((U16*) file_path_name);
    }

    OslMfree(buffer);
    OslMfree(outbuff);
    return result;

}

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_synML_convert_vtodo_to_vevent
 * DESCRIPTION
 *  
 * PARAMETERS
 *  file_path_name      [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_tdl_synML_quoted_printable_trick(S8 *file_path_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE fh = 0;             /* file handle */
    S8 *buffer, *inbuff, *vTypeStart, *vTypeEnd;
    
    S8 *outbuff;//[VOBJ_WRITE_BUFF_LEN]; /* buffer to store output */
    S32 nBytes = 0, len, result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fh = FS_Open((U16*) file_path_name, FS_READ_WRITE);
    buffer = OslMalloc(VOBJ_WRITE_BUFF_LEN);
    outbuff = OslMalloc(VOBJ_WRITE_BUFF_LEN);

    FS_Read(fh, buffer, VOBJ_WRITE_BUFF_LEN - 1, (UINT *)&nBytes);	    
    buffer[nBytes] = '\0';
    inbuff = buffer;
    memset(outbuff, 0, VOBJ_WRITE_BUFF_LEN);

    if (!nBytes)
    {
        FS_Close(fh);
        OslMfree(buffer);
        OslMfree(outbuff);
        return fh;
    }


    vTypeStart = strstr(inbuff, g_vclndr_fileds[VCLNDR_SUMMARY]);
    if (vTypeStart)
    {
        strncpy(outbuff, inbuff, (U32) vTypeStart - (U32) inbuff);
		inbuff = vTypeStart;
        
        vTypeEnd = strstr(inbuff, (S8*)VOBJ_CRLF_STR);
       
        while (vTypeEnd && vTypeEnd[2] == '=')
        {
            strncat(outbuff, inbuff, (U32) vTypeEnd - (U32) inbuff);		
            inbuff = vTypeEnd + 3;
            vTypeEnd = strstr(inbuff, (S8*)VOBJ_CRLF_STR);       
            
        }        
        strcat(outbuff, inbuff);
    }
    else
    {
        ASSERT(0);
    }

    len = strlen(outbuff);
    MMI_ASSERT(len <= VOBJ_WRITE_BUFF_LEN);

    FS_Seek(fh, 0, SEEK_SET);
    result = FS_Write(fh, outbuff, len, (UINT *)&nBytes);
    FS_Close(fh);

    if (result < 0)
    {
        FS_Delete((U16*) file_path_name);
    }

    OslMfree(buffer);
    OslMfree(outbuff);
    return result;

}
#endif /*__SYNCML_SUPPORT__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_time_info
 * DESCRIPTION
 *  copy the content of inline edotor to global context
 * PARAMETERS
 *  tdl_index       [IN]        
 *  daylist(?)          [IN/OUT]        Array to store the result.(?)
 *  SelectedDate(?)     [IN]            Date to be calculated.(?)
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_tdl_get_time_info(U8 tdl_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    U8 dt_type;
#endif 
    S32 result = DT_TIME_GREATER;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ADVANCED_TODO__
    memset(&g_tdl_cntx.TaskList[tdl_index].StartTime, 0, sizeof(MYTIME));
    memset(&g_tdl_cntx.TaskList[tdl_index].EndTime, 0, sizeof(MYTIME));

    /* Start date */
    g_tdl_cntx.TaskList[tdl_index].StartTime.nDay = (U8) gui_atoi((UI_string_type) g_tdl_cntx.DayBuff);
    g_tdl_cntx.TaskList[tdl_index].StartTime.nMonth = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MonBuff);
    g_tdl_cntx.TaskList[tdl_index].StartTime.nYear = (U16) gui_atoi((UI_string_type) g_tdl_cntx.YearBuff);
    g_tdl_cntx.TaskList[tdl_index].StartTime.DayIndex = DOW(
                                                            g_tdl_cntx.TaskList[tdl_index].StartTime.nYear,
                                                            g_tdl_cntx.TaskList[tdl_index].StartTime.nMonth,
                                                            g_tdl_cntx.TaskList[tdl_index].StartTime.nDay);

    /* End date, it will be reset when dt_type is TDL_DT_ALL */
    g_tdl_cntx.TaskList[tdl_index].EndTime.nDay = (U8) gui_atoi((UI_string_type) g_tdl_cntx.DayBuff);
    g_tdl_cntx.TaskList[tdl_index].EndTime.nMonth = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MonBuff);
    g_tdl_cntx.TaskList[tdl_index].EndTime.nYear = (U16) gui_atoi((UI_string_type) g_tdl_cntx.YearBuff);
    g_tdl_cntx.TaskList[tdl_index].EndTime.DayIndex = DOW(
                                                        g_tdl_cntx.TaskList[tdl_index].StartTime.nYear,
                                                        g_tdl_cntx.TaskList[tdl_index].StartTime.nMonth,
                                                        g_tdl_cntx.TaskList[tdl_index].StartTime.nDay);

    dt_type = mmi_tdl_get_dt_type();
    switch (dt_type)
    {
        case TDL_DT_DATE_AND_TIMEPERIOD:

            /* time Period */
            g_tdl_cntx.TaskList[tdl_index].StartTime.nHour = (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff1);
            g_tdl_cntx.TaskList[tdl_index].StartTime.nMin = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff1);
            g_tdl_cntx.TaskList[tdl_index].EndTime.nHour = (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff2);
            g_tdl_cntx.TaskList[tdl_index].EndTime.nMin = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff2);

            /* check end time */
            if ((g_tdl_cntx.TaskList[tdl_index].EndTime.nHour < g_tdl_cntx.TaskList[tdl_index].StartTime.nHour)
                || (g_tdl_cntx.TaskList[tdl_index].EndTime.nHour == g_tdl_cntx.TaskList[tdl_index].StartTime.nHour &&
                    g_tdl_cntx.TaskList[tdl_index].EndTime.nMin < g_tdl_cntx.TaskList[tdl_index].StartTime.nMin))
            {
                g_tdl_cntx.TaskList[tdl_index].EndTime.nHour = g_tdl_cntx.TaskList[tdl_index].StartTime.nHour;
                g_tdl_cntx.TaskList[tdl_index].EndTime.nMin = g_tdl_cntx.TaskList[tdl_index].StartTime.nMin;
                result = DT_TIME_LESS;
            }
            break;
        case TDL_DT_ONLY_START_DT:

            /* Start time */
            g_tdl_cntx.TaskList[tdl_index].StartTime.nHour = (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff1);
            g_tdl_cntx.TaskList[tdl_index].StartTime.nMin = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff1);

            g_tdl_cntx.TaskList[tdl_index].EndTime.nHour = (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff1);
            g_tdl_cntx.TaskList[tdl_index].EndTime.nMin = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff1);
            break;
        case TDL_DT_ALL:
            /* Start time */
            g_tdl_cntx.TaskList[tdl_index].StartTime.nHour = (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff1);
            g_tdl_cntx.TaskList[tdl_index].StartTime.nMin = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff1);

            /* End date */
            g_tdl_cntx.TaskList[tdl_index].EndTime.nDay = (U8) gui_atoi((UI_string_type) g_tdl_cntx.DayBuffEnd);
            g_tdl_cntx.TaskList[tdl_index].EndTime.nMonth = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MonBuffEnd);
            g_tdl_cntx.TaskList[tdl_index].EndTime.nYear = (U16) gui_atoi((UI_string_type) g_tdl_cntx.YearBuffEnd);
            g_tdl_cntx.TaskList[tdl_index].EndTime.DayIndex = DOW(
                                                                g_tdl_cntx.TaskList[tdl_index].EndTime.nYear,
                                                                g_tdl_cntx.TaskList[tdl_index].EndTime.nMonth,
                                                                g_tdl_cntx.TaskList[tdl_index].EndTime.nDay);

            /* End time */
            g_tdl_cntx.TaskList[tdl_index].EndTime.nHour = (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff2);
            g_tdl_cntx.TaskList[tdl_index].EndTime.nMin = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff2);

            /* check end time, start time must be less than end time */
            result = -(applib_dt_compare_time(
                        (applib_time_struct*) & g_tdl_cntx.TaskList[tdl_index].StartTime,
                        (applib_time_struct*) & g_tdl_cntx.TaskList[tdl_index].EndTime,
                        NULL));
            if (result < 0)
            {
                memcpy(
                    &g_tdl_cntx.TaskList[tdl_index].EndTime,
                    &g_tdl_cntx.TaskList[tdl_index].StartTime,
                    sizeof(MYTIME));
            }

            break;
        default:
            break;
    }

#else /* __MMI_ADVANCED_TODO__ */ 
    /* date */
    g_tdl_cntx.TaskList[tdl_index].StartTime.nDay = (U8) gui_atoi((UI_string_type) g_tdl_cntx.DayBuff);
    g_tdl_cntx.TaskList[tdl_index].StartTime.nMonth = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MonBuff);
    g_tdl_cntx.TaskList[tdl_index].StartTime.nYear = (U16) gui_atoi((UI_string_type) g_tdl_cntx.YearBuff);
    g_tdl_cntx.TaskList[tdl_index].StartTime.DayIndex = DOW(
                                                            g_tdl_cntx.TaskList[tdl_index].StartTime.nYear,
                                                            g_tdl_cntx.TaskList[tdl_index].StartTime.nMonth,
                                                            g_tdl_cntx.TaskList[tdl_index].StartTime.nDay);

    /* time */
    g_tdl_cntx.TaskList[tdl_index].StartTime.nHour = (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff1);
    g_tdl_cntx.TaskList[tdl_index].StartTime.nMin = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff1);
    g_tdl_cntx.TaskList[tdl_index].EndHour = (U8) gui_atoi((UI_string_type) g_tdl_cntx.HourBuff2);
    g_tdl_cntx.TaskList[tdl_index].EndMin = (U8) gui_atoi((UI_string_type) g_tdl_cntx.MinBuff2);

    /* Check end time */
    if ((g_tdl_cntx.TaskList[tdl_index].EndHour < g_tdl_cntx.TaskList[tdl_index].StartTime.nHour)
        || (g_tdl_cntx.TaskList[tdl_index].EndHour == g_tdl_cntx.TaskList[tdl_index].StartTime.nHour &&
            g_tdl_cntx.TaskList[tdl_index].EndMin < g_tdl_cntx.TaskList[tdl_index].StartTime.nMin))
    {
        result = DT_TIME_LESS;
        g_tdl_cntx.TaskList[tdl_index].EndHour = g_tdl_cntx.TaskList[tdl_index].StartTime.nHour;
        g_tdl_cntx.TaskList[tdl_index].EndMin = g_tdl_cntx.TaskList[tdl_index].StartTime.nMin;
    }
#endif /* __MMI_ADVANCED_TODO__ */ 

    /* Check end time */
    if (result >= 0)    /* end time is equal or greater than start time */
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }

}

#if defined(__MMI_VCALENDAR__)


/*****************************************************************************
 * FUNCTION
 *  TdlInsertTask
 * DESCRIPTION
 *  
 * PARAMETERS
 *  task        [?]         
 *  source      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
U8 TdlInsertTask(ToDoListNode *task, U8 source)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (TDLGetTotalItem() == NUM_OF_TDL)
    {
        return FALSE;
    }

    TDLAddDefaultRecord();

    i = g_tdl_cntx.CurrTaskIndex;
    g_tdl_cntx.CurrHiliteOption = source;
    g_tdl_cntx.SelectedItemInView = 0;

    memcpy(&g_tdl_cntx.TaskList[i], task, sizeof(ToDoListNode));
    TDLInitInlineVariables();
    EntryTDLEditTask();
    return TRUE;
}
#elif defined(__MMI_VCALENDAR__)


/*****************************************************************************
 * FUNCTION
 *  mmi_vclndr_fmgr_sms_forward
 * DESCRIPTION
 *  Dummy functions for vCalendar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vclndr_fmgr_sms_forward()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vclndr_fmgr_recv
 * DESCRIPTION
 *  Dummy functions for vCalendar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vclndr_fmgr_recv()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vclndr_highlight_not_support
 * DESCRIPTION
 *  Common function to display not support popup
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vclndr_highlight_not_support(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(PopupNoSupport, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vclndr_init
 * DESCRIPTION
 *  Dummy init function for vCalendar.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_vclndr_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetHiliteHandler(MENU_VCLNDR_FORWARD, mmi_vclndr_highlight_not_support);
#if !defined(__MMI_MESSAGES_NO_SEND_BY_SMS_OPTION__)
    SetHiliteHandler(MENU_VCLNDR_SEND_BY_SMS, mmi_vclndr_highlight_not_support);
#endif 

#if defined(__MMI_FILE_MANAGER__)
    SetHiliteHandler(MENU_VCLNDR_SEND_BY_FILEMGR, mmi_vclndr_highlight_not_support);
#endif 
}

#endif 
#ifdef __MMI_ADVANCED_TODO__


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_entry_select_task_type
 * DESCRIPTION
 *  Show task type list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_entry_select_task_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 nStrItemList[TDL_TOTAL_TASK];   /* Stores the strings id of submenus returned */
    U16 nImgItemList[TDL_TOTAL_TASK];
    U16 nNumofItem;                     /* Stores no of children in the submenu */
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __SYNCML_SUPPORT__
    /* popup "please wait" when syncML is executing */
    if (mmi_syncml_is_tdl_sync_now())
    {
        DisplayPopup(
            (U8*) GetString(STR_ID_SYNC_PLEASE_WAIT),
            IMG_GLOBAL_PROGRESS,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            (U8) WARNING_TONE);
            return;
    }
#endif
    EntryNewScreen(SCR_TDL_SELECT_TASK_TYPE, NULL, mmi_tdl_entry_select_task_type, NULL);

    nNumofItem = GetNumOfChild(MITEM_TODO_LIST_TASK_TYPE);

    GetSequenceStringIds(MITEM_TODO_LIST_TASK_TYPE, nStrItemList);

    for (i = 0; i < TDL_TOTAL_TASK; i++)
    {
        nImgItemList[i] = i + IMG_TODO_LIST_ICON_REMINDER;
    }

    SetParentHandler(MITEM_TODO_LIST_TASK_TYPE);

    guiBuffer = GetCurrGuiBuffer(SCR_TDL_SELECT_TASK_TYPE);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory15Screen(
        STR_TODO_SELECT_TASK_TYPE,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        nNumofItem,
        nStrItemList,
        (U16*) nImgItemList,
        LIST_MENU,
        0,
        guiBuffer);

    SetLeftSoftkeyFunction(TdlExecEdit, KEY_EVENT_UP);
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);

    SetRightSoftkeyFunction(mmi_tdl_task_list_goback, KEY_EVENT_UP);
    SetKeyHandler(mmi_tdl_task_list_goback, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_set_dt_type
 * DESCRIPTION
 *  Set the dt type for inline editor display.
 * PARAMETERS
 *  dt_type     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_set_dt_type(U8 dt_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (dt_type <= TDL_DT_ALL)
    {
        g_tdl_cntx.FieldFlag &= 0xfC;   /* Reset the dt type */
        g_tdl_cntx.FieldFlag |= dt_type;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_dt_type
 * DESCRIPTION
 *  Get the dt type for inline editor display.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_tdl_get_dt_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = g_tdl_cntx.FieldFlag & 0x03;

    if (result <= TDL_DT_ALL)
    {
        return result;
    }
    return 0xFF;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_disable_field
 * DESCRIPTION
 *  Disable a field for inline editor display.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_disable_field(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.FieldFlag &= ~index;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_field_state
 * DESCRIPTION
 *  Disable a field for inline editor display.
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_tdl_get_field_state(U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = g_tdl_cntx.FieldFlag & index;
    if (result > 0)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_time_editor_callback
 * DESCRIPTION
 *  Callback function for inline time editor.
 * PARAMETERS
 *  string_buffer       [IN/OUT]        Buffer to store the result of time
 *  hours_buffer        [IN]            Buffer to store hour string
 *  min_buffer          [IN]            Buffer to store minute string
 *  AM_PM_flag          [IN]            Flag to indicate the time format of time string
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_time_editor_callback(U8 *string_buffer, U8 *hours_buffer, U8 *min_buffer, U8 *AM_PM_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2cpy((S8*) string_buffer, (S8*) hours_buffer);
    mmi_ucs2cat((S8*) string_buffer, (S8*) ":");
    mmi_ucs2cat((S8*) string_buffer, (S8*) min_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_meeting
 * DESCRIPTION
 *  Highlight handler of selecting meeting task
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_meeting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrTaskType = TDL_TASK_MEETING;
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_course
 * DESCRIPTION
 *  Highlight handler of selecting course task
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_course(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrTaskType = TDL_TASK_COURSE;
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_date
 * DESCRIPTION
 *  Highlight handler of selecting date task
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_date(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrTaskType = TDL_TASK_DATE;
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_call
 * DESCRIPTION
 *  Highlight handler of selecting call task
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrTaskType = TDL_TASK_CALL;
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_anniversary
 * DESCRIPTION
 *  Highlight handler of selecting anniversary task
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_anniversary(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrTaskType = TDL_TASK_ANNIVERSARY;
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_highlight_reminder
 * DESCRIPTION
 *  Highlight handler of selecting reminder task
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_highlight_reminder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.CurrTaskType = TDL_TASK_REMINDER;
    SetKeyHandler(TdlExecEdit, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_set_inline_icon
 * DESCRIPTION
 *  Construct the inline icon list
 * PARAMETERS
 *  icons           [?]         [?]         [?]
 *  inline_num      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_set_inline_icon(U16 *icons, U8 inline_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 dt_type, icon_index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Type */
    icons[icon_index] = g_tdl_cntx.CurrTaskType + IMG_TODO_LIST_ICON_REMINDER;

    dt_type = mmi_tdl_get_dt_type();
    switch (dt_type)
    {
        case TDL_DT_DATE_AND_TIMEPERIOD:
        case TDL_DT_ONLY_START_DT:
            icons[icon_index] = IMG_TODO_LIST_DATE;
            icon_index++;
            icons[icon_index] = IMG_TODO_LIST_TIME;
            icon_index++;
            break;
        case TDL_DT_ALL:
            icons[icon_index] = IMG_TODO_LIST_DATE;
            icon_index++; 
            icon_index++; /* Date Input */
            icon_index++; /* Time Input */


            icons[icon_index] = IMG_TODO_LIST_DATE;
            icon_index++;
            icon_index++; /* Date Input */
            icon_index++; /* Time Input */
            break;
    }
    /* note */
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_NOTE))
    {
        icons[icon_index] = IMG_TODO_LIST_NOTE;
		icon_index += 2;
    }

    /* Alarm */
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_ALARM))
    {
        icons[icon_index] = IMG_TODO_LIST_ALARM;
		icon_index += 2;
    }

    /* TDL_FIELD_MASK_REPEAT */
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_REPEAT))
    {
        icons[icon_index] = IMG_TODO_LIST_REPEAT;
		icon_index += 3;
    }

    /* Location */
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_LOCATION))
    {
        icons[icon_index] = IMG_TODO_LIST_ICON_LOCATION;
		icon_index += 2;
    }

    /* Priority */
    if (mmi_tdl_get_field_state(TDL_FIELD_MASK_PRIORITY))
    {
        icons[icon_index] = IMG_TODO_LIST_ICON_PRIORITY;
		icon_index += 2;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_fields_of_task
 * DESCRIPTION
 *  Disable field by different task type.
 * PARAMETERS
 *  task_type       [IN]        
 *  inline_num(?)       [IN](?)
 *  icons           [?](?)(?)
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_tdl_get_fields_of_task(U8 task_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.FieldFlag = 0xFF;
    switch (task_type)
    {
        case TDL_TASK_MEETING:
        case TDL_TASK_COURSE:
            mmi_tdl_set_dt_type(TDL_DT_DATE_AND_TIMEPERIOD);
            break;
        case TDL_TASK_DATE:
            mmi_tdl_set_dt_type(TDL_DT_ONLY_START_DT);
            break;
        case TDL_TASK_CALL:
            mmi_tdl_set_dt_type(TDL_DT_ONLY_START_DT);
            mmi_tdl_disable_field(TDL_FIELD_MASK_LOCATION);
            break;
        case TDL_TASK_ANNIVERSARY:
            mmi_tdl_set_dt_type(TDL_DT_ONLY_START_DT);
            mmi_tdl_disable_field(TDL_FIELD_MASK_REPEAT);
            break;
        case TDL_TASK_REMINDER:
            mmi_tdl_set_dt_type(TDL_DT_ALL);
            break;
    }
    if (task_type >= TDL_TOTAL_TASK)
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_compute_reminder_time
 * DESCRIPTION
 *  compute the reminder time according to user's setting
 * PARAMETERS
 *  task            [?]     [?]
 *  preReminder     [?]     [?]
 *  inline_num(?)       [IN](?)
 *  icons           [?](?)(?)
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_compute_reminder_time(ToDoListNode *task, MYTIME *preReminder)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (task->Alarm)
    {
        case TODO_LIST_ALARM_BEFORE_5_MINS:
            preReminder->nMin = 5;
            break;
        case TODO_LIST_ALARM_BEFORE_15_MINS:
            preReminder->nMin = 15;
            break;
        case TODO_LIST_ALARM_BEFORE_30_MINS:
            preReminder->nMin = 30;
            break;
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_check_is_in_period
 * DESCRIPTION
 *  
 * PARAMETERS
 *  StartHour       [IN]        
 *  EndHour         [IN]        
 *  ToCompare       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_tdl_check_is_in_period(U32 StartHour, U32 EndHour, U32 ToComparStart, U32 ToComparEnd)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (ToComparStart == ToComparEnd)
	{
		if (ToComparStart == StartHour)
		{
			return MMI_TRUE;
		}
		else if (ToComparStart == EndHour)
		{
			return MMI_FALSE;
		}
	}	
		
	if (ToComparEnd > StartHour && ToComparEnd <= EndHour)
	{
		return MMI_TRUE;
	}
	else if (ToComparStart >= StartHour && ToComparStart < EndHour)
	{
		return MMI_TRUE;
	}
	else if (ToComparStart < StartHour && ToComparEnd > EndHour)
	{
		return MMI_TRUE;
	}
	else
	{    
		return MMI_FALSE;
	}
}



#endif /* __MMI_ADVANCED_TODO__ */ 

#ifdef __MMI_CALENDAR_V2__
#if defined(__MMI_ADVANCED_TODO__)

/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_monthly_task_with_icon
 * DESCRIPTION
 *  Get list of days which a task is associated to.
 *  Logic is the same as TDLGetDaysToBeHilited but supporting icon.
 * PARAMETERS
 *  ClndrTime       [?]     
 *  TaskInDay       [?]     
 *  SelectedDate        [?](?)
 *  daylist             [?](?)
 * RETURNS
 *  void
 *****************************************************************************/
/* void mmi_tdl_get_monthly_task_with_icon(MYTIME *SelectedDate, clndr_task_icon_struct *daylist) */
void mmi_tdl_get_monthly_task_with_icon(MYTIME *ClndrTime, clndr_task_icon_struct *TaskInDay)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j;
    U8 index = 0;

    /* clndr_task_icon_struct TaskInDay[MAX_LEN_MOST_VAR]; */
    U8 NextDay = 0;
    U8 IsInSameMonth;
    U8 FirstDay = 0;
    ToDoListNode *task;
    MYTIME startTime, SelectedDate;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(TaskInDay, 0, MAX_LEN_MOST_VAR * sizeof(clndr_task_icon_struct));

    memcpy(&SelectedDate, ClndrTime, sizeof(MYTIME));
    SelectedDate.nHour = 0;
	SelectedDate.nMin = 0;
	SelectedDate.nSec = 0;

    for (i = 0; i < NUM_OF_TDL; i++)
    {
        task = &(g_tdl_cntx.TaskList[i]);
        if (task->Present == 1)
        {
            memcpy(&startTime, &(task->StartTime), sizeof(MYTIME));

            if ((SelectedDate.nMonth == startTime.nMonth) && (SelectedDate.nYear == startTime.nYear))
            {
                IsInSameMonth = TRUE;
            }
            else
            {
                IsInSameMonth = FALSE;
            }

            switch (g_tdl_freq_set[task->Repeat])
            {
                case ALM_FREQ_ONCE:
					SelectedDate.nDay = 1;
                    if (IsInSameMonth == TRUE)
                    {
                        if (startTime.nMonth == task->EndTime.nMonth && startTime.nYear == task->EndTime.nYear)
                        {
                            for (j = startTime.nDay; j < task->EndTime.nDay; j++)
                            {
                                mmi_tdl_set_task_icon(TaskInDay, j, task);
                            }

							if ((task->EndTime.nHour != 0 || task->EndTime.nMin != 0) || CompareTime(task->EndTime, task->StartTime, NULL) == 0)
							{
									mmi_tdl_set_task_icon(TaskInDay, task->EndTime.nDay, task);
							}
                        }
                        else if (CompareTime(task->EndTime, task->StartTime, NULL))
                        {
                            for (j = startTime.nDay; j <= TDL_MAX_DAYS_PER_MONTH; j++)
                            {
                                mmi_tdl_set_task_icon(TaskInDay, j, task);
                            }
                        }
                                                   
                    }
                    else if (CompareTime(SelectedDate, startTime, NULL) > 0 && CompareTime(task->EndTime, SelectedDate, NULL) > 0)
                    {
                        if (SelectedDate.nMonth == task->EndTime.nMonth && SelectedDate.nYear == task->EndTime.nYear)
                        {
                            for (j = 1; j < task->EndTime.nDay; j++)
                            {
                                mmi_tdl_set_task_icon(TaskInDay, j, task);
                            }

							//if (task->EndTime.nHour > 0 || startTime.nDay == task->EndTime.nDay)
							if ((task->EndTime.nHour != 0 || task->EndTime.nMin != 0) || CompareTime(task->EndTime, task->StartTime, NULL) == 0)
							{
									mmi_tdl_set_task_icon(TaskInDay, task->EndTime.nDay, task);
							}
                        }
                        else
                        {
                            for (j = 1; j <= TDL_MAX_DAYS_PER_MONTH; j++)
                            {
                                mmi_tdl_set_task_icon(TaskInDay, j, task);
                            }
                        }
                    }
                    break;

                case ALM_FREQ_EVERYDAY:
                    if (FindMaxTime(&SelectedDate, &(startTime)) && IsInSameMonth == FALSE)
                    {
                        j = 1;
                    }
                    else if (IsInSameMonth == TRUE)
                    {
                        j = startTime.nDay;
                    }
                    else
                    {
                        break;
                    }
                    for (; j <= TDL_MAX_DAYS_PER_MONTH; j++)
                    {
                        mmi_tdl_set_task_icon(TaskInDay, (U8) j, task);
                    }
                    break;
                case ALM_FREQ_DAYS:
                    if (IsInSameMonth == TRUE)
                    {
                        FirstDay = DOW(startTime.nYear, startTime.nMonth, startTime.nDay);
                        for (j = 0; j < MAX_DAY_IN_WEEK; j++)
                        {
                            if (task->Days & gAlmDayOfWeek[j])
                            {
                                if (FirstDay == j)
                                {
                                    NextDay = startTime.nDay;
                                }
                                else if (FirstDay < j)
                                {
                                    NextDay = startTime.nDay + j - FirstDay;
                                }
                                else
                                {
                                    NextDay = startTime.nDay + j - FirstDay + MAX_DAY_IN_WEEK;
                                }

                                while (NextDay <= TDL_MAX_DAYS_PER_MONTH)
                                {
                                    /* TaskInDay[NextDay] = 1; */
                                    mmi_tdl_set_task_icon(TaskInDay, NextDay, task);
                                    NextDay = NextDay + MAX_DAY_IN_WEEK;
                                }
                            }
                        }
                    }
                    else if (FindMaxTime(&SelectedDate, &(startTime)))
                    {
                        FirstDay = DOW(SelectedDate.nYear, SelectedDate.nMonth, 1);
                        for (j = 0; j < MAX_DAY_IN_WEEK; j++)
                        {
                            if (task->Days & gAlmDayOfWeek[j])
                            {
                                if (FirstDay == j)
                                {
                                    NextDay = 1;
                                }
                                else if (FirstDay < j)
                                {
                                    NextDay = 1 + j - FirstDay;
                                }
                                else
                                {
                                    NextDay = 1 + j - FirstDay + MAX_DAY_IN_WEEK;
                                }

                                while (NextDay <= TDL_MAX_DAYS_PER_MONTH)
                                {
                                    /* TaskInDay[NextDay] = 1; */
                                    mmi_tdl_set_task_icon(TaskInDay, NextDay, task);
                                    NextDay = NextDay + MAX_DAY_IN_WEEK;
                                }
                            }
                        }
                    }

                    break;

                case ALM_FREQ_WEEKLY:
                    if (IsInSameMonth == TRUE || FindMaxTime(&SelectedDate, &startTime))
                    {
                        j = DOW(startTime.nYear, startTime.nMonth, startTime.nDay);

                        FirstDay = DOW(SelectedDate.nYear, SelectedDate.nMonth, 1);

                        if (FirstDay == j)
                        {
                            NextDay = 1;
                        }
                        else if (FirstDay < j)
                        {
                            NextDay = 1 + j - FirstDay;
                        }
                        else
                        {
                            NextDay = 1 + j - FirstDay + MAX_DAY_IN_WEEK;
                        }

                        if (IsInSameMonth == TRUE)
                            while (NextDay < startTime.nDay)
                            {
                                NextDay = NextDay + MAX_DAY_IN_WEEK;
                            }

                        while (NextDay <= TDL_MAX_DAYS_PER_MONTH)
                        {
                            /* TaskInDay[NextDay] = 1; */
                            mmi_tdl_set_task_icon(TaskInDay, NextDay, task);
                            NextDay = NextDay + MAX_DAY_IN_WEEK;
                        }
                    }

                    break;

                case ALM_FREQ_MONTHLY:
                    if (IsInSameMonth == TRUE || FindMaxTime(&SelectedDate, &startTime))
                    {
                        index = startTime.nDay;
                        /* TaskInDay[index] = 1; */
                        mmi_tdl_set_task_icon(TaskInDay, index, task);
                    }
                    break;
                case ALM_FREQ_YEARLY:
					if (IsInSameMonth == TRUE || 
						(FindMaxTime(&SelectedDate, &startTime) && SelectedDate.nMonth == startTime.nMonth))
                    {
                        index = startTime.nDay;
                        /* TaskInDay[index] = 1; */
                        mmi_tdl_set_task_icon(TaskInDay, index, task);
                    }
                    break;
                default:
                    break;
            }   /* End of switch */

        }   /* if Present */

    }   /* end of For Loop */

    /* if (*daylist != TDL_MAX_DAYS_PER_MONTH) */
    /*    
     * for (j = 0, i = 1; i <= TDL_MAX_DAYS_PER_MONTH; i++)
     * {
     * if (TaskInDay[i].date > 0)
     * {
     * j++;
     * daylist[j].date = i;
     * daylist[j].icon = TaskInDay[i].icon;
     * daylist[j].maxPriorityTask= TaskInDay[i].maxPriorityTask;
     * }
     * }
     * daylist[0].date = (U8) j;
     */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_set_task_icon
 * DESCRIPTION
 *  
 * PARAMETERS
 *  TaskInDay       [?]         [?]
 *  date            [IN]        
 *  task            [?]         [?]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_set_task_icon(clndr_task_icon_struct *TaskInDay, U8 date, ToDoListNode *task)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ToDoListNode *maxPriorityTask;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    maxPriorityTask = TaskInDay[date].maxPriorityTask;
    /* 1.the date has no task yet
       2.the priority of new task is higher than original task */
    if ((TaskInDay[date].date == 0) ||
        (task->Priority < maxPriorityTask->Priority) ||
        (task->Priority == maxPriorityTask->Priority && task->Type > maxPriorityTask->Type))
    {
    #ifdef __MMI_CLNDR_ICON_SUPPORT__
        TaskInDay[date].icon = task->Type + IMG_CLNDR_ICON_REMINDER;
    #endif /*__MMI_CLNDR_ICON_SUPPORT__*/
        TaskInDay[date].maxPriorityTask = task;
    }
    TaskInDay[date].date++;
}
#endif /* defined(__MMI_ADVANCED_TODO__) */

#ifdef __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_period_task
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_get_period_task(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 count = 0, StartHour, EndHour, ToComparEnd;
    ToDoListNode task;
    U8 tasklist[NUM_OF_TDL], i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TDLMakeListOfSelectedDate(CLNDR_WEEKLY_VIEW);
    memset(tasklist, 0, NUM_OF_TDL);
    StartHour = g_tdl_cntx.ClndrDate.nHour;
    EndHour = StartHour + mmi_clndr_get_period_interval();
    for (i = 0; i < g_tdl_cntx.TotalListedTask; i++)
    {
        memcpy(&task, &(g_tdl_cntx.TaskList[g_tdl_cntx.SortedList[i]]), sizeof(ToDoListNode));
        if (task.EndTime.nHour % mmi_clndr_get_period_interval() == 0 && task.EndTime.nMin != 0)
        {
            ToComparEnd = task.EndTime.nHour + 1;
        }
        else
        {
            ToComparEnd = task.EndTime.nHour;
        }

        if ((task.Type == TDL_TASK_REMINDER && g_tdl_freq_set[task.Repeat] == ALM_FREQ_ONCE) || mmi_tdl_check_is_in_period(StartHour, EndHour, task.StartTime.nHour, ToComparEnd))
        {            
	        tasklist[count++] = g_tdl_cntx.SortedList[i];
        }
    }

    memcpy(&g_tdl_cntx.SortedList, &tasklist, NUM_OF_TDL);
    g_tdl_cntx.TotalListedTask = count;
}
#endif
#else /* defined(__MMI_CALENDAR_V2__) */ 


/*****************************************************************************
 * FUNCTION
 *  TDLGetDaysToBeHilited
 * DESCRIPTION
 *  Get list of days which a task is associated to.
 * PARAMETERS
 *  SelectedDate        [IN]            Date to be calculated.
 *  daylist             [IN/OUT]        Array to store the result.
 * RETURNS
 *  void
 *****************************************************************************/
void TDLGetDaysToBeHilited(MYTIME SelectedDate, U8 *daylist)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j;
    U8 index = 0;
    U8 TaskInDay[MAX_LEN_MOST_VAR];
    U8 NextDay = 0;
    U8 IsInSameMonth;
    U8 FirstDay = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(daylist, 0, MAX_LEN_MOST_VAR);
    memset(TaskInDay, 0, MAX_LEN_MOST_VAR);

    for (i = 0; i < NUM_OF_TDL; i++)
    {
        if (*daylist == TDL_MAX_DAYS_PER_MONTH)
        {
            return;
        }

        if (g_tdl_cntx.TaskList[i].Present == 1)
        {
            if ((SelectedDate.nMonth == g_tdl_cntx.TaskList[i].StartTime.nMonth) &&
                (SelectedDate.nYear == g_tdl_cntx.TaskList[i].StartTime.nYear))
            {
                IsInSameMonth = TRUE;
            }
            else
            {
                IsInSameMonth = FALSE;
            }

            switch (g_tdl_freq_set[g_tdl_cntx.TaskList[i].Repeat])
            {
                case ALM_FREQ_ONCE:
                    if (IsInSameMonth == TRUE)
                    {
                        TaskInDay[g_tdl_cntx.TaskList[i].StartTime.nDay] = 1;
                    }
                    break;

                case ALM_FREQ_EVERYDAY:
                    if (IsInSameMonth == TRUE)
                    {
                        for (j = g_tdl_cntx.TaskList[i].StartTime.nDay; j <= TDL_MAX_DAYS_PER_MONTH; j++)
                        {
                            TaskInDay[j] = 1;
                        }
                    }
                    else if (FindMaxTime(&SelectedDate, &(g_tdl_cntx.TaskList[i].StartTime)))
                    {
                        *daylist = TDL_MAX_DAYS_PER_MONTH;
                    }
                    break;
                case ALM_FREQ_DAYS:
                    if (IsInSameMonth == TRUE)
                    {
                        FirstDay = DOW(
                                    g_tdl_cntx.TaskList[i].StartTime.nYear,
                                    g_tdl_cntx.TaskList[i].StartTime.nMonth,
                                    g_tdl_cntx.TaskList[i].StartTime.nDay);
                        for (j = 0; j < MAX_DAY_IN_WEEK; j++)
                        {
                            if (g_tdl_cntx.TaskList[i].Days & gAlmDayOfWeek[j])
                            {
                                if (FirstDay == j)
                                {
                                    NextDay = g_tdl_cntx.TaskList[i].StartTime.nDay;
                                }
                                else if (FirstDay < j)
                                {
                                    NextDay = g_tdl_cntx.TaskList[i].StartTime.nDay + j - FirstDay;
                                }
                                else
                                {
                                    NextDay = g_tdl_cntx.TaskList[i].StartTime.nDay + j - FirstDay + MAX_DAY_IN_WEEK;
                                }

                                while (NextDay <= TDL_MAX_DAYS_PER_MONTH)
                                {
                                    TaskInDay[NextDay] = 1;
                                    NextDay = NextDay + MAX_DAY_IN_WEEK;
                                }
                            }
                        }
                    }
                    else if (FindMaxTime(&SelectedDate, &(g_tdl_cntx.TaskList[i].StartTime)))
                    {
                        FirstDay = DOW(SelectedDate.nYear, SelectedDate.nMonth, 1);
                        for (j = 0; j < MAX_DAY_IN_WEEK; j++)
                        {
                            if (g_tdl_cntx.TaskList[i].Days & gAlmDayOfWeek[j])
                            {
                                if (FirstDay == j)
                                {
                                    NextDay = 1;
                                }
                                else if (FirstDay < j)
                                {
                                    NextDay = 1 + j - FirstDay;
                                }
                                else
                                {
                                    NextDay = 1 + j - FirstDay + MAX_DAY_IN_WEEK;
                                }

                                while (NextDay <= TDL_MAX_DAYS_PER_MONTH)
                                {
                                    TaskInDay[NextDay] = 1;
                                    NextDay = NextDay + MAX_DAY_IN_WEEK;
                                }
                            }
                        }
                    }

                    break;

                case ALM_FREQ_WEEKLY:
                    if (IsInSameMonth == TRUE || FindMaxTime(&SelectedDate, &g_tdl_cntx.TaskList[i].StartTime))
                    {
                        j = DOW(
                                g_tdl_cntx.TaskList[i].StartTime.nYear,
                                g_tdl_cntx.TaskList[i].StartTime.nMonth,
                                g_tdl_cntx.TaskList[i].StartTime.nDay);

                        FirstDay = DOW(SelectedDate.nYear, SelectedDate.nMonth, 1);

                        if (FirstDay == j)
                        {
                            NextDay = 1;
                        }
                        else if (FirstDay < j)
                        {
                            NextDay = 1 + j - FirstDay;
                        }
                        else
                        {
                            NextDay = 1 + j - FirstDay + MAX_DAY_IN_WEEK;
                        }

                        if (IsInSameMonth == TRUE)
                            while (NextDay < g_tdl_cntx.TaskList[i].StartTime.nDay)
                            {
                                NextDay = NextDay + MAX_DAY_IN_WEEK;
                            }

                        while (NextDay <= TDL_MAX_DAYS_PER_MONTH)
                        {
                            TaskInDay[NextDay] = 1;
                            NextDay = NextDay + MAX_DAY_IN_WEEK;
                        }
                    }

                    break;

                case ALM_FREQ_MONTHLY:
                    if (IsInSameMonth == TRUE || FindMaxTime(&SelectedDate, &g_tdl_cntx.TaskList[i].StartTime))
                    {
                        index = g_tdl_cntx.TaskList[i].StartTime.nDay;
                        TaskInDay[index] = 1;
                    }
                    break;

                default:
                    break;
            }   /* End of switch */

        }   /* if Present */

    }   /* end of For Loop */

    if (*daylist != TDL_MAX_DAYS_PER_MONTH)
    {
        for (j = 0, i = 1; i <= TDL_MAX_DAYS_PER_MONTH; i++)
            if (TaskInDay[i])
            {
                j++;
                daylist[j] = (U8) i;
            }
        *daylist = (U8) j;
    }
}   /* End of Function */
#endif /* #if defined(__MMI_CALENDAR_V2__) && defined(__MMI_ADVANCED_TODO__) */ 
#ifdef __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_get_weekly_tasks
 * DESCRIPTION
 *  
 * PARAMETERS
 *  SelectedDate        [?]         [?]
 *  TaskInPeriod        [?]         
 *  PeriodInterval      [IN]        
 *  PeriodRow           [IN]        
 *  PeriodList          [?](?)
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_get_weekly_tasks(
        MYTIME *SelectedDate,
        /* clndr_weekly_task_struct *PeriodList, */ clndr_task_icon_struct *TaskInPeriod,
        U8 PeriodInterval,
        U8 PeriodRow)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j;
    U8 IsInSameWeek;
    S32 tempDay = 0;
    ToDoListNode *task;
    MYTIME startTime, currWeek, nextWeek, incTime;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(TaskInPeriod, 0, CLNDR_COLUMN * CLNDR_MAX_ROW * sizeof(clndr_task_icon_struct));
    memset(&currWeek, 0, sizeof(MYTIME));
    memset(&nextWeek, 0, sizeof(MYTIME));
    memset(&incTime, 0, sizeof(MYTIME));

    mmi_clndr_get_first_date_of_week(SelectedDate, &currWeek);
    incTime.nDay = CLNDR_TOTAL_WEEKDAY;
    applib_dt_increase_time(
        (applib_time_struct*) & currWeek,
        (applib_time_struct*) & incTime,
        (applib_time_struct*) & nextWeek);

    for (i = 0; i < NUM_OF_TDL; i++)
    {
        task = &(g_tdl_cntx.TaskList[i]);
        if (task->Present == 1)
        {
            memcpy(&startTime, &(task->StartTime), sizeof(MYTIME));
            /* periodDuration = g_clndr_cntx->PeriodInterval; */
            if (applib_dt_compare_time((applib_time_struct*) & startTime, (applib_time_struct*) & currWeek, NULL) >=
                DT_TIME_EQUAL &&
                applib_dt_compare_time(
                    (applib_time_struct*) & startTime,
                    (applib_time_struct*) & nextWeek,
                    NULL) == DT_TIME_LESS)
            {
                IsInSameWeek = TRUE;
            }
            else
            {
                IsInSameWeek = FALSE;
            }
            switch (g_tdl_freq_set[task->Repeat])
            {
                case ALM_FREQ_ONCE:
                    /* the task's start time is during this week */
                    if (CompareTime(task->StartTime,currWeek, NULL) >= DT_TIME_EQUAL && CompareTime(task->StartTime, nextWeek, NULL) < DT_TIME_EQUAL)
                    {
                        j = applib_dt_dow(task->StartTime.nYear, task->StartTime.nMonth, task->StartTime.nDay);
                        mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_FALSE);
                    }
                    /* start time is earlier than this week, but end during this week */
                    else if (CompareTime(task->StartTime, currWeek, NULL) < DT_TIME_EQUAL)
                    {
                        if (CompareTime(task->EndTime, nextWeek, NULL) > DT_TIME_EQUAL)
                        {
                            j = 0xff;
                        }
                        else if (CompareTime(task->EndTime, currWeek, NULL) > DT_TIME_EQUAL)
                        {
                            j = applib_dt_dow(task->EndTime.nYear, task->EndTime.nMonth, task->EndTime.nDay);
                        }
                        else    /* endtime is before current week */
                        {
                            continue;
                        }
                        mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_TRUE);
                    }
                    break;

                case ALM_FREQ_EVERYDAY:
                    if (FindMaxTime(&currWeek, &(startTime)))
                    {
                        j = 0;
                    }
					else if (!FindMaxTime(&currWeek, &(startTime)) && FindMaxTime(&nextWeek, &(startTime)))
					{
						j = applib_dt_dow(startTime.nYear, startTime.nMonth, startTime.nDay);
					}
                    else
                    {
                        break;
                    }
                    for (; j < CLNDR_TOTAL_WEEKDAY; j++)
                    {
                        mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_FALSE);
                    }
                    break;
                case ALM_FREQ_DAYS:
                    tempDay = (S32)DOW(startTime.nYear, startTime.nMonth, startTime.nDay);
                    for (j = 0; j < MAX_DAY_IN_WEEK; j++)
                    {
                        if (task->Days & gAlmDayOfWeek[j])
                        {
                            /* tdl's start time is in selected week and the repeat days is larger than tdl's week day */
                            if (IsInSameWeek == TRUE && j >= tempDay)
                            {
                                mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_FALSE);
                            }
                            /* tdl's start time is before selected week */
                            else if (IsInSameWeek == FALSE && FindMaxTime(SelectedDate, &(startTime)))
                            {
                                mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_FALSE);
                            }
                        }
                    }
                    break;

                case ALM_FREQ_WEEKLY:
                    if (IsInSameWeek == TRUE || FindMaxTime(SelectedDate, &startTime))
                    {                        
                        j = DOW(startTime.nYear, startTime.nMonth, startTime.nDay);

                        mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_FALSE);
                    }
                    break;
                case ALM_FREQ_MONTHLY:
                    if (IsInSameWeek == TRUE || (FindMaxTime(SelectedDate, &startTime)))
                    {
                        for (j = 1; j <= CLNDR_TOTAL_WEEKDAY; j++)
                        {
                            tempDay = nextWeek.nDay - j;
                            if (tempDay > 0 && tempDay == startTime.nDay)
                            {   
								startTime.nYear = nextWeek.nYear;
								startTime.nMonth = nextWeek.nMonth;								
                                break;
                            }
                            else if (tempDay <= 0)
                            {
                                tempDay += applib_dt_last_day_of_mon(currWeek.nMonth, currWeek.nYear);
                                if (tempDay == startTime.nDay)
                                {
									startTime.nYear = currWeek.nYear;
									startTime.nMonth = currWeek.nMonth;									
                                    break;
                                }                                    
                            }
                        }  
                        if (j <= CLNDR_TOTAL_WEEKDAY)
                        {
                            j = DOW(startTime.nYear, startTime.nMonth, startTime.nDay);
                            mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_FALSE);
                        }
                    }
                    break;                    
                case ALM_FREQ_YEARLY:
                    if (IsInSameWeek == TRUE || (FindMaxTime(SelectedDate, &startTime)))
                    {
                        for (j = 1; j <= CLNDR_TOTAL_WEEKDAY; j++)
                        {
                            tempDay = nextWeek.nDay - j;
                            if (tempDay > 0 && (tempDay == startTime.nDay && nextWeek.nMonth == startTime.nMonth))
                            {    
								startTime.nYear = nextWeek.nYear;
								startTime.nMonth = nextWeek.nMonth;	
                                break;
                            }
                            else if (tempDay <= 0)
                            {
                                tempDay += applib_dt_last_day_of_mon(currWeek.nMonth, currWeek.nYear);
                                if (tempDay == startTime.nDay && currWeek.nMonth == startTime.nMonth)
                                {									
									startTime.nYear = currWeek.nYear;
									startTime.nMonth = currWeek.nMonth;	
                                    break;
                                }                                    
                            }
                        }  
                        if (j <= CLNDR_TOTAL_WEEKDAY)
                        {
                            j = DOW(startTime.nYear, startTime.nMonth, startTime.nDay);
                            mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_FALSE);
                        }
                    }
                    break;               

                    
                    if (IsInSameWeek == TRUE || FindMaxTime(SelectedDate, &startTime))
                    {                       
                        if (SelectedDate->nMonth == startTime.nMonth && SelectedDate->nDay== startTime.nDay)
                        {
                           j = DOW(startTime.nYear, startTime.nMonth, startTime.nDay);

                            mmi_tdl_set_weekly_task(TaskInPeriod, task, (U8) j, PeriodInterval, MMI_FALSE);
                        }                                          
                    }
                    break;
                default:
                    break;
            }   /* End of switch */

        }   /* if Present */

    }   /* end of For Loop */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_set_weekly_task
 * DESCRIPTION
 *  set task information for weekly view
 * PARAMETERS
 *  TaskInPeriod        [?]         [?]         [?]
 *  task                [?]         [?]
 *  dow                 [IN]        Dow of task. If StartCheck is true, this parameter will be the end dow of the task.
 *  PeriodInterval      [IN]        
 *  StartCheck          [IN]        Used to check if the task's start time is earlier than this week, true means it is.
 * RETURNS
 *  void
 *****************************************************************************/
/* void mmi_tdl_set_weekly_task(clndr_task_icon_struct **TaskInPeriod, MYTIME* startTime, MYTIME* endTime,ToDoListNode* task, U8 PeriodInterval) */
void mmi_tdl_set_weekly_task(
        clndr_task_icon_struct *TaskInPeriod,
        ToDoListNode *task,
        U8 dow,
        U8 PeriodInterval,
        U8 StartCheck)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* U8 StartDay, */
    S32 StartPeriodIndex, TasktotalPeriod, lastPeriodIndex, periodInday;
    ToDoListNode *maxPriorityTask;
    clndr_task_icon_struct *cellCursor;
    MYTIME TaskDuration, startPeriod, endPeriod;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&TaskDuration, 0, sizeof(MYTIME));

    periodInday = DLNDR_MAX_DAY_HOURS / PeriodInterval;

    /* calculate start period of task */
    if (!StartCheck)
    {

        StartPeriodIndex = task->StartTime.nHour / PeriodInterval;
        cellCursor = TaskInPeriod + (StartPeriodIndex * CLNDR_COLUMN + dow);
        maxPriorityTask = cellCursor->maxPriorityTask;

        /* get the information of task's start period
           1.the date has no task yet
           2.the priority of new task is higher than original task */
        if ((maxPriorityTask == NULL) ||
            (task->Priority < maxPriorityTask->Priority) ||
            (task->Priority == maxPriorityTask->Priority && task->Type > maxPriorityTask->Type))
        {
        #ifdef __MMI_CLNDR_ICON_SUPPORT__
            cellCursor->icon = task->Type + IMG_CLNDR_ICON_REMINDER;
        #endif /*__MMI_CLNDR_ICON_SUPPORT__*/
            cellCursor->maxPriorityTask = task;
        }
        cellCursor->date++;

        /* mark the period blocks of the task duration */
        memcpy(&startPeriod, &task->StartTime, sizeof(MYTIME));
        memcpy(&endPeriod, &task->EndTime, sizeof(MYTIME));

        startPeriod.nHour = (startPeriod.nHour / PeriodInterval) * PeriodInterval;      /* adjust the start time to period base point */
        startPeriod.nMin = startPeriod.nSec = 0;
        
		if (CompareTime(task->StartTime, task->EndTime, NULL) == DT_TIME_EQUAL)
		{
			endPeriod.nHour++;
		}
		else if (endPeriod.nMin > 0)
        {
            endPeriod.nHour++;
			endPeriod.nMin = 0;
        }
		endPeriod.nHour = ((endPeriod.nHour / PeriodInterval) + (endPeriod.nHour % PeriodInterval)) * PeriodInterval;
        endPeriod.nMin = endPeriod.nSec = 0;
        applib_get_time_difference(
            (applib_time_struct*) & endPeriod,
            (applib_time_struct*) & startPeriod,
            (applib_time_struct*) & TaskDuration);
        /* Total period is more than one week */
        if (TaskDuration.nYear != 0 || TaskDuration.nMonth != 0)
        {
            TasktotalPeriod = (CLNDR_TOTAL_WEEKDAY * DLNDR_MAX_DAY_HOURS) / PeriodInterval;
        }
        else
        {
            TasktotalPeriod = (TaskDuration.nHour + TaskDuration.nDay * DLNDR_MAX_DAY_HOURS) / PeriodInterval;
        }
    }
    else
    {
        memcpy(&endPeriod, &task->EndTime, sizeof(MYTIME));
		if (CompareTime(task->StartTime, task->EndTime, NULL) == DT_TIME_EQUAL || endPeriod.nMin > 0)
		{
			endPeriod.nHour = ((endPeriod.nHour / PeriodInterval) + 1) * PeriodInterval;    /* adjust the end time to period base point */
		}
		else
		{
			endPeriod.nHour = (endPeriod.nHour / PeriodInterval) * PeriodInterval;
		}
        if (dow == 0xff)
        {
			/* fill in all the cell with the task */
            TasktotalPeriod = ((CLNDR_TOTAL_WEEKDAY * DLNDR_MAX_DAY_HOURS) / PeriodInterval) + 1;
        }
        else
        {
            TasktotalPeriod = (dow * DLNDR_MAX_DAY_HOURS + endPeriod.nHour) / PeriodInterval + 1;
        }

        StartPeriodIndex = -1;
        dow = 0;
    }

    lastPeriodIndex = periodInday - 1;

    for (; TasktotalPeriod > 1; TasktotalPeriod--)
    {
        if (StartPeriodIndex == lastPeriodIndex)
        {
            /* within the boundary of the week */
            if (dow < CLNDR_TOTAL_WEEKDAY - 1)
            {
                dow++;
                StartPeriodIndex = 0;
            }
            else
            {
                break;
            }
        }
        else
        {
            StartPeriodIndex++;
        }
        /* cellCursor = TaskInPeriod + (dow * periodInday + StartPeriodIndex); */
        cellCursor = TaskInPeriod + (StartPeriodIndex * CLNDR_COLUMN + dow);

        maxPriorityTask = cellCursor->maxPriorityTask;
        if ((maxPriorityTask == NULL) ||
            (task->Priority < maxPriorityTask->Priority) ||
            (task->Priority == maxPriorityTask->Priority && task->Type > maxPriorityTask->Type))
        {
            cellCursor->maxPriorityTask = task;
        }
        cellCursor->date++;
    }

}
#endif /* __MMI_CLNDR_WEEKLY_VIEW_SUPPORT__ */ 

#endif /* __MMI_TODOLIST__ */ // #ifdef __MMI_TODOLIST__

#ifdef __MMI_BIRTHDAY_REMINDER__


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_construct_birthday_memory
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_construct_birthday_memory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //U16 bm = mmi_clndr_get_daily_birthday_amount(g_tdl_cntx.ClndrDate.nDay);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_tdl_cntx.PBIndexList = (U16*) mmi_frm_scrmem_alloc(TDL_BIRTHDAY_INDEX_POOL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_tdl_destruct_birthday_memory
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_tdl_destruct_birthday_memory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tdl_cntx.PBIndexList != NULL)
    {        
        mmi_frm_scrmem_free((void*)g_tdl_cntx.PBIndexList);
        g_tdl_cntx.PBIndexList = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_birthday_highlight_make_call
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_birthday_highlight_make_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_birthday_make_call, KEY_EVENT_UP);
    SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_birthday_make_call
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_birthday_make_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 pbName[(MAX_PB_NAME_LENGTH + 1) * ENCODING_LENGTH], pbNumber[MAX_PB_NUMBER_LENGTH + 1];
    U8 pbNumberUnicode[MAX_PB_NUMBER_LENGTH * ENCODING_LENGTH];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(pbNumber, 0, MAX_PB_NUMBER_LENGTH + 1);
    memset(pbName, 0, (MAX_PB_NAME_LENGTH + 1) * ENCODING_LENGTH);
            
    mmi_phb_get_name_number(g_tdl_cntx.CurrHighlightBRIndex, pbName, pbNumber);
    if (mmi_birthday_check_pb_number(pbNumber) == MMI_FALSE)
    {
        return;
    }
    mmi_asc_to_ucs2((S8*) pbNumberUnicode, (S8*) pbNumber);
    mmi_phb_call_set_dial_from_list(MMI_PHB_FROM_OTHER_APP);
    mmi_phb_set_global_store_index(g_tdl_cntx.CurrHighlightBRIndex);
#ifdef __MMI_UCM__
    mmi_ucm_app_entry_dial_option(pbNumberUnicode, NULL, NULL);
#else /* __MMI_UCM__ */    
    MakeCall((S8*) pbNumberUnicode);
#endif /* __MMI_UCM__ */    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_birthday_highlight_send_sms
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_birthday_highlight_send_sms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_birthday_send_sms, KEY_EVENT_UP);
    SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_birthday_send_sms
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_birthday_send_sms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 *content;
    U8 pbName[(MAX_PB_NAME_LENGTH + 1) * ENCODING_LENGTH], pbNumber[MAX_PB_NUMBER_LENGTH + 1];
	U32 strlen;
    mmi_frm_sms_api_entry_write_struct *sendData = OslMalloc(sizeof(mmi_frm_sms_api_entry_write_struct));

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    strlen = (mmi_ucs2strlen(GetString(STR_HAPPY_BIRTHDAY)) + 1) * ENCODING_LENGTH;
    memset((S8*) sendData, 0, sizeof(mmi_frm_sms_api_entry_write_struct));
    content = OslMalloc(strlen);
	memcpy(content, GetString(STR_HAPPY_BIRTHDAY), strlen);   

    memset(pbNumber, 0, MAX_PB_NUMBER_LENGTH + 1);
    memset(pbName, 0, (MAX_PB_NAME_LENGTH + 1) * ENCODING_LENGTH);

    mmi_phb_get_name_number(g_tdl_cntx.CurrHighlightBRIndex, pbName, pbNumber);
    if (mmi_birthday_check_pb_number(pbNumber) == MMI_FALSE)
    {
        return;
    }

    sendData->string = content;
    sendData->stringlength = mmi_ucs2strlen(GetString(STR_HAPPY_BIRTHDAY));
    sendData->dcs = SMSAL_UCS2_DCS;
    sendData->flag = MMI_FRM_SMS_ENTRY_WRITE_REPLY;
    sendData->ascii_addr = pbNumber;

    mmi_frm_sms_api_entry_write_msg(sendData);
    OslMfree(content);
    OslMfree(sendData);
}

#ifdef MMS_SUPPORT
/*****************************************************************************
 * FUNCTION
 *  mmi_birthday_highlight_send_mms
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_birthday_highlight_send_mms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_birthday_send_mms, KEY_EVENT_UP);
    SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_birthday_send_mms
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_birthday_send_mms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 pbName[(MAX_PB_NAME_LENGTH + 1) * ENCODING_LENGTH], pbNumber[MAX_PB_NUMBER_LENGTH + 1];
    U8 pbNumberUnicode[MAX_PB_NUMBER_LENGTH * ENCODING_LENGTH];
    mms_content_entry_struct data;
    S8 *content;   
	U32 strlen;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(pbNumber, 0, MAX_PB_NUMBER_LENGTH + 1);
    memset(pbName, 0, (MAX_PB_NAME_LENGTH + 1) * ENCODING_LENGTH);
    
    strlen = (mmi_ucs2strlen(GetString(STR_HAPPY_BIRTHDAY)) + 1) * ENCODING_LENGTH;
    memset(&data, 0, sizeof(mms_content_entry_struct));
    content = OslMalloc(strlen);
	memcpy(content, GetString(STR_HAPPY_BIRTHDAY), strlen); 
    
    mmi_phb_get_name_number(g_tdl_cntx.CurrHighlightBRIndex, pbName, pbNumber);
    if (mmi_birthday_check_pb_number(pbNumber) == MMI_FALSE)
    {
        return;
    }
    mmi_asc_to_ucs2((S8*) pbNumberUnicode, (S8*) pbNumber);
    data.text_buffer = (char*)content;
    data.addr = (char*)pbNumberUnicode;

    mms_general_insert_hdlr(&data);    

    OslMfree(content);
}

#endif /* MMS_SUPPORT */
/*****************************************************************************
 * FUNCTION
 *  mmi_entry_birthday_option_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_entry_birthday_option_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 nStrItemList[3];    /* Stores the strings id of submenus returned */
    U16 nNumofItem;         /* Stores no of children in the submenu */
    U16 menuId;    
    U8 sim_check = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EntryNewScreen(SCR_BIRTHDAY_OPTION, NULL, mmi_entry_birthday_option_screen, NULL);

#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __FLIGHT_MODE_SUPPORT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif 
#else /*__MMI_DUAL_SIM_MASTER__*/
    if (mmi_bootup_is_sim_valid()
	#ifdef __FLIGHT_MODE_SUPPORT__
			&& mmi_bootup_get_active_flight_mode() == 0 /* in flight mode */
    #endif 
	)
    {
        sim_check = MMI_TRUE;
    }
#endif /*__MMI_DUAL_SIM_MASTER__*/


    if (sim_check == MMI_TRUE)
    {
        menuId = MITEM_BIRTHDAY_OPTION;
    }
    else
    {
        menuId = MITEM_BIRTHDAY_NO_SIM_OPTION;
    }

    nNumofItem = GetNumOfChild(menuId);

    GetSequenceStringIds(menuId, nStrItemList);

    SetParentHandler(menuId);

    guiBuffer = GetCurrGuiBuffer(SCR_BIRTHDAY_OPTION);

    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    ShowCategory15Screen(
        STR_GLOBAL_OPTIONS,
        GetRootTitleIcon(ORGANIZER_TODOLIST_MENU),
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        nNumofItem,
        nStrItemList,
        (U16*) gIndexIconsImageList,
        LIST_MENU,
        0,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);

    SetKeyHandler(GoBackHistory, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
}

MMI_BOOL mmi_birthday_check_pb_number(U8 *pbNumber)
{
    if (strlen((S8*) pbNumber) == 0)
    {
        DisplayPopup(
            (U8*)GetString(STR_BIRTHDAY_EMPTY_PHONE_NUMBER),
            IMG_GLOBAL_WARNING,
            1,
            UI_POPUP_NOTIFYDURATION_TIME,
            WARNING_TONE);
        return MMI_FALSE;
    }
    return MMI_TRUE;
}
#endif /* __MMI_BIRTHDAY_REMINDER__ */ 
#endif /* _MMI_TODOLIST_C */ // #ifndef _MMI_TODOLIST_C

