/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   wgui_categories_idlescreen.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 * Idle Screen related categories.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"
#include "stdC.h"
#include "L4Dr1.h"
#include "MMIDataType.h"
#include "GlobalDefs.h"
#include "gui_data_types.h"
#include "CustDataProts.h"
#include "CustMenuRes.h"
#include "EventsDef.h"
#include "gui_themes.h"
#include "wgui.h"
#include "CustThemesRes.h"
#include "wgui_inputs.h"
#include "wgui_categories.h"
#include "wgui_softkeys.h"
#include "wgui_status_icons.h"
#include "wgui_categories_MM.h"
#include "wgui_categories_idlescreen.h"
#include "wgui_categories_multimedia.h"
#include "IdleAppProt.h"
#include "IdleAppDef.h"
#include "SettingDefs.h"
#include "SettingGprots.h"
#include "PhoneSetup.h"
#include "gui_hardware_dependent.h"

#ifdef __MMI_AUDIO_PLAYER__
/* dependent headers for AudioPlayerXXX.h" */
#include "gui_data_types.h"
#include "FrameworkStruct.h"
#include "GlobalConstants.h"
#include "mdi_datatype.h"
#include "kal_release.h"
#include "Conversions.h"
#include "FileMgr.h"

#include "AudioPlayerDef.h"
#include "AudioPlayerType.h"
#endif /* __MMI_AUDIO_PLAYER__ */ 

#include "DebugInitDef.h"

#include "lcd_sw_rnd.h"         /* required for macro BLACK_BACKLIGHT, WHITE_BACKLIGHT, BLUE_BACKLIGHT macro */

#include "gdi_include.h"        /* include for graphic lib */

#include "SATGProts.h"
#include "wgui_draw_manager.h"
#ifdef __MMI_TOUCH_SCREEN__
#include "QuickAccessMenuItemProt.h"
#include "wgui_touch_screen.h"
#endif /* __MMI_TOUCH_SCREEN__ */ 

#include "SimDetectionGprot.h"

#include "fs_type.h"
#include "fs_func.h"

#include "ScrMemMgrGprot.h"
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
#include "ResMemMgrGprot.h"
#endif

#ifdef __DRM_SUPPORT__
#include "Drm_gprot.h"  /* DRM check */
#endif 

#ifdef __MMI_DUAL_SIM_MASTER__
#include "MTPNP_AD_master_header.h"
#include "MTPNP_PFAL_category_screen.h"
#endif	/* __MMI_DUAL_SIM_MASTER__ */

scrolling_text scroll_sat_idleText;

#define NORMAL_IDLE_SCREEN                   0
#define ANALOG_IDLE_SCREEN                   1
#define DIGITAL_IDLE_SCREEN                     2

#define NORMAL_SCREEN_SAVER                     0
#define ANALOG_SCREEN_SAVER                     1
#define DIGITAL_SCREEN_SAVER                 2

#define  VIEW_WALLPAPER_CLOCK                1
#define  VIEW_SCREENSAVER_CLOCK                 2
#define PREVIEW_CLOCK                        3

#ifdef __MMI_ANALOG_CLOCK__
void analog_clock_initialize(void);
#endif /* __MMI_ANALOG_CLOCK__ */ 


/***************************************************************************/
#ifdef __MMI_FM_RADIO__
BOOL mmi_fmrdo_is_power_on(void);
UI_string_type mmi_fmrdo_get_channel_name_or_freq(void);
scrolling_text scroll_fmrdo_idleText;
#endif /* __MMI_FM_RADIO__ */ 

#ifdef __MMI_AUDIO_PLAYER__
extern audply_struct g_audply;
scrolling_text scroll_audply_idleText;
UI_character_type idle_title[FMGR_MAX_FILE_LEN + 1];
#endif /* __MMI_AUDIO_PLAYER__ */ 

#include "lcd_if.h"
gdi_handle wgui_layer_1 = GDI_LAYER_EMPTY_HANDLE;
gdi_handle wgui_base_layer = GDI_LAYER_EMPTY_HANDLE;

/* store Main lcd width */
extern S32 MAIN_LCD_device_width;

/* store Main LCD height */
extern S32 MAIN_LCD_device_height;

/* MTK Elvis for R2L characters */
extern BOOL r2lMMIFlag;

/* MTK end */

U8 idle_screen_type = NORMAL_IDLE_SCREEN;

static U8 display_network_name = TRUE;

/* 122105 wallpaper Calvin */
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
static U8 gIsWallpaperChange = 0;
#endif 

extern U16 on_idle_screen;
static S32 gis_on_idlescreen = 0;

#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
extern GDI_HANDLE animation_handle;
#endif 

#ifdef __DRM_SUPPORT__
static S32 consumer;
#endif

void gui_idle_touch_screen_display_pressed_shorcut_item(S32 index);
void gui_idle_touch_screen_display_shorcut_item(S32 index);

void idle_screen_show_network_name(void);


/*****************************************************************************
 * FUNCTION
 *  is_on_idlescreen
 * DESCRIPTION
 *  Get is on idlescreen
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 is_on_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gis_on_idlescreen;
}


/*****************************************************************************
 * FUNCTION
 *  set_on_idlescreen
 * DESCRIPTION
 *  is on idlescreen
 * PARAMETERS
 *  temp_on_idlescreen      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void set_on_idlescreen(S32 temp_on_idlescreen)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gis_on_idlescreen = temp_on_idlescreen;
}

extern S16 status_icon;

/* Idle screen related wrappers  */
/* store the adress of string which stores idle screen netwrok name */
UI_string_type idle_screen_network_name = NULL;

/* store teh address of string which store the netwrok name */
UI_string_type idle_screen_network_status = NULL;

/* store the image id of wallpaper */
extern MMI_ID_TYPE idle_screen_wallpaper_ID;
/* store the image name of wallpaper */
extern S8 *idle_screen_wallpaper_name;
extern S8 *idle_screen_wallpaper_name_original;
extern S8 *idle_screen_screensaver_name;
extern S8 *idle_screen_cache_name;
extern MMI_ID_TYPE idle_screen_cache_id;

#if (defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) && (defined(__MMI_MAINLCD_240X320__)))
stFontAttribute idle_screen_network_name_font = {1, 0, 0, LARGE_FONT, 0, 0};
#else 
stFontAttribute idle_screen_network_name_font = {0, 0, 0, MEDIUM_FONT, 0, 0};
#endif 
stFontAttribute idle_screen_network_status_font = {0, 0, 0, MEDIUM_FONT, 0, 0};

/* store the x position of wallpaer of idle screen */
S32 cat33_image_x;

/* store the y position of wallpaer of idle screen */
S32 cat33_image_y;

/* store the image width  of wallpaer of idle screen */
S32 cat33_image_width;

/* store the image height  of wallpaer of idle screen */
S32 cat33_image_height;

/* store the total number frames  of animation wallpaper */
S32 cat33_n_frames = 0;

/* store the current frame number of animation wallppaer */
S32 cat33_frame_number = 0;

/* store the delay time to show next frame of animation wallpapaer */
S32 cat33_animation_delay = 1000;

/* store the image id ofcategory86 used foe analog clock */
PU8 cat86_image;

/* store x position of image,y position of image ,image widh ,image height */
S32 cat86_image_x,cat86_image_y;

#ifdef __MMI_LCD_PARTIAL_ON__
static UI_time cat161_time;
static S32 cat161_last_y_offset;
#endif /* __MMI_LCD_PARTIAL_ON__ */ 

/* MTK Leo add 20040423, add new interface to show screensaver */
/* store the type of screen saver like normal or analog/digital screen saver */
U8 screen_saver_type = NORMAL_SCREEN_SAVER;
U8 *ScreenSaverName;
U8 disp_network_screeen_saver = 0;
extern S32 PhnsetScreenSaverBadFileCallBack(void);
extern void PhnsetWallpaperBadFileCallBack(U16 imgID);

extern void dm_set_scr_bg_image_no_draw(U16 image_id, S8 *file_name, S32 x, S32 y, U8 opacity);        /* 092005 grayscale Calvin */

S32 cat128_image_x, cat128_image_y;
PU8 cat128_image;

scrolling_text *extra_scrolling_text = NULL;
S16 extra_text_x1 = -1;
S16 extra_text_y1 = -1;
S16 extra_text_x2 = -1;
S16 extra_text_y2 = -1;

#if 0// defined (__MMI_WALLPAPER_ON_BOTTOM__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined (__MMI_WALLPAPER_ON_BOTTOM__) */ 

extern U16 title_bg_id;

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
extern MMI_BOOL PhnsetGetShowDateTimeStatus(void);
MMI_ID_TYPE idlescreen_bar_id = IMG_TECHNO_ANALOG_CLOCK;    /* 070306 Alpha layer */
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 

extern icontext_button MMI_softkeys[];
extern void cat129_clear_icon_bg(void *button);

/**************************************************************************/

/* micha1111, michaSATc3, #212 */


/*****************************************************************************
 * FUNCTION
 *  satIdleTextScrollTimer
 * DESCRIPTION
 *  handle scrolling text of SAT scrrem
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void satIdleTextScrollTimer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&scroll_sat_idleText);
}


/*****************************************************************************
 * FUNCTION
 *  audply_idle_text_scroll_timer
 * DESCRIPTION
 *  scroll timer callbakc
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void audply_idle_text_scroll_timer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_AUDIO_PLAYER__
    gui_handle_scrolling_text(&scroll_audply_idleText);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  fmrdo_idle_text_scroll_timer
 * DESCRIPTION
 *  scroll timer callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmrdo_idle_text_scroll_timer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FM_RADIO__
    gui_handle_scrolling_text(&scroll_fmrdo_idleText);
#endif 
}

/* 092005 draw_wallpaper Calvin Start */


/*****************************************************************************
 * FUNCTION
 *  wgui_hide_background_with_wallpaper
 * DESCRIPTION
 *  redrwa the background by using the wallpaper
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_hide_background_with_wallpaper(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __GDI_MEMORY_PROFILE_2__
    /* gui_fill_rectangle(x1,y1,x2,y2,wgui_transparent_color); */
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); /* 112205 transparent color Calvin */
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
    if (idle_screen_wallpaper_ID == 0)
    {
        S32 disp_height = UI_device_height, disp_width = UI_device_width;

    #ifndef __MMI_IDLE_FULL_SCREEN__
        disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
        disp_width = UI_device_width - 1;
    #endif /* __MMI_IDLE_FULL_SCREEN__ */ 

        if ((disp_width >= cat33_image_width) && (disp_height >= cat33_image_height))   /* image can be displayed entirely */
        {
            S32 offset_x = 0;
            S32 offset_y = 0;

            /* align preview window at the center of screen */
            offset_x = (disp_width - cat33_image_width) >> 1;
            offset_y = (disp_height - cat33_image_height) >> 1;

            gdi_image_draw_file(offset_x, offset_y, (PS8) idle_screen_wallpaper_name);
        }
        else    /* image is larger than screen size */
        {
            S32 resized_offset_x;
            S32 resized_offset_y;
            S32 resized_width;
            S32 resized_height;

            gdi_image_util_fit_bbox(
                disp_width,
                disp_height,
                cat33_image_width,
                cat33_image_height,
                &resized_offset_x,
                &resized_offset_y,
                &resized_width,
                &resized_height);

            gdi_image_draw_resized_file(
                resized_offset_x,
                resized_offset_y,
                resized_width,
                resized_height,
                (PS8) idle_screen_wallpaper_name);
        }
    }
    else
    {
        idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
        if (cat33_n_frames > 1)
        {
            gui_show_animated_image_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
        }
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gui_show_image(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
}

/* 092005 draw_wallpaper Calvin End */


/*****************************************************************************
 * FUNCTION
 *  idle_screen_sat_display_text_background_redraw
 * DESCRIPTION
 *  redrwa the background ofSAT scrolling text area
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
/* 092005 draw_wallpaper Calvin Start */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#else /* 0 */ 
void idle_screen_sat_display_text_background_redraw(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    wgui_hide_background_with_wallpaper(x1, y1, x2, y2);
    gui_pop_clip();
}
#endif /* 0 */ 
/* 092005 draw_wallpaper Calvin End */

#ifdef __MMI_AUDIO_PLAYER__
extern BOOL mmi_audply_is_playing(void);
#endif 

#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
typedef enum
{
    SIM1_TEXT_ON_IDLE,
    SIM2_TEXT_ON_IDLE
} CURRENT_TEXT_TYPE;
U8 current_text_type;
#endif

/*****************************************************************************
 * FUNCTION
 *  idle_screen_show_network_details
 * DESCRIPTION
 *  show network name and network status on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_show_network_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL show_extra = FALSE;
    UI_string_type extra_text = NULL;
    void (*extra_scrolling_text_timer) (void) = NULL;
    U8* SAT_icon = NULL;
    S32 width = 0, height = 0, x = 0, y = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    if (extra_text_x1 >= 0)
    {
        gdi_layer_set_clip(extra_text_x1, extra_text_y1, extra_text_x2, extra_text_y2);
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(extra_text_x1, extra_text_y1, extra_text_x2, extra_text_y2, GDI_COLOR_TRANSPARENT);
#else
        draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */
    }
    gdi_layer_pop_clip();

#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    if (current_text_type == SIM1_TEXT_ON_IDLE) /* Current is Show SIM1 */
    {
#endif
    /* show network name */
    idle_screen_show_network_name();
    /* show network status */
    if (!(idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN))
    {
        S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;

        gui_set_font(&idle_screen_network_status_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_network_status_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_status_border_color);

        y = MMI_IDLE_NETWORK_STATUS_Y;
        /* clear background */
        gdi_layer_push_clip();
        gdi_layer_set_clip(
            w_inset, y,
            (UI_device_width - w_inset), (y + Get_CharDisplayHeightOfAllLangAndType(idle_screen_network_status_font.size)));
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(
            w_inset, y,
            (UI_device_width - w_inset), (y + Get_CharDisplayHeightOfAllLangAndType(idle_screen_network_status_font.size)),
            GDI_COLOR_TRANSPARENT);
#else
        draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */

        if (idle_screen_network_status != NULL)
        {
            width = gui_get_string_width(idle_screen_network_status) + 2;

            if (width <= (UI_device_width - (w_inset * 2)))
            {
                x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
                gui_move_text_cursor(x + 1, y + 1);
                gui_print_bordered_text(idle_screen_network_status);
            }
            else
            {
                S32 w;

                x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
                w = UI_device_width - (w_inset * 2);
                gui_print_truncated_borderd_text(x + 1, y + 1, w - 2, idle_screen_network_status);
            }
        }
        gdi_layer_pop_clip();
    }
#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    }
    else if (current_text_type == SIM2_TEXT_ON_IDLE) /* Current is Show SIM2 */
    {
#endif
#ifdef __MMI_DUAL_SIM_MASTER__
    idle_screen_show_card2_network_name((idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN) ? MMI_FALSE : MMI_TRUE);
    if (!(idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN))
    {
        idle_screen_show_card2_network_status();
    }
#endif	/* __MMI_DUAL_SIM_MASTER__ */
#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    }
#endif
    /* stop previous text scrolling */
    if (extra_scrolling_text)
    {
        gui_scrolling_text_stop(extra_scrolling_text);
        extra_scrolling_text = NULL;
    }

    /* configure extra text */
    if (idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN)
    {
        show_extra = FALSE;
    }
    else 
    {
        MMI_BOOL show_song_name = MMI_FALSE;

        if (mmi_idle_is_allow_to_display_song_name() == MMI_TRUE)
        {
#ifdef __MMI_AUDIO_PLAYER__
            if (mmi_audply_is_playing())
            {
                show_extra = TRUE;
                memcpy(idle_title, g_audply.title, (FMGR_MAX_FILE_LEN + 1)*sizeof(UI_character_type));
                extra_text = (UI_string_type) idle_title;
                extra_scrolling_text = &scroll_audply_idleText;
                extra_scrolling_text_timer = audply_idle_text_scroll_timer;
                show_song_name = MMI_TRUE;
            }
#endif /* __MMI_AUDIO_PLAYER__ */ 
#ifdef __MMI_FM_RADIO__
            if (mmi_fmrdo_is_power_on())
            {
                show_extra = TRUE;
                extra_text = (UI_string_type) mmi_fmrdo_get_channel_name_or_freq();
                extra_scrolling_text = &scroll_fmrdo_idleText;
                extra_scrolling_text_timer = fmrdo_idle_text_scroll_timer;
                show_song_name = MMI_TRUE;
            }
#endif /* __MMI_FM_RADIO__ */ 
        }
#ifdef __SAT__
        if (show_song_name == MMI_FALSE)
        {
            U8* SAT_text = NULL;

            SAT_text = GetSATIdleText();
            if (SAT_text != NULL)
            {
                show_extra = TRUE;
                extra_text = (UI_string_type) SAT_text;
                extra_scrolling_text = &scroll_sat_idleText;
                extra_scrolling_text_timer = satIdleTextScrollTimer;
            }
        }
#endif /* __SAT__ */
    }

    /* show extra information */
    if (show_extra && extra_scrolling_text != NULL)
    {
        S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
        S32 bracket_width = 0, text_bracket_gap = 5;

        gui_set_font(&idle_screen_network_name_font);
        gui_measure_string(extra_text, &width, &height);
        height = Get_CharDisplayHeightOfAllLangAndType(idle_screen_network_name_font.size) + 2;
        y = MMI_IDLE_EXTRA_Y;

        /* set refresh region */
        extra_text_x1 = (S16) w_inset;
        extra_text_y1 = (S16) y;
        extra_text_x2 = (S16) (UI_device_width - w_inset - 1);
        extra_text_y2 = (S16) (y + height);

        gdi_layer_push_clip();
#ifdef __GDI_MEMORY_PROFILE_2__
        if (extra_text_x1 >= 0)
        {
            gdi_layer_set_clip(extra_text_x1, extra_text_y1, extra_text_x2, extra_text_y2);
            //gdi_draw_solid_rect(extra_text_x1, extra_text_y1, extra_text_x2, extra_text_y2, GDI_COLOR_TRANSPARENT);
        }
#endif /* __GDI_MEMORY_PROFILE_2__ */
        gdi_layer_pop_clip();

        gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);

        /* print "[" */
        bracket_width = gui_get_character_width((UI_character_type)'[') + 2;
        x = (r2lMMIFlag) ? extra_text_x1 + bracket_width : extra_text_x1;
        y = extra_text_y1;
        gui_move_text_cursor(x + 1, y + 1);
        gui_print_bordered_text(L"[");

        /* print "]" */
        bracket_width = gui_get_character_width((UI_character_type)']') + 2;
        x = (r2lMMIFlag) ? extra_text_x2 : extra_text_x2 - bracket_width;
        y = extra_text_y1;
        gui_move_text_cursor(x + 1, y + 1);
        gui_print_bordered_text(L"]");

        /* show extra information */
        if (width <= (UI_device_width - ((w_inset + text_bracket_gap + 2/*bordered text*/*3/*"[","]",content*/) * 2)))
        {
            width = gui_get_string_width(extra_text);
            x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
            y = extra_text_y1;
            gui_move_text_cursor(x + 1, y + 1);
            gui_print_bordered_text(extra_text);
        }
        else
        {
            x = w_inset + bracket_width + text_bracket_gap;
            width = UI_device_width - (x)*2;
            gui_create_scrolling_text(
                    extra_scrolling_text,
                    x + 1,
                    y + 1,
                    width - 2,
                    height - 2,
                    extra_text,
                    extra_scrolling_text_timer,
                    idle_screen_sat_display_text_background_redraw,
                    *current_MMI_theme->idle_scr_network_extra_color,
                    *current_MMI_theme->idle_scr_network_extra_border_color);
            extra_scrolling_text->scroll_gap = 20;
            extra_scrolling_text->flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
            gui_show_scrolling_text(extra_scrolling_text);
        }
    }
    else
    {
        /* for indicate no draw extra_text this time,
         * so no need to clean it next time */
        extra_text_x1 = -1;
    }
    
    /* show SAT icon */
    /* the rule to display the SAT icon is a little complicated,
     * can be revised in the future */
#ifdef __SAT__
    SAT_icon = GetSATIdleIcon();
    if (SAT_icon)
    {
        S32 display_x_offset, display_y_offset;
        S32 display_width, display_height;
        
        gui_measure_image(SAT_icon, &width, &height);
        gdi_util_fit_box(
                GDI_UTIL_MODE_LONG_SIDE_FIT,
                26, 26, /* available display area, can be defined in wgui.h in the future */
                width, height,
                &display_x_offset, &display_y_offset,
                &display_width, &display_height);

#if defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)
        x = 1;  /* can be defined in wgui.h in the future */
        y = 22; /* can be defined in wgui.h in the future */
#elif defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
        x = 1;  /* can be defined in wgui.h in the future */
        y = 24; /* can be defined in wgui.h in the future */
#else /* defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
        x = (UI_device_width >> 1) - (display_width >> 1);
        y = MMI_IDLE_SATICON_Y;
#endif /* defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
        
        gui_push_clip();
        gui_set_clip(x, y, x + display_width, y + display_height);
        gdi_image_draw_resized(x, y, display_width, display_height, SAT_icon);
        gui_pop_clip();
    }
#endif /* __SAT__ */

#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_lcd_repaint_all();
    //gdi_layer_blt_previous(extra_text_x1, extra_text_y1 - 1, extra_text_x2, extra_text_y2 + 2);
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  idle_screen_show_network_name
 * DESCRIPTION
 *  show only network name on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_show_network_name(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (idle_screen_network_name != NULL)
    {
        S32 width, x, y;
        S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
        
      
        gdi_layer_push_clip();

        gui_set_font(&idle_screen_network_name_font);
        
        gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);

        width = gui_get_string_width(idle_screen_network_name) + 2;

        if (idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN)
        {
            y = MMI_IDLE_NETWORK_NAME_Y_WITH_CLOCK_BG;
        }
        else
        {
            y = MMI_IDLE_NETWORK_NAME_Y;
        }


#if 1
//Huyanwei Add it 
/*shaokai modify it start 090831*/ 
	y = 44/*30*/ ;
/*shaokai modify it end 090831*/ 
#endif
        /* clear background */
        gdi_layer_set_clip(
            w_inset, y,
            (UI_device_width - w_inset), (y + Get_CharDisplayHeightOfAllLangAndType(idle_screen_network_name_font.size)));
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(
            w_inset, y,
            (UI_device_width - w_inset), (y + Get_CharDisplayHeightOfAllLangAndType(idle_screen_network_name_font.size)),
            GDI_COLOR_TRANSPARENT);
#else
        draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */
        if (width <= (UI_device_width - (w_inset * 2)))
        {
            x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
            gui_move_text_cursor(x + 1, y + 1);
            gui_print_bordered_text(idle_screen_network_name);
        }
        else
        {
            S32 w;

            x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
            w = UI_device_width - (w_inset * 2) - 2;
            gui_print_truncated_borderd_text(x + 1, y + 1, w, idle_screen_network_name);
        }

        gdi_layer_pop_clip();
    }
}


/*****************************************************************************
 * FUNCTION
 *  dummy_dt_hide_function
 * DESCRIPTION
 *  dummy func of hide date
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void dummy_dt_hide_function(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x1);
    UI_UNUSED_PARAMETER(y1);
    UI_UNUSED_PARAMETER(x2);
    UI_UNUSED_PARAMETER(y2);
}

extern void redraw_status_icon_bar(U8 j);


/*****************************************************************************
 * FUNCTION
 *  cat33_analog_clock_hide_dt_display
 * DESCRIPTION
 *  hide function of date display of analog clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_analog_clock_hide_dt_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 0;

#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    /* for proper display of the status bar at analog clock */
    if (is_on_idlescreen())
    {
        y1 = 0;
    }
    else
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
        y1 = MMI_status_bar_height;

    x2 = UI_device_width - 1;

#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    /* for proper display of the status bar at analog clock */
    if (is_on_idlescreen())
    {
        y2 = (UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 4);
    }
    else
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
        y2 = UI_device_height - MMI_button_bar_height;

    gui_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); /* 112205 transparent color Calvin */
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    if (idle_screen_wallpaper_ID == 0)
    {
        ASSERT(idle_screen_wallpaper_ID == 0);  /* 092005 draw_wallpaper Calvin added //analog clock idle screen should predefined image */
        gdi_image_draw_file(cat33_image_x, cat33_image_y, idle_screen_wallpaper_name);
    }
    else
    {
        if (cat33_n_frames > 1)
        {
            gui_show_animated_image_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
        }
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gui_show_image(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    redraw_status_icon_bar(1);
#if 0
/* under construction !*/
#endif
    idle_screen_show_network_details();
}


/*****************************************************************************
 * FUNCTION
 *  cat33_digital_clock_hide_dt_display
 * DESCRIPTION
 *  hide function of date display of digital  clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
/* Assumes that the wallpaper displayed behind the digital clock is always full screen */
void draw_wallpaper(void);
void cat33_digital_clock_hide_dt_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_DALMATIAN_IDLESCREEN__
    /* To retain passing coordinates to the clip window */
    x1 = 0;
    x2 = UI_device_width - 1;
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    /* for proper display of the status bar at digital clock */
    if (is_on_idlescreen())
    {
        y1 = 0;
    }
    else
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    {
        y1 = MMI_status_bar_height;
    }
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    /* for proper display of the status bar at digital clock */
    if (is_on_idlescreen())
    {
        y2 = (UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 4);
    }
    else
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    {
        /* change for idlescreen shortcuts as their height is greater
           than MMI_button_bar_height */
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
        y2 = UI_device_height - max_touch_idle_screen_shortcut_height() - 1;
#else 
        y2 = UI_device_height - MMI_button_bar_height;
#endif 
    }
#endif /* __MMI_UI_DALMATIAN_IDLESCREEN__ */ 
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);

#ifdef __GDI_MEMORY_PROFILE_2__
    /* gui_fill_rectangle(x1,y1,x2,y2,wgui_transparent_color); */
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); /* 112205 transparent color Calvin */
#else /* __GDI_MEMORY_PROFILE_2__ */ 
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */ 
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 

    redraw_status_icon_bar(1);
    gui_pop_clip();

    /* 101904 MTK Calvin changed to sync with every other digital idle screen */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    {
        idle_screen_show_network_details();
    }
}

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
/*****************************************************************************
 * FUNCTION
 *  cat33_hide_date_display
 * DESCRIPTION
 *  hide function of date display on idlescreen
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_hide_date_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); /* 112205 transparent color Calvin */
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id)); /* 070306 Alpha layer */
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  cat33_hide_day_string_display
 * DESCRIPTION
 *  hide function of day display on idlescreen
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_hide_day_string_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    /* gui_fill_rectangle(x1,y1,x2,y2,wgui_transparent_color); */
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); /* 112205 transparent color Calvin */
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id)); /* 070306 Alpha layer */
    gui_pop_clip();
}
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 


/*****************************************************************************
 * FUNCTION
 *  cat33_hide_time_display
 * DESCRIPTION
 *  hide function of time display of analog/digital  clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
/* 092005 draw_wallpaper Calvin Start */
#if 0
/* under construction !*/
/* under construction !*/
#ifndef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
/* under construction !*/
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* 0 */ 
void cat33_hide_time_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(0, y1, MAIN_LCD_device_width - 1, y2);
    wgui_hide_background_with_wallpaper(x1, y1, x2, y2);
    redraw_status_icon_bar(1);
    gui_pop_clip();
}
#endif /* 0 */ 
/* 092005 draw_wallpaper Calvin End */


/*****************************************************************************
 * FUNCTION
 *  idle_screen_hide_status_icons_bar0
 * DESCRIPTION
 *  hide function of stats icon horizontal bar of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_hide_status_icons_bar0(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

#ifndef __MMI_IDLE_FULL_SCREEN__
    //color c = *current_MMI_theme->statusbar0_background_color;
    UI_filled_area *f = current_MMI_theme->status_icon_bar_filler;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    get_status_icon_bar_clip(0, &x1, &y1, &x2, &y2);
    gui_set_clip(x1, y1, x2, y2);
#ifdef __MMI_IDLE_FULL_SCREEN__
    /* MTK Leo add 20040423, provide new interfaces to set wallpaper */
    if (idle_screen_wallpaper_ID == 0)
#ifdef __GDI_MEMORY_PROFILE_2__
        /* gui_fill_rectangle(x1,y1,x2,y2,wgui_transparent_color); */
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);     /* 112205 transparent color Calvin */
#else /* __GDI_MEMORY_PROFILE_2__ */ 
        draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    else
    {
    #ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);     /* 112205 transparent color Calvin */
    #else /* __GDI_MEMORY_PROFILE_2__ */ 
        draw_wallpaper();
    #endif /* __GDI_MEMORY_PROFILE_2__ */ 
    }
    /* MTK Leo end */
#else /* __MMI_IDLE_FULL_SCREEN__ */ 
//    gui_fill_rectangle(x1, y1, x2, y2, c);
    gui_draw_filled_area(x1, y1, x2 -x1 + 1, y2 - y1 + 1, f);
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  idle_screen_hide_status_icons_bar1
 * DESCRIPTION
 *  hide function of stats icon vertical  bar of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_hide_status_icons_bar1(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    PU8 idle_screen_wallpaper;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
    gui_push_clip();
    get_status_icon_bar_clip(1, &x1, &y1, &x2, &y2);
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    y1 = y1 + 4;    /* To restrict the clip area below from the time date area lines. */
#endif 
    gui_set_clip(x1, y1, x2, y2);
    /* MTK Leo add 20040423, provide new interfaces to set wallpaper */
    if (idle_screen_wallpaper_ID == 0)
    {
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);     /* 112205 transparent color Calvin */
#else /* __GDI_MEMORY_PROFILE_2__ */ 
        draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    }
    else
    {
    #ifdef __GDI_MEMORY_PROFILE_2__
        /* gui_fill_rectangle(x1,y1,x2,y2,wgui_transparent_color); */
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);     /* 112205 transparent color Calvin */
    #else /* __GDI_MEMORY_PROFILE_2__ */ 
        draw_wallpaper();
    #endif /* __GDI_MEMORY_PROFILE_2__ */ 
    }
    /* MTK Leo end */
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaper
 * DESCRIPTION
 *  Sets the Image to be used by the idle screen
 * PARAMETERS
 *  image_ID        [IN]        wallpaper image ID
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaper(U16 image_ID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__    
#ifdef __MMI_ANALOG_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_ANALOG_CLK))
    {
        idle_screen_type = ANALOG_IDLE_SCREEN;
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_ANALOG_CLK;
    }
    else
#endif /* __MMI_ANALOG_CLOCK__ */ 

#ifdef __MMI_DIGITAL_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_DIGITAL_CLK))
    {
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_DIGITAL_CLK;
        idle_screen_type = DIGITAL_IDLE_SCREEN;
    }
    else
#endif /* __MMI_DIGITAL_CLOCK__ */ 
#endif /* !__MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    {
        idle_screen_type = NORMAL_IDLE_SCREEN;
        idle_screen_wallpaper_ID = image_ID;
    }
    idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
    gui_measure_image(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
    cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
    cat33_image_x = (UI_device_width - cat33_image_width) >> 1;
    cat33_image_y = (UI_device_height - cat33_image_height) >> 1;
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenNetworkName
 * DESCRIPTION
 *  Sets the network name to be displayed by the idle screen
 * PARAMETERS
 *  s       [IN]     network name string
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenNetworkName(U8 *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 strlen, i, real_pos;
    S8 start_flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (s == NULL)
    {
        idle_screen_network_name = NULL;
        return;
    }

    real_pos = 0;
    strlen = (U16) gui_strlen((UI_string_type) s) << 1;
    for (i = 0; i < strlen; i += 2)
    {
        if (s[i] != 0x20 || s[i + 1] != 0x00)
        {
            start_flag = 1;
        }
        if (start_flag == 1)    /* real data starts */
        {
            s[real_pos] = s[i];
            s[real_pos + 1] = s[i + 1];
            real_pos += 2;
        }
    }
    if (real_pos < strlen)
    {
        for (i = real_pos; i < strlen; i++)
        {
            s[i] = '\0';
        }
    }
    strlen = (U16) gui_strlen((UI_string_type) s) << 1;
    for (i = strlen - 2; i > 0; i -= 2)
    {
        if (s[i] != 0x20 || s[i + 1] != 0x00)
        {
            break;
        }
        else
        {
            s[i] = '\0';
            s[i + 1] = '\0';
        }
    }
    idle_screen_network_name = (UI_string_type) s;
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenNetworkStatus
 * DESCRIPTION
 *  Sets the network status to be displayed by the idle screen
 * PARAMETERS
 *  s       [IN]     status string
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenNetworkStatus(U8 *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 strlen, i, real_pos;    /* To avoid the strlen length 0 case */
    S8 start_flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    real_pos = 0;
    strlen = (S16) gui_strlen((UI_string_type) s) << 1;
    for (i = 0; i < strlen; i += 2)
    {
        if (s[i] != 0x20 || s[i + 1] != 0x00)
        {
            start_flag = 1;
        }
        if (start_flag == 1)    /* real data starts */
        {
            s[real_pos] = s[i];
            s[real_pos + 1] = s[i + 1];
            real_pos += 2;
        }
    }
    if (real_pos < strlen)
    {
        for (i = real_pos; i < strlen; i++)
        {
            s[i] = '\0';
        }
    }
    strlen = (S16) gui_strlen((UI_string_type) s) << 1;
    for (i = strlen - 2; i > 0; i -= 2)
    {
        if (s[i] != 0x20 || s[i + 1] != 0x00)
        {
            break;
        }
        else
        {
            s[i] = '\0';
            s[i + 1] = '\0';
        }
    }
    idle_screen_network_status = (UI_string_type) s;
}


/*****************************************************************************
 * FUNCTION
 *  cat33_animation_processor
 * DESCRIPTION
 *  a function which shows frames of animated wallpaper
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_animation_processor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat33_frame_number++;
    if (cat33_frame_number >= cat33_n_frames)
    {
        cat33_frame_number = 0;
    }
    gui_start_timer(cat33_animation_delay, cat33_animation_processor);

    gui_lock_double_buffer();

#ifndef __MMI_IDLE_FULL_SCREEN__
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - MMI_button_bar_height);
#else /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_reset_clip();
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
    gui_show_animated_image_frame(cat33_image_x, cat33_image_y, idle_screen_wallpaper, (S16) cat33_frame_number);

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
#ifndef __MMI_UI_TECHNO_STATUS_ICON__
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
#endif 
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));//070306 Alpha layer
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
    show_main_LCD_dt_display();
#ifdef __MMI_IDLE_FULL_SCREEN__
    redraw_status_icon_bar(0);
#endif 
    redraw_status_icon_bar(1);
    idle_screen_show_network_details();

#ifdef __MMI_IDLE_FULL_SCREEN__
    if (cat33_image_height < UI_device_height)
    {
        show_softkey_background();
    }
    show_left_softkey();
    show_right_softkey();
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}

/* MTK Leo add 20040422, provide new interfaces to set wallpaper */


/*****************************************************************************
 * FUNCTION
 *  wgui_set_wallpaper_change
 * DESCRIPTION
 *  Sets the Image to be used by the idle screen using ID
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
void wgui_set_wallpaper_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gIsWallpaperChange = 1;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_is_wallpaper_change
 * DESCRIPTION
 *  get wallpaper changed
 * PARAMETERS
 *  void
 * RETURNS
 *  is wallpaper changed
 *****************************************************************************/
U8 wgui_is_wallpaper_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gIsWallpaperChange;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_reset_wallpaper_change
 * DESCRIPTION
 *  set wallpaper not change
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_reset_wallpaper_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gIsWallpaperChange = 0;
}
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaperID
 * DESCRIPTION
 *  set Idle screen wall paper ID
 * PARAMETERS
 *  image_ID        [IN]        wallpaper ID
 *  is_default      [IN]        Save the layer of wallpaper as fast format
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaperID(U16 image_ID, MMI_BOOL is_default)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(is_default);

#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
    if (idle_screen_wallpaper_ID != 0 && !mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
    {
        mmi_frm_resmem_dereg_retain((U16)idle_screen_wallpaper_ID);
    }
#endif /* __MMI_RESOURCE_ENFB_SUPPORT__ */ 

#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
#ifdef __MMI_ANALOG_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_ANALOG_CLK))
    {
        idle_screen_type = ANALOG_IDLE_SCREEN;
        /* __CUSTPACK_MULTIBIN Calvin BEGIN */
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_ANALOG_CLK;
        /* __CUSTPACK_MULTIBIN Calvin END */
    }
    else
#endif /* __MMI_ANALOG_CLOCK__ */ 
#ifdef __MMI_DIGITAL_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_DIGITAL_CLK))
    {
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_DIGITAL_CLK;
        idle_screen_type = DIGITAL_IDLE_SCREEN;
    }
    else
#endif /* __MMI_DIGITAL_CLOCK__ */ 
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    {
        idle_screen_type = NORMAL_IDLE_SCREEN;
        idle_screen_wallpaper_ID = image_ID;
    }
    
    if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
    {
        cat33_n_frames = 1;
        cat33_image_width = MAIN_LCD_DEVICE_WIDTH;
        cat33_image_height = MAIN_LCD_DEVICE_HEIGHT;
        cat33_image_x = 0;
        cat33_image_y = 0;
    }
    else
    {
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
        mmi_frm_resmem_reg_retain((U16)idle_screen_wallpaper_ID);
#endif
        
        idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
        gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
        gdi_image_get_frame_count_id(idle_screen_wallpaper_ID, &cat33_n_frames);
        cat33_image_x = (UI_device_width - cat33_image_width) >> 1;
        cat33_image_y = (UI_device_height - cat33_image_height) >> 1;
    }


    #ifdef __MMI_WALLPAPER_ON_BOTTOM__
        idle_screen_cache_id = idle_screen_wallpaper_ID;
        idle_screen_cache_name = NULL;
    #endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
}

#ifdef __MMI_WALLPAPER_ON_BOTTOM__


/*****************************************************************************
 * FUNCTION
 *  SetListWallpaperID
 * DESCRIPTION
 *  set list wallpaper ID
 * PARAMETERS
 *  image_ID        [IN]        wallpaper ID
 * RETURNS
 *  void
 *****************************************************************************/
 void SetListWallpaperID(U16 image_ID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
/*
    U16 bg_img_id;
    S8 *bg_img_name;
    S32 bg_img_x, bg_img_y;
    U8 bg_img_opacity;
*/

    PU8 idle_screen_wallpaper;
    S32 disp_height = UI_device_height, disp_width = UI_device_width;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    idle_screen_type = NORMAL_IDLE_SCREEN;
    idle_screen_wallpaper_ID = image_ID;
    
    idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
    cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
    gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
    cat33_image_x = (disp_width - cat33_image_width) >> 1;
    cat33_image_y = (disp_height - cat33_image_height) >> 1;
    

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    idle_screen_cache_id = idle_screen_wallpaper_ID;
    idle_screen_cache_name = NULL;
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
    
/*
    dm_set_scr_bg_redraw(MMI_TRUE);
    dm_get_scr_bg_image(&bg_img_id, &bg_img_name, &bg_img_x, &bg_img_y, &bg_img_opacity);
    dm_set_scr_bg_image(idle_screen_wallpaper_ID, NULL, bg_img_x, bg_img_y, bg_img_opacity);
*/
}
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaperName
 * DESCRIPTION
 *  set idle screen wallpaper name
 * PARAMETERS
 *  name        [IN]        image file name
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaperName(UI_string_type name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 disp_height = UI_device_height, disp_width = UI_device_width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
    if (idle_screen_wallpaper_ID != 0)
    {
        mmi_frm_resmem_dereg_retain((U16)idle_screen_wallpaper_ID);
    }
#endif /* __MMI_RESOURCE_ENFB_SUPPORT__ */ 
    idle_screen_wallpaper_ID = 0;
    idle_screen_type = NORMAL_IDLE_SCREEN;

#ifndef __MMI_IDLE_FULL_SCREEN__
    disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
    disp_width = UI_device_width - 1;
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    gdi_image_get_dimension_file((S8*) name, &cat33_image_width, &cat33_image_height);
    cat33_image_x = (disp_width - cat33_image_width) >> 1;
    cat33_image_y = (disp_height - cat33_image_height) >> 1;

    gdi_image_get_frame_count_file((U8 *)name, &cat33_n_frames);

    mmi_ucs2cpy(idle_screen_wallpaper_name_original, (S8*) name);
    idle_screen_wallpaper_name = idle_screen_wallpaper_name_original;

}


#ifdef __DRM_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_scrsvr_drm_callback
 * DESCRIPTION
 *  Screen saver DRM consume callback
 * PARAMETERS
 *  point       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_wallpaper_drm_callback(S32 res, S32 id)
{
    DRM_stop_consume(consumer);
    PhnsetWallpaperBadFileCallBack(0);
}
#endif /* __DRM_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  draw_wallpaper
 * DESCRIPTION
 *  Redraws the Idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void draw_wallpaper(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);

    /* Robin 1208 Display user define wallpaper */
    S32 disp_height = UI_device_height, disp_width = UI_device_width;

    GDI_RESULT ret = GDI_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
#ifndef __MMI_IDLE_FULL_SCREEN__
    /* Robin 1208 Display user define wallpaper */
    disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
    disp_width = UI_device_width - 1;
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - MMI_button_bar_height);
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    if (idle_screen_wallpaper_ID != 0)  /* image comes from resource */
    {
        if (cat33_n_frames > 1)
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
            gdi_image_draw_animation_frames(
            cat33_image_x,
            cat33_image_y,
            idle_screen_wallpaper,
            &animation_handle,
            (S16) cat33_frame_number);
#else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
        {
            gdi_image_draw_animation_single_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
            cat33_animation_delay = gdi_image_get_animation_delay();
        }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gdi_image_draw(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
    else
    {
        /* 102406 DRM check Start */
        FS_HANDLE originalPath = 0;
    #ifdef __DRM_SUPPORT__
        kal_bool DRM_ret = KAL_FALSE;
    #endif

        //if (cat33_n_frames <= 1) /* check if the original file of the cached static image still exists and the DRM right as well */
        {
            if (idle_screen_wallpaper_name_original == NULL)
            {
                ret = GDI_IMAGE_ERR_INVALID_FILE;
            }
            else
            {
            #ifdef __DRM_SUPPORT__
                originalPath = DRM_open_file((PU16) idle_screen_wallpaper_name_original, FS_READ_ONLY, DRM_PERMISSION_DISPLAY);
                //if (originalPath > 0 && DRM_validate_permission(originalPath, NULL, DRM_PERMISSION_DISPLAY))
                if (originalPath > 0 && DRM_validate_forward_rule(originalPath, DRM_PERMISSION_DISPLAY))
                {
                    //consumer = DRM_consume_rights(originalPath, DRM_PERMISSION_DISPLAY, mmi_wallpaper_drm_callback);
                    DRM_ret = KAL_TRUE;
                }
                if (DRM_ret == KAL_FALSE)
            #else /* __DRM_SUPPORT__ */ 
                originalPath = FS_Open((PU16) idle_screen_wallpaper_name_original, FS_READ_ONLY | FS_OPEN_NO_DIR);
                if (originalPath < 0) /* file open error but not DRM related problem */
            #endif /* __DRM_SUPPORT__ */ 
                {
                    ret = GDI_IMAGE_ERR_INVALID_FILE;
                }
                if (originalPath > 0)
                {
                #ifdef __DRM_SUPPORT__
                    DRM_close_file(originalPath);
                #else
                    FS_Close(originalPath);
                #endif
                    originalPath = 0;
                }
             }
        }
        
        if (ret != GDI_IMAGE_ERR_INVALID_FILE)
        {
            S32 offset_x = 0;
            S32 offset_y = 0;

            gdi_image_get_dimension_file(idle_screen_wallpaper_name, &cat33_image_width, &cat33_image_height);
            cat33_image_x = (disp_width - cat33_image_width) >> 1;
            cat33_image_y = (disp_height - cat33_image_height) >> 1;

            if ((disp_width >= cat33_image_width) && (disp_height >= cat33_image_height))       /* image can be displayed entirely */
            {
                /* align preview window at the center of screen */
                offset_x = (disp_width - cat33_image_width) >> 1;
                offset_y = (disp_height - cat33_image_height) >> 1;

            #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                ret = gdi_image_draw_animation_file(
                        offset_x,
                        offset_y,
                        (PS8) idle_screen_wallpaper_name,
                        &animation_handle);
            #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                ret = gdi_image_draw_file(offset_x, offset_y, (PS8) idle_screen_wallpaper_name);
            #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            }
            else    /* image is larger than screen size */
            {
                S32 resized_offset_x;
                S32 resized_offset_y;
                S32 resized_width;
                S32 resized_height;

                gdi_image_util_fit_bbox(
                    disp_width,
                    disp_height,
                    cat33_image_width,
                    cat33_image_height,
                    &resized_offset_x,
                    &resized_offset_y,
                    &resized_width,
                    &resized_height);

                /* for images of other formats, try to set center alignment */
            #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                ret = gdi_image_draw_animation_resized_file(
                        resized_offset_x,
                        resized_offset_y,
                        resized_width,
                        resized_height,
                        (PS8) idle_screen_wallpaper_name,
                        &animation_handle);
                /* ret = gdi_image_draw_resized_file(resized_offset_x, resized_offset_y, resized_width, resized_height, (PS8)idle_screen_wallpaper_name); */
            #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                ret = gdi_image_draw_resized_file(
                        resized_offset_x,
                        resized_offset_y,
                        resized_width,
                        resized_height,
                        (PS8) idle_screen_wallpaper_name);
            #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            }
        }
        /* 102406 DRM check End */

        if (ret < 0 && ret != GDI_GIF_ERR_OUT_OF_CLIP_REGION && ret != GDI_BMP_ERR_OUT_OF_CLIP_REGION)
        {
            /* Robin 1208 Display user define wallpaper */
            PRINT_INFORMATION_2(MMI_TRACE_G7_MISC, "draw_wallpaper():[$$$]GDI_RESULT:%d[$$$]\n", ret);
            PhnsetWallpaperBadFileCallBack(0);
            idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
            cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
            gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
            cat33_image_x = (disp_width - cat33_image_width) >> 1;
            cat33_image_y = (disp_height - cat33_image_height) >> 1;
            if (cat33_n_frames > 1)
        #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                gdi_image_draw_animation_frames(
                    cat33_image_x,
                    cat33_image_y,
                    idle_screen_wallpaper,
                    &animation_handle,
                    (S16) cat33_frame_number);
        #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                gdi_image_draw_animation_single_frame(
                    cat33_image_x,
                    cat33_image_y,
                    idle_screen_wallpaper,
                    (S16) cat33_frame_number);
        #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            else
            {
                gdi_image_draw(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_stop_wallpaper
 * DESCRIPTION
 *  Stop wallpaper animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_stop_wallpaper(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    animation_handle = cat129_get_image_handle();
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }

        animation_handle = cat222_get_image_handle();
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_save_wallpaper_to_speedup
 * DESCRIPTION
 *  Save the layer of wallpaper as fast format
 * PARAMETERS
 *  is_default      [IN]        not used
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_save_wallpaper_to_speedup(MMI_BOOL is_default)
{
    UI_UNUSED_PARAMETER(is_default);
#if 0
#ifdef GDI_USING_LAYER
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* __GDI_MEMORY_PROFILE_2__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __FS_QM_SUPPORT__
/* under construction !*/
/* under construction !*/
        #endif /* __FS_QM_SUPPORT__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #ifndef __MMI_IDLE_FULL_SCREEN__
/* under construction !*/
/* under construction !*/
            #endif /* __MMI_IDLE_FULL_SCREEN__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
        #endif 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __MMI_WALLPAPER_ON_BOTTOM__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* GDI_USING_LAYER */ 
#endif
}


/*****************************************************************************
* FUNCTION
 *  wgui_check_wallpaper_frame_count
* DESCRIPTION
*  Provide wallpaper frame count. 
* PARAMETERS
 *  name            [?]         
 *  error_str       [IN]        
* RETURNS
*   void
*****************************************************************************/
MMI_BOOL wgui_check_wallpaper_frame_count(S8 *name, S8 **error_str)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 wallpaper_frames = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_image_gif_get_frame_count_file(name, &wallpaper_frames);
    PRINT_INFORMATION_2(MMI_TRACE_G7_MISC, "Wallpaper frame count = %d",  wallpaper_frames);

    if(wallpaper_frames > PHNSET_MAX_WALLPAPER_FRAME)
    {
        *error_str = (PS8)GetString(STR_ID_WP_FRAME_ERR);
        return MMI_FALSE;
    }
    else
    {
        *error_str = NULL;
        return MMI_TRUE;
    }

}


#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
#define MAX_IDLE_SCREEN_SHORTCUTS   4

#define IDLE_TOUCH_SHORTCUT_UNPRESSED   0
#define IDLE_TOUCH_SHORTCUT_PRESSED     1

typedef struct
{
    S32 x;
    S32 y;
    S32 width;
    S32 height;
    S32 state;
    FuncPtr entryfn;
} idle_touch_screen_shortcut;

static idle_touch_screen_shortcut touch_idle_shortcuts[MAX_IDLE_SCREEN_SHORTCUTS];
static S32 touch_idle_screen_highlighted_shortcut;
static S32 touch_idle_screen_highlight_changed;

extern void mmi_phb_entry_main_menu(void);
extern void EntryScrMessagesMenuList(void);
extern void EntryMainMenuFromIdleScreen(void);


/*****************************************************************************
 * FUNCTION
 *  setup_touch_idle_screen_shortcuts
 * DESCRIPTION
 *  This function is used to set up touch screen shortcuts
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF IMAGE ID's
 *****************************************************************************/
void setup_touch_idle_screen_shortcuts(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width[MAX_IDLE_SCREEN_SHORTCUTS], image_height[MAX_IDLE_SCREEN_SHORTCUTS], i, total_width =
        0, x, x_margin;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MAX_IDLE_SCREEN_SHORTCUTS; i++)
    {
        gui_measure_image((PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + i)), &image_width[i], &image_height[i]);
        total_width += image_width[i];
        touch_idle_shortcuts[i].height = image_height[i];
        touch_idle_shortcuts[i].width = image_width[i];
        touch_idle_shortcuts[i].state = IDLE_TOUCH_SHORTCUT_UNPRESSED;
    }

    MMI_DBG_ASSERT(total_width >= 0 && total_width <= UI_device_width);

    touch_idle_shortcuts[0].entryfn = EntryMainMenuFromIdleScreen;
    touch_idle_shortcuts[1].entryfn = EntryScrMessagesMenuList;
    touch_idle_shortcuts[2].entryfn = mmi_phb_entry_main_menu;
    touch_idle_shortcuts[3].entryfn = IdleScreenDigitHandler;

    x_margin = (UI_device_width - total_width) / ((MAX_IDLE_SCREEN_SHORTCUTS - 1) + 2); /* Margin between shortcut Images,Leave margin on front and back also */

    x = x_margin;

    for (i = 0; i < MAX_IDLE_SCREEN_SHORTCUTS; i++)
    {
        touch_idle_shortcuts[i].x = x;
        touch_idle_shortcuts[i].y = UI_device_height - touch_idle_shortcuts[i].height;
        x += touch_idle_shortcuts[i].width + x_margin;
    }

}


/*****************************************************************************
 * FUNCTION
 *  display_touch_idle_screen_shortcuts
 * DESCRIPTION
 *  This function is used to draw touch screen shortcuts
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF IMAGE ID's
 *****************************************************************************/
void display_touch_idle_screen_shortcuts(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, max_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    for (i = 0; i < MAX_IDLE_SCREEN_SHORTCUTS; i++)
    {
        if (touch_idle_shortcuts[i].state == IDLE_TOUCH_SHORTCUT_PRESSED)
        { 
            gui_idle_touch_screen_display_pressed_shorcut_item(i);      
        }
        else
        {
            gui_idle_touch_screen_display_shorcut_item(i);
        }
    }
    max_height = max_touch_idle_screen_shortcut_height();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, UI_device_height - max_height, UI_device_width, UI_device_height);
}


/*****************************************************************************
 * FUNCTION
 *  max_touch_idle_screen_shortcut_height
 * DESCRIPTION
 *  This function is used to find the maximum height of idlescreen shortcut
 *  among them.
 * PARAMETERS
 *  void
 * RETURNS
 *  S32 max_height
 * REMARKS
 *  
 *****************************************************************************/
S32 max_touch_idle_screen_shortcut_height(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, max_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* In case Image's are of different height, Find the maximum height image */
    max_height = touch_idle_shortcuts[0].height;

    for (i = 0; i < MAX_IDLE_SCREEN_SHORTCUTS; i++)
    {
        if (max_height < touch_idle_shortcuts[i].height)
        {
            max_height = touch_idle_shortcuts[i].height;
        }
    }
    return (max_height);
}
#endif /* defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */ 


#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
/*****************************************************************************
 * FUNCTION
 *  show_boundries_to_status_bar_at_bottom_idlescreen
 * DESCRIPTION
 *  redraw status bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_boundries_to_status_bar_at_bottom_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    c = gui_color(255, 255, 255);
    gui_draw_horizontal_line(0, UI_device_width - 1, UI_device_height - 1 - MMI_button_bar_height, c);
    gui_draw_horizontal_line(
        0,
        UI_device_width - 1,
        UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 2,
        c);
    gui_draw_horizontal_line(0, UI_device_width - 1, 0, c);

#ifdef __MMI_MAINLCD_128X128__
    gui_draw_horizontal_line(0, UI_device_width - 1, MMI_status_bar_height + 2, c);
#else 
    gui_draw_horizontal_line(0, UI_device_width - 1, MMI_status_bar_height, c);
#endif 
}
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_cat33_get_cache_wallpaper_info
 * DESCRIPTION
 *  get cat33 cache wallpaper information, used after ShowCategory33Screen and before entering another new screen
 * PARAMETERS
 *  id                  [IN]    Current wallpaper id to determine whether to cache
 *  filename            [IN]    Current wallpaper filename to determine whether to cache
 *  wallpaper_layer     [OUT]   layer handle of wallpaper
 *  output_image_type   [OUT]   output image type (GDI image type)
 * RETURNS
 *  MMI_BOOL            whether to enable cache wallpaper mechanism
 *****************************************************************************/
MMI_BOOL mmi_cat33_get_cache_wallpaper_info (MMI_ID_TYPE id, PS8 filename, GDI_HANDLE *wallpaper_layer, U16 *output_image_type)
{
    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_cache_image_type_enum cache_test = GUI_CACHE_IMAGE_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *wallpaper_layer = dm_get_wallpaper_layer();
    
    cache_test = gui_image_query_cache_type(id, filename);

    switch(cache_test)
    {
        case GUI_CACHE_IMAGE_PBM:
            *output_image_type = GDI_IMAGE_TYPE_DEVICE_BMP_FILE;
            break;
            
        case GUI_CACHE_IMAGE_JPG:
            *output_image_type = GDI_IMAGE_TYPE_JPG_FILE;
            break;
            
        default:
            return MMI_FALSE;
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory33Screen
 * DESCRIPTION
 *  redraw category 33
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory33Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    gui_cancel_timer(cat33_animation_processor);
#endif 

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    gui_push_clip();
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + MMI_IDLESCREEN_BAR_HEIGHT - 1);
#ifndef __MMI_UI_TECHNO_STATUS_ICON__
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
#endif /* __MMI_UI_TECHNO_STATUS_ICON__ */
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    }
    gui_pop_clip();
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 

#ifdef __GDI_MEMORY_PROFILE_2__
    update_mainlcd_dt_display();
#else /* __GDI_MEMORY_PROFILE_2__ */
    show_main_LCD_dt_display();
#endif /* __GDI_MEMORY_PROFILE_2__ */

#ifndef __MMI_IDLE_FULL_SCREEN__
    idle_screen_hide_status_icons_bar0();
#endif /* __MMI_IDLE_FULL_SCREEN__ */
    in_idle_screen();

    show_status_icons();

#ifdef __MMI_UI_TECHNO_STATUS_ICON__
    refresh_fixed_status_icon(STATUS_ICON_SIGNAL_STRENGTH, 0);
    refresh_fixed_status_icon(STATUS_ICON_BATTERY_STRENGTH, 0);
#endif /* __MMI_UI_TECHNO_STATUS_ICON__ */ 
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    {
        idle_screen_show_network_details();
    }

    on_idle_screen = 1;
    set_on_idlescreen(1);
    
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    show_boundries_to_status_bar_at_bottom_idlescreen();
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM_ */

#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
    if (mmi_idle_is_display_touch_shortcuts() == MMI_TRUE)
    {
        display_touch_idle_screen_shortcuts();
    }
#endif /* defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */ 

    register_hide_status_icon_bar(0, idle_screen_hide_status_icons_bar0);
    register_hide_status_icon_bar(1, idle_screen_hide_status_icons_bar1);

#if defined(ENABLE_ANIMATED_WALLPAPERS)
#ifndef __GDI_MEMORY_PROFILE_2__
    if (cat33_n_frames > 1 && idle_screen_wallpaper_ID != 0)
    {
        gui_start_timer(cat33_animation_delay, cat33_animation_processor);
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
#endif /* (ENABLE_ANIMATED_WALLPAPERS) */ 
}


/*****************************************************************************
 * FUNCTION
 *  dm_category_33_controlled_area
 * DESCRIPTION
 *  This function is used to draw the category controlled area of idle screen
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void dm_category_33_controlled_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RedrawCategory33Screen();
}

#ifdef __MMI_TOUCH_SCREEN__
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
/*****************************************************************************
 * FUNCTION
 *  gui_idle_touch_screen_display_shorcut_item
 * DESCRIPTION
 *  This function is Display individual shorcut item on Touch idle screen
 * PARAMETERS
 *  index       [IN]        idle screen shortcut
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
void gui_idle_touch_screen_display_shorcut_item(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(index >= 0 && index < MAX_IDLE_SCREEN_SHORTCUTS);

    touch_idle_shortcuts[index].state = IDLE_TOUCH_SHORTCUT_UNPRESSED;
    
    x1 = touch_idle_shortcuts[index].x;
    y1 = touch_idle_shortcuts[index].y;
    x2 = touch_idle_shortcuts[index].x + touch_idle_shortcuts[index].width - 1;
    y2 = touch_idle_shortcuts[index].y + touch_idle_shortcuts[index].height - 1;
    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); /* 112205 transparent color Calvin */
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + index)));
    gui_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
}


/*****************************************************************************
 * FUNCTION
 *  gui_idle_touch_screen_display_pressed_shorcut_item
 * DESCRIPTION
 *  This function is Display individual pressed shorcut item on Touch idle screen
 * PARAMETERS
 *  index       [IN]        pressed shortcut index
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
void gui_idle_touch_screen_display_pressed_shorcut_item(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(index >= 0 && index < MAX_IDLE_SCREEN_SHORTCUTS);

    touch_idle_shortcuts[index].state = IDLE_TOUCH_SHORTCUT_PRESSED;
    
    x1 = touch_idle_shortcuts[index].x;
    y1 = touch_idle_shortcuts[index].y;
    x2 = touch_idle_shortcuts[index].x + touch_idle_shortcuts[index].width - 1;
    y2 = touch_idle_shortcuts[index].y + touch_idle_shortcuts[index].height - 1;
    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); /* 112205 transparent color Calvin */
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT_PRESSED + index)));
    gui_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
}


/*****************************************************************************
 * FUNCTION
 *  gui_idle_touch_screen_shortcut_translate_pen_position
 * DESCRIPTION
 *  This function finds index of shorcut item on which pen event came
 * PARAMETERS
 *  x           [IN]        Pen's x position
 *  y           [IN]        Pen's y position
 *  index       [OUT]       Index of selected item
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
void gui_idle_touch_screen_shortcut_translate_pen_position(S32 x, S32 y, S32 *index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *index = -1;

    for (i = 0; i < MAX_IDLE_SCREEN_SHORTCUTS; i++)
    {
        if (x >= touch_idle_shortcuts[i].x && x <= touch_idle_shortcuts[i].x + touch_idle_shortcuts[i].width &&
            y >= touch_idle_shortcuts[i].y && y <= touch_idle_shortcuts[i].y + touch_idle_shortcuts[i].height)
        {
            *index = i;
            break;
        }
    }
}
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 


/*****************************************************************************
 * FUNCTION
 *  category33_pen_down_handler
 * DESCRIPTION
 *  pen down handler
 * PARAMETERS
 *  point       [IN]        pen down position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category33_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, y2;
    MMI_BOOL ret = MMI_FALSE;;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_idle_restart_screensaver_timer();
    mmi_idle_restart_keypad_lock_timer();

#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (mmi_idle_is_display_touch_shortcuts() == MMI_FALSE)
    {
        y2 = UI_device_height - 1 - MMI_button_bar_height;
    }
    else
    {
        y2 = UI_device_height;  /* N CASE IDLE SCREEN SHORTCUTS ARE DISPLAYED, BUTTON BAR IS NOT DISPLAYED */
    }
#else /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    y2 = UI_device_height - 1 - MMI_button_bar_height;
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    if (pos_x > 0 && pos_x < UI_device_width - 1 && pos_y > MMI_content_y && pos_y < y2)
    {
        ret = MMI_TRUE;
    #ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
        {
            S32 index;

            gui_idle_touch_screen_shortcut_translate_pen_position(pos_x, pos_y, &index);
            if (index >= 0 && index < MAX_IDLE_SCREEN_SHORTCUTS)
            {
                touch_idle_screen_highlighted_shortcut = index;
                touch_idle_screen_highlight_changed = 0;
                gui_idle_touch_screen_display_pressed_shorcut_item(index);
            }
        }
    #endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    }
    return ret;
}

S32 cat33_scr_lock_repeat = -1;


/*****************************************************************************
 * FUNCTION
 *  category33_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler
 * PARAMETERS
 *  point       [IN]        pen tap position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category33_pen_long_tap_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_keylock_context.gKeyPadLockFlag == 0 && pos_x >= UI_device_width >> 2 &&
        pos_x <= UI_device_width - (UI_device_width < 2) && pos_y >= UI_device_height >> 2 &&
        pos_y <= UI_device_height - (MMI_button_bar_height >> 2))
    {
        cat33_scr_lock_repeat = 0;
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category33_pen_repeat_handler
 * DESCRIPTION
 *  pen repeat handler
 * PARAMETERS
 *  point       [IN]        pen repeat position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category33_pen_repeat_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_idle_restart_screensaver_timer();
    mmi_idle_restart_keypad_lock_timer();
    return MMI_TRUE;
}

#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__


/*****************************************************************************
 * FUNCTION
 *  category33_pen_up_handler
 * DESCRIPTION
 *  pen up handler
 * PARAMETERS
 *  point       [IN]        pen up handler
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category33_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, index;
    MMI_BOOL ret = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_idle_touch_screen_shortcut_translate_pen_position(pos_x, pos_y, &index);
    if (index >= 0 && index < MAX_IDLE_SCREEN_SHORTCUTS)
    {
        gui_idle_touch_screen_display_shorcut_item(index);
        if (!touch_idle_screen_highlight_changed)
        {
            if (touch_idle_shortcuts[index].entryfn)
            {
                touch_idle_shortcuts[index].entryfn();
            }
        }
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  category33_pen_move_handler
 * DESCRIPTION
 *  pen move handler
 * PARAMETERS
 *  point       [IN]       pen move position 
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category33_pen_move_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, index;
    MMI_BOOL ret = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_idle_touch_screen_shortcut_translate_pen_position(pos_x, pos_y, &index);
    if (index != touch_idle_screen_highlighted_shortcut)
    {
        touch_idle_screen_highlight_changed = 1;
        /* Unpressed Image */
        gui_idle_touch_screen_display_shorcut_item(touch_idle_screen_highlighted_shortcut);
    }
    if (index >= 0 && index < MAX_IDLE_SCREEN_SHORTCUTS)
    {
        touch_idle_screen_highlighted_shortcut = index;
        /* Pressed Image */
        gui_idle_touch_screen_display_pressed_shorcut_item(index);
    }
    return ret;
}
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  cat33_hide_lsk
 * DESCRIPTION
 *  category 33 hide left softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_hide_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(
        MMI_softkeys[MMI_LEFT_SOFTKEY].x,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y,
        MMI_softkeys[MMI_LEFT_SOFTKEY].x + MMI_softkeys[MMI_LEFT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y + MMI_softkeys[MMI_LEFT_SOFTKEY].height - 1);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(
        MMI_softkeys[MMI_LEFT_SOFTKEY].x,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y,
        MMI_softkeys[MMI_LEFT_SOFTKEY].x + MMI_softkeys[MMI_LEFT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y + MMI_softkeys[MMI_LEFT_SOFTKEY].height - 1,
        GDI_COLOR_TRANSPARENT);
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  cat33_hide_rsk
 * DESCRIPTION
 *  category 33 hide right softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_hide_rsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x + MMI_softkeys[MMI_RIGHT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y + MMI_softkeys[MMI_RIGHT_SOFTKEY].height - 1);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x + MMI_softkeys[MMI_RIGHT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y + MMI_softkeys[MMI_RIGHT_SOFTKEY].height - 1,
        GDI_COLOR_TRANSPARENT);
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gdi_layer_pop_clip();
}

#ifdef __MMI_WGUI_CSK_ENABLE__


/*****************************************************************************
 * FUNCTION
 *  cat33_hide_csk
 * DESCRIPTION
 *  category 33 hide center softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_hide_csk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(
        MMI_softkeys[MMI_CENTER_SOFTKEY].x,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y,
        MMI_softkeys[MMI_CENTER_SOFTKEY].x + MMI_softkeys[MMI_CENTER_SOFTKEY].width - 1,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y + MMI_softkeys[MMI_CENTER_SOFTKEY].height - 1);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(
        MMI_softkeys[MMI_CENTER_SOFTKEY].x,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y,
        MMI_softkeys[MMI_CENTER_SOFTKEY].x + MMI_softkeys[MMI_CENTER_SOFTKEY].width - 1,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y + MMI_softkeys[MMI_CENTER_SOFTKEY].height - 1,
        GDI_COLOR_TRANSPARENT);
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gdi_layer_pop_clip();
}
#endif /* __MMI_WGUI_CSK_ENABLE__ */ 


/*****************************************************************************
 * FUNCTION
 *  ShowCategory33Screen_ext
 * DESCRIPTION
 *  Displays the Idle screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory33Screen_ext(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 status_bar1_y1;
    S32 status_bar1_y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    GDI_LOCK;
    gui_lock_double_buffer();

    set_on_idlescreen(1);

#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    set_status_bar_at_bottom();
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */

    on_idle_screen = 1;
#ifdef __MMI_IDLE_FULL_SCREEN__
#if defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)
    disable_softkey_background();
#endif /* __MMI_MAINLCD_128X128__ || __MMI_MAINLCD_128X160__ */
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    cat33_frame_number = 0;
    MMI_menu_shortcut_number = -1;

    /* No need to set the default handlers for Left and Right Softkeys in case of
       Idlescreen Shortcuts. So passing the value 0 for string ID and icon ID. */
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (mmi_idle_is_display_touch_shortcuts() == MMI_FALSE)
    {
        change_left_softkey(left_softkey, left_softkey_icon);
        change_right_softkey(right_softkey, right_softkey_icon);
    }
    else
    {
        change_left_softkey(0, 0);
        change_right_softkey(0, 0);
    }
#else /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 

    SetupCategoryKeyHandlers();

    /* No need to register the hide functions for Left and Right Sofkeys
       when Idle Screen Shortcuts are present.   */
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if(mmi_idle_is_display_touch_shortcuts() == MMI_FALSE)
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    {
#if !defined(MT6205B) && !defined(MT6208) 
        {
            register_hide_left_softkey(cat33_hide_lsk);
            register_hide_right_softkey(cat33_hide_rsk);
#ifdef __MMI_WGUI_CSK_ENABLE__
            register_hide_softkey(cat33_hide_csk, MMI_CENTER_SOFTKEY);
#endif /* __MMI_WGUI_CSK_ENABLE__ */
        }
#else /* !defined(MT6205B) && !defined(MT6208) */
        {
            /* Because MT6205B does not have LCD layer support, clearing 
               softkey background requires redrawing wallpaper, which is 
               very slow */
            set_softkey_flags_on(UI_BUTTON_NO_SHIFT_BUTTON, MMI_LEFT_SOFTKEY);
            set_softkey_flags_on(UI_BUTTON_NO_SHIFT_BUTTON, MMI_RIGHT_SOFTKEY);
#ifdef __MMI_WGUI_CSK_ENABLE__
            set_softkey_flags_on(UI_BUTTON_NO_SHIFT_BUTTON, MMI_CENTER_SOFTKEY);
#endif /* __MMI_WGUI_CSK_ENABLE__ */
        }
#endif /* !defined(MT6205B) && !defined(MT6208) */
    }

    register_hide_status_icon_bar(0, UI_dummy_function);
    register_hide_status_icon_bar(1, UI_dummy_function);

#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    set_status_icon_bar_clip(
            0,
            0,
            UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height,
            UI_device_width - 1,
            UI_device_height - 1 - MMI_button_bar_height - 1);
#else /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    move_status_icons(0, 0, MMI_STATUS_BAR_IDLE_Y, UI_device_width - 1, MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y - 1);
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        status_bar1_y1 = MMI_status_bar_height + MMI_IDLESCREEN_BAR_HEIGHT + MMI_STATUS_BAR_IDLE_Y;
    }
    else
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    {
        status_bar1_y1 = MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y;
    }

#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (mmi_idle_is_display_touch_shortcuts() == MMI_TRUE)
    {
        status_bar1_y2 = UI_device_height - WGUI_TOUCH_IDLESCREEN_SHORTCUTS_HEIGHT - 2;
    }
    else
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    {
        status_bar1_y2 = UI_device_height - MMI_softkey_height - 2;
    }

#ifdef __MMI_UI_TECHNO_STATUS_ICON__
    set_status_icon_bar_clip(1, 0, 0, 0, 0);
    arrange_status_icons();
#else /* __MMI_UI_TECHNO_STATUS_ICON__ */ 
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    move_status_icons(1,
                      UI_device_width - MMI_IDLE_STRING_MARGIN_GAP,
                      MMI_status_bar_height,
                      UI_device_width - 1,
                      UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - (STATUS_ICON_Y_GAP << 1) - 1);
    arrange_status_icons();
#else /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
#ifdef __MMI_KLG__
    move_status_icons(1, UI_device_width - MMI_IDLE_STRING_MARGIN_GAP, status_bar1_y1, UI_device_width - 1, UI_device_height >> 1);
#else /* __MMI_KLG__ */
    move_status_icons(1, UI_device_width - MMI_IDLE_STRING_MARGIN_GAP, status_bar1_y1, UI_device_width - 1, status_bar1_y2);
#endif /* __MMI_KLG__ */
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
#endif /* __MMI_UI_TECHNO_STATUS_ICON__ */ 

    show_status_icon_bar(0);
    show_status_icon_bar(1);

    switch (idle_screen_type)
    {
        case NORMAL_IDLE_SCREEN:
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
            set_main_LCD_dt_date_hide_function(cat33_hide_date_display);
            analog_clock_initialize();
            set_main_LCD_dt_time_hide_function(dummy_dt_hide_function);
            set_main_LCD_day_hide_function(cat33_hide_day_string_display);
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(cat33_hide_time_display);
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
#if defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__)
            set_dt_display(DT_IDLE_SCREEN_2);
#else /* defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 
            set_dt_display(DT_IDLE_SCREEN);
#endif /* defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 
            break;

#ifdef __MMI_ANALOG_CLOCK__
        case ANALOG_IDLE_SCREEN:
            analog_clock_initialize();
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(cat33_analog_clock_hide_dt_display);
            set_dt_display(DT_ANALOG_CLOCK_SC);
            break;
#endif /* __MMI_ANALOG_CLOCK__ */ 

#ifdef __MMI_DIGITAL_CLOCK__
        case DIGITAL_IDLE_SCREEN:
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(cat33_digital_clock_hide_dt_display);
            set_dt_display(DT_DIGITAL_CLOCK_SC1);
            break;
#endif /* __MMI_DIGITAL_CLOCK__ */ 
    }

    gui_unlock_double_buffer();

#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    /* clear the memory of touch_idle_shortcuts when the Flight Mode is ON. */
    if (mmi_idle_is_display_touch_shortcuts() == MMI_TRUE)
    {
        setup_touch_idle_screen_shortcuts();
    }
    else
    {
        memset(touch_idle_shortcuts, 0, sizeof(idle_touch_screen_shortcut) * MAX_IDLE_SCREEN_SHORTCUTS);
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 

#if (defined __MMI_TOUCH_SCREEN__)
    wgui_register_category_screen_control_area_pen_handlers(category33_pen_down_handler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(category33_pen_repeat_handler, MMI_PEN_EVENT_REPEAT);
    /* In case of touch idle screen unlock creates problem TEMP ONLY, FIX LATER AFTER DISCUSSION WITH LEO */
#ifndef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    wgui_register_category_screen_control_area_pen_handlers(category33_pen_long_tap_handler, MMI_PEN_EVENT_LONG_TAP);
#else /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    /* remove the pen handler registration for UP and MOVE event, when the Flight
       Mode is ON. */
    if (mmi_idle_is_display_touch_shortcuts() == MMI_TRUE)
    {
        wgui_register_category_screen_control_area_pen_handlers(category33_pen_up_handler, MMI_PEN_EVENT_UP);
        wgui_register_category_screen_control_area_pen_handlers(category33_pen_move_handler, MMI_PEN_EVENT_MOVE);
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
#endif /* (defined __MMI_TOUCH_SCREEN__) */ 
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();
    GDI_UNLOCK;
}

#ifdef __MMI_ALPHA_BLENDING__

/*****************************************************************************
 * FUNCTION
 *  cat33_redraw_alpha_images
 * DESCRIPTION
 *  Redraw alpha images when wallpaper animation updates
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_redraw_alpha_images(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle base_layer;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    gdi_layer_get_base_handle(&base_layer);
    gdi_layer_push_and_set_active(base_layer);

    // TODO: redraw only if images contain alpha
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    /*
     * draw idle screen shortcuts
     */
    display_touch_idle_screen_shortcuts();
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    /* 
     * draw techno idlescreen bar (including clock)
     */
    gui_push_clip();
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + MMI_IDLESCREEN_BAR_HEIGHT - 1);
#ifndef __MMI_UI_TECHNO_STATUS_ICON__
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE) /* no idlescreen bar when data and time is off */
#endif /* __MMI_UI_TECHNO_STATUS_ICON__ */
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    }
    gui_pop_clip();

#ifdef __GDI_MEMORY_PROFILE_2__
    update_mainlcd_dt_display();
#else /* __GDI_MEMORY_PROFILE_2__ */
    show_main_LCD_dt_display();
#endif /* __GDI_MEMORY_PROFILE_2__ */

#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
}

#endif /* __MMI_ALPHA_BLENDING__ */

#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
void idle_text_change_processor(void)
{
    if (current_text_type == SIM1_TEXT_ON_IDLE)
    {
        current_text_type = SIM2_TEXT_ON_IDLE;
    }
    else
    {
        current_text_type = SIM1_TEXT_ON_IDLE;
    }
    gui_start_timer(5000, idle_text_change_processor);
    idle_screen_show_network_details();
}
#endif

/*****************************************************************************
 * FUNCTION
 *  ShowCategory33Screen
 * DESCRIPTION
 *  Show category 33 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory33Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    current_text_type = SIM1_TEXT_ON_IDLE;
    gui_start_timer(5000, idle_text_change_processor);
#endif

#ifdef __MMI_ALPHA_BLENDING__    
    dm_register_wallpaper_anim_update_callback(cat33_redraw_alpha_images);
#endif /* __MMI_ALPHA_BLENDING__ */

    ShowCategory33Screen_ext(
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        history_buffer);
    
    GDI_LOCK;
    
    ExitCategoryFunction = ExitCategory33Screen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    RedrawCategoryFunction = dm_redraw_category_screen;

    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY33_ID;
    dm_data.s32flags = 0;
#ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (mmi_idle_is_display_touch_shortcuts() == MMI_TRUE)
    {
        dm_data.s32flags |= DM_NO_SOFTKEY;
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(dm_category_33_controlled_area);
    dm_redraw_category_screen();
	
    GDI_UNLOCK;
}

extern void leave_idle_screen(void);


/*****************************************************************************
 * FUNCTION
 *  ExitCategory33Screen
 * DESCRIPTION
 *  Exits the Idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory33Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    gui_cancel_timer(idle_text_change_processor);
#endif
    leave_idle_screen();
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    reset_status_bar_at_bottom();
#endif 

    on_idle_screen = 0;
    set_on_idlescreen(0);

    if (extra_scrolling_text)
    {
        gui_scrolling_text_stop(extra_scrolling_text);
        extra_scrolling_text = NULL;
    }
    /* 110206 digital clock Start */
    extra_text_x1 = -1;
    extra_text_y1 = -1;
    extra_text_x2 = -1;
    extra_text_y2 = -1;
    /* 110206 digital clock End */

    gui_cancel_timer(cat33_animation_processor);
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
    close_status_icons();

    register_hide_status_icon_bar(1, MMI_dummy_function);
    close_main_LCD_dt_display();
    reset_softkeys();
    enable_softkey_background();
#ifdef __MMI_UI_TECHNO_STATUS_ICON__
    arrange_status_icons();
#endif 
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
#if defined(__MMI_KLG__)
    set_status_icon_bar_clip(
        1,
        UI_device_width - 16,
        MMI_status_bar_height,
        UI_device_width - 1,
        UI_device_height >> 1);
#else /* defined(__MMI_KLG__) */ 
    set_status_icon_bar_clip(
        1,
        UI_device_width - 16,
        MMI_status_bar_height,
        UI_device_width - 1,
        UI_device_height - MMI_softkey_height - 2);
#endif /* defined(__MMI_KLG__) */ 
    arrange_status_icons();
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    move_status_icons(0, 0, 0, UI_device_width - 1, MMI_status_bar_height - 1);
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
}


#ifdef __MMI_ANALOG_CLOCK__
gdi_handle cat86_anim_handle;


/*****************************************************************************
 * FUNCTION
 *  cat86_hide_analog_clock_display
 * DESCRIPTION
 *  hide function of analog clock of categor 86
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat86_hide_analog_clock_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 0;
    y1 = (MMI_title_y + MMI_title_height);
    x2 = UI_device_width - 1;
    y2 = UI_device_height - MMI_button_bar_height;
    gui_set_clip(x1, y1, x2, y2);

#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#else 
    gui_show_image(cat86_image_x, cat86_image_y, cat86_image);
#endif 

    redraw_status_icon_bar(1);
    if (display_network_name)
    {
        idle_screen_show_network_name();
    }
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate86CategoryControlArea
 * DESCRIPTION
 *  Draws the category86 category control area
 * PARAMETERS
 *  coordinate      [IN]     area to redraw
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate86CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RedrawCategory86Screen();
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory86Screen
 * DESCRIPTION
 *  Redraws the category86 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory86Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_main_LCD_dt_display();
    if (display_network_name)
    {
        idle_screen_show_network_name();
    }

}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory86Screen
 * DESCRIPTION
 *  Displays the Idle screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  img_id                  [IN]        background image ID
 *  network_string          [IN]        Service provider name
 *  history_buffer          [IN]        History buffer
 *  show_network_name       [IN]        If network name display on the screen
 * RETURNS
 *  void
 *****************************************************************************/
/* __CUSTPACK_MULTIBIN Calvin BEGIN */
void ShowCategory86Screen(U16 title, U16 title_icon, U16 left_softkey, U16 left_softkey_icon, U16 right_softkey, U16 right_softkey_icon, U16 img_id, U8 *network_string, U8 *history_buffer, U8 show_network_name)    /* 051305 Calvin modified */
/* __CUSTPACK_MULTIBIN Calvin END */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U16 btn_prev_item_id = 0, btn_next_item_id = 0; 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    UI_UNUSED_PARAMETER(network_string);
    gui_lock_double_buffer();

    MMI_menu_shortcut_number = -1;
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();
    wgui_softkey_set_filler_disabled(MMI_TRUE);

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);

    display_network_name = show_network_name;

    dm_add_image(get_image(img_id), NULL, NULL);
    wgui_set_wallpaper_on_bottom(MMI_TRUE);
    #ifndef __GDI_MEMORY_PROFILE_2__
    cat86_image_x = cat86_image_y = 0;
    cat86_image = get_image(img_id);
    #endif /* __GDI_MEMORY_PROFILE_2__ */

    /* check if the title bar buttons are enabled for the particular screen. */
    if (wgui_is_touch_title_bar_buttons())
    {
        btn_prev_item_id = dm_add_button(
                            NULL,
                            get_image(LEFT_RED_ARROW),
                            get_image(LEFT_RED_ARROW),
                            cat129_clear_icon_bg);
        btn_next_item_id = dm_add_button(
                            NULL,
                            get_image(RIGHT_RED_ARROW),
                            get_image(RIGHT_RED_ARROW),
                            cat129_clear_icon_bg);
        title_bg_id = IMAGE_VIEW_TITLEBAR_BG;
    }
    analog_clock_initialize();
    set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
    set_main_LCD_dt_time_hide_function(cat86_hide_analog_clock_display);
    set_dt_display(DT_ANALOG_CLOCK_SC);

    gui_unlock_double_buffer();

    ExitCategoryFunction = ExitCategory86Screen;
#if defined(__MMI_TOUCH_SCREEN__)
    if (wgui_is_touch_title_bar_buttons())
    {
        /* register the handler for pen event down istead of pen event up. */
        dm_register_button_functions(btn_prev_item_id, KEY_EVENT_UP, gMMI_touch_title_button1_down_handler);
        dm_register_button_functions(btn_next_item_id, KEY_EVENT_UP, gMMI_touch_title_button2_down_handler);
    }
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawCate86CategoryControlArea);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY86_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_data.s32flags |= DM_SET_AS_ABM_LAYER;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory86Screen
 * DESCRIPTION
 *  Exits the Idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory86Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
    register_hide_status_icon_bar(1, MMI_dummy_function);
    close_status_icons();
    close_main_LCD_dt_display();
    reset_softkeys();

    title_bg_id = 0;

    wgui_reset_touch_title_bar_buttons();

    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
}

#endif /* __MMI_ANALOG_CLOCK__ */ 
extern gdi_handle animation_handle;


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory106Screen
 * DESCRIPTION
 *  redraw category 106
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory106Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 SScallbackID;
    PU8 image;
    color c = gui_color(0, 0, 0);
    gdi_handle h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    c.alpha = 100;

    gui_lock_double_buffer();
    gui_reset_clip();
    clear_screen();
    gui_fill_rectangle(0, 0, UI_device_width - 1, UI_device_height - 1, c);
    if (ScreenSaverName == NULL)
    {
        wgui_show_animation();
    }
    else
    {
        S32 n_frames = 0;
        S32 width, height;
        GDI_RESULT ret;

        gdi_image_gif_get_frame_count_file((S8*) ScreenSaverName, &n_frames);
        gdi_image_get_dimension_file((S8*) ScreenSaverName, &width, &height);

        if (n_frames > 1)
        {
            ret = gdi_image_draw_animation_file(
                    (UI_device_width - width) >> 1,
                    (UI_device_height - height) >> 1,
                    (S8*) ScreenSaverName,
                    &h);
        }
        else
        {
            /* The orignal implementation seems just to fill whole screen */
            S32 disp_width = UI_device_width; 
            S32 disp_height = UI_device_height;

            S32 offset_x = 0, offset_y = 0;
            S32 img_width = 0, img_heigth = 0;

            gdi_image_get_dimension_file((S8*) ScreenSaverName, &img_width, &img_heigth);
            if ((disp_width >= img_width) && (disp_height >= img_heigth))
            {

                /* align preview window at the center of screen */
                offset_x = (disp_width - img_width) >> 1;
                offset_y = (disp_height - img_heigth) >> 1;
                ret = gdi_image_draw_file(offset_x, offset_y, (PS8) ScreenSaverName);
            }
            else
            {
                S32 resized_offset_x;
                S32 resized_offset_y;
                S32 resized_width;
                S32 resized_height;
                U16 img_type;

                gdi_image_util_fit_bbox(
                    disp_width,
                    disp_height,
                    img_width,
                    img_heigth,
                    &resized_offset_x,
                    &resized_offset_y,
                    &resized_width,
                    &resized_height);

                img_type = gdi_image_get_type_from_file((PS8) ScreenSaverName);
                if (img_type == GDI_IMAGE_TYPE_JPG_FILE)
                {
                    ret = gdi_image_draw_resized_file(
                            resized_offset_x,
                            resized_offset_y,
                            resized_width,
                            resized_height,
                            (PS8) ScreenSaverName);
                }
                else
                {
                    ret = gdi_image_draw_file(offset_x, offset_y, (PS8) ScreenSaverName);
                }
            }
        }

        if (ret < 0 && ret != GDI_GIF_ERR_OUT_OF_CLIP_REGION && ret != GDI_BMP_ERR_OUT_OF_CLIP_REGION)
        {
            PRINT_INFORMATION_2(MMI_TRACE_G7_MISC, "RedrawCategory106Screen():[$$$]ret:%d [$$$]\n", ret);
            SScallbackID = PhnsetScreenSaverBadFileCallBack();
            image = get_image((MMI_ID_TYPE) SScallbackID);
            gui_measure_image(image, &width, &height);
            gdi_image_draw_animation(
                (UI_device_width - width) >> 1,
                (UI_device_height - height) >> 1,
                image,
                &animation_handle);
        }
    }
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory106Screen
 * DESCRIPTION
 *  Shows an animated icon
 * PARAMETERS
 *  icon_screensaver        [IN]        screen saver image ID
 *  filename                [IN]        screen saver image file path
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory106Screen(U16 icon_screensaver, U8 *filename, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 screensaver_icon;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    entry_full_screen();
    gui_lock_double_buffer();
    clear_category_screen_key_handlers();
    screen_saver_type = NORMAL_SCREEN_SAVER;
    if (icon_screensaver != 0)
    {
        screensaver_icon = (PU8) get_image(icon_screensaver);
        wgui_set_animation((UI_device_width >> 1), (UI_device_height >> 1), icon_screensaver);
        ScreenSaverName = NULL;
    }
    else
    {
        ScreenSaverName = filename;
    }

    gui_unlock_double_buffer();
    ExitCategoryFunction = ExitCategory106Screen;
    RedrawCategoryFunction = RedrawCategory106Screen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    RedrawCategory106Screen();
}

/* MTK Leo end */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory106Screen
 * DESCRIPTION
 *  Exits the category106 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory106Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
    }
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
}



/*****************************************************************************
 * FUNCTION
 *  DrawCate130CategoryControlArea
 * DESCRIPTION
 *  Draws the category130 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate130CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory130Screen
 * DESCRIPTION
 *  Exits the category130 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory130Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    title_bg_id = 0;
    wgui_reset_touch_title_bar_buttons();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory130Screen
 * DESCRIPTION
 *  Displays the category130 screen,show system theme wallpaper
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory130Screen(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U16 btn_prev_item_id = 0, btn_next_item_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    MMI_menu_shortcut_number = -1;
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();
    wgui_softkey_set_filler_disabled(MMI_TRUE);

    MMI_title_string = (UI_string_type) title;
    MMI_title_icon = (PU8) get_image(title_icon);
    MMI_message_string = (UI_string_type) NULL;

    wgui_set_wallpaper_on_bottom(MMI_TRUE);

    /* check if the title bar buttons are enabled for the particular screen. */
    if (wgui_is_touch_title_bar_buttons())
    {
        btn_prev_item_id = dm_add_button(
                            NULL,
                            get_image(LEFT_RED_ARROW),
                            get_image(LEFT_RED_ARROW),
                            cat129_clear_icon_bg);
        btn_next_item_id = dm_add_button(
                            NULL,
                            get_image(RIGHT_RED_ARROW),
                            get_image(RIGHT_RED_ARROW),
                            cat129_clear_icon_bg);
        title_bg_id = IMAGE_VIEW_TITLEBAR_BG;   /* for showing different title bar. */
    }

    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SET_AS_ABM_LAYER;

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory130Screen;

#if defined(__MMI_TOUCH_SCREEN__)
    if (wgui_is_touch_title_bar_buttons())
    {
        /* register the handler for pen event down istead of pen event up */
        dm_register_button_functions(btn_prev_item_id, KEY_EVENT_UP, gMMI_touch_title_button1_down_handler);
        dm_register_button_functions(btn_next_item_id, KEY_EVENT_UP, gMMI_touch_title_button2_down_handler);
    }
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawCate130CategoryControlArea);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY130_ID;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


gdi_handle cat128_anim_handle;
/*****************************************************************************
 * FUNCTION
 *  category128_hide_dt_display
 * DESCRIPTION
 *  hide date function of category128
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void category128_hide_dt_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 0;
    x2 = UI_device_width - 1;
    y1 = MMI_title_y + MMI_title_height;
    y2 = UI_device_height - MMI_button_bar_height;
    gui_set_clip(x1, y1, x2, y2);

#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#else 
    gui_show_image(cat128_image_x, cat128_image_y, cat128_image);
#endif 

    if (status_icon)
    {
        redraw_status_icon_bar(1);
    }
    gui_reset_clip();
    if (display_network_name && (disp_network_screeen_saver == 1))
    {
        idle_screen_show_network_name();
    }
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate128CategoryControlArea
 * DESCRIPTION
 *  Draws the category128 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate128CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RedrawCategory128Screen();
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory128Screen
 * DESCRIPTION
 *  Redraws the category128 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory128Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_clip(0, (MMI_title_y + MMI_title_height), UI_device_width - 1, UI_device_height - MMI_button_bar_height);
    if (display_network_name && (disp_network_screeen_saver == 1))
    {
        idle_screen_show_network_name();
    }
    show_main_LCD_dt_display();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory128Screen
 * DESCRIPTION
 *  Exits the category128 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory128Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
    reset_softkeys();
    register_hide_status_icon_bar(1, MMI_dummy_function);
    close_status_icons();
    close_main_LCD_dt_display();
    reset_multiline_inputbox();

    title_bg_id = 0;
    wgui_reset_touch_title_bar_buttons();

#if 0//def __MMI_WALLPAPER_ON_BOTTOM__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory128Screen
 * DESCRIPTION
 *  Displays the Category128 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  screen_img              [IN]        Image id
 *  date_flag               [IN]        
 *  time_flag               [IN]        
 *  service_provider        [IN]        Service provider name id
 *  history_buffer          [IN]        History buffer
 *  show_network_name       [IN]        If network name display on the screen
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory128Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 screen_img,
        U8 date_flag,
        U8 time_flag,
        U8 service_provider,
        U8 *history_buffer,
        U8 show_network_name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U16 btn_prev_item_id = 0, btn_next_item_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gui_lock_double_buffer();
    MMI_menu_shortcut_number = -1;
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();
    wgui_softkey_set_filler_disabled(MMI_TRUE);

    display_network_name = show_network_name;

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);

#if 0//__MMI_WALLPAPER_ON_BOTTOM__
/* under construction !*/
/* under construction !*/
#else /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
    dm_add_image(get_image(screen_img), NULL, NULL);
    wgui_set_wallpaper_on_bottom(MMI_TRUE);
    #ifndef __GDI_MEMORY_PROFILE_2__
    cat128_image_x = cat128_image_y = 0;
    cat128_image = get_image(screen_img);
    #endif /* __GDI_MEMORY_PROFILE_2__ */
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 

    /* check if the title bar buttons are enabled for the particular screen. */
    if (wgui_is_touch_title_bar_buttons())
    {
        btn_prev_item_id = dm_add_button(
                            NULL,
                            get_image(LEFT_RED_ARROW),
                            get_image(LEFT_RED_ARROW),
                            cat129_clear_icon_bg);
        btn_next_item_id = dm_add_button(
                            NULL,
                            get_image(RIGHT_RED_ARROW),
                            get_image(RIGHT_RED_ARROW),
                            cat129_clear_icon_bg);
        title_bg_id = IMAGE_VIEW_TITLEBAR_BG;
    }

    set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
    set_main_LCD_dt_time_hide_function(category128_hide_dt_display);
    if (date_flag == 1 && time_flag == 1)
    {
        set_dt_display(DT_DIGITAL_CLOCK_SC1);
    }
    else if (date_flag == 1)
    {
        set_dt_display(DT_DIGITAL_CLOCK_SC2);
    }
    else if (time_flag == 1)
    {
        set_dt_display(DT_DIGITAL_CLOCK_SC3);
    }

    if (service_provider == 1)
    {
        disp_network_screeen_saver = 1;
    }
    else
    {
        disp_network_screeen_saver = 0;
    }

    gui_unlock_double_buffer();

    ExitCategoryFunction = ExitCategory128Screen;
#if defined(__MMI_TOUCH_SCREEN__)
    if (wgui_is_touch_title_bar_buttons())
    {
        /* register the handler for pen event down istead of pen event up. */
        dm_register_button_functions(btn_prev_item_id, KEY_EVENT_UP, gMMI_touch_title_button1_down_handler);
        dm_register_button_functions(btn_next_item_id, KEY_EVENT_UP, gMMI_touch_title_button2_down_handler);
    }
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawCate128CategoryControlArea);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY128_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_data.s32flags |= DM_SET_AS_ABM_LAYER;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory131Screen
 * DESCRIPTION
 *  Exits the category131 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory131Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
    close_main_LCD_dt_display();
}


/*****************************************************************************
 * FUNCTION
 *  cat131_hide_analog_clock_display
 * DESCRIPTION
 *  hide function of category131 for analog clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat131_hide_analog_clock_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 16;
    y1 = (MMI_title_y + MMI_title_height);
    x2 = UI_device_width - 16;
    y2 = UI_device_height - MMI_button_bar_height;
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
}


/*****************************************************************************
 * FUNCTION
 *  cat131_hide_digital_clock_display
 * DESCRIPTION
 *  hide function of category131 for digital  clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat131_hide_digital_clock_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 0;
    y1 = 0;
    x2 = UI_device_width - 1;
    y2 = UI_device_height - 1;
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory131Screen
 * DESCRIPTION
 *  show analog or digital clock screen saver depends icon_screensaver value
 * PARAMETERS
 *  icon_screensaver        [IN]        Id of the image
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory131Screen(U16 icon_screensaver, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    entry_full_screen();
    gui_lock_double_buffer();
    clear_category_screen_key_handlers();
    if (screen_saver_type == ANALOG_SCREEN_SAVER)
    {
    #ifdef __MMI_ANALOG_CLOCK__
        analog_clock_initialize();
        set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
        set_main_LCD_dt_time_hide_function(cat131_hide_analog_clock_display);
        set_dt_display(DT_ANALOG_CLOCK_SC);
#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__  
        dm_add_image(get_image(IMG_ID_DISPCHAR_ANALOG_CLK), NULL, NULL);
#endif
    #endif /* __MMI_ANALOG_CLOCK__ */ 
    }
    else if (screen_saver_type == DIGITAL_SCREEN_SAVER)
    {
    #ifdef __MMI_DIGITAL_CLOCK__
        set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
        set_main_LCD_dt_time_hide_function(cat131_hide_digital_clock_display);
        set_dt_display(DT_DIGITAL_CLOCK_SC1);
#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__  
        dm_add_image(get_image(IMG_ID_DISPCHAR_DIGITAL_CLK), NULL, NULL);
#endif
    #endif /* __MMI_DIGITAL_CLOCK__ */ 
    }
    gui_unlock_double_buffer();

    ExitCategoryFunction = ExitCategory131Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY131_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}

#ifdef __MMI_LCD_PARTIAL_ON__


/*****************************************************************************
 * FUNCTION
 *  Category161ChangeTime
 * DESCRIPTION
 *  change the time of category161
 * PARAMETERS
 *  t       [IN]        Time
 * RETURNS
 *  void
 *****************************************************************************/
void Category161ChangeTime(UI_time *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat161_time = *t;
}

#if defined(__MMI_MAINLCD_176X220__) || defined (__MMI_MAINLCD_240X320__) 
#define CAT161_ICON_GAP    (3)
#else 
#define CAT161_ICON_GAP    (2)
#endif 

extern stFontAttribute wgui_dialer_box_f1;


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory161Screen
 * DESCRIPTION
 *  Redraws the category161 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory161Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;
    S32 twidth, theight;
    S32 y_round, partial_on_height = UI_LCD_PARTIAL_ON_HEIGHT;
    S32 x1, x2, y1, y2, y2_last = 0;
    S32 text_x;
    S32 icon_width, icon_height;
    int icon_index, num_icon_displayed;
    U8 timestr[64];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();

#if defined(BLACK_BACKLIGHT)
    c.r = c.g = c.b = 0;
#elif defined(BLUE_BACKLIGHT)
    c.r = c.g = 0;
    c.b = 255;
#elif defined(WHITE_BACKLIGHT)
    c.r = c.g = c.b = 255;
#else 
    c.r = c.g = c.b = 255;
#endif 
    c.alpha = 100;

#ifndef WIN32
    y_round = lcd_partial_display_align_line(MAIN_LCD);
    if (y_round > 1 && (partial_on_height % y_round) != 0)
    {
        partial_on_height += (y_round - (partial_on_height % y_round));
    }
#endif /* WIN32 */ 

    y_round = UI_device_height / partial_on_height;

    x1 = 0;
    y1 = (cat161_time.nMin % y_round) * partial_on_height;
    x2 = UI_device_width - 1;
    y2 = y1 + partial_on_height - 1;
    if (cat161_last_y_offset >= 0 && cat161_last_y_offset != y1)
    {
        y2_last = cat161_last_y_offset + partial_on_height - 1;
    }

    /* Dialing font has only english characters */
    time_string(&cat161_time, (UI_string_type) timestr, DT_IDLE_SCREEN_ENGLISH_ONLY);

    gui_push_clip();
    gui_push_text_clip();

    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    gui_set_text_clip(0, 0, UI_device_width - 1, UI_device_height - 1);

    if (cat161_last_y_offset >= 0 && cat161_last_y_offset != y1)
    {
        gui_fill_rectangle(x1, cat161_last_y_offset, x2, y2_last, c);
    }
    gui_fill_rectangle(x1, y1, x2, y2, c);

    gui_set_font(&wgui_dialer_box_f1);
    gui_measure_string((UI_string_type) timestr, &twidth, &theight);
    text_x = (UI_device_width - twidth) >> 1;

    if (MMI_status_icons_partial_display_n_icons > 0)
    {
        gui_measure_image(MMI_status_icons[0].icon_data, &icon_width, &icon_height);
        if ((CAT161_ICON_GAP + (icon_width + CAT161_ICON_GAP) * MMI_status_icons_partial_display_n_icons)
            * 2 + twidth > UI_device_width)
        {
            /* Do not center the text */
            num_icon_displayed = (UI_device_width - twidth - (CAT161_ICON_GAP * 2)) / (icon_width + CAT161_ICON_GAP);
            if (num_icon_displayed > MMI_status_icons_partial_display_n_icons)
            {
                num_icon_displayed = MMI_status_icons_partial_display_n_icons;
            }
            text_x = CAT161_ICON_GAP + (icon_width + CAT161_ICON_GAP) * num_icon_displayed;
        }
        else
        {
            text_x = (UI_device_width - twidth) >> 1;
            num_icon_displayed = MMI_status_icons_partial_display_n_icons;
        }

        for (icon_index = 0; icon_index < num_icon_displayed; icon_index++)
        {
            if (icon_height > partial_on_height)
            {
                break;  /* Abnormal case */
            }

            gui_show_transparent_image(
                CAT161_ICON_GAP + (CAT161_ICON_GAP + icon_width) * icon_index,
                y1 + ((partial_on_height - icon_height) >> 1),
                MMI_status_icons[MMI_status_icons_list_partial_display[icon_index]].icon_data,
                0);
        }
    }

#if defined(BLACK_BACKLIGHT)
    gui_set_text_color(gui_color(255, 255, 255));
#else
    gui_set_text_color(gui_color(0, 0, 0));
#endif

    if (r2lMMIFlag)
    {
        gui_move_text_cursor((text_x + twidth - 1), y1 + ((partial_on_height - theight) >> 1));
    }
    else
    {
        gui_move_text_cursor(text_x, y1 + ((partial_on_height - theight) >> 1));
    }
    gui_print_text((UI_string_type) timestr);
    gui_set_font(&MMI_medium_font);

    gui_pop_text_clip();
    gui_pop_clip();

    gui_unlock_double_buffer();

    /* Try to reduce the BLT region in order to save computation power */
    if (cat161_last_y_offset == -1) /* First time */
    {
        gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
    }
    else
    {
        if (cat161_last_y_offset != y1)
        {
            gui_BLT_double_buffer(x1, cat161_last_y_offset, x2, y2_last);
        }
        gui_BLT_double_buffer(x1, y1, x2, y2);
    }
    cat161_last_y_offset = y1;

#ifndef WIN32
    lcd_partial_on(MAIN_LCD, y1, y2);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory161Screen
 * DESCRIPTION
 *  Displays the category161 screen
 * PARAMETERS
 *  t       [IN]        Time
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory161Screen(UI_time *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

    cat161_time = *t;
    cat161_last_y_offset = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(BLACK_BACKLIGHT)
    c.r = c.g = c.b = 0;
#elif defined(BLUE_BACKLIGHT)
    c.r = c.g = 0;
    c.b = 255;
#elif defined(WHITE_BACKLIGHT)
    c.r = c.g = c.b = 255;
#else 
    c.r = c.g = c.b = 255;
#endif 
    c.alpha = 100;

    entry_full_screen();

    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    /* Delay filling white until RedrawCategory161Screen. We do not redraw the whole screen for each update. */
    gui_fill_rectangle(0, 0, UI_device_width - 1, UI_device_height - 1, c);

    gui_pop_clip();
    gui_unlock_double_buffer();

    ExitCategoryFunction = ExitCategory161Screen;
    RedrawCategoryFunction = RedrawCategory161Screen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;

    RedrawCategory161Screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory161Screen
 * DESCRIPTION
 *  Exits the category161 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory161Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef WIN32
    lcd_partial_off(MAIN_LCD);
#endif 
    /* Because partial display is text on white background,
       it looks weird if new popup comes and we don't clear background here. */
#if defined(BLACK_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_BLACK);
#elif defined(BLUE_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_BLUE);
#elif defined(WHITE_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_WHITE);
#else
    gdi_layer_clear(GDI_COLOR_WHITE);
#endif

    leave_full_screen();

    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
}

#endif /* __MMI_LCD_PARTIAL_ON__ */ 


#ifdef __MMI_UI_ANIMATED_TITLE_EFFECT__
/*****************************************************************************
 * FUNCTION
 *  show_network_detail_on_animated_highlighter_on_idlescreen
 * DESCRIPTION
 *  Handle title text on idlescreen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_network_detail_on_animated_highlighter_on_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    {
        idle_screen_show_network_details();
    }
}

#endif /* __MMI_UI_ANIMATED_TITLE_EFFECT__ */ 

