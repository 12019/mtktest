/*******************************************************************************
*  Modification Notice:
*  --------------------------
*  This software is modified by MediaTek Inc. and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*******************************************************************************/


 /*******************************************************************************
 * Filename:
 * ---------
 *   l1_types.h
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *   Layer1 global types
 *
 * Author:
 * -------
 * -------
 * -------
 *
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 *******************************************************************************/

/******************************************************************************
 *
 *  File:            /MTKteam/source/gprsmtk/l1/generic/SCCS/s.l1_types.h
 *  -----
 *
 *  SCCS Version:    2.22
 *  -------------
 *
 *  Copyright Statement:
 *  --------------------
 *  This software is protected by Copyright and the information contained
 *  herein is confidential. The software may not be copied and the information
 *  contained herein may not be used or disclosed except with the written
 *  permission of Communications Consultants Worldwide Limited (C) 2001
 *
 *  Project:
 *  --------
 *
 *  Software Unit:  Layer1 global types.
 *  --------------
 *
 *  Description:
 *  ------------
 *
 *
 *  Modification History:
 *  ---------------------
 *  Date       Vers  Auth  Details
 *  ----       ----  ----  -------
 *  28-Mar-01  2.1   VKL   Initial version.
 *  17-Apr-01  2.2   VKL   added L1SCModeScan and L1SCModeAccess
 *  27-Apr-01  2.3   VKL   Changed timing advance from int8 to uint8 for GSM400
 *                         Extended RxData (member of Report) structure so
 *                         it can contain up to 4 blocks with a size suitable
 *                         for GPRS.
 *                         Added frequency error fields to RxData.
 *                         Remove usedTxPower firld from ReportPeriodData
 *                         (member of report)
 *  01-May-01  2.4   VKL   Add TimeSlotMask
 *                         Add report type for PDTCh
 *                         Add data structures for TBF
 *  21-May-01  2.5   VKL   added new report types
 *                         added type Measurements for power measurement manager
 *                         added usf to RxSlotData
 *                         removed scan list from ReportPeriodData
 *                         removed measurementCount from PowerScanData
 *                         added SurroundMeasurmentData and InterferenceData
 *                          to ReportData
 *  15-Jul-01  2.6   VKL   Changed comments
 *                         Added TSC and PowerControlLevel types
 *                         Added ReportPeriodLock type
 *                         Add FrequencyBand enum
 *                         Removed PChMode enum
 *                         Changed TChMode params for half rate and 14400 data
 *                         Added new report types
 *                         Changed RxSlotData to save memory
 *                         Changed monitoring values in RxData
 *                         Added layer1 internal fields some report data
 *                         Added TxData structure
 *                         Renamed some fields
 *                         Changed data structures dealing with TBF and MAC
 *  08-Aug-01  2.7   VKL   RxData structure changed so power of bursts is
 *                         reported separately for each burst
 *                         RxData structure field errorSumCount replaces
 *                         frequencyErrorCount and ebitTimingErrorCount
 *                         RxData structure field quality moved to RxSlotData
 *                         RxData structure got new layer1 internal fields
 *                         Added MeasurementMapping structure to
 *                         MACDownlinkParams
 *                         Added field txPower to PacketBlockSpec
 *                         Added field mode to PacketUplinkSpec
 *  16-Aug-01  2.7   SGB   Add fcb_ok to SCH struct
 *  02-Sep-01  2.8   VKL   Remove ReportPowerMeasurement, add new report types
 *                         move CodingScheme enumeration, add powerCount field,
 *                         frameNumber and arfcn field to RxData structure
 *                         Add blockCount, blockData and codingScheme fields
 *                         to TxData structure, add DChData structure
 *                         add dtxUsed field, dch field to ReportData structure
 *                         add frameOffset and ebitOffset fields to DChParams
 *                         remove expectedRxPower field from SurroundBS structure
 *                         change size of bitmap in MACFixedUplinkParams structure
 *                         add timingAdvance field to PacketUplinkSpec structure
 * 03-Sep-01   2.09  SGB   Fix merge errors
 * 04-Sep-01   2.10  APB   Fix merge errors
 * 12-Sep-01   2.11  VKL   Add ReportHoppingSequenceSet, add useCount field to
 *                         HoppingSequence structure, rearrange field in Report
 *                         structure so data field is at the end
 * 13-Sep-01   2.12  VKL   Add ReportNPBCCh
 * 26-Sep-01   2.13  APB   Predict volker's additions of L1SCModePacketIdle,
 *                         and L1SCModePacketTransfer definitions
 * 26-Sep-01   2.14  VKL   Add ReportPollResp
 *                         Remove count field from PowerScanResults
 *                         Remove nextSession field from MeasurementStruct
 *                         Add channelMode field to RxData
 *                         Add hs field to ReportData
 *                         Add debug field needToCallMonitorReport to Report
 * 01-Oct-01   2.15  VKL   Replace 'quality' field in RxSlotData by 'bitCount'
 *                         and 'bitErrorCount'
 * 04-Oct-01   2.16  VKL   Add bsTimingOffset to SChData
 * 09-Oct-01   2.17  VKL   Add new fields used by AGC
 * 10-Oct-01   2.18  VKL   Add per cell AFC support
 * 18-Oct-01   2.20  APB   Add DChDataMode type, in anticipation of VK vhange
 * 26-Oct-01   2.21  VKL   Add types for surround cell engine.
 *                         Add SurroundReportBestSix and associated data structure
 * 01-Nov-01   2.22  VKL   Add pbcchExists field to TBFParams.
 * 06-Nov-01   2.23  VKL   Add new types and enums for NC and ext measurements
 * 08-Nov-01   2.24  VKL   Add structure for extended measurement report
 *                         Fixed typos
 *  09-Oct-01  2.25  VKL   Use L1_SURROUND_MAX_CELLS for arrays dealing with
 *                          BA lists
 *                         Change report periods in SuroundNCMeasParams to
 *                          use encoded value
 *                         Remove BTSPowerControlModePCCCh
 *                         Add hardwareUnavailable flag to SChData
 *  17-Nov-01  2.22  VKL   Define new data structures and extend report for AGC
 *  21-Nov-01  2.23  VKL   Remove frequencyErrorSum from RxData
 *                         Add layer1 internal fields to report
 *  28-Nov-01  2.24  SY    Add TimeStamp from l1_core_Private.h and revise AFCParams
 *  04-Dec-01  2.27  VKL   Add arfcn to L1I_AllocRxReport()
 *                         Add L1I_AllocMultislotRxReport()
 *                         L1I_PDTChStop() now always fully stops PDTCh and
 *                          add L1I_PDTChRestart() instead.
 *                         Add L1T_CalcBlockPower()
 *                         Change monitoring interface
 *
 *****************************************************************************/

#ifndef l1_generic_l1_types_h
#define l1_generic_l1_types_h

/*
@doc BBREF COREREF
*/
#include "..\l1d\l1d_cid.h"

#include "kal_release.h"
#include "mph_types.h"

typedef kal_int8 int8;
typedef kal_int16 int16;
typedef kal_int32 int32;
typedef kal_int32 intx;
typedef kal_uint8 uint8;
typedef kal_uint16 uint16;
typedef kal_uint32 uint32;
typedef kal_uint32 uintx;
typedef kal_bool  bool;

//enum { false, true };
#define false KAL_FALSE
#define true KAL_TRUE


/* --- GSM primitive types ------------------------------------------------- */

typedef int32  PowerSum32;
typedef int8   TID;
typedef int16  Gain; /* in 0.125 dB *//* !!important: please update the copy in m12194.c */
typedef int16  GainSum; /* in dBm, used to do calculations */
typedef uint32 TimeStamp; /* redefine in l1-CORE_PRIVATE.H */

/* --- enumerated types ---------------------------------------------------- */

typedef enum
{
   PBCChPriorityLow,
   PBCChPriorityMid,
   PBCChPriorityHigh
} PBCChPriority;

typedef enum
{
   NBCChPriorityNull,
   NBCChPriorityLow,
#ifdef __GEMINI__
   NBCChPriorityHigh,
#endif
   NBCChPriorityTop
} NBCChPriority;

typedef enum
{
   FrequencyBand400,
   FrequencyBand850,
   FrequencyBand900,
   FrequencyBand1800,
   FrequencyBand1900,

   FrequencyBandCount
} FrequencyBand;

/*
@enum ReportType | Type of a report.
*/
typedef enum
{
   ReportNone,             /* @emem No valid report. */
   ReportReportPeriodDone, /* @emem End of report period. */
   ReportPowerScanDone,    /* @emem Power scan results. */
   ReportFCCh,             /* @emem FCCh result. */
   ReportSCh,              /* @emem SCh result. */
   ReportPCh,              /* @emem PCh block received. */
   ReportBCCh,             /* @emem BCCh block received. */
   ReportNBCCh,            /* @emem BCCh block on neighbour base station received. */
   ReportNBCChSC,          /* @emem BCCh block on neighbour base station received, L1C/SC internal */
   ReportAGCh,             /* @emem AGCh block received. */
   ReportRACh,
   ReportSDCCh,            /* @emem SDCCh block received. */
   ReportSACChC,           /* @emem SACCh/C block received */
   ReportTCh,              /* @emem TCh or FACCh block received */
   ReportSACChT,           /* @emem SACCh/T block received */
   ReportCBCh,             /* @emem CBCh block received */
   ReportPPCh,
   ReportPAGCh,            /* @emem PAGCh block received. */
   ReportPBCCh,
   ReportNPBCCh,
   ReportPDTCh,
   ReportPTCCh,
   ReportPRACh,
   ReportDChStarted,
   ReportDChStopped,
   ReportInterference,
   ReportSurroundMeasurement,
   ReportExtendedMeasurement,
   ReportSACChTx,
   ReportCChTx,
   ReportHoppingSequenceSet,
   ReportPollResp,
   ReportSurroundRLA,
   ReportNCReportingPeriod,
   ReportSingleDL,
   ReportSingleULWithoutTBF,
   ReportSingleULTwoPhase,
   ReportPACCh,
   ReportPDTChConflict,
   ReportTBFStarted,
   ReportTBFStopped,
   ReportRepeatAllocation,
   ReportHoppingSequenceFree,
   ReportDChAfc,
   ReportReset,   
   ReportTickLapdm,
   ReportPeek, //SM_WAKEUP_COMPENSATION
#ifdef __GEMINI__
   ReportPChSharing,   
   ReportPChConflict,
   ReportBCChConflict,
   ReportGemini,
   ReportReportPeriodDone_2 =    ReportGemini + ReportReportPeriodDone,                   
   ReportPowerScanDone_2 =       ReportGemini + ReportPowerScanDone,                      
   ReportFCCh_2 =                ReportGemini + ReportFCCh,                               
   ReportSCh_2 =                 ReportGemini + ReportSCh,                                
   ReportPCh_2 =                 ReportGemini + ReportPCh,                                
   ReportBCCh_2 =                ReportGemini + ReportBCCh,                               
   ReportNBCCh_2 =               ReportGemini + ReportNBCCh,                              
   ReportNBCChSC_2 =             ReportGemini + ReportNBCChSC,                            
   ReportAGCh_2 =                ReportGemini + ReportAGCh,                               
   ReportRACh_2 =                ReportGemini + ReportRACh,                               
   ReportSDCCh_2 =               ReportGemini + ReportSDCCh,                              
   ReportSACChC_2 =              ReportGemini + ReportSACChC,                             
   ReportTCh_2 =                 ReportGemini + ReportTCh,                                
   ReportSACChT_2 =              ReportGemini + ReportSACChT,                             
   ReportCBCh_2 =                ReportGemini + ReportCBCh,                               
   ReportPPCh_2 =                ReportGemini + ReportPPCh,                               
   ReportPAGCh_2 =               ReportGemini + ReportPAGCh,                              
   ReportPBCCh_2 =               ReportGemini + ReportPBCCh,                              
   ReportNPBCCh_2 =              ReportGemini + ReportNPBCCh,                             
   ReportPDTCh_2 =               ReportGemini + ReportPDTCh,                              
   ReportPTCCh_2 =               ReportGemini + ReportPTCCh,                              
   ReportPRACh_2 =               ReportGemini + ReportPRACh,                              
   ReportDChStarted_2 =          ReportGemini + ReportDChStarted,                         
   ReportDChStopped_2 =          ReportGemini + ReportDChStopped,                         
   ReportInterference_2 =        ReportGemini + ReportInterference,                       
   ReportSurroundMeasurement_2 = ReportGemini + ReportSurroundMeasurement,                
   ReportExtendedMeasurement_2 = ReportGemini + ReportExtendedMeasurement,                
   ReportSACChTx_2 =             ReportGemini + ReportSACChTx,                            
   ReportCChTx_2 =               ReportGemini + ReportCChTx,                              
   ReportHoppingSequenceSet_2 =  ReportGemini + ReportHoppingSequenceSet,                 
   ReportPollResp_2 =            ReportGemini + ReportPollResp,                           
   ReportSurroundRLA_2 =         ReportGemini + ReportSurroundRLA,                        
   ReportNCReportingPeriod_2 =   ReportGemini + ReportNCReportingPeriod,                  
   ReportSingleDL_2 =            ReportGemini + ReportSingleDL,                           
   ReportSingleULWithoutTBF_2 =  ReportGemini + ReportSingleULWithoutTBF,                 
   ReportSingleULTwoPhase_2 =    ReportGemini + ReportSingleULTwoPhase,                   
   ReportPACCh_2 =               ReportGemini + ReportPACCh,                              
   ReportPDTChConflict_2 =       ReportGemini + ReportPDTChConflict,                      
   ReportTBFStarted_2 =          ReportGemini + ReportTBFStarted,                         
   ReportTBFStopped_2 =          ReportGemini + ReportTBFStopped,                         
   ReportRepeatAllocation_2 =    ReportGemini + ReportRepeatAllocation,                   
   ReportHoppingSequenceFree_2 = ReportGemini + ReportHoppingSequenceFree,                
   ReportDChAfc_2 =              ReportGemini + ReportDChAfc,                             
   ReportReset_2 =               ReportGemini + ReportReset,                               
   ReportTickLapdm_2 =           ReportGemini + ReportTickLapdm,                          
   ReportPChSharing_2 = 			ReportGemini + ReportPChSharing,
   ReportPChConflict_2 = 			ReportGemini + ReportPChConflict,
   ReportBCChConflict_2 = 			ReportGemini + ReportBCChConflict,
   ReportPeek_2      =           ReportGemini + ReportPeek, //SM_WAKEUP_COMPENSATION
#endif /* __GEMINI__ */

   ReportEnd               /* @emem No valid report. Marks end of <t ReportType> enumeration */
} ReportType;

/*
@enum AMRFrameType | AMR Frame Type.
*/
typedef enum
{
/* AMR Frame Type used by L1D. */   

   AMRFrame_FACCH,      /* @emem FACCH      */
   AMRFrame_RATSCCH,    /* @emem RATSCCH    */
   AMRFrame_SID_FIRST,  /* @emem SID FIRST  */
   AMRFrame_SID_UPDATE, /* @emem SID UPDATE */
   AMRFrame_ONSET,      /* @emem ONSET      */
   AMRFrame_NO_DATA,    /* @emem No Data    */

   AMRFrame_AFS1220,    /* @emem AMR Full rate speech 12.2k */
   AMRFrame_AFS1020,    /* @emem AMR Full rate speech 10.2k */
   AMRFrame_AFS795,     /* @emem AMR Full rate speech 7.95k */
   AMRFrame_AFS740,     /* @emem AMR Full rate speech 7.4k  */
   AMRFrame_AFS670,     /* @emem AMR Full rate speech 6.7k  */
   AMRFrame_AFS590,     /* @emem AMR Full rate speech 5.9k  */
   AMRFrame_AFS515,     /* @emem AMR Full rate speech 5.15k */
   AMRFrame_AFS475,     /* @emem AMR Full rate speech 4.75k */

   AMRFrame_AHS795,     /* @emem AMR Half rate speech 7.95k */
   AMRFrame_AHS740,     /* @emem AMR Half rate speech 7.4k  */
   AMRFrame_AHS670,     /* @emem AMR Half rate speech 6.7k  */
   AMRFrame_AHS590,     /* @emem AMR Half rate speech 5.9k  */
   AMRFrame_AHS515,     /* @emem AMR Half rate speech 5.15k */
   AMRFrame_AHS475      /* @emem AMR Half rate speech 4.75k */
  
} AMRFrameType;

/* R99, TBF_EST */
typedef enum
{
   SingleBlockTypeSingle,  /* send 1 block and monitor PACCh */
   SingleBlockTypeMulti,  /* send 2 blocks and monitor PACCh */
   SingleBlockTypeNone    /* just monitor PACCh */
} SingleBlockType;

typedef enum
{
   None,
   NonSyncHandover,
   SyncHandover
} HandoverState;

/* --- structure types ----------------------------------------------------- */

typedef struct
{
   int32       k_factor; /* K factor * 2^12 */
   int32       phi_factor[1];
   TimeStamp   lastFn;
   int16       DacValue; /* TCVCXO quantisation step */
   bool        fcb_ok;

#if IS_EDGE_CHIP_MT6229_AND_LATTER_VERSION
   /* Variable for the TX outer loop */
   int16       Tx_DacValue;   /* TX TCVCXO quantisation step    */
   int16       Tx_acc_err;    /* Tx Accumulated frequency error */
   int16       Tx_Rx_Freqerr; /* Freq error between Rx/Tx       */
   bool        TX_Loop_Enable;/* Dual loop enable switch        */
#endif

#ifdef   AFC_TC
/*XO*/ int32  lastCompensatePhi;
#endif

#ifdef __GEMINI__
    bool is_SIM2;
#endif
} AfcParams;

/*
@struct Time | GSM time.
*/
typedef struct
{
   FrameNumber frame; /* @field Frame number */
   intx        ebits; /* @field Eighth bits */
} Time;

/*
@struct HoppingSequence | Hopping sequence definition.
*/
typedef struct
{
   intx  hsn;         /* @field Hopping sequence number. */
   intx  maio;        /* @field Mobile allocation index offset. */
   intx  arfcnCount;  /* @field Number of frequencies in <e HoppingSequence.arfcn>. */
   ARFCN arfcn[ 64 ]; /* @field List of frequencies. */

   int8  useCount;    /* layer1 core internal use */
   Power maxTxPwr;    /* L1A set max Tx power for each band */
#ifdef __GEMINI__
	bool  is_SIM2;
#endif
} HoppingSequence;

typedef enum
{
   L1SCModeReset,
   L1SCModeNull,
   L1SCModeScan = L1SCModeNull, /* identical behaviour */
   L1SCModeIdle,
   L1SCModeAccess,
   L1SCModeDediSDCCh,
   L1SCModeDediTCh
#ifdef __PS_SERVICE__
   ,L1SCModePacketIdle,
   L1SCModePacketAccess,
   L1SCModePacketTransfer
#endif
} SurroundMode;

typedef struct
{
   intx               baListId;
   uint8             arfcnCount;
   ARFCN           arfcn[L1_SURROUND_MAX_CELLS];
} SurroundBAList;

typedef struct
{
    ARFCN       arfcn;
    bool          bsicKnown;
    FrameNumber  frameOffset;
    intx          ebitOffset;
    bool          needRetry;
    bool          retry_FB_SB;
#if 1 //__NORMAL_NW_SEARCH__    
    bool          FreqCorrect;
#endif
} ScCellBsicInfo;


typedef struct
{
    ScCellBsicInfo        cell[L1_SURROUND_MAX_CELLS];
    uint8          cellCount;
} SCBsicInfo;

typedef struct
{
    ARFCN        cell[L1_SURROUND_MAX_CELLS];
    uint8          cellCount;
} SCBsicStopInfo;

typedef struct
{
    ARFCN       arfcn;
    bool          bsicKnown;
    FrameNumber  frameOffset;
    intx          ebitOffset;
    BSIC         bsic;
    uint16        bcchMask;
    bool          needRetry;
    bool          is_prior_to_acquire;
    bool         use_priority_index_order;
    uint16        priority_index;
} ScCellBcchInfo;

typedef struct
{
    ScCellBcchInfo        cell[ 6 ];
    uint8          cellCount;
} SCBcchInfo;

typedef struct
{
#if 1 //__NORMAL_NW_SEARCH__	
    bool          manual;
#endif    
    ARFCN        cell[ 6 ];
    uint8          cellCount;
} SCBcchStopInfo;


typedef struct
{
   intx reportingPeriodI; /* 0: 0.48 sec, 1: 0.96 sec, ..., 7 = 61.44 sec */
   intx reportingPeriodT; /* 0: 0.48 sec, 1: 0.96 sec, ..., 7 = 61.44 sec */
} SuroundNCMeasParams;


typedef struct
{
   uint8                arfcnCount;
   ARFCN              arfcn[L1_SURROUND_MAX_CELLS];
} SuroundExtMeasParams;

/*
 * Example for lag in SurroundBS
 *
 * neighbour BS
 * . . | . . . 7 . . . | . . . 8 . . . | . . . 9 . . . |
 * current BS
 * | . . . 8 . . . | . . . 9 . . . | . . . 10. . . | . .
 *
 * lag.frame   = 1
 * lag.ebits = 2500
 */
/* --- calculation of RLA_C ------------------------------------------------- */

typedef struct
{
   PowerSum32 sum;
   uint8    sumCount;
   Power     last5[5];
   uint8    last5Next;
   bool     last5Full;
   bool     last1;
} PowerAverager;

typedef struct
{
   ARFCN      arfcn;
   AfcParams  afc;
   Power      rxPower;         /* last averaged power level */
   Power      ncPower;         /* last averaged power level for NC measurements */
   uint8       ncCount;
   /* used to calculate the average power for the cell */
   PowerAverager avg;

   bool       inNewBAList;
#if 1 //__NORMAL_NW_SEARCH__
   bool       keep;        
#endif
   bool       newCell;
} SurroundBS;

typedef struct
{
   BTSPowerControlMode mode;
   bool                prModeA;
   intx                p0;
} BTSPowerControl;

/*
@struct PowerScanResults | Results of full power scan.
*/
typedef struct
{
   PowerSum power[ ARFCN_COUNT ]; /* @field Sum of power measurements for each arfcn */
} PowerScanResults;

/*
@struct MonitorResultItem | Partial results of current channel monitoring.
*/

typedef struct
{
   PowerSum32 powerSum;   /* @field Sum of power measurements in dBm */
   intx     powerCount; /* @field Number of measurements added. */
   intx     errorSum;   /* @field Number of bit errors. */
   intx     errorCount; /* @field Number of bits. */
   uint8     RxQual;
} MonitorResultItem;

#ifdef   __R99__  /* __R99__ */
typedef struct
{
   /* reported to upper layer */
   int8    meanBep;    /* mean BEP of a rp to report to upper layer, 5 bits */
   int8    cvBep;         /* CV BEP of a rp to report to upper layer, 3 bits */
   int8    nbrRcvdBlocks;     /* for NBR_RCVD_BLOCKS */
   PowerSum32 powerSumVal;   /* Sum of power measurements  to calculate RXLEV_VAL */

   /*  Below this line, L1C internal use */
   int16    meanBepCount;    /* count of meanBEP(block) */  
   int16    cvBepCount;         /* count of cvBEP(block), 
                                             different from meanBepCount because CV_BEP(block) from SACCh
                                             are excluded in enhanced meas report (05.02, 8.4.8.2) */  
   intx     meanBepSum;    /* sum of meanBEP(block) */   
   intx     cvBepSum;         /* sum of cvBEP(block) */
   intx     powerCountVal; /* number of measurements added, to calculate RXLEV_VAL, including SACCh */
} MonitorResultItemEnhanced;
#endif
/*
@struct MonitorResult | Results of current channel monitoring.
*/
typedef struct
{
   MonitorResultItem full; /* @field Results for all blocks. */
   MonitorResultItem sub;  /* @field Results for sub channel blocks. */
   TChMode           chMode;
   kal_int8          amrBadBlockCount; /* layer1 internal use */
#ifdef   __R99__ /* __R99__ */  
   MonitorResultItemEnhanced enhanced; /* for enhanced measurement*/
#endif   
} MonitorResult;

/*
@struct ScanItem | Per frequency information in <t ScanList>.
*/
typedef struct
{
   ARFCN    arfcn; /* @field The frequency. */
   PowerSum32 power; /* @field Sum of all power measurements (in dBm) for above frequency */
} ScanItem;

/*
@struct ScanList | List of neighbour ARFCNs and measurement results.
*/
typedef struct
{
   intx     baListId;                     /* @field BA list Id */
   intx     itemCount;                    /* @field Number of frequencies used. */
   intx     measurementCount;             /* @field Total number of measurements performed */
   ScanItem items[L1_SURROUND_MAX_CELLS]; /* @field Per frequency information */
} ScanList;

typedef struct
{
   bool  AMRConfigValid; /* 1 bits, to indicate whether the following 
                            AMR parameters are valid.Filled by L1A. */
   bool  ICMValid;       /* 1 bits, Initial Codec Mode Indicator. 
                            Filled by L1A. */ 
   uint8 ICM;            /* 2 bits, the initial codec mode is coded 
                            as in GSM05.09 sec 3.4.1. Filled by L1A. */
   uint8 ACS;            /* 8 bits, set of adaptive codec modes. 
                            Filled by L1A. */  
   uint8 CMIP;           /* 1 bits. Codec mode indication phase. 
                            Filled by L1C. 
                            
                            3GPP 05.09 / sec 3.2.1.3, at call set-up, after
                            successful handover and after a channel mode 
                            modify with consistent MUltirate IE, the default
                            phase (odd) shall be used in downlink direction.
                            
                            CMIP        even phase  odd phase
                            ==========  ==========  =========
                             0             CMI         CMC
                             1(default)    CMC         CMI     */                            
   uint8 THRESH1;        /* 6 bits. Filled by L1A. */ 
   uint8 HYST1;          /* 4 bits. Filled by L1A. */
   uint8 THRESH2;        /* 6 bits. Filled by L1A. */
   uint8 HYST2;          /* 4 bits. Filled by L1A. */ 
   uint8 THRESH3;        /* 6 bits. Filled by L1A. */
   uint8 HYST3;          /* 4 bits. Filled by L1A. */
   uint8 ConfigMask;     /* 1 bits. Filled by L1C. */
   uint8 THRESH_Valid;   /* 1 bits. Filled by L1A/L1C. */
} TChAMRConfig;
   
#define AMRConfigMask_DL_CMIP     0x01
#define AMRConfigMask_DL_THRESH   0x02   /* For both downlink THRESH and HYST. */
#define AMRConfigMask_DL_ACS      0x04   /* For both downlink ACS and ICM. */
#define AMRConfigMask_UL_ACS      0x08   /* For both uplink ACS and ICM. */
#define AMRConfigMask_ALL        (AMRConfigMask_DL_CMIP | AMRConfigMask_UL_ACS | AMRConfigMask_DL_ACS | AMRConfigMask_DL_THRESH)
#define AMRConfigMask_None        0x00   /* This means that the amrConfig is not valid.
                                            It shall be only set by L1I. */
                                            
typedef struct
{	
   bool          amrEnabled;       /* True if in AMR mode, false otherwise. 
                                      Set in L1C L1I_TimerTch. 
                                      Used in L1D module. */                   
   TChMode       channelMode;      /* Downlink TChMode (Useful for AMR). 
                                      Set by L1C. */ 
   AMRFrameType  FrameFormat;      /* Downlink FrameFormat (Useful for AMR). 
                                      Set by L1D. 
                                      Used in L1D QI module.*/                                        
   bool          isDTX;            /* Assigned by AGC module in afterBlock each RxBlock.
                                      Used in L1D QI module. */                                                               
   bool          mon_sub;          /* Reset by L1C and set by L1D.
                                      True if monitored to sub, false if monitored to full. */
   uint8         fnMod13;          /* Filled by L1C. */

#if IS_SAIC_CHIP_MT6223_AND_LATTER_VERSION
   bool          burst_IsSaicOn[4];     /* Used in L1D QI module.*/
   int32         burst_EQSoftSum[4];    /* Used in L1D QI module.*/   
#else   
   int16         burst_CI[4];      /* Used in L1D QI module.*/ 
   int16         burst_RNV[4];     /* Used in L1D QI module.*/
#endif
      
} AMRQICompensationData;

/*
@struct DChParams | Parameters for a DCh
*/
typedef struct
{
   int32             frameOffset;        /* @field Synchronisation frame offset */
   intx              ebitOffset;         /* @field Synchronisation eighth bit offset */
   LogChannel        log;                /* @field Type of DCh */
   ARFCN             arfcn;              /* @field C0 ARFCN BSIC of the base station */
   BSIC              bsic;               /* @field BSIC of the base station */
   TSC               tsc;                /* @field The training sequence code */
   HoppingSequence*  hs;                 /* @field The hopping sequence */
   TChMode           channelMode;        /* @field The main TCh channel mode */
   TChAMRConfig      amrConfig;          /* downlink AMR channel mode */  /*AMR_ENABLE*/
   SubChannel        subChannel;         /* @field The main channels sub channel number */
   bool              dtxAllowed;         /* @field DTX allowed flag
                                               @flag false | DTX not allowed.
                                               @flag true | DTX allowed. */
   TimeSlot          timeSlot;           /* @field The DCh timeslot */
   PowerControlLevel txPower;            /* @field The initial transmit power level as defined in 05.05/4.1.1 */
   TimingAdvance     timingAdvance;      /* @field Initial timing advance in bits */
   Power             powerdBm;           /* @field power in dBm */
   bool              powerControl;       /* @field Initial power control flag
                                               @flag false | base station does not use power
                                                     control during first reporting period.
                                               @flag true | base station uses power control
                                                     during first reporting period. */
   RAChData          rachData;           /* @field Data for RACh bursts during handover */
   intx              handoverRAChCount;  /* @field Number of RACh burst to be transmitted initially.
                                               @flag 0 | No handover.
                                               @flag 4 | Synchronous handover.
                                               @flag 32767 | Asynchronous handover. */
   bool              cipherEnable;       /* @field Ciphering enable flag
                                               @flag false | Ciphering disabled.
                                               @flag true | Ciphering enabled. */
   int8              cipherAlgorithm;    /* @field Cipher algorithm. Valid only if ciphering is enabled. */
   uint8             cipherKey[ 8 ];     /* @field Cipher key . Valid only if ciphering is enabled. */
} DChParams;

typedef enum
{
   UplinkAccessNone,
   UplinkAccessFixed,
   UplinkAccessDynamic,
   UplinkAccessExtendedDynamic
} UplinkAccessMode;

typedef struct
{
   TimeSlotMask       timeSlots;
   TFI                tfi;

#ifdef __EGPRS_MODE__
   int16             windowSize;
   bool              rlcMode;       // = 1 if ACK mode, =0 if UNACK mode
#endif
} MACDownlinkParams;

typedef struct
{
   TimeSlot           downlinkControlTimeSlot;
   uint8              bitmap[36]; /* one extra byte at the end allows for padding with zeros if
                                     bitmapSize is no multiple of the number of timeslots and
                                     blockPeriods == false */
   intx               bitmapSize;
   bool               blockPeriods;
} MACFixedUplinkParams;

typedef struct
{
   bool usfGranularity;
   USF  usf[8];
} MACDynamicUplinkParams;

typedef struct
{
   intx dummy;
} MACSingleUplinkParams;

typedef struct
{
   UplinkAccessMode          mode;
   TimeSlotMask              timeSlots;
   TFI                       tfi;
   union
   {
      MACFixedUplinkParams   fixed;
      MACDynamicUplinkParams dynamic;
      MACSingleUplinkParams  single;
   }                         data;
} MACUplinkParams;

typedef struct
{
   TimingAdvance     ta;          /* can be TimingAdvance_INVALID */
   int8              index;       /* can be -1 */
   TimeSlot          timeSlot;    /* valid if timingAdvanceIndex != -1 */
   int8              burstLength; /* Length of PTCCh/U access burst. Either 8 or 11 */
} PacketTimingAdvance;

typedef struct
{
   bool              valid;
   uint8             alpha;
   uint8             gamma[8];
} PowerControl;

typedef struct
{
   FrameNumber         startingTime; /* Frame number when to start the TBF. Relative to current BS. -1 means immediately. */
   TimeSlot            syncTimeSlot; /* The time slot to synchronise to. This should be chosen so it is equal to smallest timeslot number of all active PDTChs when the TBF is started. */
   HoppingSequence*    hoppingSequence;
   BSIC                bsic;         /* BSIC of the base station */
   TSC                 tsc;          /* training sequence code */
   PowerControl        powerControl;
   PacketTimingAdvance timingAdvance;

   BTSPowerControl     btsPowerControl;

   bool                downValid;
   MACDownlinkParams   down;

   bool                upValid;
   MACUplinkParams     up;

   bool                pbcchExists;
   uint8               assign_ref;   /* reference id used by L1A */

#ifdef __EGPRS_MODE__
   bool        tbfMode;                // =0 if in GPRS mode, =1 if in EGPRS mode
   bool        resetIR;                // =1 if RLC wants to reset IR memory          
#endif

} TBFParams;

typedef struct
{
   Power        txPower;
   uint8        bufferIndex;
} PacketBlockSpec;

typedef struct
{
   TimeSlotMask     timeSlots;
   TimingAdvance    timingAdvance;
   PacketBlockSpec  blocks[4];
} PacketUplinkSpec;

typedef struct
{
   TimeSlotMask timeSlots;
} PacketDownlinkSpec;

typedef struct
{
   PacketUplinkSpec   up;
   PacketDownlinkSpec down;
} PacketTransferSpec;

typedef enum
{
   DChDataModeTrans,
   DChDataModeFax1,
   DChDataModeFax2,
   DChDataModeNonTrans
} DChDataMode;

typedef struct MeasurementsStruct Measurements;
struct MeasurementsStruct
{
/* --- must be initialised by called of L1I_StartMeasurements() --- */

   /* not changed by measurement manager */

   ARFCN            ( *get )( Measurements* meas, int index );
   void             ( *put )( Measurements* meas, int index, Power power );
   void             ( *done )( Measurements* meas, intx measurementsDone );

   intx                indexCount;
   intx                measurementCount; /* number of measurements to be performed */

/* --- private data of measurement manager --- */

   intx                started;      /* total number of measurements started */
   intx                finished;     /* total number of measurements completed */
   intx                sessionLimit; /* total number of measurments to be done before session ends */
   intx                startIndex;
   intx                resultIndex;
   bool                is_stopped;
};

/*
(A) set by L1I_AllocRxReport()
(B) set by L1I_ReportRxBurstData()
(C) initialised by L1I_AllocRxReport(), updated by L1I_ReportRxBurstData()
(D) set by channel handler
(E) set by hardware driver
*/
/*
@struct RxSlotData | Report data for received block reporting.
*/

#if IS_EDGE_CHIP_MT6229_AND_LATTER_VERSION 
typedef struct
{
   BlockData*     data;    
   
   bool           ok;            /* for GSM, GPRS, EGPRS header part, use this field */
   bool           data1Ok;       /* for EGPRS data part, use this field
                                    when GSM, or type is CS1~4, this field has no meaning */
   bool           data2Ok;       /* for EGPRS data part of 2nd RLC blk, use this field
                                    when MCS type is not 7~9, this field has no meaning */
                                    
   USF            usf;           /* @field (E) Received USF */
   TimeSlot       timeSlot;      /* @field (E) Time slot number */
   CodingScheme   codingScheme;  /* @field (E) Coding scheme. */
   uint8          modScheme;     /* for results of blind detection, L1 internal use */
   int16          snrSum;        /* @field (C) Sum of SNR of all bursts */
   uint16         irDecision;      /* DSP DSP IR Decision */
   Power          power[4];      /* @field (B) Power for bursts in dBm */
   intx           powerCount;    /* @field (C) Number of burst in power[] */
   intx           bitErrorCount; /* @field (E) Sum of bit errors. */
   intx           bitCount;      /* @field (E) Sum of bits. */
   bool           discardPrevBitError; /* @field (E) Flag of discard previous bit error information */
   intx           timingErrorSum;      /* @field (C) Sum of timing errors of all bursts in good blocks in ebits 
                                          for GMSK only, L1 internal use */
   intx           timingErrorCnt;      /* @field (C) Number of values added in timingErrorSum
                                          for GMSK only, L1 internal use*/
   intx           epskTimingErrorSum;  /* @field (C) Sum of timing errors of all bursts in good blocks in ebits 
                                          for 8PSK only, L1 internal use */
   intx           epskTimingErrorCnt;  /* @field (C) Number of values added in timingErrorSum
                                          for 8PSK only, L1 internal use */
                                          
   intx           meanBep;             /* Mean_BEP(block), L1 internal use if not in EGPRS mode*/
   intx           cvBep;               /* CV_BEP(block), L1 internal use if not in EGPRS mode */
   
} RxSlotData;
#else /*IS_EDGE_CHIP_MT6229_AND_LATTER_VERSION*/
typedef struct
{
#ifdef __PS_SERVICE__
   BlockData data[ 54 ];    /* @field (E) Received block data. Invalid for speech block */
                            /* at beginning of this structure, make it pointer as even address,
                               help L1D to move data in word */
#else /*__PS_SERVICE__*/  
   BlockData data[ 38 ];    /* @field (E) Received block data. Invalid for speech block */
                            /* at beginning of this structure, make it pointer as even address,
                               help L1D to move data in word */

#endif   /*__PS_SERVICE__*/
   bool      ok;                  /* @field (E) Block status for the timeslot.
                                      @flag false | Block was bad. Data is invalid.
                                      @flag true | Block was OK. Data is valid. */
   USF       usf;                 /* @field (E) Received USF */
                                  
   Power     power[4];            /* @field (B) Power for bursts in dBm */
   intx      powerCount;          /* @field (C) Number of burst in power[] */
   intx      bitErrorCount;       /* @field (E) Sum of bit errors. */
   intx      bitCount;            /* @field (E) Sum of bits. */
   bool      discardPrevBitError; /* @field (E) Flag of discard previous bit error information */
   TimeSlot  timeSlot;            /* @field (E) Time slot number */
   CodingScheme codingScheme;     /* @field (E) Coding scheme. */
   int16     snrSum;              /* @field (C) Sum of SNR of all bursts */

   intx      timingErrorSum;      /* @field (C) Sum of timing errors of all bursts in good blocks in ebits */
   intx      timingErrorCnt;      /* @field (C) Number of values added in timingErrorSum */

   intx           meanBep;        /* Mean_BEP(block), L1 internal use if not in EGPRS mode*/
   intx           cvBep;          /* CV_BEP(block), L1 internal use if not in EGPRS mode */
} RxSlotData;
#endif   /*IS_EDGE_CHIP_MT6229_AND_LATTER_VERSION*/

/* Report forward declaration */
typedef struct Report Report;

/*
@struct RxData | Report data for received block reporting.
*/
typedef struct
{
   FrameNumber frameNumber;    /* @field (A) Frame number of the first burst of
                                             the block.                       */
   ARFCN       arfcn;          /* @field (A) BCCh carrier of base station
                                             sending this block.              */
   bool        isBCChBurst[4]; /* @field (B) true for each burst received on
                                             the BCCh carrier                 */
   int8        slotCount;      /* @field (A) Number of slots used. Always 1
                                             except for PDTCh                 */
#ifdef __PS_SERVICE__
   RxSlotData  slot[4];        /* @field     Data for receive timeslots       */
#else
   RxSlotData  slot[1];        /* @field     Data for receive timeslots       */
#endif   

   bool        isSID;         /* determined by L1D based on the decision of DSP */
   bool        isDTX;         /* determined in AGC*/
   
   bool        isFACCh;        /* @field (D) Valid only for ReportTCh. true if
                                             block is a FACCh block           */
   /*AMR_ENABLE*/
   bool        isRATSCCh;      /* @field (D) Valid only for ReportTCh. true if
                                             block is a AMR RATSCCh block           */
   bool        isCSD;          /* @field (D) Valid only for ReportTCh. true if
                                             block is a CSD block           */
   int8        tc;             /* @field (D) Valid only for ReportBCCh,
                                             ReportNBCCh, ReportCBCh. Value of
                                             TC of the received block
                                             ((FN/51)%8)                      */
   bool        extended;       /* @field (D) Valid only for ReportBCCh,
                                             ReportNBCCh, ReportCBCh, ReportPCh,
                                             ReportPPCh. true if the block has
                                             been received on the extended
                                             channel                          */

   /* flag for ignoring timing error of this report after timing adjust */

   int8        timingTag;      /* (A) layer1 internal use */

   int8        blockNo;        /* (A) layer1 internal use. 0..2 */

   /* points to report for reporting period if this report is monitored */

   Report*     monitorReport;  /* (A) layer1 internal use */

   /* used to handle the TCh  */

   uint8       flags;          /* (A) layer1 internal use */

   /* used to determine if bursts receive on BCCh should be used for power averaging */

   bool        powerControl;   /* (A) layer1 internal use */

   bool        allocationExhausted; /* @field (D) Valid only for ReportPDTCh and
                                                  ReportPDTChConflict. It is only
                                                  applicable to fixed allocation and
                                                  not applicable to (ext-)dynamic
                                                  allocation.                        */
   TimeSlot    syncTimeSlot;   /* (A) layer1 internal use */

   AMRQICompensationData amr;  /*QI Compensation*/

   bool        isBeforeStartingTime;   // =1 in the last block of old TBF when DL TBF+DL TBF and resetIR=1
   uint16      newTBFtid;
      
#ifdef __EGPRS_MODE__                                                  
   bool        outOfMem;   // outOfMem=1 if MS is out of memory, =0 otherwise
   bool        isEdge;     // to change setpoint in EDGE mode PDTCh, only valid in ReportPDTCh
   uint16      dspVQ;      // DSP reports its V(Q)   
   uint16      availableIRBlocks;   // DSP reports available blocks in IR memory
#endif

#if IS_EDGE_CHIP_MT6229_AND_LATTER_VERSION
   int8        allocatedSlotCount;  // for L1I_AllocMultislotRxReport, alloc/free data sector pointer
#endif
   
} RxData;

typedef struct
{
   FrameNumber  frameNumber;
   intx         blockCount;
   BlockData*   blockData[4];
   CodingScheme codingScheme[4]; /* only valid for PDTCh */
   TimeSlotMask pollTimeSlots;   /* only valid for PDTCh, timeslots where poll responses have been sent */
   bool         ok;
} TxData;

typedef struct
{
   FrameNumber   frameNumber;   /* first frame of new DCh */
   TimingAdvance timingAdvance; /* last used timing advance on old DCh */
   intx          sacchPosition; /* position of the SACCh. 0=>12, 1=>25, 2=>38 ... */
   AfcParams     afc;
   ARFCN         arfcn;
} DChData;

typedef struct
{
   FrameNumber      frameNumber;       /* first frame of new TBF */
   TimeSlot         startTimeSlotFBSB; /* layer1 internal use. Start timeslot to search FB or SB */
   uint8            assign_ref;        /* reference id used by L1A */
   TimeSlot         syncTimeSlot;
   bool             downValid;
   TimeSlotMask     downTimeSlots;
   bool             upValid;
   TimeSlotMask     upTimeSlots;
   HoppingSequence* hs;
   TID              uptid;
   TID              downtid;
   uint8            newtbfdir;         /* TBF direction: 1->downlink only, 2->uplink only, 3->both direction. */
} TBFData;

typedef struct
{
   bool             onCurrentDCh; /* true if the DCh where the hopping sequence
                                     has been set is the active one */
   HoppingSequence* hs;           /* valid only when onCurrentDCh equals true */
} HoppingSequenceSetData;

/*
@struct SChData | Report data for sync burst reporting.
*/
typedef struct
{
   ARFCN     arfcn;
   bool      ok;         /* @field Sync burst status. Set by the baseband driver.
                               @flag false | Burst was bad. Other fields in this structure are invalid.
                               @flag true | Burst was OK. Other fields in this structure are valid. */
   bool      fcb_ok;
   intx      frameDelay; /* @field Frame where sync burst has been received relative to the frame where <f L1T_FCChStart> was called. . Set by the baseband driver. */
   intx      ebitDelay;  /* @field Position of sync burst relative to current frame start in eighth bits. Set by the baseband driver. */
   BlockData data[ 4 ];  /* @field Sync burst data. Set by the baseband driver. */

   Time        bsTimingOffset; /* @field Timing offset of the base station relative to the mobiles current
                                         synchronisation. Calculated by layer1 */
   FrameNumber bsFrame;  /* @field Frame number decoded from the sync burst. Calculated by layer1. */
   BSIC        bsic;     /* @field BSIC number decoded from the sync burst. Calculated by layer1. */
   Time        rxTime;   /* @field Time the sync burst has been received. Calculated by layer1. */

   bool        hardwareUnavailable; /* special flag returned by SChT only if SCh was aborted because hardware
                                       was occupied by higher priority operation */
   bool        extBsic;  /* @field A flag to indicate if Extended measurement BSIC */
   bool        manual;   /* @distinguish manual or surrounding */
/* Tier-1 Modem */  int16     snr;   
/* Tier-1 Modem */  intx      bitErrorCount;
} SChData;

/*
@struct AMRData | Information about current used AMR parameter.
*/

typedef struct
{
   kal_uint8 amr_valid; /* AMR enable or not */
   kal_uint8 CMR_CMC_CMIu_CMId;	/*CMR, CMC, CMI*/
   kal_uint8 C_I;								/* C/I */
   kal_uint16 ICM;							/* initial codec mode */	
   kal_uint16 ACS;   						/* active codec mode */
} AMRData;

/*
@struct ReportPeriodData | Information about last reporting period.
*/
typedef struct
{
   bool          dtxUsed;  /* set by hardware driver */

   MonitorResult monitor;  /* set by layer1 core */
   intx          useCount; /* layer1 internal use */
   AMRData       amr;      /* @field send AMR parameter to engineer mode*/
} ReportPeriodData;

/*
@struct PowerScanData | Results of power scan.
*/
typedef struct
{
   PowerScanResults* results; /* @field <t PowerScanResults> structure passed to <f L1T_PowerScanStart> */
   Measurements      meas;    /* layer1 internal use */
} PowerScanData;

typedef struct
{
   ScanList*    list; /* layer1 internal use */
   Measurements meas; /* layer1 internal use */
   Report*      lock; /* layer1 internal use */
} MeasurementData;

typedef struct
{
   Power        power[8];
   TimeSlotMask timeSlots;
   uint8        assign_ref;
} InterferenceData;

typedef struct
{
   intx             baListId;
   uint8            count;
 /*ARFCN            arfcn[L1_SURROUND_MAX_CELLS];*/
 /*Power            power[L1_SURROUND_MAX_CELLS];*/
   ARFCN           *arfcn;
   Power           *power;   
} SurroundCellData;

typedef struct
{
   int32              power;
   int32              iOffset;
   int32              qOffset;
   int32              deviation;
   int32              validSamples;
   Gain               usedGain;
   Measurements       meas;
} PM_TST_Data;

typedef struct
{
   int16  iOffset;
   int16  qOffset;
   Power  power;   
} PMResult;

/*
@union ReportData | Contains report information
*/
typedef union
{
   RxData                 rx;           /* @field Results of normal receives */
   TxData                 tx;
   DChData                dch;
   TBFData                tbf;
   HoppingSequenceSetData hsSet;
   SChData                sch;          /* @field Results of FCB and SB search */
   ReportPeriodData       rp;           /* @field End of report period information */
   PowerScanData          powerScan;    /* @field Power scan results */
   MeasurementData        meas;         /* @field Surround power measurement results */
   InterferenceData       interference; /* @field Interference measurement results */
   SurroundCellData       sc;           /* @field surround cell and NC results */
   PM_TST_Data            pm_tst;       /* @field power meas results in test mode */
   HoppingSequence*       hs;           /* layer1 internal use */
} ReportData;

typedef struct     /* !!important: please update the copy in m12194.c */
{
   Power defaultPower;
   Power bestPower;
   Power underflowPower;
   Power overflowPower;
   Gain  underflowReportPower;
   Gain  overflowReportPower;
} AGCParams;

typedef struct AGCDataStruct AGCData;

typedef struct
{
   Power ( *predict )( AGCData* p, ARFCN arfcn, TimeSlot timeSlot );
   void  ( *update )( AGCData* p, ARFCN arfcn, TimeSlot timeSlot, Power antennaPower, intx rangeError );
   void  ( *beforeBlock )( AGCData* p, TimeSlotMask timeSlots );
   void  ( *afterBlock )( AGCData* p, TimeSlotMask timeSlots );
} AGCAlgorithm;

typedef struct
{
   ARFCN bcchARFCN;        /* ARFCN of BCCh carrier */
   Power powerReductionPb; /* power reduction of PBCCh relative to BCCh */
   Power* bcchPower;        /* location to store power */
} AGCCellData;

typedef struct
{
   Power averagePower;
   uint8 overflows;
   uint8 underflows;
   uint8 good;
   uint8 total;
   uint8 goodsnr;
} AGCTimeSlotData;

typedef struct
{
   AGCTimeSlotData tsd[8];
} AGCDataDTX;

typedef struct
{
   Power*          timeSlotPowerOffset;
   BTSPowerControl btsPowerControl;
   TFI             downlinkTFI;
   TFI             uplinkTFI;
   const USF*      usf;
} AGCDataPDTCh;


typedef struct
{
   AGCCellData      servingCell;
   const AGCParams* servingBandParams;
#ifdef __PS_SERVICE__
   bool             servingPBCChExists;
   Power            interferencePower;
#endif
   AGCDataDTX       dtx[2];
   intx             nextDTX;
   Power            gainoffset;

   Power            timeSlotPower[8];
   TimeStamp        timeSlotTimeStamp[8];
   TimeStamp        servingBCChTimeStamp;
   
} AGCServingDB;


struct AGCDataStruct
{
   const AGCAlgorithm* algorithm;  /* channel specific algorithm    */
   const AGCParams*    bandParams; /* band specific AGC limits      */
   AGCCellData*        cell;       /* cell specific data            */
   AGCDataDTX*         dtx;
   AGCDataPDTCh*       pdtch;      /* PDTCh algorithm specific data */
   TimeSlot            syncTimeSlot;
   TimeSlotMask        timeSlots;  /* rx time slots filled by L1D   */
   AGCServingDB*       servingInfo;/* Serving cell AGC parameters   */
};


/* It is used in m11303.C and m11303_2.c */
typedef struct
{
   Power      bcchPower[ARFCN_COUNT];

} AGCPowerDB;

#ifdef __GEMINI__
typedef enum
{
	ConflictWithOther = 2,
	ConflictWithPCh = 3,
	ConflictWithNBCCh = 4,
	ConflictWithBCCh = 4
} ConflictType;
#endif

/*
tid (transaction id) is used to handle race conditions when dealing with reports.
tid is the value of the transaction id when the report was generated.
If PH stops a channel, it increments the channels transaction identifier.
The report is then invalid because (report->tid != 'channel'.tid)
*/
/*
@struct Report | Results of operations.
*/
struct Report
{
   ReportType type; /* @field Type of report */
   void    ( *callback )( Report* ); /* layer1 internal use */
   TID        tid;                   /* layer1 internal use */

   ReportData data; /* @field Contains information dependent on the <e Report.type> field */

   void*      chan; /* layer1 internal use. Channel specific data */
   AGCData    agc;

#ifdef L1C_DEBUG
   bool needToCallMonitorReport;
#endif

#if IS_EDGE_CHIP_MT6229_AND_LATTER_VERSION
   bool        isRxReport;
#endif

#ifdef __GEMINI__
    bool    unadjustedTimer;
    bool    pchAligned;
    ConflictType	conflictTimer;
#endif
};

/*
@struct sMTMAXTIME | To measure the maximum execution time.
*/
typedef  struct
{
   int16       tq_start;
   int16       max_start;
   int16       max_end;
   int16       max_diff;

}  sMTMAXTIME;


/*
@struct SBATMEASARG | To periodically measure the battery voltage & temperature
*/
typedef  struct
{  int  period;    /* peiod of updating the measurement result  */
   int  count;     /* sample count to average in one period */
}  SADCMEASARG;

typedef   struct
{  SADCMEASARG  voltage;
   SADCMEASARG  temperature;
}  SBATMEASARG;

#ifdef __MTK_TARGET__
typedef struct
{
   uint32   sleepDisable;
   volatile uint32   fmResult;
   bool     calbrating;
   uint8    handleCount;
   /* Modified by Anthony Chin for SM 04/17/2002. */
   uint8    handle;
   uint8    gprs_im_sleep_handle; //SM_WAKEUP_COMPENSATION
   bool     rf_sleep;
   uint32   multiplyConstant;
   uint32*  hanlde_ptr; 
} SM_Globals;
#endif
/*
@struct sBBTXCfg | used to set/get run-time BBTX param
*/
typedef struct 
{
   int8   TxTrimI;
   int8   TxTrimQ;
   int8	  TxOffsetI;
   int8	  TxOffsetQ;
   int8	  TxCalbias;
   int8	  TxIQSwap;
   int8	  TxCMV;
   int8	  TxGain;
   int8	  TxCalrcsel;
   int8	  TxPhasesel;
   int8   TxDccoarseI;
   int8   TxDccoarseQ;
} sBBTXCfg;

#ifdef L1A_SIM
/* elly, for L1 simulation catcher use */
typedef struct _l1c_l1a_report_struct
{
     kal_uint8				ref_count;
     kal_uint16				msg_len;
     Report                             report;
} l1c_l1a_report_struct;
#endif

#endif


