/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   rtfiles.h
 *
 * Project:
 * --------
 *   Maui
 *
 * Description:
 * ------------
 *    Native api declarations
 *
 * Author:
 * -------
 *
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
/* RTFiles native API declarations */

#ifndef _RTFILES_H
#define _RTFILES_H

/***************** Compile Option definition, Karen Hsu *****************/
#undef __FS_DEBUG__

/************************************************************************/

#ifndef RTTDLL
   #ifdef RTT32DLL
      #if defined(_MSC_VER)
         #define RTTDLL __declspec(dllimport)
         #define RTTDDL __declspec(dllimport)
      #elif defined(__BORLANDC__)
         #define RTTDLL
         #define RTTDDL extern __import
      #else // importing needs no special declaration or is not supported
         #define RTTDLL
         #define RTTDDL extern
      #endif
   #else
      #define RTTDLL
      #define RTTDDL extern
   #endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//#define RTFILE_VER 404

#if defined(_WIN32) || defined (WIN32) || defined (__FLAT__)
   #define RTF_32_BIT
   #define RTFAPI __cdecl
#else
   /* #define RTFAPI _cdecl */
   #define RTFAPI
#endif

#if !defined(WIN32)
#undef  _MSC_VER
#define min(X,Y) ((X) < (Y)) ? (X) : (Y)
#endif

#define LSB(FileName, i) (FileName[2*i])
#define MSB(FileName, i) (FileName[2*i+1])
#define isASCII(FileName, i) ( !((BYTE) MSB(FileName, i)) && (LSB(FileName, i)<0x80) )
#define toASCII(FileName, i) ((BYTE) LSB(FileName, i))
#define setASCII(FileName, i, ch) (LSB(FileName, i)=ch); (MSB(FileName,i)=0)
#define compASCII(FileName, i, c) (isASCII(FileName, i) && (toASCII(FileName, i) == c))


#define memset    kal_mem_set
#define memcpy    kal_mem_cpy

// for one byte alignment, pre-compile option in different environment
/* add GEN_FOR_PC for cgen compile error, Karen Hsu, 2004/02/09 */
#if defined(_WIN32) || defined(WIN32) || defined(GEN_FOR_PC)
#define ONE_BYTE_ALIGN_ADS
#else
#define ONE_BYTE_ALIGN_ADS   __packed
#endif

//#define RTF_MAX_FILES 32

#define RTF_MIN_BUFFER_SIZE       512
#define RTF_MAX_BUFFER_SIZE     32768
#define RTF_MAX_PATH              520   // 260x2=520

// error codes
#define RTF_NO_ERROR                      0
#define RTF_ERROR_RESERVED                -1
#define RTF_PARAM_ERROR                   -2
#define RTF_INVALID_FILENAME              -3
#define RTF_DRIVE_NOT_FOUND               -4
#define RTF_TOO_MANY_FILES                -5
#define RTF_NO_MORE_FILES                 -6
#define RTF_WRONG_MEDIA                   -7
#define RTF_INVALID_FILE_SYSTEM           -8
#define RTF_FILE_NOT_FOUND                -9
#define RTF_INVALID_FILE_HANDLE           -10
#define RTF_UNSUPPORTED_DEVICE            -11
#define RTF_UNSUPPORTED_DRIVER_FUNCTION   -12
#define RTF_CORRUPTED_PARTITION_TABLE     -13
#define RTF_TOO_MANY_DRIVES               -14
#define RTF_INVALID_FILE_POS              -15
#define RTF_ACCESS_DENIED                 -16
#define RTF_STRING_BUFFER_TOO_SMALL       -17
#define RTF_GENERAL_FAILURE               -18
#define RTF_PATH_NOT_FOUND                -19
#define RTF_FAT_ALLOC_ERROR               -20
#define RTF_ROOT_DIR_FULL                 -21
#define RTF_DISK_FULL                     -22
#define RTF_TIMEOUT                       -23
#define RTF_BAD_SECTOR                    -24
#define RTF_DATA_ERROR                    -25
#define RTF_MEDIA_CHANGED                 -26
#define RTF_SECTOR_NOT_FOUND              -27
#define RTF_ADDRESS_MARK_NOT_FOUND        -28
#define RTF_DRIVE_NOT_READY               -29
#define RTF_WRITE_PROTECTION              -30
#define RTF_DMA_OVERRUN                   -31
#define RTF_CRC_ERROR                     -32
#define RTF_DEVICE_RESOURCE_ERROR         -33
#define RTF_INVALID_SECTOR_SIZE           -34
#define RTF_OUT_OF_BUFFERS                -35
#define RTF_FILE_EXISTS                   -36
#define RTF_LONG_FILE_POS                 -37
#define RTF_FILE_TOO_LARGE                -38
#define RTF_BAD_DIR_ENTRY                 -39
#define RTF_ATTR_CONFLICT                 -40 // Recoverable support: Can't specify FS_PROTECTION_MODE and FS_NONBLOCK_MODE
#define RTF_CHECKDISK_RETRY               -41 // Recoverable support: used for CROSSLINK
#define RTF_LACK_OF_PROTECTION_SPACE      -42 // UN-USED

// add for non_blocking write and protection
typedef enum{
  FS_BLOCK_ENUM,
  FS_NON_BLOCK_ENUM,
  FS_BLOCK_PROTECTION_ENUM
}fs_block_type_enum;// file attributes

// file attributes
#define RTF_ATTR_READ_ONLY      0x01
#define RTF_ATTR_HIDDEN         0x02
#define RTF_ATTR_SYSTEM         0x04
#define RTF_ATTR_VOLUME         0x08
#define RTF_ATTR_DIR            0x10
#define RTF_ATTR_ARCHIVE        0x20
#define RTF_LONGNAME_ATTR       (RTF_ATTR_READ_ONLY | RTF_ATTR_HIDDEN | RTF_ATTR_SYSTEM | RTF_ATTR_VOLUME)
#define RTF_ATTR_ANY            0x3F

// file open flags
// 0x000000XX - attributes
// 0x0000XX00 - sharing
// 0x000X0000 - creation
// 0xXX000000 - caching
// 0x00X00000 - RTFiles internal use

#define RTF_READ_WRITE          0x00000000L
#define RTF_READ_ONLY           0x00000100L
#define RTF_OPEN_SHARED         0x00000200L
#define RTF_OPEN_NO_DIR         0x00000400L
#define RTF_OPEN_DIR            0x00000800L

#define RTF_CREATE              0x00010000L // create if it does not exist
#define RTF_CREATE_ALWAYS       0x00020000L // always create

// defaults:
// DIR and FAT is written at file close
// buffers are written when file pointer leaves the sector
#define RTF_COMMITTED           0x01000000L // commit all buffers after every write
#define RTF_CACHE_DATA          0x02000000L // do not discard data buffers
#define RTF_LAZY_DATA           0x04000000L // do not commit buffer when file pointer leaves sector
// add a new flags for non_blocking write for flash driver
#define FS_NONBLOCK_MODE        0x10000000L // writing while encounter flash erase return immediately
#define FS_NOBUSY_CHECK_MODE		0x40000000L
/* add a new flags for write protection for flash driver.
  *  Note that, currently, we protect a write range of 2 or less sectors.
  *  Originally, only NVRAM files are meant to be protected.
  */
#define FS_PROTECTION_MODE      0x20000000L // Keep old versioned sectors for recovery on unexpected poweroff.


// note that RTF_DEVICE_LAZY_WRITE is a drive option and applies to all files

// file seek options
#define RTF_FILE_BEGIN          0
#define RTF_FILE_CURRENT        1
#define RTF_FILE_END            2

// format flags, low 8 bits are reserved for media specification
// Use RTF_FPLY_DRIVE_360/1200/720/1440/2880 to force a particular medium
// Default is the highest supported medium

#define RTF_FMT_SINGLE_FAT      0x00000100L
#define RTF_FMT_FORCE_LOW_LEVEL 0x00000200L
#define RTF_FMT_NO_LOW_LEVEL    0x00000400L
#define RTF_FMT_GET_DATA_SECTOR 0x00000800L
#define RTF_FMT_FAT_12          0x00001000L
#define RTF_FMT_FAT_16          0x00002000L
#define RTF_FMT_FAT_32          0x00004000L
#define RTF_FMT_NO_FAT_32       0x00008000L

#define RTF_FMT_PGS_LOW_FMT      1
#define RTF_FMT_PGS_HIGH_FMT     2
#define RTF_FMT_PGS_CLEAR_MEDIUM 5
#define RTF_FMT_PGS_DONE        -1

// check disk flags
#define RTF_CHK_FAT_MISMATCH              0x00000001L
#define RTF_CHK_FAT_MISMATCH_1            0x00000002L
#define RTF_CHK_FAT_MISMATCH_2            0x00000003L
#define RTF_CHK_FAT_MISMATCH_MASK         0x00000003L

#define RTF_CHK_INVALID_DIR               0x00000004L
#define RTF_CHK_INVALID_DIR_DELETE        0x00000008L
#define RTF_CHK_INVALID_DIR_MASK          0x0000000CL

#define RTF_CHK_INVALID_CLUSTER           0x00000010L
#define RTF_CHK_INVALID_CLUSTER_TRUNC     0x00000020L
#define RTF_CHK_INVALID_CLUSTER_DELETE    0x00000030L
#define RTF_CHK_INVALID_CLUSTER_MASK      0x00000030L

#define RTF_CHK_CROSSLINK                 0x00000040L
#define RTF_CHK_CROSSLINK_TRUNC           0x00000080L
#define RTF_CHK_CROSSLINK_DELETE          0x000000C0L
#define RTF_CHK_CROSSLINK_MASK            0x000000C0L

#define RTF_CHK_FILESIZE_SMALL            0x00000100L     // DIR.FileSize < FAT.FileSize
#define RTF_CHK_FILESIZE_SMALL_TRUNC      0x00000200L     // truncate FAT chain
#define RTF_CHK_FILESIZE_SMALL_DELETE     0x00000300L
#define RTF_CHK_FILESIZE_SMALL_MASK       0x00000300L

#define RTF_CHK_FILESIZE_LARGE            0x00000400L     // DIR.FileSize > FAT.FileSize
#define RTF_CHK_FILESIZE_LARGE_TRUNC      0x00000800L     // truncate DIR.FileSize
#define RTF_CHK_FILESIZE_LARGE_DELETE     0x00000C00L
#define RTF_CHK_FILESIZE_LARGE_MASK       0x00000C00L

#define RTF_CHK_LOST_CLUSTER              0x00001000L
#define RTF_CHK_LOST_CLUSTER_FREE         0x00002000L
#define RTF_CHK_LOST_CLUSTER_MASK         0x00003000L

#define RTF_CHK_LONG_FILENAME             0x00004000L
#define RTF_CHK_LONG_FILENAME_REMOVE      0x00008000L
#define RTF_CHK_LONG_FILENAME_DELETE      0x0000C000L
#define RTF_CHK_LONG_FILENAME_MASK        0x0000C000L

#define RTF_CHK_VERBOSE                   0x80000000L

// Flags for RTFCompactDir

#define RTF_CMPCT_READ_ONLY               0x00000001
#define RTF_CMPCT_RECURSIVE               0x00000002

// Flags for RTFDiskInfoEx

#define RTF_DI_BASIC_INFO                 0x00000001L
#define RTF_DI_FREE_SPACE                 0x00000002L  // return FreeClusters
#define RTF_DI_FAT_STATISTICS             0x00000004L  // return BadClusters, Files, FileChains, FreeChains, LargestFreeChain

// device types

#define RTF_DEVICE_UNKNOWN      0
#define RTF_DEVICE_FLOPPY       1
#define RTF_DEVICE_FDISK        2

// device flags, use only lower 16 bits

#define RTF_DEVICE_SINGLE_FAT       0x0001
#define RTF_DEVICE_LAZY_WRITE       0x0002  // update FAT/DIR/data buffers at last file close of drive
#define RTF_DEVICE_MOUNT_CONTIGUOUS 0x0004
#define RTF_DEVICE_REMOVABLE        0x0008
#define RTF_DEVICE_NO_MEDIA         0x0010
#define RTF_DEVICE_NEW_LOCK         0x0020

// device driver flags, may only use upper 16 bits

// floppy driver flags
#define RTF_CUSTOM_TIMER        0x80000000L
#define RTF_MOTOR_TIMEOUT_1     0x40000000L
#define RTF_MOTOR_TIMEOUT_5     0x20000000L
#define RTF_MOTOR_TIMEOUT_10    0x10000000L
#define RTF_READ_AHEAD_0        0x01000000L
#define RTF_READ_AHEAD_2        0x02000000L
#define RTF_READ_AHEAD_8        0x03000000L
#define RTF_READ_AHEAD_16       0x04000000L

// IDE driver flags
#define RTF_NO_CMOS_RAM         0x80000000L
#define RTF_32_BIT_IO           0x40000000L
#define RTF_16_BIT_IO           0x20000000L
#define RTF_NO_MULTI_SECTOR     0x10000000L
#define RTF_NO_WRITE_CACHE      0x08000000L
#define RTF_CONTIGUOUS_IO       0x04000000L

// Flash driver flags
#define RTF_FLASH_NO_SECTOR_MAP 0x80000000L
#define RTF_FLASH_NO_LOW_FMT    0x40000000L
#define RTF_FLASH_NO_HIGH_FMT   0x20000000L

// a few data types

#ifndef _WINDOWS_
/* Patch for AMNT double define warning, Karen, 2004/01/08 */
#ifndef __AMNT__
typedef unsigned int  DWORD;
#endif
typedef unsigned short WORD;
typedef unsigned int   UINT;
typedef unsigned char  BYTE;
typedef void * HANDLE;
#endif

typedef int   RTFHANDLE;
typedef DWORD RTFSector;
typedef DWORD RTFCluster;

#if defined(WIN32)
#pragma pack(1)
#endif
typedef ONE_BYTE_ALIGN_ADS struct {
   BYTE  BootIndicator,       // 0x80 for bootable, 0 otherwise
         StartHead,           // 0 based
         StartSector,         // 1 based, bits 0..5, bits 6,7 are bits 8,9 of StartTrack
         StartTrack,          // 0 based, bits 0..7
         OSType,              // FAT-12: 1, FAT-16: 4, 6, 14, FAT-32: 11, 12
         EndHead,             // see StartHead
         EndSector,           // see StartSector
         EndTrack;            // see StartTrack
   RTFSector RelativeSector,  // offset to first sector of partition data
                              // for primary partitions, this is the absolute
                              // LBA of the boot sector
                              // for logical drives, the boot sector is at ExtendedPartition.RelativeSector + Drive.RelativeSector
         Sectors;             // number of sectors in partition
} RTFPartitionRecord; /* ! Must SYNC ! */

typedef ONE_BYTE_ALIGN_ADS struct {
   unsigned int Second2:5;
   unsigned int Minute:6;
   unsigned int Hour:5;
   unsigned int Day:5;
   unsigned int Month:4;
   unsigned int Year1980:7;
} RTFDOSDateTime; /* ! Must SYNC ! */

typedef ONE_BYTE_ALIGN_ADS struct {
   char           FileName[8];
   char           Extension[3];
   BYTE           Attributes;
   BYTE           NTReserved;
   BYTE           CreateTimeTenthSecond; // range 0..199, not used
   RTFDOSDateTime CreateDateTime;
   WORD           LastAccessDate;        // not used
   WORD           FirstClusterHi;        // FAT-32 only
   RTFDOSDateTime DateTime;              // of last modification
   WORD           FirstCluster;
   DWORD          FileSize;
} RTFDOSDirEntry; /* ! Must SYNC ! */

// end of one byte alignment for structure definitions
#if defined(WIN32)
#pragma pack()
#endif

typedef struct {
   const RTFDOSDirEntry * DirEntry;
   DWORD                  FilePos;
   DWORD                  AllocatedSize;
   DWORD                  ClusterChains;
   DWORD                  VolumeSerialNumber;
   const char           * FullName;
} RTFFileInfo; /* ! Must SYNC ! */

typedef struct {
   char             Label[24];
   char             DriveLetter;
   /* Add for memory card write protection, Karen Hsu, 2004/04/14, MOD START */
   BYTE             WriteProtect;
   char             Reserved[2];
   //char             Reserved[3];
   /* Add for memory card write protection, Karen Hsu, 2004/04/14, MOD END */
   DWORD            SerialNumber;
   DWORD            FirstPhysicalSector;
   UINT             FATType;            // 12 or 16
   UINT             FATCount;
   UINT             MaxDirEntries;
   UINT             BytesPerSector;
   UINT             SectorsPerCluster;
   RTFCluster       TotalClusters;
   RTFCluster       BadClusters;
   RTFCluster       FreeClusters;
   DWORD            Files;
   DWORD            FileChains;
   DWORD            FreeChains;
   RTFCluster       LargestFreeChain;
} RTFDiskInfo; /* ! Must SYNC ! */

typedef struct {
   RTFPartitionRecord Partition;
   RTFSector PartitionSector;      // absolute sector containing the partition table (0 for primary partitions and floppies)
   int       PhysicalDiskIndex;    // nth physical hard disk (0 based, -1 for floppies)
   UINT      BytesPerSector;       // usually 512
   BYTE      MediaDescriptor;      // F8 for hard disks, 0 for unknown
   BYTE      Reserved;             // for alignment
   short     DeviceListIndex;      // nth entry in the RTFiles device list (0 based)
} RTFPartitionInfo;

typedef struct {
   DWORD TotalBuffers,             // number of installed sector buffers
         ValidBuffers,             // buffers currently holding valid data
         DirtyBuffers,             // buffers currently holding unflushed data
         MaxDirtyBuffers,          // max number of dirty buffers

         PhysicalBufferReads,      // number of physical buffer reads
         CachedBufferReads,        // number of times data was in the cache
         BuffersDiscarded,         // number of times a valid buffer was discared to make room for a new buffer
         CacheHits,                // 100 * CachedBufferReads / (PhysicalBufferReads+CachedBufferReads)

         PhysicalBufferWrites,     // buffer writes to disk
         CachedBufferWrites,       // updates of a dirty buffer
         AsynchBufferFlushs,       // buffers written in a differen RTFiles API call than the first update to that buffer

         UnbufferedReads,          // sectors read bypassing the buffer cache
         UnbufferedWrites;         // sectors written bypassing the buffer cache
} RTFBufferStatistic;

typedef enum { RTFRetry, RTFFail } RTFErrorAction;
typedef RTFErrorAction (RTFAPI * RTFCriticalErrorHandler)(WCHAR Drive, DWORD SerialNumber, int ErrorCode);

typedef void (RTFAPI * RTFFormatCallback)(const char * DeviceName, int Action, DWORD Total, DWORD Completed);

typedef DWORD (RTFAPI * RTFCheckDiskCallback)(DWORD Flag,
                                              const char * Path,
                                              const RTFDOSDirEntry * FileInfo,
                                              DWORD N1,
                                              DWORD N2);
#ifndef _WINDOWS_
typedef struct {
   DWORD Reserved[12];
} CRITICAL_SECTION;
#endif

typedef struct RTFMutex_t {
   kal_semid    rtf_sem;
   kal_taskid   rtf_sem_owner;
   kal_uint32   rtf_lock_count;
   /* Solve MMI hang for waiting lock, Karen Hsu, 2004/04/23, ADD START */
   int DeviceNum_1;
   int DeviceNum_2;
   /* Solve MMI hang for waiting lock, Karen Hsu, 2004/04/23, ADD END */
} RTFMutex; /* ! Must SYNC ! */

typedef RTFMutex RTFSemaphore;

typedef struct rtfdriver {
   //UINT Version;
   int  (RTFAPI * MountDevice)    (void * DriveData, int DeviceNumber, int DeviceType, DWORD Flags);
   int  (RTFAPI * ShutDown)       (void * DriveData);
   int  (RTFAPI * ReadSectors)    (void * DriveData, RTFSector Sector, UINT Sectors, void * Buffer);
   int  (RTFAPI * WriteSectors)   (void * DriveData, RTFSector Sector, UINT Sectors, void * Buffer);
   int  (RTFAPI * MediaChanged)   (void * DriveData);
   int  (RTFAPI * DiscardSectors) (void * DriveData, RTFSector Sector, UINT Sectors);
   int  (RTFAPI * GetDiskGeometry)(void * DriveData, RTFPartitionRecord * DiskGeometry, BYTE * MediaDescriptor);
   int  (RTFAPI * LowLevelFormat) (void * DriveData, const char * DeviceName, RTFFormatCallback Progress, DWORD Flags);
   int  (RTFAPI * NonBlockWriteSectors)   (void * DriveData, RTFSector Sector, UINT Sectors, void * Buffer);
   int  (RTFAPI * RecoverableWriteSectors)(void * DriveData, RTFSector Sector, UINT Sectors, void * Buffer); // Recoverable support
   int  (RTFAPI * ResumeSectorStates)     (void  * DriveData); // Recoverable support
   int  (RTFAPI * HighLevelFormat)(void * DriveData, UINT BaseSector); /* for speed up format, WCP_SW , 2007/08/27 */
   int  (RTFAPI * RecoverDisk)    (void * DriveData); /* Support advance disk recover operation, WCP_SW, 2007/08/30 */
   int  (RTFAPI * MessageAck)     (void * DriveData, int type); /* Add for USB OTG Device, 2005/12/13 */
   int  (RTFAPI * CopySectors)    (void * DriveData, RTFSector SrcSector, RTFSector DstSector, UINT Sectors); /* Add for XCOPY Speed up, 2006/06/15 */
   int  (RTFAPI * OTPAccess)      (void * DriveData, int type, UINT Offset, void * BufferPtr, UINT Length); /* Add for OTP device IO, 2006/06/29 */
   int  (RTFAPI * OTPQueryLength) (void * DriveData, UINT *Length); /* Add for OTP device IO, 2006/06/29 */
} RTFDriver; /* ! Must SYNC ! */

struct _rtfDrive;
struct _rtfBuffer;

typedef struct {
   RTFMutex         * Lock;
   struct _rtfDrive * FirstDrive;
   BYTE               MediaPresent;
   BYTE               MediaRemovedReported; // set to zero when MediaPresent is set to zero
   BYTE               Reserved;
   BYTE               MountState;
   int                SectorSize;
   RTFPartitionRecord Geometry;         // size = 4 DWORDs
   UINT               SectorShift;
   UINT               AccessCount;
   struct _rtfBuffer *B;                // temporary buffer
   struct _rtfBuffer *AltBuffer;        // temporary buffer for critical errors
   int                ErrorCondition;   // keep returning this until it is remounted
   int                PhysicalDiskIndex;
   char               FriendlyName[7];  // "Disk X"
   BYTE               MediaDescriptor;
} RTFDeviceData; /* ! Must SYNC ! */

typedef struct _rtfDevice {
   int                DeviceType;
   int                DeviceNumber;
   DWORD              DeviceFlags;
   RTFDriver        * Driver;
   void             * DriverData;       // total size = 5 DWORD
   RTFDeviceData      DevData;          // size = 16 DWORDS
} RTFDevice; /* ! Must SYNC ! */

// driver specific data for well known drivers

// Windows NT driver, do not use for embedded systems
typedef struct {
   int DeviceType;
   DWORD Flags;
   HANDLE FileHandle;
   CRITICAL_SECTION CS;
   // just for diagnostics
   DWORD LastStatus;
   DWORD SectorSize;
   DWORD SectorsPerTrack;
   DWORD Heads;
} RTFDrvNTData;


// ATA-IDE driver

typedef struct {
   void * ReadAheadBuffer;
   UINT ReadAheadBufferSize;
   UINT PortBase;
   UINT InitTimeout;
   UINT DiskTimeout;
   UINT ControllerTimeout;
   UINT IRQ;
   UINT Cylinders;
   UINT Heads;
   UINT SectorsPerTrack;
   UINT MaxSectors;
   UINT DeviceNumber;     // 0 or 1
   UINT Controller;       // 0 to 3
   RTFSector TotalSector;
   RTFSector InBufferSector;
   RTFSector InBufferSectors;
   DWORD ExtraReads;
   DWORD SavedReads;
   DWORD SavedAccesses;
   DWORD Flags;
} RTFDrvIDEData;


// Floppy driver
// these are also used as media identifiers. 0 means unknown.
// drive types never change, but medias can

#define RTF_FPLY_DRIVE_UNKNOWN 0
#define RTF_FPLY_DRIVE_360  1
#define RTF_FPLY_DRIVE_1200 2
#define RTF_FPLY_DRIVE_720  3
#define RTF_FPLY_DRIVE_1440 4
#define RTF_FPLY_DRIVE_2880 5

typedef struct {
   BYTE CommandByte2;     // use 0xDF
   BYTE CommandByte3;     // HeadLoadTime, use 0x02
   BYTE MotorTimeout;     // 55ms timer ticks, use 0x25
   BYTE SectorSize;       // use 2 for 512 bytes
   BYTE LastSector;       // media dependent, don't use
   BYTE GapLength;        // media dependent, don't use
   BYTE CommandByte8;     // DataLength, use 0xFF
   BYTE FormatGapLength;  // media dependent, don't use
   BYTE FormatFillByte;   // use 0xF6
   BYTE HeadSettleTime;   // use 0x0F (milliseconds)
   BYTE MotorStartupTime; // 8th of a second, use 8 (only used from write)
} RTF_FPLY_BIOS_Disk_Parameter;

typedef struct {
   UINT DeviceType;       // 0 to have the driver ask the BIOS CMOS RAM
   RTF_FPLY_BIOS_Disk_Parameter * DPT; // NULL to use default
   UINT DiskTimeout;                   // 0 for default of 2000 milliseconds
   UINT ControllerTimeout;             // 0 for default 500 milliseconds
   UINT Retries;                       // 3 by default
   UINT DeviceNumber;
   UINT Media;
   UINT CurrentTrack;
   UINT RetryCount;
   UINT ReadAheadSectors;
   DWORD ExtraReads;
   DWORD SavedReads;
   DWORD SavedAccesses;
   DWORD Flags;
   BYTE CtrStatus[7];
} RTFDrvFLPYData;


// RAM Disk

typedef struct {
   RTFSector Sectors;
   DWORD Reserved1, Reserved2;
   UINT  SectorsPerSegment;
   void  * * * MasterSegment;
} RTFDrvRAMData;


// BIOS Driver

typedef struct {
   void * ReadAheadBuffer;
   UINT  ReadAheadBufferSize;
   UINT  LockIndex;
   UINT  Retries;
   UINT  DeviceNumber;
   UINT  DeviceType;
   UINT  SectorsPerTrack;
   UINT  Heads;
   UINT  RetryCount;
   UINT  InBufferSectors;
   RTFSector InBufferSector;
   DWORD ExtraReads;
   DWORD SavedReads;
   DWORD SavedAccesses;
   DWORD Flags;
} RTFDrvBIOSData;


// DiskOnChip 2000

typedef struct {
   unsigned DeviceNumber;
} RTFDrvDOCData;


// PCMCIA SRAM card driver

typedef struct {
   RTFSector  Sectors;
   BYTE     * WinAddrP;   // physical address of window
   BYTE     * WinAddrV;   // virtual  address of window
   RTFSector  WinSize;    // in sectors
   RTFSector  CurrSec;
   int        Socket;
   DWORD      Flags;
} RTFDrvSRAMData;

// port i/o routines for the drivers

RTTDLL BYTE   RTFAPI RTIn   (UINT Port);
RTTDLL WORD   RTFAPI RTInW  (UINT Port);
RTTDLL DWORD  RTFAPI RTInD  (UINT Port);
RTTDLL void   RTFAPI RTOut  (UINT Port, BYTE  val);
RTTDLL void   RTFAPI RTOutW (UINT Port, WORD  val);
RTTDLL void   RTFAPI RTOutD (UINT Port, DWORD val);
RTTDLL void * RTFAPI RTInSW (UINT Port, void * Buffer, UINT Bytes);
RTTDLL void * RTFAPI RTInSD (UINT Port, void * Buffer, UINT Bytes);
RTTDLL void * RTFAPI RTOutSW(UINT Port, void * Buffer, UINT Bytes);
RTTDLL void * RTFAPI RTOutSD(UINT Port, void * Buffer, UINT Bytes);


// 32-bit disk drivers

RTTDDL RTFDriver RTFDrvNT;      // Windows NT driver (not for embedded systems)
RTTDDL RTFDriver RTFDrvIDE;     // ATA-IDE driver
RTTDDL RTFDriver RTFDrvFloppy;  // floppy disk driver
RTTDDL RTFDriver RTFDrvRAM;     // RAM disk driver
RTTDDL RTFDriver RTFDrvDOC;     // M-Systems DiskOnChip 2000 driver
RTTDDL RTFDriver RTFDrvSRAM;    // PCMCIA SRAM card driver
RTTDDL RTFDriver RTFDrvNULL;    // Dummy driver to reserve driver letters
RTTDDL RTFDriver RTFDrvFlash;   // linear flash driver

// 16-bit disk drivers

RTTDDL RTFDriver RTFDrvBIOS;    // BIOS int 13h driver
RTTDDL RTFDriver RTFDrvRAM;     // RAM disk driver
RTTDDL RTFDriver RTFDrvNULL;    // dummy driver to reserve driver letters


// The device list

RTTDDL RTFDevice gFS_DeviceList[]; /* Move to custom, Karen Hsu, 2004/08/30 */
//RTTDDL RTFDevice RTFDeviceList[];

struct _rtfDevice;
struct _rtfDrive;

typedef struct _rtfBuffer {
   struct _rtfBuffer * Next;
   struct _rtfBuffer * Prev;
   RTFDevice         * Dev;
   BYTE              * Data;
   RTFSector           Sector;
   struct _rtfDrive  * FATSectorInfo;
   UINT                Flags;
   UINT                FirstDirtyTime,
                       LastDirtyTime;
   int                 Num;       // for debugging only

   BYTE             recoverable_flag; // 1 means the buffer needs recoverablewritesector, 0 means not

#define    RTF_RECOVERABLE_WRITE     1
#define    RTF_NORMAL_WRITE          0
} RTFBuffer; /* ! Must SYNC ! */

typedef struct {
   RTFCluster Cluster;                  // zero if none
   UINT Index;                          // undefined if none
} RTFDirLocation; /* ! Must SYNC ! */

typedef struct {
   RTFCluster          DirCluster;      // start of dir containing this entry
   RTFDirLocation      LongPos;
   RTFDirLocation      ShortPos;
   RTFDOSDirEntry      Dir;
} RTFDirEntry; /* ! Must SYNC ! */

typedef struct _rtfDrive {
   struct _rtfDevice * Dev;
   struct _rtfDrive  * NextDrive;
   int                 MountState;       // see type MountStates
   RTFPartitionRecord  Geometry;
   RTFCluster          Clusters;         // 1 + last valid cluster value, actual value +2
   UINT                SectorsPerCluster;
   DWORD               ClusterSize;      // in bytes
   UINT                ClusterShift;
   UINT                SPerCShift;       // sector per cluster shift
   UINT                FATType;
   UINT                FATCount;
   DWORD               SectorsPerFAT;
   RTFCluster          ClusterWatermark;
   RTFCluster          FreeClusterCount; // 0xFFFFFFFF if unknown
   RTFSector           InfoSector;       // 0 if none
   DWORD               SerialNumber;
   RTFSector           FirstSector;
   RTFSector           FirstFATSector;
   RTFSector           FirstDirSector;   // this is the first root dir cluster on FAT-32
   RTFSector           FirstDataSector;
   UINT                RootDirEntries;   // not used on FAT-32
   RTFDirEntry         CurrDirEntry;
   char                CurrDir[RTF_MAX_PATH]; // "X:\[Dir]"
   /* Add for quota management, Karen Hsu, 2004/07/12, ADD START */
#ifdef __FS_QM_SUPPORT__
   BYTE                QuotaMgt;
   BYTE                Reserved[3];
#endif
   /* Add for quota management, Karen Hsu, 2004/07/12, ADD END */
} RTFDrive; /* ! Must SYNC ! */

typedef struct {
   RTFDrive     * Drive;        // NULL for physical disk files
   RTFDevice    * Dev;          // redundant for data and volume files

   int            SpecialKind;
   UINT           Unique;
   DWORD          Flags;

   RTFDirEntry    DirEntry;

   DWORD          FilePointer;
   RTFCluster     LastCluster;  // cluster preceeding Cluster     (A1 and A2 for search handles)
   RTFCluster     Cluster;      // cluster containing FilePointer (RTFDirLocation for search handles)
   DWORD          Offset;       // within Cluster                 (ditto)

   char           FullName[RTF_MAX_PATH];
   void         * Task; /* ADD for garbage collection, Karen Hsu, 2004/04/16 */
   /* Speedup seek, Karen Hsu, 2004/08/24, ADD START */
   UINT           HintNum;
   RTFDirLocation * Seek_Hint;
   /* Speedup seek, Karen Hsu, 2004/08/24, ADD END */
   BYTE           Lock;
   /* Modified for hot plug I/O, Karen Hsu, 2004/02/04, ADD START */
   BYTE           Valid;
   BYTE           Reserved[sizeof(int) - 2*sizeof(BYTE)]; // integer alignment
   //BYTE           Reserved[sizeof(int) - sizeof(BYTE)]; // integer alignment
   /* Modified for hot plug I/O, Karen Hsu, 2004/02/04, ADD END */
} RTFile; /* ! Must SYNC ! */

typedef struct {
   RTFDrive  * DriveTable;
   RTFile    * FileTable;
   RTFBuffer * BufferTable;
   BYTE      * BufferData;
} RTFTables; /* ! Must SYNC ! */

#if defined(WIN32)
#pragma pack(1)
#endif
typedef ONE_BYTE_ALIGN_ADS struct {
   DWORD Signature1;            // 0x41615252l
   BYTE  Reserved[480];
   DWORD Signature2;            // 0x61417272l
   RTFCluster FreeClusterCount; // 0xFFFFFFFF for unkown, not guaranteed to be correct
   RTFCluster NextFreeCluster;  // 0xFFFFFFFF for unkown, start free cluster search here, not guaranteed to be correct
   BYTE  Reserved2[12];
   DWORD Signature;             // 0xAA550000l
} RTFFAT32InfoSector;

typedef ONE_BYTE_ALIGN_ADS struct {
   BYTE     PhysicalDiskNumber; // 0x80, 0x81, etc.
   BYTE     CurrentHead;        // not used
   BYTE     Signature;          // needed by NT
   DWORD    SerialNumber;
   BYTE     Label[11];          // not used
   char     SystemID[8];
} RTFExtendedBIOSParameter; /* ! Must SYNC ! */

typedef ONE_BYTE_ALIGN_ADS struct {
   char     OEMName[8];
   WORD     BytesPerSector;
   BYTE     SectorsPerCluster;
   WORD     ReservedSectors;    // relative to partition start
   BYTE     NumberOfFATs;
   WORD     DirEntries;         // zero on FAT-32
   WORD     SectorsOnDisk;
   BYTE     MediaDescriptor;
   WORD     SectorsPerFAT;      // zero on FAT-32
   WORD     SectorsPerTrack;
   WORD     NumberOfHeads;
   RTFSector NumberOfHiddenSectors; // OS specific, unreliable
   RTFSector TotalSectors;
   ONE_BYTE_ALIGN_ADS union {
      ONE_BYTE_ALIGN_ADS struct {
         RTFExtendedBIOSParameter BPB;
      } _16;
      ONE_BYTE_ALIGN_ADS struct {
         RTFCluster SectorsPerFAT;
         WORD     Flags;              // if (Flags & 0x0080) { SingleFAT; ActiveFat = (Flags & 0x000F); }
         WORD     Version;
         RTFCluster RootDirCluster;
         WORD     FSInfoSector;       // relative to start of partition, usually 1, 0xFFFF for none.
         WORD     BackupBootSector;   // usually 6
         BYTE     Reserved[12];       // should be all zero
         RTFExtendedBIOSParameter BPB;
      } _32;
   } E;
} RTFBIOSParameter; /* ! Must SYNC ! */

typedef ONE_BYTE_ALIGN_ADS  struct {
   BYTE BootCode[512-4*sizeof(RTFPartitionRecord)-sizeof(WORD)];
   RTFPartitionRecord PTable[4];
   WORD Signature;
} RTFMasterBootRecord; /* ! Must SYNC ! */

typedef ONE_BYTE_ALIGN_ADS struct {
   BYTE NearJump[3];
   RTFBIOSParameter BP;
   BYTE BootCode[512-3-sizeof(RTFBIOSParameter)-sizeof(WORD)];
   WORD Signature;
} RTFBootRecord; /* ! Must SYNC ! */

#if defined(WIN32)
#pragma pack()
#endif

// API functions

// General File I/O

RTTDLL RTFHANDLE RTFAPI RTFOpenFile(const WCHAR * FileName, DWORD Flags, RTFHANDLE handle, RTFDirLocation * DSR_Hint);
RTTDLL RTFHANDLE RTFAPI RTFOpen(const WCHAR * FileName, DWORD Flags);
RTTDLL RTFHANDLE RTFAPI RTFReopen(const WCHAR * FileName, DWORD Flags, RTFHANDLE handle);
RTTDLL RTFHANDLE RTFAPI RTFOpenHint(const WCHAR * FileName, DWORD Flags, RTFDirLocation * DSR_Hint);

RTTDLL int       RTFAPI RTFCloseFile(RTFHANDLE File, BYTE freeSlot);
#define RTFKEEPSLOT 0
#define RTFFREESLOT 1
RTTDLL int       RTFAPI RTFClose(RTFHANDLE File);
#define RTFSoftClose(File) RTFCloseFile(File, RTFKEEPSLOT)

RTTDLL int       RTFAPI RTFRead(RTFHANDLE File, void * DataPtr, UINT Length, UINT * Read);
RTTDLL int       RTFAPI RTFWrite(RTFHANDLE File, void * DataPtr, UINT Length, UINT * Written);
RTTDLL int      RTFAPI RTFSeek(RTFHANDLE File, int Offset, int Whence);
RTTDLL int       RTFAPI RTFExtend(RTFHANDLE File, DWORD Length);
RTTDLL int       RTFAPI RTFCommit(RTFHANDLE File);
RTTDLL int       RTFAPI RTFTruncate(RTFHANDLE File);

// Information about Files

RTTDLL int       RTFAPI RTFGetFileInfo(RTFHANDLE File, RTFFileInfo * FileInfo);
RTTDLL int       RTFAPI RTFGetFileSize(RTFHANDLE File, DWORD * Size);
RTTDLL int       RTFAPI RTFSetFileTime(RTFHANDLE File, const RTFDOSDateTime * Time);
RTTDLL int       RTFAPI RTFSetFileCreatedTime(RTFHANDLE File, const RTFDOSDateTime * Time);
RTTDLL int       MTCheckMSCard(RTFHANDLE File, RTFBootRecord *BR);

// File Attributes

RTTDLL int       RTFAPI RTFGetAttributes(const WCHAR * FileName);
RTTDLL int       RTFAPI RTFSetAttributes(const WCHAR * FileName, BYTE Attributes);

// Directories

RTTDLL int       RTFAPI RTFGetCurrentDir(WCHAR * DirName, UINT MaxLength);
RTTDLL int       RTFAPI RTFSetCurrentDir(const WCHAR * DirName);
RTTDLL int       RTFAPI RTFCreateDir(const WCHAR * DirName);
RTTDLL int       RTFAPI RTFRemoveDir(const WCHAR * DirName);
RTTDLL int       RTFAPI RTFCompactDir(const WCHAR * DirName, DWORD Flags);

// Finding Files

RTTDLL RTFHANDLE RTFAPI RTFFindFirstEx  (const WCHAR * NamePattern, BYTE Attr, BYTE AttrMask, RTFDOSDirEntry * FileInfo, WCHAR * FileName, UINT MaxLength);
RTTDLL int       RTFAPI RTFFindNextEx   (RTFHANDLE File, RTFDOSDirEntry * FileInfo, WCHAR * FileName, UINT MaxLength);
RTTDLL int       RTFAPI RTFFindClose(RTFHANDLE File);
RTTDLL int       RTFAPI RTFGetDiskInfoEx(const WCHAR * DriveName, RTFDiskInfo * DiskInfo, int Flags);

// File Name Operations

RTTDLL int       RTFAPI RTFRename(const WCHAR * FileName, const WCHAR * NewName);
RTTDLL int       RTFAPI RTFDelete(const WCHAR * FileName);
RTTDLL int       RTFAPI RTFMakeTempFileName(const WCHAR * DirName, WCHAR * FileName, UINT MaxLength);
RTTDLL int       RTFAPI RTFMakeFileName(const RTFDOSDirEntry * FileInfo, WCHAR * FileName);
RTTDLL int       RTFAPI RTFExpandName(WCHAR * FileName, UINT MaxLength);

// Disk and Volume Management

RTTDLL int       RTFAPI RTFResetDisk(const WCHAR * DriveName);
RTTDLL int       RTFAPI RTFGetDiskInfoEx(const WCHAR * DriveName, RTFDiskInfo * DiskInfo, int Flags);
RTTDLL int       RTFAPI RTFGetPartitionInfo(const WCHAR * DriveName, RTFPartitionInfo * PartitionInfo);
RTTDLL int       RTFAPI RTFSetVolumeLabel(const WCHAR * DriveName, const WCHAR * Label);
RTTDLL int       RTFAPI RTFFormat(const WCHAR * DriveName, UINT MinSectorsPerCluster, RTFFormatCallback Progress, DWORD Flags);
RTTDLL int       RTFAPI RTFCheckDiskBufferSize(const WCHAR * DriveName);
RTTDLL int       RTFAPI RTFCheckDisk(const WCHAR * DriveName, void * Buffer, UINT BufferSize, RTFCheckDiskCallback ErrorHandler, DWORD Flags);

RTTDLL int       RTFAPI RTFSanityCheck(void);
RTTDLL int       RTFAPI RTFClearDiskFlag(void);
RTTDLL int       RTFAPI RTFSetDiskFlag(void);

// Miscellaneous File Functions

RTTDLL int       RTFAPI RTFCommitAll(const WCHAR * DriveName);
RTTDLL int       RTFAPI RTFCloseAll(void);
RTTDLL int       RTFAPI RTFUnlockAll(void);
RTTDLL void      RTFAPI RTFShutDown(void);
RTTDLL RTFErrorAction RTFAPI RTFDefaultCriticalErrorHandler(WCHAR Drive, DWORD SerialNumber, int ErrorCode);
RTTDLL int       RTFAPI RTFCreateMasterBootRecord(void * SectorBuffer, const RTFPartitionRecord * DiskGeometry);
RTTDLL int       RTFAPI RTFSplitPartition(void * MasterBootRecord, RTFSector Sectors);
RTTDLL int       RTFAPI RTFCreateBootSector(void * BootSector, const RTFPartitionRecord * Partition, BYTE MediaDescriptor, UINT MinSectorsPerCluster, DWORD Flags);

// Raw I/O functions
RTTDLL int       RTFAPI RTFRawLowLevelFormat(int DeviceIndex, const WCHAR * DeviceName, RTFFormatCallback Progress, DWORD Flags);

// Functions for Debugging

RTTDLL void      RTFAPI RTFBufferInfo(RTFBufferStatistic * BufferInfo);

// Obsolete functions

RTTDLL RTFHANDLE RTFAPI RTFFindFirst(const WCHAR * NamePattern, BYTE Attr1, BYTE Attr2, RTFDOSDirEntry * FileInfo, WCHAR * FileName);
RTTDLL int       RTFAPI RTFFindNext (RTFHANDLE File, RTFDOSDirEntry * FileInfo, WCHAR * FileName);
RTTDLL int       RTFAPI RTFGetDiskInfo(const WCHAR * DriveName, RTFDiskInfo * DiskInfo);

#ifdef RTF_32_BIT
#ifdef RTT32_VER
#if RTT32_VER >= 202
RTTDDL RTFileSystemHandlers RTFilesFileSystem;
#endif
#endif
#endif

/* MTK Enhancement, Karen Hsu, ADD START */
/*************************************************/
/*------------- Internal EXTERN -------------*/
#define ParseFileName(FileName) ParseFileName1((const char *)FileName, (RTFHANDLE) NULL)

typedef enum { NotMounted, Initialized, Mounted, Accessible, HasFileSystem } MountStates;

typedef enum {NeverUsed, Available, Lfn, InUse} DirEntry;

typedef enum { NormalFile, FileMapFile, Volume, PhysicalDisk } FileKind;

#define SEARCH_FILES  0
#define SEARCH_LABEL  1
#define SEARCH_PARENT 2

#define RTF_BAD_CLUSTER       0x0FFFFFF7L
#define RTF_INVALID_CLUSTER   0xFFFFFFFFL
#define RTF_CLUSTER_CHAIN_END 0x0FFFFFF8L  // also 0x0FFFFFF9..0x0FFFFFFF, test for >=, write RTF_CHAIN_END_MARK
#define RTF_ROOT_DIR          0xFFFFFFFFL  // pseudo cluster for the root directory (not for FAT-32)

#define FIRST_FILE_CLUSTER(Dir)               (((RTFCluster)((Dir).FirstClusterHi) << 16) + (Dir).FirstCluster)
#define SET_FIRST_FILE_CLUSTER(Dir, Cluster)  (Dir).FirstCluster = (Cluster), (Dir).FirstClusterHi = (Cluster) >> 16
#define CLUSTER_BIT(ClusterMap, C)  ((ClusterMap[C / 8] & (1 << (C % 8))) != 0)
#define SET_CLUSTER_BIT(ClusterMap, C)    ClusterMap[C / 8] |= 1 << (C % 8)
#define CLEAR_CLUSTER_BIT(ClusterMap, C)    ClusterMap[C / 8] &= ~(1 << (C % 8))

#if defined(WIN32)
#pragma pack(1)
#endif
typedef ONE_BYTE_ALIGN_ADS struct {
   BYTE Ord;          // sequency number (backwards, 0x40 set if last record)
   WORD Name1[5];     // name chars 1..5
   BYTE Attributes;   // magic value
   BYTE Type;         // must be zero
   BYTE CheckSum;     // checksum of the short name
   WORD Name2[6];     // name chars 6..11
   WORD FirstCluster; // zero
   WORD Name3[2];     // name chars 12..13
} LFNDirEntry;
#if defined(WIN32)
#pragma pack()
#endif

RTTDDL RTFTables  gFS_Data; /* Move to custom, Karen Hsu, 2004/08/30 */
//RTTDDL RTFTables  RTFData;
RTTDDL const WCHAR dchar_dot[]; /* . */
RTTDDL const WCHAR dchar_dot_dot[]; /* .. */
RTTDDL const WCHAR dchar_start_dot_star[];
RTTDDL RTFMutex * RTFLock;

RTTDDL RTFMutex *MTFMLock;

RTTDDL RTFMutex *MTXLock;

#ifdef __FS_MOVE_SUPPORT__
RTTDDL RTFMutex *MTMoveLock;
#endif

RTTDDL RTFMutex *MTXdelLock;

#ifdef __FS_SORT_SUPPORT__
RTTDDL RTFMutex *MTSortLock;
#endif

#ifdef __FS_TRACE_SUPPORT__
RTTDDL RTFMutex *MTTraceLock;
#endif

RTTDDL int DrvMappingOld;
RTTDDL int DrvMappingNew;

RTTDLL int        RTFAPI SearchFile(RTFile * f, UINT Flags, const char * FileName, RTFDirLocation * DSR_Hint);
RTTDLL RTFile *   RTFAPI ParseFileName1(const char * FileName, RTFHANDLE File);
RTTDLL void       RTFAPI RTFInit(void);
RTTDLL void       RTFAPI DiscardAllBuffers(RTFDevice * Dev);
RTTDLL void       RTFAPI MountLogicalDrive(RTFDrive * Drive, MountStates State);
RTTDLL void       RTFAPI FlushAllBuffers(RTFDevice * Dev);
RTTDLL void       RTFAPI FreeFTSlot(RTFile * f);
RTTDLL RTFile *   RTFAPI ParseFileHandle(RTFHANDLE File);
RTTDLL int        RTFAPI WFNamesMatch(const char * N1, const char * N2);
RTTDLL RTFDOSDirEntry * RTFAPI GetDir(RTFDrive * Drive, const RTFDirLocation * Pos);
RTTDLL DirEntry   RTFAPI EntryType(const RTFDOSDirEntry * D);
RTTDLL int        RTFAPI LFNCharCount(const LFNDirEntry * LD);
RTTDLL void       RTFAPI CopyLFN(char * Name, const LFNDirEntry * LD);
RTTDLL RTFDOSDirEntry * RTFAPI NextDir(RTFDrive * Drive, RTFDirLocation * DSR);
RTTDLL int        RTFAPI MakeShortFileName(const RTFDOSDirEntry * FileInfo, char * FileName, UINT MaxLength);
RTTDLL void       RTFAPI FileNameExtendToWCHAR(char *filename);
RTTDLL WCHAR      RTFAPI wchartoupper(WCHAR c);
RTTDLL void       RTFAPI MakePseudoRootDirEntry(RTFDrive * Drive, RTFDirEntry * DirEntry);
RTTDLL void       RTFAPI InitFilePointer(RTFile * f);
RTTDLL RTFHANDLE  RTFAPI MakeNewFileHandle(RTFile * f);
RTTDLL void       RTFAPI FreeFTSlotAndDevice(RTFile * f);
RTTDLL void       RTFAPI UnlockDevice(RTFDevice * Dev);
RTTDLL BYTE       RTFAPI ShortNameCheckSum(const BYTE * Name);
RTTDLL int        RTFAPI FileNamesMatch(const WCHAR * p, const WCHAR * n);
RTTDLL void       RTFAPI DeleteDirEntry(RTFile * f);
RTTDLL void       RTFAPI UpdateDirEntry(RTFile * f);
RTTDLL void       RTFAPI ExtendFile(RTFile * f, DWORD Bytes);
RTTDLL void       RTFAPI CommitBuffer(RTFDevice * Dev);
RTTDLL RTFCluster RTFAPI GetClusterValue(RTFDrive * Drive, RTFCluster Cluster);
RTTDLL void       RTFAPI SetClusterValue(RTFDrive * Drive, RTFCluster Cluster, RTFCluster Value);

RTTDLL int        RTFAPI SafeLock(DWORD Lock, RTFDevice * Dev, UINT Timeout);
RTTDLL int        RTFAPI SafeUnlock(DWORD Lock);
RTTDLL void       RTFAPI CheckNotOpen(RTFile * File);
RTTDLL int        RTFAPI UpdateClusterWatermark(RTFDrive * Drive, RTFCluster Watermark, int DeltaFreeClusters);
RTTDLL int        RTFAPI RTFCheckDiskFlag(void);
RTTDLL void       RTFAPI CheckSharing(RTFile * File);
RTTDLL RTFCluster RTFAPI SafeGetClusterValue(RTFDrive * Drive, RTFCluster Cluster);
RTTDLL void       RTFAPI DelDirEntry(RTFDrive * Drive, RTFDirLocation * LongPos, const RTFDirLocation * Pos);
RTTDLL int        RTFAPI IsValidLongNameChar(WCHAR c);
RTTDLL RTFCluster RTFAPI FATDelete(RTFDrive * Drive, RTFCluster Cluster, RTFile * f);
RTTDLL int        RTFAPI FileNameInvalid(const char * Name);

/*------------- Internal Use -------------*/
typedef enum{
   MT_ENUM_FH_INVALID,
   MT_ENUM_FH_VALID,
   MT_ENUM_FH_MEDIACHANGED,
   MT_ENUM_FH_ABORTED,
   MT_ENUM_FH_EXPORTED
}MT_FH_ENUM;

//Device Flag (lower 16 bit only; higher 16 bit for driver)
#define MT_DEVICE_NOR_FLASH      0x0040
#define MT_DEVICE_NAND_FLASH     0x0080
#define MT_DEVICE_WRITE_PROTECT  0x0100
#define MT_DEVICE_NO_EXPORT      0x0200
#define MT_DEVICE_EXPORTING      0x0400
#define MT_DEVICE_EXTERNAL       0x0800
#define MT_DEVICE_SIMPLUS       0x1000
#define MT_DEVICE_MEMORY_STICK  0x4000
#define MT_DEVICE_CHECK_PART    0x8000

//Special for function
#define MT_LOCK_ALL              0x00000001           //SafeUnlockDevice
#define MT_LOCK_RTF              0x00000002           //SafeUnlockDevice
#define MT_LOCK_DEV              0x00000004           //SafeUnlockDevice
#define MT_LOCK_FMT              0x00000008           //SafeUnlockDevice
#define MT_LOCK_EXT              0x00000010           //SafeUnlockDevice
#define MT_LOCK_MOVE             0x00000020           //SafeUnlockDevice
#define MT_LOCK_XDEL             0x00000040           //SafeUnlockDevice
#define MT_LOCK_SORT             0x00000080           //SafeUnlockDevice
#define MT_LOCK_TRACE            0x00000100           //SafeUnlockDevice

//drive letter
#define MT_BASE_DRIVE_LETTER     'C'
#define MT_BASE_DRIVE_INDEX      0

//for sanity check
#define MT_CHECKDISK_MAX_DEPTH   10

/*------------- External Use -------------*/
#ifdef __FS_TRACE_SUPPORT__
#define MAX_TRACE_STR_LEN        128
#define MT_TRACE_TMP_LEN         1536
extern DWORD      g_TraceFlag;
extern char       TraceTmpBuf[MT_TRACE_TMP_LEN];
#endif

//Error Code Number
#define MT_SYSTEM_CRASH                -43            //for NAND Bad Block
#define MT_FAIL_GET_MEM                -44            //for get system memory failure
#define MT_READ_ONLY_ERROR             -45            //for access on read only error
#define MT_DEVICE_BUSY                 -46            //for look up device status
#define MT_ABORTED_ERROR               -47            //for abort copy
#define MT_QUOTA_OVER_DISK_SPACE       -48            //for quota management configure check
#define MT_PATH_OVER_LEN_ERROR         -49            //for longh path over 260
#define MT_APP_QUOTA_FULL              -50            //for quota management
#define MT_VF_MAP_ERROR                -51            //for virtual file feature
#define MT_DEVICE_EXPORTED_ERROR       -52            //for usb access in normal mode
#define MT_DISK_FRAGMENT               -53            //for RTF_Extend() user
#define MT_DIRCACHE_EXPIRED            -54            //for dir cache feature
#define MT_QUOTA_USAGE_WARNING         -55            //for quota management run time usage check

// Error codes that related to device driver feature or system/kernel adadption layer
#define MT_MSDC_MOUNT_ERROR            -100           //for MSDC only
#define MT_MSDC_READ_SECTOR_ERROR      -101           //for MSDC only
#define MT_MSDC_WRITE_SECTOR_ERROR     -102           //for MSDC only
#define MT_MSDC_DISCARD_SECTOR_ERROR   -103           //for MSDC only
#define MT_MSDC_PRESNET_NOT_READY      -104           //for MSDC only
#define MT_MSDC_NOT_PRESENT            -105           //for MSDC only

#define MT_EXTERNAL_DEVICE_NOT_PRESENT -106           //for USB OTG only

#define MT_FLASH_MOUNT_ERROR           -120           //for flash driver
#define MT_FLASH_ERASE_BUSY            -121           //for flash driver
#define MT_NAND_DEVICE_NOT_SUPPORTED   -122           //for flash driver

#define MT_LOCK_MUTEX_FAIL             -141
#define MT_NO_NONBLOCKMODE             -142
#define MT_NO_PROTECTIONMODE           -143

//Trace Code Number
#define MT_TRACE_QM_OK                 -500           //for Quota Feature only
#define MT_TRACE_QM_ERR                -501           //for Quota Feature only

//New API
RTTDLL int  RTFAPI MTGetDrive(DWORD Type, DWORD Serial, DWORD AltMask);
RTTDLL int  RTFAPI MTMappingDrive(DWORD UpperOldDrv, DWORD UpperNewDrv);
RTTDLL void RTFAPI MTSetTrace(DWORD Flag, DWORD Timeout);
RTTDLL void RTFAPI MTTraceFS(DWORD TaskId, DWORD FileCode, DWORD Line, int Code, RTFile * f, BYTE * TraceStr);
RTTDLL void * RTFAPI MTProxyGetBuffer (RTFDevice * Dev, RTFSector Sector);
RTTDLL int  RTFAPI MTCopyFileByClusterChain(RTFHANDLE FileDst, RTFCluster *ClustersArray, UINT ClusterNum);
RTTDLL UINT RTFAPI GetFirstSector(WCHAR * FileName, void * SectorContent, UINT *Sector1, UINT *Sector2);
RTTDLL int  RTFAPI SetCopyrightEntry(RTFDirLocation *lFS_CopyrightLongPos, RTFDirLocation *lFS_CopyrightShortPos, RTFDOSDirEntry *lFS_CopyrightDir);
RTTDLL void RTFAPI AdjustBuffer(void);
RTTDLL int  RTFAPI BatchCountFreeClusters(RTFDrive * Drive);
RTTDLL void RTFAPI MTGetDirCacheValue(RTFDrive * Drive, RTFCluster DirCluster, UINT *CurrValue);
RTTDLL void RTFAPI MTSetDirCacheValue(RTFDrive * Drive, RTFCluster DirCluster, UINT NewValue);
RTTDLL void RTFAPI MTExpireDirCacheValue(RTFDrive * Drive, RTFCluster DirCluster);
RTTDLL int  RTFAPI CleanUpDataSectors(RTFDrive * Drive, RTFCluster *Start, int MaxClusters);
RTTDLL void RTFAPI MTCheckSharingWithSpecialKindFh(RTFile * File);
RTTDLL void RTFAPI MTToLowerString(WCHAR *FileName, UINT MaxLength);
RTTDLL void RTFAPI MTCheckFileNameCase(WCHAR *FileName, UINT MaxLength, BYTE NTReserved);
RTTDLL WCHAR * RTFAPI TruncateWideWhiteSpacesAndPeriods(const WCHAR *pSrcBuf);

//MTGetDrive Parameter
#define MT_NO_ALT_DRIVE       0x00000001
#define MT_ONLY_ALT_SERIAL    0x00000002
#define MT_DRIVE_I_SYSTEM     0x00000004
#define MT_DRIVE_V_NORMAL     0x00000008
#define MT_DRIVE_V_REMOVABLE  0x00000010
#define MT_DRIVE_V_EXTERNAL   0x00000020
#define MT_DRIVE_V_SIMPLUS   0x00000040

//NTReserved for Find series
typedef enum{
   MT_ENUM_FIND_NONE,
   MT_ENUM_FIND_LFN,
   MT_ENUM_FIND_SFN,
   MT_ENUM_LOWERCASE_MARK = 0x08,
   MT_ENUM_EXT_LOWERCASE_MARK = 0x10
}MT_FIND_ENUM;

//MTSetTrace Parameter
#define MT_TRACE_API          0x00000001
#define MT_TRACE_ERROR        0x00000002
#define MT_TRACE_DISABLE      0x00000004
#define MT_TRACE_ALL_TASK     0x00000008

#ifdef __FS_QM_SUPPORT__

typedef struct __QuotaStruct
{
   BYTE        Path[RTF_MAX_PATH/2];
   UINT        Priority;
   UINT        Qmin;
   UINT        Qmax;
   UINT        Uint;
}QuotaStruct;

typedef struct __InternQuotaStruct
{
   UINT        Qmin;
   UINT        Qmax;
   UINT        Qnow;
}InternQuotaStruct;

typedef enum
{
   MT_QP_HIG_ENUM,
   MT_QP_MID_ENUM,
   MT_QP_LOW_ENUM,
   MT_QP_DEL_ENUM
}MT_QP_ENUM;

extern const QuotaStruct gFS_ExtQuotaSet[];
extern InternQuotaStruct gFS_IntQuotaSet[];
extern const UINT    FS_MAX_QSET;
extern WCHAR NvramName[6];

#endif

extern const UINT    FS_MAX_DRIVES;
extern const UINT    FS_MAX_FILES;
extern const UINT    FS_MAX_BUFFERS;
extern const UINT    FS_MAX_THREAD;
extern kal_taskid    gFS_TaskList[];

extern const int     gFS_DeviceNumOfSYSDRV;
extern const UINT    FS_MAX_CHECK_BUFFER;
extern BYTE          gFS_SanityCheckBuffer[];

extern int SysLockFAT; //for USB mode

extern int SysBlockFAT; //for single bank

extern int CardBusyCheck;

extern kal_bool COPYRIGHT_USB_ON;

/*************************************************/
/* MTK Enhancement, Karen Hsu, ADD END */

#ifdef  __cplusplus
}
#endif

#endif


