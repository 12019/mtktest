/*
 * Copyright (C) Obigo AB, 2002-2006.
 * All rights reserved.
 *
 * This software is covered by the license agreement between
 * the end user and Obigo AB, and may be 
 * used and copied only in accordance with the terms of the 
 * said agreement.
 *
 * Obigo AB assumes no responsibility or 
 * liability for any errors or inaccuracies in this software, 
 * or any consequential, incidental or indirect damage arising
 * out of the use of the software.
 *
 */

#ifndef _PRNG_H /* Prevent multiple inclusion */
#define _PRNG_H

#include "cstopt.h" /* For system-specific settings */
#include "prntypes.h" /* For u8, prng_inst, ... */

#include "msf_lib.h"	    /* For FILE */	/* LOKO 22/5 2002 */
/*loko#include "stdio.h"*/  /* For FILE */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define PRNG_EBASE (0x00500000) /* Module code */

#define PRNG_ENOMEM (PRNG_EBASE + 0x40000) /* Out of memory */
#define PRNG_ENOGEN (PRNG_EBASE + 0x40100) /* Table couldn't create prng */
#define PRNG_ESEEDF (PRNG_EBASE + 0x40200) /* Seed operation failed */
#define PRNG_EITERF (PRNG_EBASE + 0x40300) /* Iterate operation failed */
#define PRNG_EMODNF (PRNG_EBASE + 0x40400) /* Modulo operation failed */
#define PRNG_EGETRF (PRNG_EBASE + 0x40500) /* prng->get failed */
#define PRNG_EPARAM (PRNG_EBASE + 0x40600) /* Bad params (debug) */
#define PRNG_EPRIME (PRNG_EBASE + 0x40700) /* utmpm_ipp() failed */
#define PRNG_EHASHF (PRNG_EBASE + 0x40800) /* Message digest failed */
#define PRNG_EFILEF (PRNG_EBASE + 0x40900) /* Couldn't access file */
#define PRNG_ENTRNL (PRNG_EBASE + 0x40A00) /* Internal failure */
#define PRNG_EBSAFE (PRNG_EBASE + 0x40B00) /* BSAFE error */
/* Data:        <prngs>
 * Summary:     Array of supported prng algorithms
 * Description: The prngs array contains a pointer to the prng_alg structure
 *              corresponding to each of the supported prng algorithms.
 *              A specific prng algorithm structure can be obtained from
 *              prngs using ut_choose().
 */
extern const prng_alg *prngs[];


/* Function:    <prng_prng2u32>
 * Summary:     Generates 4 bytes of random data.
 * Syntax:      int rval = prng_prng2u32(u32 *dest, prng_inst *prng);
 * Description: The function writes 4 random bytes to memory at dest. The
 *              random data is generated by prng.
 * Returns:     This function returns 0 on success or -1 on failure due to
 *              problems with the prng.
 */

extern int 
CST32EXPORTTYPE CST16EXPORTTYPE
prng_prng2u32(u32 *, prng_inst *);


#ifdef WITH_prng_table
/* Function:    <prng_init_table>
 * Summary:     Modifies the seed table.
 * Syntax:      int rval = prng_init_table(u8 *input);
 * Description: The prng_init_table() function uses input and an R48 prng to
 *              modify the contents of the seed table. If no seed data is
 *              provided for a prng, the seed table is used to seed the prng.
 * Returns:     This function returns 0 on success or -1 on failure due to
 *              problems with the R48 prng.
 */

extern int 
CST32EXPORTTYPE CST16EXPORTTYPE
prng_init_table(u8 *);


/* Function:    <prng_read_table>
 * Summary:     Reads seed data from the seed table.
 * Syntax:      void rval = prng_read_table(void *buf, size_t len);
 * Description: The prng_read_table() function uses the seed table to generate
 *              len bytes of seed data. This data is written to memory at buf.
 * Returns:     void.
 */

extern void 
CST32EXPORTTYPE CST16EXPORTTYPE
prng_read_table(void *, size_t);
#endif /* WITH_prng_table */

#ifdef WITH_mpm
/* Function:    <prng_prng2mpm>
 * Summary:     Generates a random number in a given range.
 * Syntax:      prng_prng2mpm(md, dest_reg, lo_reg, hi_reg, prng);
 * Description: This routine loads register dest_reg in the machine mid with 
 *              a random number between lo_reg and hi_reg and generated by
 *              prng.
 * Errors:      Any failure results in a UT_ACONTINUE error message and a
 *              return of the value -1; success returns 0.
 */
extern int 
CST32EXPORTTYPE CST16EXPORTTYPE
prng_prng2mpm(void *, int, int, int, prng_inst *);
#endif /* WITH_mpm */

/*
 * Algorithm-specific declarations
 */

#ifdef WITH_prng_bbs

/* Function:    <prng_create_bbs>
 * Summary:     Creates a BBS pseudo-random number generator.
 * Syntax:      prng_inst *  rval = prng_create_bbs(u8 *);
 * Description: This function creates a Blum-Blum-Shub pseudo-random
 *              number generator and returns a pointer to it in rval.
 *
 *              The argument to prng_create_bbs() is a u8 * pointing to an 
 *              octet string encoding the generator's modulus in the 
 *              following way: the first two octets, modulus[0] and 
 *              modulus[1], indicate the length L of the modulus (most 
 *              significant octet first), and the following L octets encode 
 *              the modulus itself (again, most significant octet first). 
 *              The default modulus is (in hex):
 *           (code)
 *                              1 63e86691 cebb9b7c d42a477a f0f221d9
 *              fa5df16b 474dd685 b2d1169e ee9a954d 5e8ce969 e8c24c3a
 *              f2744680 4498c10e 112b7d4d c6fb35be dfe8107d 9481599d
 *              You can use the prng_bbs_generate_modulus() function to 
 *              generate a Blum-Blum-Shub modulus in the correct format. 
 *           (/code)
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_bbs(u8 *);

/* Data:        <prng_bbs>
 * Summary:     Function pointers for bbs prng routines
 * Notes:       The ut_choose() name for this structure is "Blum-Blum-Shub".
 */
extern const prng_alg prng_bbs;


/* Function:    <prng_bbs_generate_modulus>
 * Summary:     Creates a modulus for BBS generator.
 * Syntax:      ut_mblk *rval = prng_bbs_generate_modulus(unsigned len, 
 *                prng_inst *prng);
 * Description: The prng_bbs_generate_modulus() function generates a
 *              modulus of length len to use for the Blum-Blum-Shub random
 *              number generator. rval.data can be passed directly to
 *              prng_create_bbs() or prng_create_bbs_nonmt().
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               ut_dispose_mblk_f(rval);
 *           (/code)
 */
extern ut_mblk CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_bbs_generate_modulus(unsigned len, prng_inst *prng);

/* Function:    <prng_create_bbs_nonmt>
 * Summary:     Creates a non-threadsafe BBS generator.
 * Syntax:      prng_inst *  rval = prng_create_bbs_nonmt(u8 *);
 * Description: The prng_create_bbs_nonmt() function does exactly the same
 *              as prng_create_bbs(), except that the prng created has no
 *              critical section protection.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_bbs_nonmt(u8 *);


/* Data:        <prng_bbs_nonmt>
 * Summary:     Function pointers for bbs_nonmt prng routines
 * Notes:       The ut_choose() name for this structure is 
 *              "Blum-Blum-Shub-non-multithreaded".
 */
extern const prng_alg prng_bbs_nonmt;

#endif /* WITH_prng_bbs */

#ifdef WITH_prng_lcg

/* Function:    <prng_create_lcg>
 * Summary:     Creates an LCG pseudo-random number generator.
 * Syntax:      prng_inst *  rval = prng_create_lcg(u8 *);
 * Description: This function creates a Blum-Blum-Shub pseudo-random
 *              number generator and returns a pointer to it in rval.
 *
 *              LCG is a weak but fast pseudo-random number generator. It is 
 *              appropriate for padding algorithms. LCG works by choosing N, 
 *              a, c, and X0, then iterating Xi+1= (a Xi + c) mod N, 
 *              outputting Xi at each step.
 *              For efficiency, this implementation always uses a modulus N 
 *              = 2^B and an increment c = 1. You specify B and the 
 *              multiplier, a, although a is always modified so that a = 5 
 *              mod 8. If B is not a multiple of 8, the top (B mod 8) bits of 
 *              Xi will not be output.
 *
 *              The argument to prng_create_lcg() is a u8 * pointing to an 
 *              octet string encoding B and a in the following way: the 
 *              first two octets, modulus[0] and modulus[1], encode B (most 
 *              significant octet first), modulus[2] and modulus[3] indicate 
 *              the length L of a and the following L octets encode a itself 
 *              (again, most significant octet first).
 *
 *              The default size is 512 bits, with a multiplier of (in hex):
 *           (code)
 *                63e86691 cebb9b7c d42a477a f221d9fa
 *                5df16b47 4dd685b2 d1169eee 9a954d5e 8ce969e8 c24c3af2
 *                74468044 98c10e11 2b7d4dc6 fb35bedf e8107d94 81599d75
 *           (/code)
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_lcg(u8 *);

/* Data:        <prng_lcg>
 * Summary:     Function pointers for lcg prng routines
 * Notes:       The ut_choose() name for this structure is
 *              "linear-congruential".
 */
extern const prng_alg prng_lcg;

#endif /* WITH_prng_lcg */

#ifdef WITH_prng_r48

/* Function:    <prng_create_r48>
 * Summary:     Creates an R48 pseudo-random number generator.
 * Syntax:      prng_inst *  rval = prng_create_r48(u8 *);
 * Description: This function creates an R48 pseudo-random
 *              number generator and returns a pointer to it in rval.
 *
 *              This generator uses the same algorithm as LCG, but with B 
 *              fixed at 48, and a and c user-defined. It behaves similarly 
 *              to the popular rand48 generator. It is faster than LCG due 
 *              to the small modulus and optimised implementation but, as 
 *              with LCG, is not cryptographically secure. See 
 *              prng_create_lcg() for more details on the algorithm.
 *
 *              The argument to prng_create_r48() is a u8 * pointing to an 
 *              octet string encoding a and c as follows: the first six 
 *              octets (param[0..5]) describe a (most significant octet 
 *              first), and the next pair ( param[6] and param[7]) describe 
 *              c (which may only take on values in the range 
 *              [0, 216-1] as a result).
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_r48(u8 *);

/* Data:        <prng_r48>
 * Summary:     Function pointers for r48 prng routines
 * Notes:       The ut_choose() name for this structure is "R48".
 */
extern const prng_alg prng_r48;

/* Function:    <prng_create_r48_nonmt>
 * Summary:     Creates a non-threadsafe R48 generator.
 * Syntax:      prng_inst *  rval = prng_create_r48_nonmt(u8 *);
 * Description: The prng_create_r48_nonmt() function does exactly
 *              the same as prng_create_r48(), except that the
 *              pseudo-random number generator created has no 
 *              critical section protection.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_r48_nonmt(u8 *);


/* Data:        <prng_r48_nonmt>
 * Summary:     Function pointers for r48_nonmt prng routines
 * Notes:       The ut_choose() name for this structure is
 *              "R48-non-multithreaded".
 */
extern const prng_alg prng_r48_nonmt;

#endif /* WITH_prng_r48 */

#ifdef WITH_prng_hshf

/* Function:    <prng_create_hshf>
 * Summary:     Creates a hash file pseudo-random number generator.
 * Syntax:      prng_inst *  rval = prng_create_hshf(u8 *);
 * Description: This function creates a file-hashing pseudo-random
 *              number generator and returns a pointer to it in rval.
 *
 *              The argument to prng_create_hshf() is a u8 * pointing to an 
 *              octet string encoding the lead time in the first pair of 
 *              octets, the block size in the next pair (all numbers are, as 
 *              usual, encoded most significant octet first) and the 
 *              filename as a null-terminated string in the fifth and 
 *              subsequent octets. Each block of the file is hashed with
 *              RIPEMD-160. If the end of the file is reached the result
 *              of the previous hash is hashed repeatedly to give the output.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, call rval->get to obtain
 *              random output.
 *           
 *              The hshf generator has no default parameters, so 
 *              its create function cannot be called with a null (0) 
 *              argument. This is a difference between it and all the other
 *              supported prngs.
 *
 *              Only the data supplied to prng_create_hshf() is used
 *              to generate output data. Calls to rval->seed return 0
 *              (success) but have no effect on the internal state of
 *              the generator.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_hshf(u8 *);

/* Data:        <prng_hshf>
 * Summary:     Function pointers for hshf prng routines
 * Notes:       The ut_choose() name for this structure is "hash-file".
 */
extern const prng_alg prng_hshf;

#endif /* WITH_prng_hshf */

#ifdef WITH_prng_hshs

/* Function:    <prng_create_hshs>
 * Summary:     Creates a hash string pseudo-random number generator.
 * Syntax:      prng_inst *  rval = prng_create_hshs(u8 *);
 * Description: This function creates a string-hashing pseudo-random
 *              number generator and returns a pointer to it in rval.
 *
 *              The argument to prng_create_hshs() is a u8 * pointing to a 
 *              null-terminated string. The string is hashed repeatedly
 *              using RIPEMD-160.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, call rval->get to obtain
 *              random output.
 *
 *              Only the string supplied to prng_create_hshs() is used
 *              to generate output data. Calls to rval->seed return 0
 *              (success) but have no effect on the internal state of
 *              the generator.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_hshs(u8 *);


/* Data:        <prng_hshs>
 * Summary:     Function pointers for hshs prng routines
 * Notes:       The ut_choose() name for this structure is "hash-string".
 */
extern const prng_alg prng_hshs;

#endif /* WITH_prng_hshs */

#ifdef WITH_prng_fips186

/* Type:        <prng_fips186_type>
 * Summary:     Select type of the FIPS 186 prng.
 * Description: The prng_fips186_type type describes the required type
 *              of the FIPS 186 prng.
 *              - FIPS186_TYPE_KEY means that the prng will be used to
 *                generate DSA (or Diffie-Hellman) keys, as in FIPS 186 
 *                appendix 3.1, "Algorithm for computing m values of x".
 *                This also produces results compatible with ANSI X9.42,
 *                Annex C. This is the default value.
 *              - FIPS186_TYPE_NONCE means that the prng will be used to
 *                generate DSA nonces, as in FIPS 186 appendix 3.2,
 *                "Algorithm for computing one or more k and r values".
 *
 *              There are two differences between the two output types.
 *              - Some internal constants in the prng are initialized
 *                slightly differently depending on the type.
 *              - When the type is FIPS186_TYPE_NONCE, any calls to
 *                seed() the prng are ignored.
 */
typedef enum {
  FIPS186_TYPE_KEY,       /* for generating keys */
  FIPS186_TYPE_NONCE,     /* for generating nonces */
  FIPS186_TYPE_MAX
} prng_fips186_type;

/* Type:        <prng_fips186_core>
 * Summary:     Select core function for the FIPS 186 prng.
 * Description: The prng_fips186_core type describes the core
 *              randomising function (the G function) in the FIPS 186
 *              prng.
 *              - FIPS186_CORE_SHA means to use the compression function
 *                from SHA as the core, as in FIPS 186 appendix 3.3,
 *                "Constructing the function G from the SHA". This is
 *                the default value.
 *              - FIPS186_CORE_DES means to use DES as the core, as in
 *                FIPS 186 appendix 3.4, "Constructing the function G
 *                from the DES".
 */
typedef enum {
  FIPS186_CORE_SHA,
  FIPS186_CORE_DES,
  FIPS186_CORE_MAX
} prng_fips186_core;

/* Type:        <prng_fips186_params>
 * Summary:     Initial parameters for the FIPS 186 prng.
 * Description: The prng_fips186_params type provides configuration
 *              information for the FIPS 186 random number generator.
 *
 *              The type and core fields are described above. The xkey
 *              field contains a ut_mblk which contains a random
 *              seed-key. 
 *
 *              - If core == FIPS186_CORE_DES, then xkey->used MUST be
 *                20.
 *              - If core == FIPS186_CORE_SHA, then xkey->used may be
 *                any number between 20 and 64. This is a deviation from
 *                the letter of the standard, which allows XKEY to be
 *                any number of bits, rather than forcing it to be an
 *                integer number of bytes as we do here; but it is in
 *                conformance with the examples in FIPS 186 and ANSI
 *                X9.42, which use integer numbers of bytes.
 */

typedef struct prng_fips186_params_s {
  prng_fips186_type   type;
  prng_fips186_core   core;
  ut_mblk            *xkey;
} prng_fips186_params;

/* Function:    <prng_create_fips186>
 * Summary:     Creates a FIPS 186-style pseudo-random number generator.
 * Syntax:      prng_inst *rval = prng_create_fips186((u8 *) &params);
 * Description: This function creates a FIPS 186-style pseudo-random
 *              number generator and returns a pointer to it in rval.
 *
 *              The argument to prng_create_fips186() is a
 *              prng_fips186_params * cast to a u8 *. See the
 *              description of prng_fips186_params for more details.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output.
 *
 *              The FIPS 186 random number generator is defined to
 *              produce output in blocks of 20 bytes at a time. If
 *              you use rval->get() to get X bytes, where X is not
 *              divisible by 20, the generator is "cranked" often enough
 *              to provide the requested number of bytes and any surplus
 *              bytes from the final cranking are discarded.
 *
 *              rval->seed behaves differently according to the
 *              value of params->core.
 *              - If params->core == FIPS186_TYPE_KEY, the data passed
 *                to rval->seed() is split up into blocks of length
 *                params->xkey->used. Surplus data is discarded. Each
 *                time the generator is "cranked", the first remaining
 *                block of seed data is used as the XSEED for that round
 *                and then discarded. If there is no seed data left,
 *                that rounds XSEED is 0.
 *              - If params->core == FIPS186_TYPE_NONCE, any data passed
 *                to rval->seed() is ignored.
 * Example:     The following code gives an example of the use of this
 *              function. It instantiates a prng with the (20-byte)
 *              secret key "abcdefghijklmnopqrst", uses it to get 20
 *              bytes of random data using "ABCDEFGHIJKLMNOPQRST" as the
 *              XSEED, and then closes the prng.
 *           (code)
 *              prng_params    params;
 *              prng_inst     *prng;
 *              u8             outbuf[20];
 *              char           xkey[] = "abcdefghijklmnopqrst";
 *              char           xseed[] = "ABCDEFGHIJKLMNOPQRST";
 *              ut_mblk        keyblk = {(u8 *)xkey, 20, 20};
 *
 *              // set up params
 *              params.f186.type = FIPS186_TYPE_KEY;
 *              params.f186.core = FIPS186_CORE_SHA;
 *              params.f186.xkey = &keyblk;
 *
 *              // initialize prng
 *              prng = prng_create_fips186((u8 *) &params);
 *              if (!prng) 
 *                // handle error
 *
 *              // seed prng and get data
 *              if (prng->seed((void *) xseed, 20, prng))
 *                // handle error
 *              if (prng->get((void *) outbuf, 20, prng))
 *                // handle error
 *
 *              // shut down
 *              prng->destroy(prng);
 *           (/code)
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_fips186(u8 *params);


/* Data:        <prng_fips186>
 * Summary:     Function pointers for fips186 prng routines
 * Notes:       The ut_choose() name for this structure is "FIPS-186".
 */
extern const prng_alg prng_fips186;


/* Function:    <prng_create_fips186_nonmt>
 * Summary:     Creates a non-threadsafe FIPS 186 generator.
 * Syntax:      prng_inst *  rval = prng_create_fips186_nonmt(u8 *);
 * Description: The prng_create_fips186_nonmt() function does exactly
 *              the same as prng_create_fips186(), except that the
 *              pseudo-random number generator created has no 
 *              critical section protection.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       See prng_create_fips186().
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_fips186_nonmt(u8 *);


/* Data:        <prng_fips186_nonmt>
 * Summary:     Function pointers for fips186_nonmt prng routines
 * Notes:       The ut_choose() name for this structure is
 *              "FIPS-186-non-multithreaded".
 */
extern const prng_alg prng_fips186_nonmt;

#endif /* WITH_prng_fips186 */

#ifdef WITH_prng_intelisd

/* Function:    <prng_create_intelisd>
 * Summary:     Creates an interface to Intel Security Driver RNG.
 * Syntax:      prng_inst *rval = prng_create_intelisd((u8 *) 0);
 * Description: This function creates an interface to the Intel Security
 *              Driver hardware-based RNG returns a pointer to it in rval.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       This RNG does not make use of seed data; it simply discards
 *              it.
 *
 *              This RNG is entirely threadsafe.
 * Example:     The following code gives an example of the use of this
 *              function. It instantiates a prng, extracts 20 bytes of
 *              random data from it, and shuts it down.
 *           (code)
 *              prng_inst      *prng;
 *              u8              outbuf[20];
 *
 *              // initialize prng
 *              prng = prng_create_intelisd((u8 *)0);
 *              if (!prng) 
 *                // handle error
 *
 *              // get data
 *              if (prng->get((void *) outbuf, 20, prng))
 *                //handle error
 *
 *              // shut down
 *              prng->destroy(prng);
 *           (/code)
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_intelisd(u8 *dum);


/* Data:        <prng_intelisd>
 * Summary:     Function pointers for intelisd prng routines
 * Notes:       The ut_choose() name for this structure is "FIPS-186".
 */
extern const prng_alg prng_intelisd;

#endif /* WITH_prng_intelisd */

#ifdef WITH_prng_cesgrng

/* Type:        <prng_cesgrng_params>
 * Summary:     Initial parameters for the CESG Random Number Generator.
 * Description: The prng_cesgrng_params type provides configuration
 *              information for the CESG random number generator.
 *
 *              - The key field contains a ut_mblk which contains a random
 *                seed-key. This must be between 20 and 40 bytes in
 *                length.
 *              - The xlen field contains the length (in bits) of 
 *                additional data to be concatenated with the key before
 *                hashing. This number must be between 32 and 256, and
 *                must be a multiple of 8. See the description of
 *                prng_create_cesgrng() for more details, and for
 *                details of the always_seed field.
 *              - the shrdpub field contains a ut_mblk containing a
 *                set of DSA shared parameters. If this field is
 *                present, the output of the RNG will be reduced modulo
 *                q (the subprime in the DSA shared parameters). 
 *              - maxseedlen contains the maximum number of bytes of seed 
 *                data to be held inside the prng. If it is not an exact
 *                multiple of 1024 bytes, it is rounded up to the next
 *                multiple of 1024 bytes within prng_create_cesgrng().
 *                EXCEPTION: If maxseedlen is greater than or equal to
 *                (xlen/8) but less than 1024 it is left as specified,
 *                to allow the developer to save space.
 */

typedef struct prng_cesgrng_params_s {
  ut_mblk    *key;
  ut_mblk    *shrdpub;
  int         xlen;
  int         always_seed;
  size_t      maxseedlen;
} prng_cesgrng_params;

/* Function:    <prng_create_cesgrng>
 * Summary:     Creates a FIPS 186-style pseudo-random number generator.
 * Syntax:      prng_inst *rval = prng_create_cesgrng((u8 *) &params);
 * Description: This function creates a FIPS 186-style pseudo-random
 *              number generator and returns a pointer to it in rval.
 *
 *              The argument to prng_create_cesgrng() is a
 *              prng_cesgrng_params * cast to a u8 *. See the
 *              description of prng_cesgrng_params for more details.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output. When calling rval->get(), the output is
 *              reduced modulo q, where q is the subprime in the DSA
 *              shared parameters. The amount of data you request should
 *              be a multiple of the length of q. Currently, all
 *              implementations of DSA require q to be 160 bits in
 *              length, so when you call rval->get(), you should request a
 *              multiple of 20 bytes of data. If the requested length
 *              is not a multiple of the length of q, the leading 
 *              (requested length % q_len) bytes will be filled with 0s
 *              on a call to rval->get().
 *
 *              The random number generator produces output by
 *              combining the initial secret key with seed data. The
 *              seed data is read from a buffer which is filled up by
 *              successive calls to rval->seed(). If (params.always_seed)
 *              was set, there must be at least (params.xlen) bytes of
 *              unused data in the internal seed buffer on every call to
 *              rval->seed().
 *
 *              The precise details of the algorithm are confidential and
 *              may only be disclosed by arrangement. 
 *
 *              Note that if you have set params.always_seed to be
 *              nonzero on the call to prng_create_cesgrng(), then there
 *              must be sufficient unused data in the internal seed
 *              buffer on every call to rval->get(). If there are less than
 *              params.xlen bytes in the internal seed buffer,
 *              rval->get() will return 1. This indicates that you must
 *              call rval->seed() before any calls to rval->get() will
 *              succeed.
 *
 * Example:     The following code gives an example of the use of this
 *              function. It instantiates a prng with the (24-byte)
 *              secret key "abcdefghijklmnopqrstuvwx", seeds it with the
 *              data "ABCDEFGHIJKLMNOPQRST", and carries on extracting
 *              random data from it until we run out of seed data, when
 *              it closes. We write output to stdout while it is
 *              available. Note that if we had set params.cesg.always_seed
 *              to be 0 this code would run forever.
 *
 *              We assume that a DSA shared parameters block is
 *              available in the ut_mblk shrdpub -- see
 *              bsapi_generate_sharedparams_dsa() for details.
 *           (code)
 *              prng_params     params = {0};
 *              prng_inst      *prng;
 *              u8              outbuf[20];
 *              char            xkey[] = "abcdefghijklmnopqrstuvwx";
 *              char            xseed[] = "ABCDEFGHIJKLMNOPQRST";
 *              ut_mblk         keyblk = {(u8 *)xkey, 24, 24};
 *              int             iLoop = 0;
 *              int             done = 0;
 *
 *              // set up params
 *              params.cesg.key = &keyblk;
 *              params.cesg.shrdpub = &shrdpub;
 *              params.cesg.xlen = 32;  // given in bits, not bytes
 *              params.cesg.always_seed = 1;
 *              // params.cesg.maxseedlen defaults to 1024 bytes.
 *
 *              // initialize prng
 *              prng = prng_create_cesgrng((u8 *) &params);
 *              if (!prng) 
 *                // handle error
 *
 *              // seed prng
 *              if (prng->seed((void *) xseed, 20, prng))
 *                // handle error
 *              
 *              // get data while allowed to
 *              while (done == 0) {
 *                switch (prng->get((void *) outbuf, 20, prng)) {
 *
 *                  // success!
 *                  case 0:
 *                    fwrite (outbuf, sizeof (u8), 20, stdout);
 *                    break;
 *
 *                  // internal error!
 *                  case -1:
 *                  default:
 *                    ut_log0(0UL, UT_ACONTINUE, "internal error");
 *                    // handle error
 *                    done = 1;
 *                    break;
 *
 *                  // out of seed data
 *                  case 1:
 *                    ut_log0(0UL, UT_ACONTINUE, "out of seed data"
 *                      "please call prng->seed()");
 *                    done = 1;
 *                    break;
 *                }
 *              }
 *
 *              // shut down
 *              prng->destroy(prng);
 *           (/code)
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_cesgrng(u8 *params);


/* Data:        <prng_cesgrng>
 * Summary:     Function pointers for cesgrng prng routines
 * Notes:       The ut_choose() name for this structure is "FIPS-186".
 */
extern const prng_alg prng_cesgrng;

#endif /* WITH_prng_cesgrng */

#ifdef WITH_prng_nullprng

/* Function:    <prng_create_nullprng>
 * Summary:     Creates a dummy pseudo-random number generator.
 * Syntax:      prng_inst *  rval = prng_create_nullprng(u8 *);
 * Description: This function creates an dummy pseudo-random
 *              number generator and returns a pointer to it in rval.
 *
 *              The dummy prng can be seeded once. Thereafter, it
 *              responds to calls to the rval->get() method by returning the
 *              value it was seeded with, repeated as often as necessary
 *              to fill up the buffer provided to rval->get().
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_nullprng(u8 *);

/* Data:        <prng_nullprng>
 * Summary:     Function pointers for nullprng prng routines
 * Notes:       The ut_choose() name for this structure is "Dummy-RNG".
 */
extern const prng_alg prng_nullprng;

/* Function:    <prng_create_nullprng_nonmt>
 * Summary:     Creates a non-threadsafe DUMPRNG generator.
 * Syntax:      prng_inst *  rval = prng_create_nullprng_nonmt(u8 *);
 * Description: The prng_create_nullprng_nonmt() function does exactly
 *              the same as prng_create_nullprng(), except that the
 *              pseudo-random number generator created has no 
 *              critical section protection.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *               rval->destroy(rval);
 *           (/code)
 * Notes:       After calling this function, use rval->seed() to seed
 *              the random number generator and rval->get() to obtain
 *              random output.
 */
extern prng_inst CST32EXPORTTYPE *  CST16EXPORTTYPE
    prng_create_nullprng_nonmt(u8 *);


/* Data:        <prng_nullprng_nonmt>
 * Summary:     Function pointers for nullprng_nonmt prng routines
 * Notes:       The ut_choose() name for this structure is
 *              "DUMPRNG-non-multithreaded".
 */
extern const prng_alg prng_nullprng_nonmt;

#endif /* WITH_prng_nullprng */

/* Type:        <prng_params>
 * Summary:     Union of parameters for prng algorithms
 */
typedef union prng_param_u {
#ifdef WITH_prng_cesgrng
  prng_cesgrng_params   cesg;
#endif
#ifdef WITH_prng_fips186
  prng_fips186_params   f186;
#endif
  char pad;          /* provided so we never have an empty union */
} prng_params;


#ifdef WITH_prng_entpoll

/* Entropy polling routines */

#define SIMPLE_ENTROPY_POLL_LENGTH  (20)


/* Type:        <prng_entropy_poller>
 * Summary:     Used to generate random bytes of data
 * Notes:       See prng_create_system_entropy_poller(), 
 *              prng_simple_poll_system_entropy() and 
 *              prng_destroy_system_entropy_poller().
 */
typedef void *prng_entropy_poller;

/* Type:        <prng_entropy_poller_algn>
 * Summary:     Type of entropy poller (default or debug) being used
 * Notes:       See prng_entropy_poller_params.
 */
typedef enum {
  PRNG_ENTROPY_POLLER,
  PRNG_ENTROPY_POLLER_DEBUG
} prng_entropy_poller_algn;

/* Used in fileFlags field of prng_entropy_poller_params */

#define ENTPOLL_FFLAGS_COMBINE      (0)
#define ENTPOLL_FFLAGS_FILEFIRST    (1)

#define ENTPOLL_FFLAGS_NOOVERWRITE  (0)
#define ENTPOLL_FFLAGS_OVERWRITE    (2)

/* Type:        <prng_entropy_poller_params>
 * Summary:     Entropy poller parameters structure
 * Description: The default system entropy poller takes no parameters.
 *              The debug entropy poller takes as parameters a char *,
 *              filename. The debug system entropy poller writes the raw
 *              data to this file so that independent statistical tests
 *              may be run on it.
 *
 *              In addition to polling the system for entropy, the entropy
 *              poller will read entropy from a file if a pointer to one is
 *              provided in entFile. This FILE * must have been
 *              opened in mode "rb" or "r+b". If the file cannot be read
 *              from, or if the pointer does not point to the start of 
 *              the file, the function will return 0.
 *
 *              The fileFlags field is only read if entfile is nonzero.
 *              The flags have the following meanings:             
 *              - ENTPOLL_FFLAGS_OVERWRITE: The entropy poller will erase 
 *                data from the file as it reads it. For this to happen,
 *                params->entFile must have been opened in mode "r+b".
 *                If the file cannot be written to, the function will
 *                return 0.
 *              - ENTPOLL_FFLAGS_FILEFIRST: The entropy poller will
 *                return only the data from the file while there is still
 *                data to be read. If this flag is not set, the entropy
 *                poller will XOR the data from the file with the system
 *                entropy it gathers.
 */
typedef struct prng_entropy_poller_params_s {
  prng_entropy_poller_algn    number;
  FILE                       *entFile;
  u32                         fileFlags;
  union {
    struct {
      const char *filename;
    } debug;
    int dummy;
  } alg;
} prng_entropy_poller_params;


/* Function:    <prng_create_system_entropy_poller>
 * Summary:     Creates a a system entropy poller.
 * Syntax:      prng_entropy_poller rval = prng_create_system_entropy_poller 
 *                (prng_entropy_poller_params *params);
 * Description: The prng_create_system_entropy_poller() function creates
 *              a system entropy poller using the parameters in params.
 *              The default system entropy poller takes no parameters
 *              and can be specified by setting params = 0, or by
 *              setting params->number = PRNG_ENTROPY_POLLER.
 *
 *              Setting params->number = PRNG_ENTROPY_POLLER_DEBUG
 *              instantiates the debug system entropy poller. This takes
 *              as parameters a char *, filename. The debug system
 *              entropy poller writes the raw data to this file so that
 *              independent statistical tests may be run on it.
 *
 *              In addition to polling the system for entropy, the entropy
 *              poller will read entropy from a file if a pointer to one is
 *              provided in params->entFile. This FILE * must have been
 *              opened in mode "rb" or "r+b". If the file cannot be read
 *              from, or if the pointer does not point to the start of 
 *              the file, the function will return 0.
 *
 *              The params->fileFlags field is only read if
 *              params->entFile is nonzero. The flags have the
 *              following meanings:
 *              - ENTPOLL_FFLAGS_OVERWRITE: The entropy poller will erase 
 *                data from the file as it reads it. For this to happen,
 *                params->entFile must have been opened in mode "r+b".
 *                If the file cannot be written to, the function will
 *                return 0.
 *              - ENTPOLL_FFLAGS_FILEFIRST: The entropy poller will
 *                return only the data from the file while there is still
 *                data to be read. If this flag is not set, the entropy
 *                poller will XOR the data from the file with the system
 *                entropy it gathers.
 *
 *              On successful completion, this function returns a pointer 
 *              to the created entropy poller.
 * Memory:      Dispose of the memory allocated by this function
 *              as follows:
 *           (code)
 *              prng_destroy_system_entropy_poller (rval);
 *           (/code)
 * Notes:       This function fails (returning 0) on non-Win32 systems.
 *
 *              See prng_simple_poll_system_entropy() for further
 *              discusson of the use of entFile.
 */
extern prng_entropy_poller
prng_create_system_entropy_poller (prng_entropy_poller_params *params);


/* Function:    <prng_simple_poll_system_entropy>
 * Summary:     Polls the system for entropy.
 * Syntax:      int rval = prng_simple_poll_system_entropy(
 *                prng_entropy_poller poller, u8 *buf);
 * Description: The prng_simple_poll_system_entropy() function extracts
 *              system information from various sources it, hashes it
 *              with SHA-1, and places it in the buffer at buf.
 *              SIMPLE_ENTROPY_POLL_LENGTH bytes of memory must have
 *              been allocated at buf.
 *
 *              If poller is the debug entropy poller, the raw system
 *              information (before hashing) is written to 'filename',
 *              where filename is the parameter supplied in params to
 *              the call to prng_create_system_entropy_poller.
 *
 *              If the entFile provided to
 *              prng_create_system_entropy_poller() was nonzero, the
 *              function reads SIMPLE_ENTROPY_POLL_LENGTH bytes of data
 *              from the file and XORs them with the system entropy it
 *              obtained. If it cannot read this many bytes, it closes
 *              the file and does not attempt to read from it again.
 * Returns:     This function returns 0 on success, or -1 on failure.
 * Memory:      This function allocates no memory.
 * Notes:       This function fails (returning -1) on non-Win32 systems.
 */
extern int
prng_simple_poll_system_entropy(prng_entropy_poller poller, u8 *buf);


/* Function:    <prng_destroy_system_entropy_poller>
 * Summary:     Shuts down a system entropy poller.
 * Syntax:      prng_destroy_system_entropy_poller(prng_entropy_poller poller);
 * Description: The prng_destroy_system_entropy_poller() function
 *              disposes of a prng_entropy_poller object created by
 *              prng_create_system_entropy_poller(). If a FILE * was
 *              provided to prng_create_system_entropy_poller, and if
 *              this file is still open,
 *              prng_destroy_system_entropy_poller() closes it.
 * Memory:      This function allocates no memory.
 */
extern void
prng_destroy_system_entropy_poller(prng_entropy_poller poller);

#endif /* def WITH_prng_entpoll */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* not _PRNG_H */
