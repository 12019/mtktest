/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * tst_def.h
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *   This file provides typedefs and definiton for PS index trace.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef _TST_DEF_H
#define _TST_DEF_H


#ifndef _KAL_TRACE_H
#error  "kal_trace.h shold be included before tst_def.h"
#endif

#ifndef _GV1_H
#error  "gv.h shold be included before tst_def.h"
#endif

#ifdef __EM_MODE__
#ifndef _EM_STRUCT_H
#include "em_struct.h"
#endif
#ifdef __PS_SERVICE__
#if 0
#ifndef  _GPRS_FLC_KAL_DATA_TYPES_H
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* END OF _GPRS_FLC_KAL_DATA_TYPES_H */
#endif /*0*/
#endif /* END OF __PS_SERVICE__*/
#endif

#include "stack_buff_pool.h"
#include "tst_buff_pool.h"
#include "uart_sw.h"
#include "stack_timer.h"
#include "init.h"
#include "tst_ext.h"

extern kal_eventgrpid	tst_event_group;
#define TST_EVENT_WRITE_OK   0x01
#define TST_EVENT_SYNC       0x02
#define TST_EVENT_IRCOMM     0x04
#define TST_EVENT_LOGMSG     0x08
#define TST_EVENT_KDWPHOOK   0x10
#define TST_EVENT_LOG_IDLE   0x20
#define TST_EVENT_PORT_NOT_SWITCHING  0x40
#define TST_EVENT_PORT_NOT_USING      0x80
#define TST_EVENT_CTI_TO_LOG 0x0100

#if defined(FORCE_TST_RING_BUFFER_SCALE)
#define TST_RING_BUFFER_SIZE (1<<FORCE_TST_RING_BUFFER_SCALE)
#elif defined(UNIT_TEST)
#define TST_RING_BUFFER_SIZE (1<<20)
#elif defined(NEPTUNE_BB) || defined(NEPTUNE_BW_BB) || defined(LOW_COST_SUPPORT)
#define TST_RING_BUFFER_SIZE (1<<13)
#elif defined(__WCDMA_RAT__)
/* under construction !*/
#else
#define TST_RING_BUFFER_SIZE (1<<15)
#endif


//extern UART_PORT   TST_PORT;
extern UART_PORT   tst_L1Trc_port;
extern UART_PORT   tst_PsTrc_port;
extern UART_PORT   tst_rx_port;
//extern UART_flowCtrlMode tst_flowCtrlMode;
extern UART_flowCtrlMode tst_l1_flowCtrlMode;
extern UART_flowCtrlMode tst_ps_flowCtrlMode;
extern UART_baudrate tst_L1Trc_baudrate;
extern UART_baudrate tst_PsTrc_baudrate;
extern kal_bool  tst_is_L1Trc_open;
extern kal_bool  tst_is_PsTrc_open;
//extern kal_bool  tst_is_uart_open;
extern kal_bool  tst_is_l1_writing_uart;/*protect UART Port from closing while writing*/
extern kal_bool  tst_is_ps_writing_uart;/*protect UART Port from closing while writing*/

/*for close/open UART port in run time*/
extern kal_bool tst_is_uart_open;
extern kal_bool  tst_is_writing_uart;

#ifndef TST_BEFORE_COST_DOWN_ARCH
/*for COST DOWN ARCH*/
extern kal_uint8  tst_ring_buffer[];
extern kal_uint32 tst_ptr_buffer_start;
extern kal_uint32 tst_ptr_buffer_end;
#endif 

#ifdef TST_BEFORE_COST_DOWN_ARCH
/*for arch before COST DOWN ARCH*/
extern kal_uint32  tst_lost_primitive;
extern kal_uint32  tst_lost_trace;
extern kal_uint32  tst_lost_em_data;
#endif

#define  MSG_ID_LOGGED_PRIMITIVE          0x0001
#define  MSG_ID_PS_INDEX_TRACE            0x0002
#define  MSG_ID_PROMPT_TRACE              0x0003
#define  MSG_ID_SYSTEM_TRACE              0x0004
#define  MSG_ID_READ_VARIABLE			  0x0005
#define  MSG_ID_SIM_REPORT				  0x0006
#define  MSG_ID_EXCEPTION_REPORT          0x0007
#define  MSG_ID_STATISTIC_REPORT          0x0008
#define  MSG_ID_READ_MEMORY               0x0009
#define  MSG_ID_VRT												0x000A
#define	 MSG_ID_VRSAMPLE_IND							0x000B
#define	 MSG_ID_QUERY_MEMORY_RANGE				0x000C
 
 
#define TST_MUX_BUFFER_SIZE 256

#define  INJECT_STRING_TO_MODULE_MAX_LENGTH  (128)
#define  INJECT_AT_COMMAND_MAX_LENGTH        (128)

#ifndef UNIT_TEST
#define  MAX_TST_RECEIVE_BUFFER_LENGTH       256
#else
#define  MAX_TST_RECEIVE_BUFFER_LENGTH       (64*1024-1)
/*950105: In Monza, a frame may exceed the length of 32k,
 and TSTR should copy a whole frame (to tst_rcv_buf) one time from CShare in MNT.
 So, change it to 64KB.
*/
#endif  /* UNIT_TEST */

#define   MUX_KEY_WORD		    0x5A
#define   SOFT_FLOW_CTRL_BYTE   0x77

#define  ESC_NOT_DETECT 0
#define  ESC_DETECT     1


//RX
#define  RS232_LOGGED_PRIMITIVE_TYPE   0x60
#define  RS232_PS_TRACE_TYPE           0x61
#define  RS232_PS_PROMPT_TRACE_TYPE    0x62
#define  RS232_COMMAND_TYPE_OCTET      0x63
#define  RS232_INJECT_PRIMITIVE_OCTET  0x64
#define  RS232_INJECT_UT_PRIMITIVE     0x65


//TX
/* defined in kal_trace.h
#define LOGGED_PRIMITIVE_TYPE       0x60
#define PS_TRACE_INDEX_TRACE_TYPE   0x61
#define PS_PROMPT_TRACE_TYPE        0x62
#define CONTROL_COMMAND_TYPE        0x63
#define INJECT_PRIMITIVE_TYPE       0x64
#define SYS_TRACE_TYPE              0x65
*/
#define  RS232_READ_VARIABLE_RETURN    0x66
#define  RS232_EM_DATA				   0x67
#define  RS232_SIM_DATA				   0x68
#define  RS232_EXCEPTION_DATA          0x69
#define  RS232_STATISTIC_DATA          0x70
#define  RS232_WAP_TRACE               0x71
#define  RS232_READ_MEMORY_REPORT      0x72
#define  RS232_VRT_DATA                0x73
#define  RS232_QUERY_MEMORY_RANGE      0x74
#define  RS232_QUERY_SOFT_FC_CHAR      0x75
#define  RS232_KDWP_PACKET             0x76
#define  RS232_CTI_PACKET              0x77
#define  RS232_REPORT_VERSION          0x78
#define  RS232_PS_RAWDATA_TRACE_TYPE   0x79
#define  RS232_PS_RAWDATA_TRACE2_TYPE  0x7A
#define  RS232_UBDB_RESPONSE           0x7B
#define  RS232_GDI_SNAPSHOT            0x7C
#define  RS232_SLEEP_MODE_RESPONSE     0x7D
#define  RS232_FILE_TRANSFER_REPORT    0x7E
#define  RS232_DYNAMIC_STACK_STATISTICS  0x7F
#define  RS232_ST_REPORT               0x80
#define  RS232_MA_SYS_TRACE_TYPE       0x81
#define  RS232_SIMPLE_ACK_TYPE         0x82
#define  RS232_VIRTUAL_CHANNEL         0x83
#define  RS232_PRIMITIVE_3G_CPHY_CONTAINER_TYPE       0x84
// TX ==>


/* Define the rs232 frame states */
#define  RS232_FRAME_STX               0
#define  RS232_FRAME_LENHI             1
#define  RS232_FRAME_LENLO             2
#define  RS232_FRAME_TYPE              3
#define  RS232_FRAME_COMMAND_DATA      4
#define  RS232_FRAME_COMMAND_HEADER    5
#define  RS232_FRAME_CHECKSUM          6
#define  RS232_FRAME_INJECT_PIRIMITIVE_HEADER 7
#define  RS232_FRAME_PRIM_LOCAL_PARA_DATA 8
#define  RS232_FRAME_PRIM_PEER_DATA    9
#define  RS232_FRAME_UT_DATA				10
#define  RS232_FRAME_KEYWORD			11
#define  RS232_FRAME_SOFT_CTRL         12

#define  STX_OCTET            0x55

#define  TST_ACCESS_EXCEPTION   1
#define  TST_ACCESS_STATISTIC   2



#define TST_MODULE_FILTER_LEN		((END_OF_MOD_ID+7)/8)

#define TST_SAP_FILTER_LEN			(LAST_SAP_CODE+1)

#define TST_TRACE_FILTER_LEN		(2*(END_OF_MOD_ID+1))


#define TST_TOTAL_FILTER_LEN    (TST_MODULE_FILTER_LEN+\
											TST_SAP_FILTER_LEN+\
											TST_TRACE_FILTER_LEN)
											

#define TST_TIMER_ID_POOL_QUERY 0
#define TST_TIMER_ID_PSLOG_IDLE 1

typedef enum
{
	TST_NULL_COMMAND,
	TST_LOG_ON_OFF,
	TST_SET_PRIM_MOD_FILTER,
	TST_SET_PRIM_SAP_FILTER,
	TST_SET_PS_TRC_FILTER,
	TST_SET_L1_TRC_FILTER,
	TST_INJECT_STRING_TO_MODULE,
	TST_INJECT_AT_CMD,
	TST_REBOOT_TARGET_CMD,
	TST_SET_TRAP_FILTER,
	TST_READ_GLOBAL_VARIABLE,
	TST_WRITE_GLOBAL_VARIABLE,
	TST_EM_MODE_CONFIG,
	TST_SIM_FILE_INFO_REQ,
	TST_SIM_READ_REQ,
	TST_SIM_WRITE_REQ,
#ifdef __GEMINI__
  TST_SIM_2_FILE_INFO_REQ,
	TST_SIM_2_READ_REQ,
	TST_SIM_2_WRITE_REQ,
#endif //#ifdef __GEMINI__
	TST_FT_MODE_CONFIG,
	TST_NVRAM_EXCEPTION_CMD,
	TST_READ_MEMORY_ADDR_CMD,
    TST_NVRAM_STATISTIC_CMD,
#if defined(__PS_SERVICE__) && defined (__EM_MODE__) && 0
/* under construction !*/
#endif
	TST_QUERY_MEMORY_RANGE_CMD,
	TST_FORCE_ASSERT_CMD,

#ifdef VOICE_RECOGNITION_TEST	
	TST_VRT_CMD = 0x32, 
#endif		

  TST_SET_DSP_FILTER_CMD = 0x33,
  TST_QUERY_SOFT_FC_CHAR_CMD,
  TST_KDWP_RECV_CMD,
  TST_KDWP_CONTROL_CMD,
  TST_FLUSH_SWDBG_CMD,
  TST_CTI_COMMAND_CMD,
	TST_WRITE_MEMORY_CMD,
	
	TST_GDI_SNAPSHOT_CMD,
	TST_SLEEP_MODE_CMD,
	TST_FILE_TRANSFER_CMD,

	TST_CONFIG_SWLA_CMD,
	TST_ST_START_CMD,
	TST_ST_STOP_CMD,
	TST_SET_TRAP_MSG_CMD,
	TST_REBOOT_FOR_MMI_AUTO_TEST_CMD,
	TST_UBDB_CMD,
	TST_SET_3G_FILTER_CMD,
	TST_VC_CMD,
	TST_SIMPLE_CMD,	
	TST_COMMAND_TYPE_LAST_CMD

}
tst_command_type;

typedef struct
{
    kal_uint8   dummy;    
}
tst_command_type_last_cmd_struct;


typedef struct
{
    void        *address;
    kal_uint32  length;
    kal_uint8   token;    
}
tst_read_memory_addr_cmd_struct;

typedef struct
{
    void        *address;
    kal_uint32  length;
    kal_uint8   data[1];
}
tst_write_memory_cmd_struct;

typedef struct
{
    kal_uint32  token;
}
tst_gdi_snapshot_cmd_struct;
	
typedef struct
{
    kal_uint32  token;
    kal_uint8   cmd;
}
tst_sleep_mode_cmd_struct;


typedef struct
{   
    kal_uint32  token;
    kal_uint32  start_address; //if 0xFFFFFFFF => to delete the file
    kal_uint32  buf_length;
    kal_uint8   buf[1];	// full path
}
tst_file_transfer_cmd_struct;
typedef struct
{
	  kal_uint8   token;
	  kal_uint8   command; //0: db_reset, 1:db_write, 2:db_read, 3:db_delete
	                       //4: db_snap, 5:db_exist
    kal_uint16  length;
    kal_uint8   buf[1];
}
tst_ubdb_cmd_struct;

typedef struct {
  kal_uint16 filter;
}
tst_set_3g_filter_cmd_struct;

typedef struct
{
   kal_uint8     token;
   kal_uint8     command;
   kal_uint16     length;
}
tst_ubdb_response_header_struct;

typedef struct
{
   kal_uint8     token;
   kal_uint8     command;
   kal_uint16     length;
   kal_uint8     buf[1];
}
tst_ubdb_response_struct;

typedef struct
{   
    kal_uint32  token;
    kal_uint8   mode;	// 0: assert when tst ring buffer is full, 
                      // 1: when the rest of tst ring buffer is under the threshold, call SLA_TriggerLogging
                      // 2. disable both
    kal_uint8    threshold;
}
tst_config_swla_cmd_struct;


typedef struct
{   
    kal_uint32  address_softLA;
    kal_uint32  length_softLA;
    kal_uint32	ptr_softLA;
    kal_uint32	noOfSystemElement;
    kal_uint32	noOfDspElement;
    kal_uint32	noOfMcuElement;
}
tst_query_memory_range_report_header_struct;

typedef struct
{   
    kal_uint32  address_softLA;
    kal_uint32  length_softLA;
    kal_uint32	ptr_softLA;
    kal_uint32	noOfSystemElement;
    kal_uint32	noOfDspElement;
    kal_uint32	noOfMcuElement;
    kal_uint32	buf[1];
}
tst_query_memory_range_report_struct;

typedef struct
{   
    kal_uint32  fc_chars;
}
tst_query_soft_fc_char_report_struct;

typedef struct
{   
    kal_uint8   token;
    kal_uint8   encoded; //0 for not encoded, 1 for encoded with RLE
    const void  *address;
    kal_uint32  length;
    
}
tst_read_memory_addr_report_header_struct;

typedef struct
{   
    kal_uint8  token;
    kal_uint8  encoded; //0 for not encoded, 1 for encoded with RLE
    const void *address;
    kal_uint32 length;
    kal_uint8  buf[1];
}
tst_read_memory_addr_report_struct;

typedef struct
{   
    kal_uint32  frame_number;
    kal_uint32  time_stamp;
    #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
    #endif
	  kal_uint32  token;
    kal_uint16  status;
    kal_uint8   layer_count;
    kal_uint8   drive_index;
    kal_uint16  clip_index;
    kal_uint32  clip_length;
}
tst_gdi_snapshot_report_header_struct;

typedef struct
{   
    kal_uint32  frame_number;
    kal_uint32  time_stamp;
    #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
    #endif
	  kal_uint32  token;
    kal_uint16  status;
    kal_uint8   layer_count;
    kal_uint8   drive_index;
    kal_uint16  clip_index; //0xFFFF: end of a series of clips
    kal_uint32  clip_length;
    kal_uint8   buf[1];
}
tst_gdi_snapshot_report_struct;
/*
tst_gdi_snapshot_report_struct.status
0 => Normal Mode, success
1 => MNT
2 => ASSERT MODE
3 => Failed to close the log file
4 => Failed at FS_Write
5 => Failed to dump jpeg file (gdi_layer_save_jpeg_file)
6 => No Space To Save
7 => Failed to open or create the file
*/



typedef enum
{
	TSCT_USB_LOGGING_CONNECT,
	TSCT_USB_LOGGING_DISCONNECT,
	//... for use in the future
	TSCT_LAST_ID
}
tst_simple_command_type;

typedef struct {
  kal_uint16 token;
  tst_simple_command_type  cmd;
}
tst_simple_cmd_struct;

typedef struct
{   
  kal_uint16 token;
  tst_simple_command_type  cmd;
}
tst_simple_ack_struct;
   
typedef enum
{
   NVRAM_READ,
   NVRAM_RESET,
   NVRAM_WRITE,
   NVRAM_RESET_FLAG,
   NVRAM_READ_DYNAMIC
}
nvram_actions; 

typedef struct
{
    nvram_actions act;
}    
tst_nvram_exception_cmd_struct;

typedef struct
{
    nvram_actions act;    
}
tst_nvram_statistic_cmd_struct;


#ifdef VOICE_RECOGNITION_TEST
#ifndef MAX_VM_FILE_NAME
#define MAX_VM_FILE_NAME 20
#endif /*MAX_VM_FILE_NAME*/

typedef struct
{
	kal_uint8 message_type;
	kal_uint16	clip_index;
}
tst_vrt_cmd_struct;

#endif /*VOICE_RECOGNITION_TEST*/
 
    
typedef struct
{
    kal_uint8   enable;    
}
tst_ft_mode_config_struct;

typedef struct
{
	kal_uint8			enable;
}
tst_em_mode_config_struct;


typedef struct
{
	kal_uint16 file_idx;
	kal_uint8 file_path[6];
}
tst_sim_file_info_req_struct;

typedef struct
{
	kal_uint16	file_idx;
	kal_uint16	para;
	kal_uint16	length;
	kal_uint8 file_path[6];
}
tst_sim_read_req_struct;

typedef struct
{
	/* Check the 260 is a constant */
	kal_uint16	file_idx;
	kal_uint16	para;
	kal_uint8	data[260];
	kal_uint16	length;
	kal_uint8 file_path[6];
}
tst_sim_write_req_struct;

#ifdef __GEMINI__

typedef struct
{
	kal_uint16 file_idx;
	kal_uint8 file_path[6];
}
tst_sim_2_file_info_req_struct;

typedef struct
{
	kal_uint16	file_idx;
	kal_uint16	para;
	kal_uint16	length;
	kal_uint8 file_path[6];
}
tst_sim_2_read_req_struct;

typedef struct
{
	/* Check the 260 is a constant */
	kal_uint16	file_idx;
	kal_uint16	para;
	kal_uint8	data[260];
	kal_uint16	length;
	kal_uint8 file_path[6];
}
tst_sim_2_write_req_struct;
#endif //#ifdef __GEMINI__


typedef struct
{
    kal_uint32	token;
    kal_char	data[1];
}
tst_read_global_variable_struct;

typedef struct
{
    kal_uint16		size1;
    kal_uint16		size2;
}
tst_write_global_variable_struct;

typedef struct
{
   kal_uint8	token;
   kal_uint16  size;
   kal_char    data[1];
}
tst_gv_return;

typedef struct
{
	kal_uint8	token;
   kal_uint16  size;
}
tst_gv_header_struct;



typedef kal_uint8 tst_null_command_struct ;

typedef kal_uint8 tst_set_l1_trc_filter_struct;

typedef kal_uint8 tst_reboot_target_cmd_struct;

typedef kal_uint8 tst_query_memory_range_cmd_struct;

typedef kal_uint8 tst_query_soft_fc_char_cmd_struct;


typedef kal_uint8 tst_force_assert_cmd_struct;

typedef kal_uint8 tst_flush_swdbg_cmd_struct;

typedef kal_uint8 tst_st_stop_cmd_struct;

typedef kal_uint8 tst_reboot_for_mmi_auto_test_cmd_struct;

typedef struct
{
   kal_bool    is_logging;
}
tst_log_on_off_struct;

typedef struct
{
   kal_uint8   mod_filter[TST_MODULE_FILTER_LEN];
}
tst_set_prim_mod_filter_struct;

typedef struct
{
   kal_uint8   sap_filter[TST_SAP_FILTER_LEN];
}
tst_set_prim_sap_filter_struct;

typedef struct
{
	kal_uint16 	sap_id;
	kal_uint8   is_trap;
}
tst_set_trap_filter_struct;

typedef struct
{
   kal_uint16  sap_filter[END_OF_MOD_ID+1];
}tst_set_ps_trc_filter_struct;


typedef struct
{
   module_type    dest_mod;
   kal_uint8      index;
   kal_uint8      string[INJECT_STRING_TO_MODULE_MAX_LENGTH];
}tst_inject_string_to_module_struct;


typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  params_len;
   kal_uint8   index;
   kal_uint8   string[INJECT_STRING_TO_MODULE_MAX_LENGTH];
}
tst_inject_string_struct;


#if defined (__PS_SERVICE__) && defined (__EM_MODE__) && 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


typedef struct
{
   kal_uint8      atcmd[INJECT_AT_COMMAND_MAX_LENGTH];
}tst_inject_at_cmd_struct;

typedef struct {
	kal_uint32	m_CmdCount;
} tst_set_dsp_filter_cmd_struct;

typedef struct {
	void        *m_Addr;
	kal_uint16	m_Value;
} tst_dsp_command;

typedef struct
{
   kal_uint32     frame_number;
#ifdef __GEMINI__
   kal_uint32     frame_number_2;
#endif //#ifdef __GEMINI__
   kal_uint32     time_stamp;
   #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
   #endif
   module_type    src_mod_id;
   module_type    dest_mod_id;
   sap_type       sap_id;
   msg_type       msg_id;
   kal_uint16     local_len;
   kal_uint16     peer_len;
   kal_uint32     local_addr;
   kal_uint32     peer_addr;
}
tst_log_prim_header_struct;

typedef struct
{
   kal_uint32     frame_number;
#ifdef __GEMINI__
   kal_uint32     frame_number_2;
#endif //#ifdef __GEMINI__
   kal_uint32     time_stamp;
   kal_int16      cfn;
   kal_int16      sfn;
   module_type    src_mod_id;
   module_type    dest_mod_id;
   sap_type       sap_id;
   msg_type       msg_id;
   kal_uint16     local_len;
   kal_uint16     peer_len;   /*compressed length*/
   kal_uint32     local_addr;
   kal_uint32     peer_addr;
   kal_uint8      offset[5];  /*secondary buffer 0..3, peer buffer*/
   kal_uint16     cpr_len[5]; /*compressed length*/
   kal_uint16     org_len[5]; /*secondary buffer 0..3, peer buffer*/   
}
tst_log_prim_header_cphy_container_struct;

typedef struct
{
   kal_uint32     frame_number;
   kal_uint32     time_stamp;
   #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
   #endif
   module_type    src_mod_id;
   module_type    dest_mod_id;
   sap_type       sap_id;
   msg_type       msg_id;
   kal_uint16     local_len;
   kal_uint16     peer_len;
}
tst_log_prim_header_factory_mode_struct;

typedef struct
{
   kal_uint32        frame_number;
#ifdef __GEMINI__
   kal_uint32     frame_number_2;
#endif //#ifdef __GEMINI__
   kal_uint32        time_stamp;
   #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
   #endif
   kal_uint32        msg_index;
   trace_class_enum  trace_class;
#ifdef __GEMINI__ 
   module_type    module_id;
#endif //#ifdef __GEMINI__  
   kal_uint16        buf_length;
}
tst_index_trace_header_struct;

typedef struct
{
   kal_uint32     frame_number;
#ifdef __GEMINI__
   kal_uint32     frame_number_2;
#endif //#ifdef __GEMINI__   
   kal_uint32     time_stamp;
   #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
   #endif
   module_type    module_id;
   kal_uint16     buf_length;
}
tst_prompt_trace_header_struct;

typedef struct
{
   kal_uint32     frame_number;
#ifdef __GEMINI__
   kal_uint32     frame_number_2;
#endif //#ifdef __GEMINI__
   kal_uint32     time_stamp;
   #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
   #endif
   kal_uint32     msg_index;
   trace_class_enum  trace_class;
   kal_uint16     rawdata_length;
}
tst_rawdata_trace2_header_struct;

typedef struct
{
  kal_uint32  frame_number;
  kal_uint32  time_stamp;
  #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
  #endif
	kal_uint32 token;
	kal_uint8 status;
}
tst_sleep_mode_report_struct;

typedef struct
{   
    kal_uint32  frame_number;
    kal_uint32  time_stamp;
    #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
    #endif
    kal_uint32  token;
    kal_uint32  start_address;//0xFFFFFFFF , to delete the file
    kal_uint32  path_length;
    kal_uint32  data_length; //0: end-of-file or file deleted
    //kal_uint8   buf[1];	// path + file content
}
tst_file_transfer_report_header_struct;

typedef struct
{   
    kal_uint32  frame_number;
    kal_uint32  time_stamp;
    #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
    #endif
    kal_uint32  token;
    kal_uint32  start_address;
    kal_uint32  path_length;
    kal_uint32  data_length;
    kal_uint8   buf[1];	// path + file content
}
tst_file_transfer_report_struct;

typedef struct
{   
    kal_uint32          frame_number;
    kal_uint32          time_stamp;
    #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
    #endif
    kal_uint32  buf_length; //sizeof(stack_statistics_struct)
}
tst_dynamic_stack_statistics_header;

typedef struct
{   
    kal_uint32          frame_number;
    kal_uint32          time_stamp;
    #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
    #endif
    kal_uint32  buf_length; //sizeof(stack_statistics_struct)
    kal_uint8   buf[1]; //stack_statistics_struct
}
tst_dynamic_stack_statistics;


typedef struct
{   
	  //ST_input_struct
    kal_int32 trace_time_scale;
    kal_bool all_task; 
    kal_bool trace_register;
    kal_bool trace_call_stack;
    kal_bool trace_data; 
    kal_int32 task_filter[6];
    kal_int32 trace_stack_size;
    kal_int32* data_address[16];
    kal_int32 reserved[16];
}
tst_st_start_cmd_struct;

typedef struct
{   
    kal_uint32  frame_number;
    kal_uint32  time_stamp;
    //ST_return_struct
    kal_int32 start_time1;
    kal_int32 start_time2;
    kal_int32* buffer_start_addr;
    kal_int32* buffer_end_addr;
    kal_int32* buffer_current_index_addr;
    kal_int32 time_scale_for_one_sec;
    kal_int32 reserved[4];
    kal_bool buffer_wrap_around;
}
tst_st_report_struct;

typedef struct
{
    kal_uint32          frame_number;
#ifdef __GEMINI__
   kal_uint32     frame_number_2;
#endif //#ifdef __GEMINI__    
    kal_uint32          time_stamp;
    #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
    #endif
    module_type         module_id;
    trace_class_enum    trace_class;    
    kal_uint16          buf_length;
}
tst_wap_trace_header_struct;


typedef struct
{
   kal_uint32     frame_number;
#ifdef __GEMINI__
   kal_uint32     frame_number_2;
#endif //#ifdef __GEMINI__   
   kal_uint32     time_stamp;
   #ifdef __WCDMA_RAT__
/* under construction !*/
/* under construction !*/
   #endif
   kal_uint16     buf_length;
}
tst_sys_trace_header_struct;


typedef struct
{
   tst_command_type  command_type;
   kal_uint16        cmd_len;
}
tst_command_header_struct;


typedef struct
{
   tst_command_header_struct  command;
   kal_uint16                 received_cmd_length;
   kal_uint16                 received_data_length;
   kal_uint8                  *header_buf;
   kal_uint8                  *command_buf;
}
tst_current_handle_command;


typedef struct
{
   module_type    src_mod_id;
   module_type    dest_mod_id;
   sap_type       sap_id;
   msg_type       msg_id;
   kal_uint16     local_len;
   kal_uint16     peer_len;
}
tst_inject_primitive_header_struct;


typedef struct
{
   tst_inject_primitive_header_struct inject_prim;
   kal_uint16     received_prim_header_length;
   kal_uint16     received_prim_local_para_length;
   kal_uint16     received_prim_peer_length;
   kal_uint8      *header_ptr;
   kal_uint8      *local_ptr;
   kal_uint8      *peer_ptr;
}
tst_current_handle_primitive;



typedef struct {
    kal_uint16		no_peer_buff_ptr;
    kal_uint16		peer_buff_ptr_size;
    kal_uint8		*peer_buff_ptr;
    kal_uint8		ref_count;
    kal_uint8		header_len;
    kal_uint8		tail_len;
    kal_uint8		unused1;
} asn_peer_buff_struct;

typedef struct {
    kal_uint8		ref_count;
    kal_uint16		no_local_params_ptr;
    kal_uint16		local_params_ptr_size;
    kal_uint8		*local_params_ptr;
} asn_local_para_struct;

typedef struct {
    module_type	    src_mod_id;
    module_type	    dest_mod_id;
    sap_type		sap_id;
    msg_type		msg_id;
    asn_local_para_struct	local_params;
    asn_peer_buff_struct	peer_buff;
} ilmessage;


typedef struct
{
	kal_uint16	received_data_length;
	kal_uint16  data_length;
	kal_char	*data;
	kal_char    *iterator;
}
tst_current_handle_ut_primitive;


typedef union
{
    tst_current_handle_command			command;
    tst_current_handle_primitive		primitive;
    tst_current_handle_ut_primitive	    ut_primitive;
}
tst_current_handle_rs232_frame;

typedef struct
{
	const kal_uint8* pTraceHeader;
	const kal_uint8* pData;
	const kal_uint8* pData2;
	kal_uint32 lenTraceHeader;
	kal_uint32 lenData;
	kal_uint32 lenData2;
	kal_uint32 moduleId;
	kal_uint32 ilmSapId;
	kal_uint32 ilmMessageType;
	kal_uint32 frameMessageType;
}
tst_trace_frame_arg;

#define STAT_TYPE_SIZE 3
#define STAT_TYPE_TRACE 0
#define STAT_TYPE_PRIMITIVE 1
#define STAT_TYPE_OTHER 2
#define STAT_BUFFER_SLOT_SIZE 7


typedef struct
{
	kal_uint32 count_on; //0 for OFF, non-zeor for ON
	kal_uint32 count_log[STAT_TYPE_SIZE];
	kal_uint32 count_lost[STAT_TYPE_SIZE];
	kal_uint32 count_lost_no_buffer[STAT_TYPE_SIZE][STAT_BUFFER_SLOT_SIZE];
	kal_uint32 count_lost_full_queue[STAT_TYPE_SIZE];
}
tst_statistics_struct;

//[maggie]
typedef struct
{
	kal_uint32 type_count[STAT_TYPE_SIZE];
	kal_uint32 lost_size;
	kal_uint32 request_size;
}
tst_usage_statistics_struct;

//<-- for KDWP
#define KDWP_CATCHER_SWITCH_ON       1
#define KDWP_CATCHER_SWITCH_OFF      2
#define KDWP_CATCHER_SOCKET_HOOKED   3
#define KDWP_CATCHER_SOCKET_UNHOOKED 4

#define KDWP_KVM_START_SESSION     0
#define KDWP_KVM_END_SESSION       1
#define KDWP_KVM_DATA_MID          2
#define KDWP_KVM_DATA_END          3

extern kal_bool tst_java_debug_mode;
extern kal_bool tst_java_debug_hooked;

extern kal_bool tst_kdwp_start_session(void);
extern kal_bool tst_kdwp_end_session(void);
extern kal_bool tst_kdwp_send(const kal_uint8 *pData, kal_uint32 nLen, kal_bool bEnd);

typedef struct
{
   kal_uint32     buf_length;
}
tst_kdwp_packet_header_struct;

typedef struct
{
   kal_uint32     buf_length;
}
tst_cti_response_header_struct;

typedef struct
{
    kal_uint8* pData;
}    
tst_kdwp_recv_cmd_struct;

typedef struct
{
    kal_uint8* pData;
}    
tst_cti_command_cmd_struct;

typedef struct
{
   kal_uint8    kdwp_control;
}
tst_kdwp_control_cmd_struct;
//-- for KDWP -->

//for MSG_ID_TIMER_EXPIRY
typedef stack_timer_struct timer_expiry_struct;

//for query HW version and SW version
typedef struct
{
	kal_uint16 nHWVerLen;
	kal_uint16 nSWVerLen;
}
tst_report_version_header_struct;


//=================== For GDI Logger
typedef struct
{
	kal_int32  nFreeSpace[3]; //max number of drives (no system drives)
	kal_uint8  ucDrive[3];//drive letter
	kal_uint32 nGDIFileSN;
	//kal_uint8  nFormat; //0: raw, 1: jpeg, 2: unknown 
  WCHAR strFSName[32];//i.e. X:\GDILog\00000.log
  kal_uint8 fsBuf[512];
  tst_gdi_snapshot_report_header_struct	trace_header;
  tst_trace_frame_arg argFrameToSend;
  kal_uint8 l1sm_handle;
}
tst_gdi_logger_context_struct;

extern void tst_switch_sleep_mode(kal_uint32 token, kal_uint32 cmd);
extern void tst_dump_file_clip(const tst_file_transfer_cmd_struct *pCmd);
kal_uint32 tst_RLE_Encode(kal_uint32 nBytesPerPixel, const kal_uint8* pRawDataBuffer, kal_uint32 RawDataLength, kal_uint8* pOutputBuffer, kal_uint32 *pOutputLength, kal_uint32 *pReadLength);

//===================

typedef struct
{
  kal_uint16  nCount;
  kal_uint16  MsgIDs[1];
}    
tst_set_trap_msg_cmd_struct;


//<==== Virtual Channel
typedef struct
{
   kal_uint8      channel_id;
   kal_uint32     buf_length;
}
tst_vc_packet_header_struct;

typedef struct
{
    kal_uint8     channel_id;
    kal_uint8     pData[1];
}    
tst_vc_cmd_struct;
// Virtual Channel ===>

#endif /* _TST_DEF_H */


